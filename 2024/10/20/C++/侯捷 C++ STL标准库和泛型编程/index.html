<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>侯捷 C++ STL标准库和泛型编程 | 学习笔记 | Darlingの妙妙屋</title><meta name="author" content="Darling"><meta name="copyright" content="Darling"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="侯捷 C++ STL标准库和泛型编程 | 学习笔记1 STL概述STL —— Standard Template Library，标准模板库 C++ Standard LIbrary，C++标准库中包含STL（即STL+一些小东西） 1.1 头文件名称 C++标准库的 header files 不带 .h，例如：#include&lt;vector&gt; 新式 C header files 不带">
<meta property="og:type" content="article">
<meta property="og:title" content="侯捷 C++ STL标准库和泛型编程 | 学习笔记">
<meta property="og:url" content="https://darling-123456.github.io/2024/10/20/C++/%E4%BE%AF%E6%8D%B7%20C++%20STL%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Darlingの妙妙屋">
<meta property="og:description" content="侯捷 C++ STL标准库和泛型编程 | 学习笔记1 STL概述STL —— Standard Template Library，标准模板库 C++ Standard LIbrary，C++标准库中包含STL（即STL+一些小东西） 1.1 头文件名称 C++标准库的 header files 不带 .h，例如：#include&lt;vector&gt; 新式 C header files 不带">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://darling-123456.github.io/img/34.jpg">
<meta property="article:published_time" content="2024-10-19T16:00:00.000Z">
<meta property="article:modified_time" content="2025-03-22T14:49:25.155Z">
<meta property="article:author" content="Darling">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://darling-123456.github.io/img/34.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "侯捷 C++ STL标准库和泛型编程 | 学习笔记",
  "url": "https://darling-123456.github.io/2024/10/20/C++/%E4%BE%AF%E6%8D%B7%20C++%20STL%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/",
  "image": "https://darling-123456.github.io/img/34.jpg",
  "datePublished": "2024-10-19T16:00:00.000Z",
  "dateModified": "2025-03-22T14:49:25.155Z",
  "author": [
    {
      "@type": "Person",
      "name": "Darling",
      "url": "https://darling-123456.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://darling-123456.github.io/2024/10/20/C++/%E4%BE%AF%E6%8D%B7%20C++%20STL%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Darling","link":"链接: ","source":"来源: Darlingの妙妙屋","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'medium_zoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '侯捷 C++ STL标准库和泛型编程 | 学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">57</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/34.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/test.jpg" alt="Logo"><span class="site-name">Darlingの妙妙屋</span></a><a class="nav-page-title" href="/"><span class="site-name">侯捷 C++ STL标准库和泛型编程 | 学习笔记</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">侯捷 C++ STL标准库和泛型编程 | 学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-19T16:00:00.000Z" title="发表于 2024-10-20 00:00:00">2024-10-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-22T14:49:25.155Z" title="更新于 2025-03-22 22:49:25">2025-03-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84C-%E3%81%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/">从零开始的C++の学习之路</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">14.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>61分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="侯捷-C-STL标准库和泛型编程-学习笔记"><a href="#侯捷-C-STL标准库和泛型编程-学习笔记" class="headerlink" title="侯捷 C++ STL标准库和泛型编程 | 学习笔记"></a>侯捷 C++ STL标准库和泛型编程 | 学习笔记</h1><h3 id="1-STL概述"><a href="#1-STL概述" class="headerlink" title="1 STL概述"></a>1 STL概述</h3><p>STL —— Standard Template Library，标准模板库</p>
<p>C++ Standard LIbrary，C++标准库中包含STL（即STL+一些小东西）</p>
<h4 id="1-1-头文件名称"><a href="#1-1-头文件名称" class="headerlink" title="1.1 头文件名称"></a>1.1 头文件名称</h4><ul>
<li>C++标准库的 header files 不带 <code>.h</code>，例如：<code>#include&lt;vector&gt;</code></li>
<li>新式 C header files 不带 <code>.h</code>，例如：<code>#include&lt;cstdio&gt;</code></li>
<li>老式 C header files 带 <code>.h</code> 仍然可用，例如：<code>#include&lt;stdio.h&gt;</code></li>
</ul>
<blockquote>
<p>新式 header 内的组件封装于 <em>namespace std</em></p>
<p>老式 header 内的组件<strong>不</strong>封装于 <em>namespace std</em></p>
</blockquote>
<h4 id="1-2-STL基础介绍"><a href="#1-2-STL基础介绍" class="headerlink" title="1.2 STL基础介绍"></a>1.2 STL基础介绍</h4><p>STL六大部件：容器(Containers)、分配器(Allocators)、算法(Algorithms)、迭代器(Iterators)、仿函数(Functors)、适配器(Adapters)</p>
<ul>
<li><em>容器</em>：放数据</li>
<li><em>分配器</em>：是来支持容器将数据放到内存里</li>
<li><em>算法</em>：是一个个函数来处理存放在容器里的数据</li>
<li><em>迭代器</em>：就是来支持算法操作容器的</li>
<li><em>仿函数</em>：作用类似函数，例如相加相减等等</li>
<li><em>适配器</em>：有三种，分别将容器，迭代器，仿函数来进行一个转换</li>
</ul>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/d09c45698779ce82cc027e9ea14f615d.png" alt="image-20230818085837524"></p>
<p>实例：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/04af82228aa28169dd7893570701b0d6.png" alt="image-20230818091503166"></p>
<ol>
<li>首先是创建一个 container（<em>vector</em>）</li>
<li>allocator 来帮助 container 来分配内存（一般会忽略不写）</li>
<li>用一个 Algorithm 来操作数据（<em>count_if</em> 是数出满足条件的个数）</li>
<li>iterator 就是一个泛化的指针，来告诉 Algorithm 要处理哪里的数据</li>
<li>用一个 functor 来判断数据（<em>less</em> 其有两个参数传入，第一个 &lt; 第二个就为真）</li>
<li>先用一个 function adapter（<em>bind2nd</em>）绑定了第二个参数为 40；再用一个 function adapter（<em>not1</em>）来对整个判断结果进行否定</li>
</ol>
<p>判断条件 predicate 为：<code>not1(bind2nd(less&lt;int&gt;(), 40))</code> —— 表示 &gt;&#x3D; 40 数为真</p>
<blockquote>
<p>前闭后开：[ )，基本所有容器都有 <code>begin()</code> <code>end()</code>，但 <em>begin</em> 是指向的容器的第一个元素，而 <em>end</em> 是指向的容器最后一个元素的<strong>下一个</strong></p>
<p>例子：遍历容器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Container&lt;T&gt; c;</span><br><span class="line">Container&lt;T&gt;::iterator i = c.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (; i != c.<span class="built_in">end</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//但在C++11中可以用新语法简写</span></span><br><span class="line">...</span><br><span class="line">Container&lt;T&gt; c;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> elem : c)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<h4 id="1-3-typename"><a href="#1-3-typename" class="headerlink" title="1.3 typename"></a>1.3 typename</h4><p>在模板参数的关键字使用中与 <code>class</code> 是一样的</p>
<p>在类型前面加上 <code>typename</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTemplateClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> T::NestedType NestedType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyTemplateFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> T::SomeType variable;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>typename</code> 用于告诉编译器 <code>T::NestedType</code> 和 <code>T::SomeType</code> 是类型名称而不是成员变量</p>
<p><code>typename</code> 是一个用于明确指定符号是一个类型的关键字，以帮助编译器正确解析代码并避免歧义，如果不使用 <code>typename</code>，编译器可能会认为符号是一个值而不是类型，导致编译错误。</p>
<h3 id="2-OOP-vs-GP"><a href="#2-OOP-vs-GP" class="headerlink" title="2 OOP vs. GP"></a>2 OOP vs. GP</h3><ul>
<li><p><strong>OOP</strong> —— Object-Oriented programming 面向对象编程</p>
<p>将数据和操作关联到一起</p>
<p>例如容器 List，其自带了一个 <code>sort()</code>，因为链表的存储空间不是连续的，Iterator 不能实现加减操作，所以不能使用全局的 <code>::sort()</code></p>
</li>
<li><p><strong>GP</strong> —— Generic Programming 泛式编程</p>
<p>将数据和操作分开</p>
<ul>
<li>容器和算法的团队就可以各自闭门造车，其间通过 Iterator 联通即可</li>
<li>算法通过 Iterator 确定操作范围，并通过 Iterator 取用容器的元素</li>
<li>所有的算法，其内的最终涉及元素的操作都是比大小</li>
</ul>
</li>
</ul>
<h3 id="3-容器"><a href="#3-容器" class="headerlink" title="3 容器"></a>3 容器</h3><h4 id="3-1-容器结构分类"><a href="#3-1-容器结构分类" class="headerlink" title="3.1 容器结构分类"></a>3.1 容器结构分类</h4><p>分类：序列式容器 <em>Sequence Container</em>，关联式容器 <em>Associative Container</em></p>
<ul>
<li><p>序列式容器：按照放入的次序进行排列</p>
<ul>
<li>Array 数组，固定大小</li>
<li>Vector 向量，会自动扩充大小</li>
<li>Deque 双向队列，双向都可以扩充</li>
<li>List 链表，双向链表</li>
<li>Forward-List 链表，单向链表</li>
</ul>
</li>
<li><p>关联式容器：有 <em>key</em> 和 <em>value</em>，适合快速的查找</p>
<p>STL中实现使用红黑树（高度平衡二叉树）和哈希表</p>
<ul>
<li><p>Set，<em>key</em> 就是 <em>value</em>，元素不可重复</p>
</li>
<li><p>Map，<em>key</em> 和 <em>value</em> 是分开的，元素不可重复</p>
</li>
<li><p>Multi~，元素是可以重复的</p>
</li>
<li><p>Unordered~，HashTable Separate Chaining</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>其中 <em>Array</em>，<em>Forward-List</em>，<em>Unordered~</em> 都是C++11的</p>
</blockquote>
<h4 id="3-2-序列式容器"><a href="#3-2-序列式容器" class="headerlink" title="3.2 序列式容器"></a>3.2 序列式容器</h4><h5 id="3-2-1-array"><a href="#3-2-1-array" class="headerlink" title="3.2.1 array"></a>3.2.1 array</h5><h6 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h6><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/aca4bf3e71f09fdee57770a2231e4cdd.png" alt="image-20230819103001457"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">//qsort, bsearch, NULL</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n test_array().......... \n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个包含long型元素的array容器，ASIZE为数组的大小</span></span><br><span class="line">    array&lt;<span class="type">long</span>, ASIZE&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充数组 c 中的元素，使用 rand() 生成随机数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; ASIZE; ++i) &#123;</span><br><span class="line">        c[i] = <span class="built_in">rand</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出填充数组所花费的毫秒数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出数组的大小、第一个元素、最后一个元素、起始地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;array.size()= &quot;</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;array.front()= &quot;</span> &lt;&lt; c.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;array.back()= &quot;</span> &lt;&lt; c.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;array.data()= &quot;</span> &lt;&lt; c.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目标值</span></span><br><span class="line">    <span class="type">long</span> target = <span class="built_in">get_a_target_long</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    timeStart = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="comment">// 使用标准库的 qsort 函数（快排）对数组 c 进行排序</span></span><br><span class="line">    ::<span class="built_in">qsort</span>(c.<span class="built_in">data</span>(), ASIZE, <span class="built_in">sizeof</span>(<span class="type">long</span>), compareLongs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用标准库的 bsearch 函数（二分查找）在排序后的数组中搜索目标值</span></span><br><span class="line">    <span class="type">long</span>* pItem = (<span class="type">long</span>*)::<span class="built_in">bsearch</span>(&amp;target, c.<span class="built_in">data</span>(), ASIZE, <span class="built_in">sizeof</span>(<span class="type">long</span>), compareLongs);</span><br><span class="line">    <span class="comment">// 输出排序和搜索所花费的毫秒数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;qsort()+bsearch(), milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果找到目标值，输出该值；否则输出未找到消息</span></span><br><span class="line">    <span class="keyword">if</span> (pItem != <span class="literal">NULL</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;found, &quot;</span> &lt;&lt; *pItem &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;not found! &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/1215c8aa9afe3362a81c2b9945382cf3.png" alt="image-20230818113016596"></p>
<p>随机数据填充容器：47ms；排序和搜索：187ms</p>
<hr>
<h6 id="深度探索"><a href="#深度探索" class="headerlink" title="深度探索"></a>深度探索</h6><p><strong>C++TR1</strong>下（比较简单）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, std::<span class="type">size_t</span> _Nm&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">array</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator; <span class="comment">// 迭代器为_Tp*</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	value_type _M_instance[_Nm ? _Nm : <span class="number">1</span>]; <span class="comment">// 如果_Nm为0，就分配一个空间</span></span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(&amp;_M_instance[<span class="number">0</span>]); &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(&amp;_M_instance[_Nm]); &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>GCC4.9</strong>下（复杂且无益处）：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/5a01425f1dabb780277cae4fb907917b.png" alt="image-20230827201155808"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GCC4.9通过多个typedef以下面的逻辑创建的array里的data</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">100</span>]; <span class="comment">// T即类型int[100] </span></span><br><span class="line">T c; <span class="comment">// 与int c[100]一样</span></span><br></pre></td></tr></table></figure>

<h5 id="3-2-2-vector"><a href="#3-2-2-vector" class="headerlink" title="3.2.2 vector"></a>3.2.2 vector</h5><h6 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h6><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/a5590968ff2ba875bae642ee0320a531.png" alt="image-20230819102940829"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">//abort()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>  <span class="comment">//snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> 	<span class="comment">//sort()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试函数，接受一个引用类型的长整型参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_vector</span><span class="params">(<span class="type">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\ntest_vector().......... \n&quot;</span>;</span><br><span class="line">     </span><br><span class="line">    vector&lt;string&gt; c;  	<span class="comment">// 创建一个字符串类型的向量</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();	<span class="comment">// 记录开始时间							</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>; i&lt; value; ++i)	<span class="comment">// 循环插入随机生成的字符串</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">&quot;%d&quot;</span>, <span class="built_in">rand</span>());	<span class="comment">// 将随机整数转换为字符串</span></span><br><span class="line">            c.<span class="built_in">push_back</span>(<span class="built_in">string</span>(buf));     	<span class="comment">// 将字符串添加到向量中</span></span><br><span class="line">        &#125; <span class="comment">// 这里是处理异常，如内存不够</span></span><br><span class="line">        <span class="built_in">catch</span>(exception&amp; p) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;	</span><br><span class="line">            <span class="comment">// 输出出现异常的信息以及对应的索引值</span></span><br><span class="line">            <span class="comment">// 曾經最高 i=58389486 then std::bad_alloc</span></span><br><span class="line">            <span class="built_in">abort</span>();	<span class="comment">// 异常处理后中止程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;	<span class="comment">// 输出填充向量花费时间</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector.max_size()= &quot;</span> &lt;&lt; c.<span class="built_in">max_size</span>() &lt;&lt; endl;	<span class="comment">// 输出向量的最大容量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector.size()= &quot;</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;	<span class="comment">// 输出向量的实际大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector.front()= &quot;</span> &lt;&lt; c.<span class="built_in">front</span>() &lt;&lt; endl;	<span class="comment">// 输出向量的首元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector.back()= &quot;</span> &lt;&lt; c.<span class="built_in">back</span>() &lt;&lt; endl;	<span class="comment">// 输出向量的末尾元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector.data()= &quot;</span> &lt;&lt; c.<span class="built_in">data</span>() &lt;&lt; endl;	<span class="comment">// 输出向量地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector.capacity()= &quot;</span> &lt;&lt; c.<span class="built_in">capacity</span>() &lt;&lt; endl &lt;&lt; endl;	<span class="comment">// 输出向量的容量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接find来查找————次序查找</span></span><br><span class="line">    string target = <span class="built_in">get_a_target_string</span>();	<span class="comment">// 获取一个目标字符串</span></span><br><span class="line">    &#123;</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();	<span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);	<span class="comment">// 在向量中查找目标字符串</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;std::find(), milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;found, &quot;</span> &lt;&lt; *pItem &lt;&lt; endl &lt;&lt; endl;	<span class="comment">// 输出找到的目标字符串</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;not found! &quot;</span> &lt;&lt; endl &lt;&lt; endl;	<span class="comment">// 输出未找到目标字符串</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先排序再二分法查找</span></span><br><span class="line">    &#123;</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();	<span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="built_in">sort</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());	<span class="comment">// 对向量中的字符串进行排序</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sort(), milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl; </span><br><span class="line">        </span><br><span class="line">        timeStart = <span class="built_in">clock</span>();	    </span><br><span class="line">        string* pItem = (string*)::<span class="built_in">bsearch</span>(&amp;target, (c.<span class="built_in">data</span>()), </span><br><span class="line">                                           c.<span class="built_in">size</span>(), <span class="built_in">sizeof</span>(string), compareStrings); </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bsearch(), milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl; </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (pItem != <span class="literal">NULL</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;found, &quot;</span> &lt;&lt; *pItem &lt;&lt; endl &lt;&lt; endl;	<span class="comment">// 输出在排序后向量中找到的目标字符串</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;not found! &quot;</span> &lt;&lt; endl &lt;&lt; endl;	<span class="comment">// 输出在排序后向量中未找到目标字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    c.<span class="built_in">clear</span>();	<span class="comment">// 清空向量中的数据</span></span><br><span class="line">    <span class="built_in">test_moveable</span>(<span class="built_in">vector</span>&lt;MyString&gt;(),<span class="built_in">vector</span>&lt;MyStrNoMove&gt;(), value);	<span class="comment">// 调用另一个函数进行测试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是 array 在后面插入元素，其中若空间 <em>capacity</em> 不够，其会进行<strong>两倍扩充</strong>——即空间不够时会将原来的空间 <code>*2</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">push_back</span>(<span class="built_in">string</span>(buf));</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/305e5f8e58fd9e657e93a2d8aae9cbec.png" alt="img"></p>
<p>随机数据填充容器：3063ms；直接搜索：0ms（运气很好）；排序后二分查找：2765ms</p>
<hr>
<h6 id="深度探索-1"><a href="#深度探索-1" class="headerlink" title="深度探索"></a>深度探索</h6><p><strong>GCC2.9</strong>下：</p>
<p>一共3个指针：<code>start</code>，<code>finish</code>，<code>end_of_storage</code></p>
<p>所以 <code>sizeof(vector&lt;int&gt;)</code> 是<code>12</code></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/c5e34df7714022f72444ade564b78c06.png" alt="image-20230827163726770"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator; <span class="comment">// 迭代器就是T*</span></span><br><span class="line">	<span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	iterator start;</span><br><span class="line">	iterator finish;</span><br><span class="line">	iterator end_of_storage;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="built_in">end</span>() - <span class="built_in">begin</span>()); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(end_of_storage - <span class="built_in">begin</span>()); &#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>(); &#125;</span><br><span class="line">	reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span> *(<span class="built_in">begin</span>() + n); &#125;</span><br><span class="line">    <span class="comment">// 所有连续储存的容器都有[]的重载</span></span><br><span class="line">	<span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line">	<span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vector 每次成长会大量调用元素的拷贝构造函数和析构函数，是一个大成本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage) <span class="comment">// 还有备用空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">construct</span>(finish, x); <span class="comment">// 全局函数</span></span><br><span class="line">        ++finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 无备用空间</span></span><br><span class="line">        <span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert_aux</span>(iterator position, <span class="type">const</span> T&amp; x)&#123;</span><br><span class="line"><span class="keyword">if</span> (finish != end_of_storage)&#123; <span class="comment">// insert_aux还会被其他函数调用所以还有检查</span></span><br><span class="line">    <span class="comment">// 在‘备用空间起始处’构建一个元素以vector最后一个元素为初值</span></span><br><span class="line">    <span class="comment">// insert_aux也可能被insert调用，元素插入位置不定</span></span><br><span class="line">    <span class="built_in">construct</span>(finish, *(finish - <span class="number">1</span>));</span><br><span class="line">    ++finish;</span><br><span class="line">    T x_copy = x;</span><br><span class="line">    <span class="built_in">copy_backward</span>(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>);</span><br><span class="line">    *position = x_copy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="type">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">    <span class="type">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 原大小为0，则分配1；否则，分配原大小的2倍</span></span><br><span class="line">    </span><br><span class="line">    iterator new_start = data_allocator::<span class="built_in">allocate</span>(len);</span><br><span class="line">    iterator new_finish = new_start;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 拷贝安插点前的原内容</span></span><br><span class="line">        new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);</span><br><span class="line">        <span class="built_in">construct</span>(new_finish, x);</span><br><span class="line">        ++new_finish;</span><br><span class="line">        <span class="comment">// 拷贝安插点后的原内容</span></span><br><span class="line">        new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)&#123;</span><br><span class="line">        <span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(new_start, len);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解构并释放原vector</span></span><br><span class="line">    <span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">deallocate</span>();</span><br><span class="line">    <span class="comment">// 调整迭代器，指向新vector</span></span><br><span class="line">    start = new_start;</span><br><span class="line">    finish = new_finish;</span><br><span class="line">    end_of_storage = new_start + len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GCC4.9</strong>下变得复杂：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/120e53f5542dd78a7fc49d5f44eb25ad.png" alt="image-20230827174519929"></p>
<blockquote>
<p>且迭代器也变得乱七八糟，舍近求远，何必如此！！</p>
</blockquote>
<h5 id="3-2-3-list"><a href="#3-2-3-list" class="headerlink" title="3.2.3 list"></a>3.2.3 list</h5><h6 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h6><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/ab34a433644691ad274dbf3450ee5d11.png" alt="image-20230819103100219"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_list</span><span class="params">(<span class="type">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    list&lt;string&gt; c;  <span class="comment">// 创建一个字符串列表  	</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];  <span class="comment">// 字符串缓冲区</span></span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">		</span><br><span class="line">    string target = <span class="built_in">get_a_target_string</span>();  <span class="comment">// 获取目标字符串		</span></span><br><span class="line">    timeStart = <span class="built_in">clock</span>();		</span><br><span class="line">    <span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);  <span class="comment">// 在列表中查找目标字符串						</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;std::find()，milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;  <span class="comment">// 输出查找时间		</span></span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    	</span><br><span class="line">    timeStart = <span class="built_in">clock</span>();		</span><br><span class="line">    c.<span class="built_in">sort</span>();  <span class="comment">// 对列表进行排序						</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c.sort(), milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;  <span class="comment">// 输出排序时间		    	</span></span><br><span class="line"></span><br><span class="line">    c.<span class="built_in">clear</span>();  <span class="comment">// 清空	 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code> c.sort();</code> 是容器自带的排序函数，如果容器自带肯定是要比全局的排序函数好的</p>
<p><em>list</em> 同样也是用 <code>c.push_back(string(buf));</code> 往里添加元素的</p>
</blockquote>
<p>运行结果：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/dc6e572dcf2870ccf150caaee39adc2a.png" alt="image-20230819105152408"></p>
<p>随机数据填充容器：3265ms；直接搜索：16ms；排序：2312ms</p>
<hr>
<h6 id="深度探索-2"><a href="#深度探索-2" class="headerlink" title="深度探索"></a>深度探索</h6><p><strong>GCC2.9</strong>中</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/3472edd6f4874126348f286c7c216f3f.png" alt="image-20230822105307837"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list class</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> list</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt; iterator; <span class="comment">// 迭代器，每一个容器都会 typedef</span></span><br><span class="line">	<span class="comment">// 只传一个参数就行了 不理想</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	link_type node; <span class="comment">// 一个 __list_node&lt;T&gt; 的指针</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点 class</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">void</span>* void_pointer; <span class="comment">// 每次用还要转换类型 不理想</span></span><br><span class="line">	void_pointer prev;</span><br><span class="line">	void_pointer next;</span><br><span class="line">	T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>除了 array，vector 这样是连续存储的容器，其他容器的 iterator 都是智能指针，其有大量的操作符重载 —— 模拟指针</p>
</blockquote>
<p>基本上所有的 iterator 都有下面<em>5</em>个 <em>typedef</em> 和一大堆操作符重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iterator class</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt; self;</span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category; <span class="comment">// (1)双向迭代器	</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">// (2)迭代器所指对象的类型</span></span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer; <span class="comment">// (3)迭代器所指对象的指针类型</span></span><br><span class="line">	<span class="keyword">typedef</span> Ref reference; <span class="comment">// (4)迭代器所指对象的引用类型</span></span><br><span class="line">	<span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; <span class="comment">// (5)两个迭代器之间的距离类型</span></span><br><span class="line"></span><br><span class="line">	link_type node; <span class="comment">// iterator本体，一个指向__list_node&lt;T&gt;的指针</span></span><br><span class="line"></span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">	self&amp; <span class="keyword">operator</span>++() <span class="comment">// ++i</span></span><br><span class="line">    &#123;</span><br><span class="line">        node = (link_type)((*node).next); <span class="comment">// 移到下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">    &#125;</span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="type">int</span>) <span class="comment">// i++ 为了区分加上了一个参数其实无用</span></span><br><span class="line">    &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>; </span><br><span class="line">        ++*<span class="keyword">this</span>; </span><br><span class="line">        <span class="keyword">return</span> tmp; </span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：<code>self operator++(int)&#123;...&#125;</code> 的 <code>self tmp = *this;</code> 中，由于先调用了 <code>=</code> 唤起了 <em>copy ctor</em> 用以创建 tmp 并以 <code>*this</code> 为初值，所以不会唤起 <code>operator*</code> —— <code>*this</code> 已经被解释为 ctor 的参数</p>
<p>下面的 <code>++*this;</code> 同理</p>
<blockquote>
<p>与 int 类似：iterator 可以连续前++，但不能连续后++</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/ef8375d526c91f0e218e2e003448b310.png" alt="image-20230822173147636"><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/a00deae379f70e7ae017d2f1fc32e185.png" alt="image-20230822173354379"></p>
<p>所以前++是返回引用，后++返回值</p>
</blockquote>
<p>因为要符合前闭后开原则，所以在 list 尾端加上了一个空白节点</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/e9c2a09a74edcd51c4babd40ac9f669e.png" alt="image-20230827092146933"></p>
<p><strong>GCC4.9</strong>中做出了改进：</p>
<ul>
<li>迭代器模板参数从三个 –&gt; 只有一个</li>
<li>节点 class 中的前后指针类型从 <code>void*</code> –&gt; <code>_LIst_node_base*</code></li>
</ul>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/9e8606c953607a40e72023f31bad81fd.png" alt="image-20230827091438719"></p>
<p>在GCC4.9中 <code>sizeof(list&lt;int&gt;)</code> 是 <strong>8</strong></p>
<p>在GCC2.9中 <code>sizeof(list&lt;int&gt;)</code> 是 <strong>4</strong></p>
<h5 id="3-2-4-forward-list"><a href="#3-2-4-forward-list" class="headerlink" title="3.2.4 forward_list"></a>3.2.4 forward_list</h5><h6 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h6><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/4dec1c1b47d7ff7f01aacdbed858c8de.png" alt="image-20230819103623779"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_forward_list</span><span class="params">(<span class="type">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">     </span><br><span class="line">    forward_list&lt;string&gt; c;  <span class="comment">// 创建一个前向列表  	</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];  <span class="comment">// 字符串缓冲区</span></span><br><span class="line">			</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    string target = <span class="built_in">get_a_target_string</span>();  <span class="comment">// 获取目标字符串	</span></span><br><span class="line">    timeStart = <span class="built_in">clock</span>();	</span><br><span class="line">    <span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);  <span class="comment">// 在前向列表中查找目标字符串	</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;std::find()，milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;  <span class="comment">// 输出查找时间		</span></span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    	</span><br><span class="line">    timeStart = <span class="built_in">clock</span>();		</span><br><span class="line">    c.<span class="built_in">sort</span>();  <span class="comment">// 进行排序					</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c.sort()， milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;  <span class="comment">// 输出排序时间		</span></span><br><span class="line">	</span><br><span class="line">    c.<span class="built_in">clear</span>();  <span class="comment">// 清空	 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<em>forward_list</em> 只有 <code>c.push_front();</code> 且没有 <code>forward_list.back()</code> <code>forward_list.size()</code></p>
</blockquote>
<p>运行结果：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/4e75b693896408979c4af81097a394ed.png" alt="image-20230819110505646"></p>
<p>随机数据填充容器：3204ms；直接搜索：15ms；排序：2656ms</p>
<h6 id="深度探索-3"><a href="#深度探索-3" class="headerlink" title="深度探索"></a>深度探索</h6><p>与 <em>list</em> 相似，略</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/9b70751a2edb8166845972444a2b6747.png" alt="image-20230827201331283"></p>
<h5 id="3-2-6-deque"><a href="#3-2-6-deque" class="headerlink" title="3.2.6 deque"></a>3.2.6 deque</h5><h6 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h6><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/8ba922f08b957fb8b1586a8873c340ff.png" alt="image-20230819103846501"></p>
<p>类似vector，两边都能扩充，实际上是分段连续的</p>
<p>其是通过 <em>map</em>（是一个vector，但在扩充时会 copy 到中间）里的指针指向各个 <em>buffer</em>，<em>buffer</em> 里再存数据，每个 <em>buffer</em> 的大小一致，每次扩充都是扩充一个指针指向一个新的 <em>buffer</em></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/2f6ad616b0641315dc4cf94745145e4b.png" alt="image-20230819111424969"></p>
<p>map其实是vector，它扩充的时候会增长为原来的2倍，移动原数据到新内存空间的时候，它会放到新内存空间的中间，方便扩充</p>
<p>比如：原来大小为8，扩充为16，那原来这8个放在 5-12这个位置，前面和留后面留着扩充</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_deque</span><span class="params">(<span class="type">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">     </span><br><span class="line">    deque&lt;string&gt; c;  <span class="comment">// 创建一个双端队列  	</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];  <span class="comment">// 字符串缓冲区</span></span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    string target = <span class="built_in">get_a_target_string</span>();  <span class="comment">// 获取目标字符串	</span></span><br><span class="line">    timeStart = <span class="built_in">clock</span>();	</span><br><span class="line">    <span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);  <span class="comment">// 在队列中查找目标字符串	</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;std::find()，milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;  <span class="comment">// 输出查找时间		</span></span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    	</span><br><span class="line">    timeStart = <span class="built_in">clock</span>();		</span><br><span class="line">    <span class="built_in">sort</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());  <span class="comment">// 对队列进行排序					</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sort()，milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;  <span class="comment">// 输出排序时间		</span></span><br><span class="line">	</span><br><span class="line">    c.<span class="built_in">clear</span>();  <span class="comment">// 清空队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/4b6d7996a0bbf2aa84149acf1b094145.png" alt="image-20230819112747434"></p>
<p>随机数据填充容器：2704ms；直接搜索：15ms；排序：3110ms</p>
<blockquote>
<p>下面的 <em>stack</em> 和 <em>queue</em> 内部都是一个 <em>deque</em>，所以技术上这两个可以看作容器适配器 <em>Container Adapter</em></p>
</blockquote>
<hr>
<h6 id="深度探索-4"><a href="#深度探索-4" class="headerlink" title="深度探索"></a>深度探索</h6><p><strong>GCC2.9</strong>下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc, <span class="type">size_t</span> BufSiz = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> deque</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> T* pointer;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> pointer* map_pointer; <span class="comment">// T** 指向指针的指针</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	iterator start;</span><br><span class="line">	iterator finish;</span><br><span class="line">	map_pointer map;</span><br><span class="line">	size_type map_size;</span><br><span class="line">    <span class="comment">// 两个迭代器:16*2，一个指针:4，一个size_t:4，一共40字节</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> finish - start; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：第三个模板参数 <code>size_t BufSiz = 0</code> 有一个函数：</p>
<p>如果不为0，则 buffer size 就是传入的数据</p>
<p>如果为0，表示预设值，那么</p>
<p>如果 <code>sz = sizeof(value_type)</code> &lt; 512，传回 <code>512/sz</code><br>如果 <code>sz = sizeof(value_type)</code> &gt;&#x3D; 512，传回 <code>1</code></p>
</blockquote>
<p>迭代器四个指针，<code>cur</code> 指向当前元素，<code>first</code> 指向当前 buffer 的第一个元素，<code>last</code> 指向当前 buffer 的最后一个元素的下一个，<code>node</code> 指向当前 buffer 在 map（控制中心）的指针</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/2ccb92a21a2729ae9b05d3de1c08ccae.png" alt="image-20230828084817056"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deque迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">// (1)</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">// (2)</span></span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer; <span class="comment">// (3)</span></span><br><span class="line">	<span class="keyword">typedef</span> Ref reference; <span class="comment">// (4)</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; <span class="comment">// (5)</span></span><br><span class="line">	<span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line">	<span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line"></span><br><span class="line">	T* cur;</span><br><span class="line">	T* first;</span><br><span class="line">	T* last;</span><br><span class="line">	map_pointer node; <span class="comment">// 指向指针的指针</span></span><br><span class="line">    <span class="comment">// 四个指针，一共16字节</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>deque 中的 <em>insert</em> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position.cur == start.cur) <span class="comment">// 插入点在deque最前端      </span></span><br><span class="line">    &#123;							<span class="comment">// 交给push_front</span></span><br><span class="line">        <span class="built_in">push_front</span>(x);</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur) <span class="comment">// 插入点在deque最尾端</span></span><br><span class="line">    &#123;								  <span class="comment">// 交给push_front</span></span><br><span class="line">        <span class="built_in">push_back</span>(x);</span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        --tmp;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 在中间插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_aux</span>(position, x);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">insert_aux</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    difference_type index = pos - start; <span class="comment">// 安插点前元素个数</span></span><br><span class="line">    value_type x_copy = x;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="built_in">size</span>() / <span class="number">2</span>) <span class="comment">// 安插点前的元素少————搬前面的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">push_front</span>(<span class="built_in">front</span>());</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">copy</span>(front2, pos1, front1); <span class="comment">// 搬元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 安插点后的元素少————搬后面的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">push_back</span>(<span class="built_in">back</span>());</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">copy_backward</span>(pos, back2, back1);</span><br><span class="line">    &#125;</span><br><span class="line">    *pos = x_copy; <span class="comment">// 安插点设新值</span></span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>deque 模拟连续空间（deque iterator 的功能）：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/78469510fa69e1635333a6324580906e.png" alt="image-20230828093535797"></p>
<ul>
<li><p><code>-</code>：两个位置之间的距离——前闭后开的元素个数</p>
<p>两个位置之间的距离 &#x3D; buffer_size * 两个位置之间 buffer 的数量 + 末尾位置到 buffer 前端的长度 + 起始位置到 buffer 末尾的长度</p>
</li>
<li><p><code>++</code>&#x2F;<code>--</code>：注：下面带参数的是后++（i++）</p>
</li>
<li><p><code>+=</code>&#x2F;<code>+</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n)</span><br><span class="line">&#123;</span><br><span class="line">    difference_type offset = n + (cur - first);  </span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()))  </span><br><span class="line">        <span class="comment">// 若+了之后在缓冲区大小范围内</span></span><br><span class="line">        cur += n;  <span class="comment">// 直接移动迭代器 n 步</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        difference_type node_offset = offset &gt; <span class="number">0</span> ? offset / <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) </span><br><span class="line">            : -<span class="built_in">difference_type</span>((-offset - <span class="number">1</span>) / <span class="built_in">buffer_size</span>()) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算偏移的节点数，offset &gt; 0判断是为了之后的-=/-</span></span><br><span class="line">        <span class="comment">// 这里(-offset - 1)后除buffer_size()再-1是为了offset==buffer_size()的情况</span></span><br><span class="line">        <span class="built_in">set_node</span>(node + node_offset);  <span class="comment">// 调整节点，使迭代器指向正确的节点</span></span><br><span class="line">        cur = first + (offset - node_offset * <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()));  <span class="comment">// 调整迭代器位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>+(difference_type n) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;  <span class="comment">// 复制当前迭代器</span></span><br><span class="line">    <span class="keyword">return</span> tmp += n;   <span class="comment">// 返回向前移动 n 步后的迭代器副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>-=</code>&#x2F;<code>-</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -就等于+负的</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> += -n; &#125;</span><br><span class="line">self <span class="keyword">operator</span>-(difference_type n) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp -= n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>[]</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference <span class="keyword">operator</span>[](difference_type n) <span class="type">const</span> </span><br><span class="line">&#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>GCC4.9</strong>下：其实没必要这样</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/2b42428bbfd19b7cf5b4a4bc89b8f48b.png" alt="image-20230829210932604"></p>
<p>G2.91 允许指派 buffer_size</p>
<p>G4.53 不允许了</p>
<h5 id="3-2-7-stack，queque"><a href="#3-2-7-stack，queque" class="headerlink" title="3.2.7 stack，queque"></a>3.2.7 stack，queque</h5><h6 id="测试-5"><a href="#测试-5" class="headerlink" title="测试"></a>测试</h6><p>stack：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/bfc4167220c72a1cc7600a7e56b7ba32.png" alt="image-20230819104008973"></p>
<p>queue：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/ea729478e389f82e7ec219b984d28329.png" alt="image-20230819104029805"></p>
<blockquote>
<p><em>stack</em>，<em>queue</em> 是通过 <code>push()</code> 和 <code>pop()</code> 来放取元素的，且无<em>iterator</em> 的操作</p>
</blockquote>
<hr>
<h6 id="深度探索-5"><a href="#深度探索-5" class="headerlink" title="深度探索"></a>深度探索</h6><p><em>stack</em> 和 <em>queue</em> 内部默认用 <em>deque</em> 来实现，所以有时候不会将这两个认为容器而是<strong>一个适配器</strong></p>
<ul>
<li>底层函数可以使用 <em>list</em> 和 <em>deque</em>（deque默认更快）</li>
<li>queue 不能用 vector，stack 可以用 <em>vector</em></li>
<li>set，map 都不能用</li>
</ul>
<p>用时编译器可以通过的，但在具体使用函数时，若遇到底层容器没有这个函数时，就会报错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// queue</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Sequence c; <span class="comment">// 底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 都是通过底层容器来实现</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">	<span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">	<span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">	<span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_front</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stack</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> stack</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Sequence c; <span class="comment">// 底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 都是通过底层容器来实现</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">	<span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_back</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>stack，queue 都不允许遍历，也不提供 iterator</p>
<h4 id="3-3-关联式容器"><a href="#3-3-关联式容器" class="headerlink" title="3.3 关联式容器"></a>3.3 关联式容器</h4><h5 id="3-3-0-RB-Tree"><a href="#3-3-0-RB-Tree" class="headerlink" title="3.3.0 RB-Tree"></a>3.3.0 RB-Tree</h5><p><strong>红黑树</strong>（Red-Black Tree）是一种自平衡的二叉搜索树 BST（AVL 是另一种），其设计目标是在最坏情况下也能保证基本的动态集合操作（如插入、删除和查找）的时间复杂度为O(log n)。红黑树通过一系列的颜色和性质约束来维持其平衡性，这些约束包括：</p>
<ol>
<li><strong>节点是红色或黑色</strong>：每个节点都有一个颜色属性，可以是红色或黑色。</li>
<li><strong>根节点是黑色</strong>：确保树的根始终为黑色，这有助于维持树的平衡。</li>
<li><strong>所有叶子节点都是黑色</strong>：这里的叶子节点指的是树中的空节点（NIL节点），它们被假定为黑色。</li>
<li><strong>红色节点的子节点必须是黑色</strong>（也称为“不能有两个连续的红色节点”）：这个性质确保了在任何路径上，红色节点不会紧密相连，从而限制了树的高度。</li>
<li><strong>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点</strong>：这个性质被称为“黑色平衡性质”，它确保了树在整体上保持平衡。</li>
</ol>
<blockquote>
<p>rb-tree 提供遍历操作和 iterators，按<em>中序遍历</em>遍历，便可以得到排序状态</p>
</blockquote>
<blockquote>
<p>不能用 iterator 去改变元素的 key（其有严谨的排列规则）</p>
</blockquote>
<blockquote>
<p>rb-tree 提供两种 insertion 操作：<code>insert_unique()</code> 和 <code>insert_equal()</code>，前者表示 key 独一无二，后者表示 key 可重复</p>
</blockquote>
<p><strong>GCC2.9</strong>下：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/dfd99e54d77a47ef4b3c97e7acb55666.png" alt="image-20230830083207175"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="comment">// key的类型</span></span><br><span class="line">		 <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="comment">// Value里包含key和date</span></span><br><span class="line">		 <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="comment">// 从Value中取出key的仿函数</span></span><br><span class="line">		 <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="comment">// 比较key大小的仿函数</span></span><br><span class="line">		 <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> rb_tree</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	size_type node_count; <span class="comment">// rb-tree节点数量，大小4</span></span><br><span class="line">	link_type header; <span class="comment">// 头指针，大小4</span></span><br><span class="line">	Compare Key_compare; <span class="comment">// key比大小的仿函数，大小1</span></span><br><span class="line">    <span class="comment">// sizeof: 9 ——&gt; 12(填充到4的倍数)</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>GCC4.9</strong>下：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/a6d74685d7bb2ce356159608a89c855c.png" alt="image-20230830093745761"></p>
<p><em>_M_color</em> 是 “枚举”（Enumeration）</p>
<h5 id="3-3-1-set-multiset"><a href="#3-3-1-set-multiset" class="headerlink" title="3.3.1 set &#x2F; multiset"></a>3.3.1 set &#x2F; multiset</h5><p>set&#x2F;multiset的value和key合一，value就是key</p>
<h6 id="测试-6"><a href="#测试-6" class="headerlink" title="测试"></a>测试</h6><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/6da4890fd665a5ea5514e45996b7040e.png" alt="image-20230819161037868"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_multiset</span><span class="params">(<span class="type">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\ntest_multiset().......... \n&quot;</span>;</span><br><span class="line">     </span><br><span class="line">    multiset&lt;string&gt; c;  <span class="comment">// 创建一个multiset  	</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];		</span><br><span class="line">    <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();  <span class="comment">// 记录起始时间							</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>; i&lt; value; ++i)  <span class="comment">// 添加元素到multiset中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">&quot;%d&quot;</span>, <span class="built_in">rand</span>());  <span class="comment">// 将随机数转换为字符串格式</span></span><br><span class="line">            c.<span class="built_in">insert</span>(<span class="built_in">string</span>(buf));  <span class="comment">// 将字符串插入multiset中     				</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span>(exception&amp; p) &#123;  <span class="comment">// 捕获可能的异常</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;  <span class="comment">// 输出异常信息</span></span><br><span class="line">            <span class="built_in">abort</span>();  <span class="comment">// 终止程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;毫秒数 : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;  <span class="comment">// 输出时间差，计算插入时间	</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;multiset.size()= &quot;</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// 输出multiset大小	</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;multiset.max_size()= &quot;</span> &lt;&lt; c.<span class="built_in">max_size</span>() &lt;&lt; endl;  <span class="comment">// 输出multiset的最大容量</span></span><br><span class="line">    </span><br><span class="line">    string target = <span class="built_in">get_a_target_string</span>();	</span><br><span class="line">    &#123;</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);  <span class="comment">// 在multiset中使用 std::find(...) 查找目标字符串</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;std::find()，毫秒数 : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;		</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"> 	</span><br><span class="line">    &#123;</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();		</span><br><span class="line">        <span class="keyword">auto</span> pItem = c.<span class="built_in">find</span>(target);  <span class="comment">// 在multiset中使用 c.find(...) 查找目标字符串</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c.find()，毫秒数 : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;		 </span><br><span class="line">        ...</span><br><span class="line">    &#125;	</span><br><span class="line">	 </span><br><span class="line">    c.<span class="built_in">clear</span>();  <span class="comment">// 清空multiset</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>安插元素是使用 <code>insert()</code>，其位置由红黑树决定</p>
</blockquote>
<blockquote>
<p>容器自己有 <code>c.find()</code>，其会比全局的 <code>::find()</code> 快</p>
</blockquote>
<p>运行结果：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/dd7af9538d510707b25bc72c89e7f146.png" alt="image-20230819162112550"></p>
<p>随机数据填充容器：6609ms（其在填充的时候就进行排序了）；直接搜索 <code>::find()</code>：203ms；<code>c.find()</code>：0ms</p>
<hr>
<h6 id="深度探索-6"><a href="#深度探索-6" class="headerlink" title="深度探索"></a>深度探索</h6><p>以 rb-tree 为底层结构，因此有——元素自动排序，key 与 value 和一</p>
<blockquote>
<p>set &#x2F; multiset 提供遍历操作和 iterators，按<em>中序遍历</em>遍历，便可以得到排序状态</p>
</blockquote>
<blockquote>
<p>禁止用 iterator 去改变元素的值（其有严谨的排列规则）</p>
</blockquote>
<blockquote>
<p>set的key 独一无二，其 <code>insert()</code> 操作用的 rb-tree 的：<code>insert_unique()</code></p>
<p>multiset 的 key 可以重复，其 <code>insert()</code> 操作用的 rb-tree 的：<code>insert_equal()</code></p>
</blockquote>
<p><strong>GCC2.9</strong>下：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241019171225154.png" alt="image-20241019171225154"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Compare</span> = less&lt;Key&gt;, <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> set</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> Key key_type;</span><br><span class="line">	<span class="keyword">typedef</span> Key value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">	<span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree&lt;key_type, value_type, identity&lt;value_type&gt;, </span><br><span class="line">    			    key_compare, Alloc&gt; rep_type;</span><br><span class="line">	rep_type t; <span class="comment">// 采用红黑树作为底层机制</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator iterator;</span><br><span class="line">	<span class="comment">// 注意：这里是const_iterator，所以不能用iterator改元素</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-2-map-multimap"><a href="#3-3-2-map-multimap" class="headerlink" title="3.3.2 map &#x2F; multimap"></a>3.3.2 map &#x2F; multimap</h5><p>key是key,val是val</p>
<h6 id="测试-7"><a href="#测试-7" class="headerlink" title="测试"></a>测试</h6><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/8d752c68b48392730e546ff9ad24c0f2.png" alt="image-20230819162351918"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_multimap</span><span class="params">(<span class="type">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    multimap&lt;<span class="type">long</span>, string&gt; c;  <span class="comment">// 创建一个multimap，key 为 long 类型，value 为 string 类型  	</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();  <span class="comment">// 记录起始时间							</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>; i&lt; value; ++i)  <span class="comment">// 添加元素到multimap中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">&quot;%d&quot;</span>, <span class="built_in">rand</span>());  <span class="comment">// 将随机数转换为字符串格式并复制到缓冲区</span></span><br><span class="line">            <span class="comment">// multimap 不可使用 [] 做 insertion </span></span><br><span class="line">            c.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">long</span>, string&gt;(i, buf));  <span class="comment">// 将元素插入multimap中   						</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span>(exception&amp; p) &#123;  <span class="comment">// 捕获可能的异常</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;  <span class="comment">// 输出异常信息</span></span><br><span class="line">            <span class="built_in">abort</span>();  <span class="comment">// 终止程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;毫秒数 : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;  <span class="comment">// 输出时间差，计算插入时间	</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;multimap.size()= &quot;</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// 输出multimap大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;multimap.max_size()= &quot;</span> &lt;&lt; c.<span class="built_in">max_size</span>() &lt;&lt; endl;  <span class="comment">// 输出multimap的最大容量</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> target = <span class="built_in">get_a_target_long</span>();		</span><br><span class="line">    timeStart = <span class="built_in">clock</span>();		</span><br><span class="line">    <span class="keyword">auto</span> pItem = c.<span class="built_in">find</span>(target);  <span class="comment">// 在multimap中查找目标 key								</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c.find()，毫秒数 : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;	 </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到，value=&quot;</span> &lt;&lt; (*pItem).second &lt;&lt; endl;  <span class="comment">// 如果找到，输出找到的值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到！&quot;</span> &lt;&lt; endl;  <span class="comment">// 如果未找到，输出未找到的信息	</span></span><br><span class="line">    </span><br><span class="line">    c.<span class="built_in">clear</span>();  <span class="comment">// 清空multimap		  					</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>c.insert(pair&lt;long, string&gt;(i, buf));</code> 中 <em>key</em> 是从1~1000000，<em>value</em> 是随机取的，将其组合为 <em>pair</em> 插入</p>
</blockquote>
<p>运行结果：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/9633ce7f96c68cd65d57aae788f943b6.png" alt="image-20230819163328911"></p>
<p>随机数据填充容器：4812ms（其在填充的时候就进行排序了）；<code>c.find()</code>：0ms</p>
<hr>
<h6 id="深度探索-7"><a href="#深度探索-7" class="headerlink" title="深度探索"></a>深度探索</h6><p>以 rb-tree 为底层结构，因此有——元素自动排序</p>
<blockquote>
<p>map&#x2F; multimap 提供遍历操作和 iterators，按<em>中序遍历</em>遍历，便可以得到排序状态</p>
</blockquote>
<blockquote>
<p>不能用 iterator 去改变元素的key（其有严谨的排列规则），但可以用 iterator 去改变元素的 data</p>
<p>因此 map &#x2F; multimap 将 user 指定的 <em>key_type</em> 设定成 <code>const</code></p>
</blockquote>
<blockquote>
<p>map的key 独一无二，其 <code>insert()</code> 操作用的 rb-tree 的：<code>insert_unique()</code></p>
<p>multimap 的 key 可以重复，其 <code>insert()</code> 操作用的 rb-tree 的：<code>insert_equal()</code></p>
</blockquote>
<p><strong>GCC2.9</strong>下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="comment">// key的类型</span></span><br><span class="line">		 <span class="keyword">class</span> <span class="title class_">T</span>, <span class="comment">// data的类型</span></span><br><span class="line">		 <span class="keyword">class</span> <span class="title class_">Compare</span> = less&lt;Key&gt;, </span><br><span class="line">		 <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> map</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> Key key_type;</span><br><span class="line">	<span class="keyword">typedef</span> T data_type;</span><br><span class="line">	<span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">	<span class="keyword">typedef</span> pair&lt;<span class="type">const</span> Key, T&gt; value_type;</span><br><span class="line">    <span class="comment">// 注意：这里是const Key ———— 防止改key</span></span><br><span class="line">	<span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree&lt;key_type, value_type, select1st&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">	rep_type t; <span class="comment">// 采用红黑树作为底层机制</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator iterator;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>map 的插入元素有特殊写法：<code>c[i] = string(buf)</code>，其中 <code>i</code> 就是 key；multimap没有</p>
<p>map 的 <code>[]</code> 功能：</p>
<p><strong>访问元素：</strong> 如果指定的键存在于映射中，<code>map[key]</code> 将返回与该键关联的 data；如果键不存在，<code>map[key]</code> 将自动创建一个新的键值对，key 为指定的 key，data 为默认 data，并返回这个默认 data</p>
</blockquote>
<h5 id="3-3-3-HashTable"><a href="#3-3-3-HashTable" class="headerlink" title="3.3.3 HashTable"></a>3.3.3 HashTable</h5><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/660d1a4207e93b879c1c87c748b6586c.png" alt="image-20230830144746686"></p>
<ul>
<li><p>元素的位置 &#x3D; key % bucket大小</p>
</li>
<li><p>bucket vector 的大小为质数</p>
</li>
<li><p>当元素个数大于 bucket 的总数时，bucket vector 扩充并重新打散放在新计算的 bucket 中（<em>rehashing</em> 很花时间）—— bucket 一定比元素多</p>
<blockquote>
<p>在扩充时，按 vector 扩充为2倍大小，但会选择靠进这个数的一个质数做新的大小</p>
</blockquote>
</li>
</ul>
<p><strong>GCC2.9</strong>下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="comment">// Value里包含key和date</span></span><br><span class="line">		  <span class="keyword">class</span> <span class="title class_">Key</span>, <span class="comment">// key的类型</span></span><br><span class="line">		  <span class="keyword">class</span> <span class="title class_">HashFcn</span>, <span class="comment">// hash函数</span></span><br><span class="line">		  <span class="keyword">class</span> <span class="title class_">ExtractKey</span>, <span class="comment">// 从Value中取出key的方法</span></span><br><span class="line">		  <span class="keyword">class</span> <span class="title class_">EqualKey</span>, <span class="comment">// 判断key相等的函数</span></span><br><span class="line">		  <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hashtable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> HashFcn hasher; </span><br><span class="line">	<span class="keyword">typedef</span> EqualKey key_equal; <span class="comment">// 判断key相等的函数</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 3个函数对象，大小一共3（应该是0，因为一些因素）</span></span><br><span class="line">	hasher hash;</span><br><span class="line">	key_equal equals;</span><br><span class="line">	ExtractKey get_key;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> __hashtable_node&lt;Value&gt; node;</span><br><span class="line"></span><br><span class="line">	vector&lt;node*, Alloc&gt; buckets; <span class="comment">// vector里3个指针，大小12</span></span><br><span class="line">	size_type num_elements; <span class="comment">// 大小4</span></span><br><span class="line">    <span class="comment">// 一共19 ——&gt; 20（调整为4的倍数）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buckets.<span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Hash函数：</p>
<p>给传进来的参数生成一个编号</p>
<p>偏特化写不同类型的 hash 函数，下图都是数值类型，直接返回就可以</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/8fd10d9734a5201ced1f3e32b00d00b6.png" alt="image-20230830153207439"></p>
<p>下图对 c 风格的字符串做了处理（也可以自己设计），来生成 hash code</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/e1f74e8077e6e02bd3b7d6cc586c2341.png" alt="image-20230830153109919"></p>
<blockquote>
<p>注意：老版本STL没有提供现成的 <em>string</em> 类型的 hash 函数</p>
</blockquote>
<h5 id="3-3-4-unordered容器"><a href="#3-3-4-unordered容器" class="headerlink" title="3.3.4 unordered容器"></a>3.3.4 unordered容器</h5><h6 id="测试-8"><a href="#测试-8" class="headerlink" title="测试"></a>测试</h6><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/0f4d39c7bf7aed976c5c91d093b3b7ea.png" alt="image-20230818103522538"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_unordered_multiset</span><span class="params">(<span class="type">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\ntest_unordered_multiset().......... \n&quot;</span>;</span><br><span class="line">     </span><br><span class="line">    unordered_multiset&lt;string&gt; c;  <span class="comment">// 创建一个 unordered_multiset  	</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();  <span class="comment">// 记录起始时间							</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>; i&lt; value; ++i)  <span class="comment">// 添加元素到 unordered_multiset 中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">&quot;%d&quot;</span>, <span class="built_in">rand</span>());  <span class="comment">// 将随机数转换为字符串格式</span></span><br><span class="line">            c.<span class="built_in">insert</span>(<span class="built_in">string</span>(buf));  <span class="comment">// 将字符串插入 unordered_multiset 中   			  		</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span>(exception&amp; p) &#123;  <span class="comment">// 捕获可能的异常</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;  <span class="comment">// 输出异常信息</span></span><br><span class="line">            <span class="built_in">abort</span>();  <span class="comment">// 终止程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;毫秒数 : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;  <span class="comment">// 输出时间差，计算插入时间	</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unordered_multiset.size()= &quot;</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// 输出 unordered_multiset 大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unordered_multiset.max_size()= &quot;</span> &lt;&lt; c.<span class="built_in">max_size</span>() &lt;&lt; endl;  <span class="comment">// 输出 unordered_multiset 的最大容量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unordered_multiset.bucket_count()= &quot;</span> &lt;&lt; c.<span class="built_in">bucket_count</span>() &lt;&lt; endl;  <span class="comment">// 输出 unordered_multiset 的桶数量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unordered_multiset.load_factor()= &quot;</span> &lt;&lt; c.<span class="built_in">load_factor</span>() &lt;&lt; endl;  <span class="comment">// 输出 unordered_multiset 的负载因子</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unordered_multiset.max_load_factor()= &quot;</span> &lt;&lt; c.<span class="built_in">max_load_factor</span>() &lt;&lt; endl;  <span class="comment">// 输出 unordered_multiset 的最大负载因子</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unordered_multiset.max_bucket_count()= &quot;</span> &lt;&lt; c.<span class="built_in">max_bucket_count</span>() &lt;&lt; endl;  <span class="comment">// 输出 unordered_multiset 的最大桶数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i=<span class="number">0</span>; i&lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bucket #&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; has &quot;</span> &lt;&lt; c.<span class="built_in">bucket_size</span>(i) &lt;&lt; <span class="string">&quot; elements.\n&quot;</span>;  <span class="comment">// 输出前20个桶中的元素数量</span></span><br><span class="line">    &#125;					</span><br><span class="line">				</span><br><span class="line">    string target = <span class="built_in">get_a_target_string</span>();	</span><br><span class="line">    &#123;</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);  <span class="comment">// 在 unordered_multiset 中使用 std::find(...) 查找目标字符串</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;std::find()，毫秒数 : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;	</span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;found, &quot;</span> &lt;&lt; *pItem &lt;&lt; endl;  <span class="comment">// 如果找到，输出找到的元素</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;not found! &quot;</span> &lt;&lt; endl;  <span class="comment">// 如果未找到，输出未找到的信息	</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();		</span><br><span class="line">        <span class="keyword">auto</span> pItem = c.<span class="built_in">find</span>(target);  <span class="comment">// 在 unordered_multiset 中使用 c.find(...) 查找目标字符串</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c.find()，毫秒数 : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;	 </span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;found, &quot;</span> &lt;&lt; *pItem &lt;&lt; endl;  <span class="comment">// 如果找到，输出找到的元素</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;not found! &quot;</span> &lt;&lt; endl;  <span class="comment">// 如果未找到，输出未找到的信息	</span></span><br><span class="line">    &#125;		</span><br><span class="line">	 </span><br><span class="line">    c.<span class="built_in">clear</span>();  <span class="comment">// 清空unordered_multiset</span></span><br><span class="line">&#125;					</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/3c8d1b775533c415c6169a43a0f05bfc.png" alt="image-20230819164416021"></p>
<p>随机数据填充容器：4406ms；直接搜索 <code>::find()</code>：109ms；<code>c.find()</code>：0ms；前二十个 <em>bucket</em> 中只有一个有24个元素</p>
<h6 id="深度探索-8"><a href="#深度探索-8" class="headerlink" title="深度探索"></a>深度探索</h6><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/a372453cb394dbbeb1c3f8f9f63a6d65.png" alt="image-20230830155954989"></p>
<h3 id="4-分配器"><a href="#4-分配器" class="headerlink" title="4 分配器"></a>4 分配器</h3><h4 id="4-1-测试"><a href="#4-1-测试" class="headerlink" title="4.1 测试"></a>4.1 测试</h4><p>分配器都是与容器共同使用的，一般分配器参数用默认值即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string, allocator&lt;string&gt;&gt; c1;</span><br></pre></td></tr></table></figure>

<p>不建议直接用分配器分配空间，因为其需要在释放内存时也要指明大小</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p; 	</span><br><span class="line">p = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">512</span>, (<span class="type">int</span>*)<span class="number">0</span>); <span class="comment">// 临时变量调用函数</span></span><br><span class="line"><span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p,<span class="number">512</span>); <span class="comment">// 释放时需要指明之前申请的大小</span></span><br></pre></td></tr></table></figure>

<h4 id="4-2-源码解析"><a href="#4-2-源码解析" class="headerlink" title="4.2 源码解析"></a>4.2 源码解析</h4><p><strong>VC6</strong>下：<em>allocator</em> 中有 <code>allocate</code>，<code>deallocate</code> 其分别用函数 <code>::operator new</code> 和 <code>::operator delete</code> 来调用 c 中的 <em>malloc</em> 和 <em>free</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pointer <span class="title">allocate</span><span class="params">(size_type _N, <span class="type">const</span> <span class="type">void</span>*)</span></span>&#123;...&#125; <span class="comment">// 后面一个参数只是用来指明类型的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> _FARQ *_P, size_type)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>这里经过包装还是调用的 malloc 和 free，其执行效率变慢；且如果申请的空间比较小，会有较大比例的额外开销（cookie，调试模式所需空间等等）</p>
<p><strong>GCC2.9</strong> 下：其容器都是调用的名叫 <em>alloc</em> 的分配器</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/655058573413d1f6e2c7c3d9360eccea.png" alt="在这里插入图片描述"></p>
<p>其从0到15有一共16个链表，分别代表8字节到16<em>8字节，例如 #0 的位置用 malloc 要一大块内存，然后做切割，切成一块一块的8字节空间*<em>不带cookie</em></em>，用单向链表穿起来；当要申请6字节的大小的空间时，其就会到 #0 中占用一块 —— 节省空间</p>
<blockquote>
<p>在 GCC4.9 中各个容器又用回了 allocator，而上面的 alloc 变成了<code>__poll_alloc</code></p>
</blockquote>
<h3 id="5-迭代器"><a href="#5-迭代器" class="headerlink" title="5 迭代器"></a>5 迭代器</h3><p>迭代器必须能回答算法的所有提问，才能搭配该算法的所有操作</p>
<h4 id="5-1-迭代器的设计准则"><a href="#5-1-迭代器的设计准则" class="headerlink" title="5.1 迭代器的设计准则"></a>5.1 迭代器的设计准则</h4><p>Iterator 必须提供5种 associated type（说明自己的特性的）来供算法来识别，以便算法正确地使用 Iterator</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category; <span class="comment">// (1)迭代器类别：双向迭代器	</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">// (2)迭代器所指对象的类型</span></span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer; <span class="comment">// (3)迭代器所指对象的指针类型</span></span><br><span class="line">	<span class="keyword">typedef</span> Ref reference; <span class="comment">// (4)迭代器所指对象的引用类型</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; <span class="comment">// (5)两个迭代器之间的距离类型</span></span><br><span class="line">    <span class="comment">// iter1-iter2 时，要保证数据类型以存储任何两个迭代器对象间的距离</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代器回答</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// | Λ</span></span><br><span class="line"><span class="comment">// | |</span></span><br><span class="line"><span class="comment">// | | </span></span><br><span class="line"><span class="comment">// V |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法直接提问</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">algorithm</span><span class="params">(I first, I last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    I::iterator_category</span><br><span class="line">    I::pointer</span><br><span class="line">    I::reference</span><br><span class="line">    I::value_type</span><br><span class="line">    I::difference_type</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但当 Iterator 并不是 class 时，例如指针本身，就不能 <code>typedef</code> 了 —— 这时就要设计一个 <em>Iterator Traits</em></p>
<p><strong>Traits</strong>：用于定义类型特征的信息，从而在编译时根据类型的不同进行不同的操作或处理 —— 类似一个萃取机（针对不同类型做不同操作：偏特化）</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/30a23f652b69e072b3f5d6db9450ecdd.png" alt="image-20230827102754004"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// I是class iterator进</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</span><br><span class="line">    <span class="comment">// typename用于告诉编译器，接下来的标识符是一个类型名，而不是一个变量名或其他名称</span></span><br><span class="line">    <span class="comment">// I::iterator_category 是一个类型名</span></span><br><span class="line">    <span class="comment">// iterator_category是这个迭代器类型内部的一个嵌套类型（typedef ...）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// I是指向T的指针进</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Iterator_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> T* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// I是指向T的常量指针进</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">// 注意是T而不是const T</span></span><br><span class="line">    <span class="comment">// 按理说是const T，但声明一个不能被赋值的变量无用</span></span><br><span class="line">    <span class="comment">// 所以value_type不应加上const</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">const</span> T* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">const</span> T&amp; reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除了 Iterator Traits，还有很多其他 Traits</p>
</blockquote>
<h4 id="5-2-迭代器的分类"><a href="#5-2-迭代器的分类" class="headerlink" title="5.2 迭代器的分类"></a>5.2 迭代器的分类</h4><p>迭代器的分类对算法的效率有很大的影响</p>
<ol>
<li>输入迭代器 <em>input_iterator_tag</em>：istream迭代器</li>
<li>输出迭代器 <em>output_iterator_tag</em>：ostream迭代器</li>
<li>单向迭代器 <em>forward_iterator_tag</em>：forward_list，hash类容器</li>
<li>双向迭代器 <em>bidirectional_iterator_tag</em>： list、红黑树容器</li>
<li>随机存取迭代器 <em>random_access_iterator_tag</em>：array、vector、deque</li>
</ol>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/360bfcd664d8876228828a8a6f2698f4.png" alt="image-20230831085955167"></p>
<blockquote>
<p>用有继承关系的class实现：</p>
<ol>
<li>方便迭代器类型作为参数进行传递，如果是整数的是不方便的</li>
<li>有些算法的实现没有实现所有类型的迭代器类别，就要用继承关系去找父迭代器类别</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> : <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-3迭代器对算法的影响"><a href="#5-3迭代器对算法的影响" class="headerlink" title="5.3迭代器对算法的影响"></a>5.3迭代器对算法的影响</h4><p>1.算法 <em>distance</em> 将会按照迭代器的类别进行不同的操作以提升效率</p>
<ul>
<li>如果迭代器可以跳，直接 <code>last - first</code> 即可</li>
<li>如果迭代器不能跳，就只能一步一步走来计数</li>
</ul>
<p>两者的效率差别很大</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/e81c200aa2b907031a30025d7b089d47.png" alt="image-20230902091354849"></p>
<blockquote>
<p>但如果迭代器类别是 <code>farward_iterator_tag</code> 或者 <code>bidirectional_iterator_tag</code>，该算法没有针对这种类型迭代器实现，就可以用<strong>继承关系</strong>来使用父类的实现（继承关系——<em>“is a”</em> 子类是一种父类，当然可以用父类的实现）</p>
</blockquote>
<p>2.算法 <em>copy</em> 将经过很多判断筛选来找到最高效率的实现</p>
<p>其中用到了 <em>Iterator Traits</em> 和 <em>Type Traits</em> 来进行筛选</p>
<blockquote>
<p><em>has trivial op&#x3D;()</em> 是指的有不重要的拷贝赋值函数（例如复数用的自带的拷贝赋值函数）</p>
</blockquote>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/b573a5f546683feee74f170158c52665.png" alt="image-20230902093014515"></p>
<blockquote>
<p>注意：由于 <em>output_iterator_tag</em>（例如 <em>ostream_iterator</em>）是 <strong>write-only</strong>，无法用 <code>*</code> 来读取内容，所以在设计时就需要再写个专属版本</p>
</blockquote>
<p>在源码中，算法都是模板函数，接受所有的 iterator，但一些算法只能用特定的 iterator，所以其会在模板参数的名称上进行暗示：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/9608ffde3bf57b848da7d2d60f54b389.png" alt="img"></p>
<h3 id="6-算法"><a href="#6-算法" class="headerlink" title="6 算法"></a>6 算法</h3><p>算法的标准样式：需要传进去两个指针</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/b012391cc46975834045199300adc6d6.png" alt="image-20230903084435290"></p>
<h4 id="6-1-算法源码"><a href="#6-1-算法源码" class="headerlink" title="6.1 算法源码"></a>6.1 算法源码</h4><p>算法一般最后一个参数会允许我们传入一个函数对象，使得原来的函数对元素的操作有一定的规则</p>
<h5 id="6-1-1-accumulate"><a href="#6-1-1-accumulate" class="headerlink" title="6.1.1 accumulate"></a>6.1.1 accumulate</h5><p>两个版本：</p>
<ol>
<li><p>元素<strong>累加</strong>到 <em>init</em> 上</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first, InputIterator last, T init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">		init = init + *first; <span class="comment">// 累加到init</span></span><br><span class="line">	<span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>元素<strong>累运算</strong>到 <em>init</em> 上</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">BinaryOperation</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first, InputIterator last, T init, BinaryOperation binary_op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">		init = <span class="built_in">binary_op</span>(init, *first); <span class="comment">// 累运算到init上</span></span><br><span class="line">	<span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这里可以用任意的二元操作（可以是函数，也可以是仿函数）</p>
<p>测试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>   <span class="comment">// std::minus</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span>      <span class="comment">// std::accumulate</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myfunc</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x<span class="number">+2</span>*y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x<span class="number">+3</span>*y;&#125;</span><br><span class="line">&#125; myobj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_accumulate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;\ntest_accumulate().......... \n&quot;</span>;	</span><br><span class="line">  <span class="type">int</span> init = <span class="number">100</span>;</span><br><span class="line">  <span class="type">int</span> nums[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;using default accumulate: &quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">accumulate</span>(nums,nums<span class="number">+3</span>,init);  <span class="comment">//160</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;using functional&#x27;s minus: &quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums<span class="number">+3</span>, init, <span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">//40</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;using custom function: &quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums<span class="number">+3</span>, init, myfunc);	<span class="comment">//220</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;using custom object: &quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums<span class="number">+3</span>, init, myobj);	<span class="comment">//280</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;															 </span><br></pre></td></tr></table></figure>

<h5 id="6-1-2-for-each"><a href="#6-1-2-for-each" class="headerlink" title="6.1.2 for_each"></a>6.1.2 for_each</h5><p>让范围里的所有元素都依次做同一件事情</p>
<p>Function 可以是函数也可以是仿函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Function</span>&gt;</span><br><span class="line"><span class="function">Function <span class="title">for_each</span><span class="params">(InputIterator first, InputIterator last, Function f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">		<span class="built_in">f</span>(*first);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>与C++11中的 <em>range-based for statement</em> 差不多</p>
</blockquote>
<h5 id="6-1-3-replace…"><a href="#6-1-3-replace…" class="headerlink" title="6.1.3 replace…"></a>6.1.3 replace…</h5><ul>
<li><p><code>replace</code>：范围内的所有等于 <em>old_value</em> 的，都被 <em>new_value</em> 取代</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">replace</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> T&amp; old_value, <span class="type">const</span> T&amp; new_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*first == old_value) *first = new_value;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>replace_if</code>：范围内所有满足 <code>pred()</code> 为 <em>true</em> 的元素都被 <em>new_value</em> 取代</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>,<span class="keyword">class</span> <span class="title class_">Predicate</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">replace_if</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">	Predicate pred, <span class="type">const</span> T&amp; new_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">pred</span>(*first)) *first = new_value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>replace_copy</code>：范围内的元素全部 copy 到新地方，其中所有等于 <em>old_value</em> 的，都被替代为 <em>new_value</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">replace_copy</span><span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">	OutputIterator result, <span class="type">const</span> T&amp; old_value, <span class="type">const</span> T&amp; new_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first, ++result)</span><br><span class="line">	&#123;</span><br><span class="line">		*result = (*first == old_value) ? new_value : *first;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="6-1-4-count…"><a href="#6-1-4-count…" class="headerlink" title="6.1.4 count…"></a>6.1.4 count…</h5><ul>
<li><p><code>count</code>：在范围中计数值等于 <em>value</em> 的个数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type <span class="comment">// 返回类型</span></span><br><span class="line"><span class="built_in">count</span> (InputIterator first, InputIterator last, <span class="type">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*first == value) ++n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>count_if</code>：在范围中计数满足条件 <code>pred()</code> 的个数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type <span class="comment">// 返回类型</span></span><br><span class="line"><span class="built_in">count_if</span> (InputIterator first, InputIterator last, Predicate pred)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">pred</span>(*first)) ++n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<ul>
<li>容器<strong>不带</strong>成员函数 <code>count()</code>：array，vector，forward_list，deque</li>
<li>容器<strong>自带</strong>成员函数 <code>count()</code>：set &#x2F; multiset，map &#x2F; multimap，unordered_set &#x2F; unordered_multiset，unordered_map &#x2F; unorderd_multimap —— 所有关联式容器</li>
</ul>
</blockquote>
<h5 id="6-1-5-find…"><a href="#6-1-5-find…" class="headerlink" title="6.1 5 find…"></a>6.1 5 find…</h5><ul>
<li><p><code>find</code>：在范围内找到值等于 value 的元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (first != last &amp;&amp; *first != value) ++first;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>find_if</code>：在范围内找到满足 <code>pred()</code> 的元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find_if</span><span class="params">(InputIterator first, InputIterator last, Predicate pred)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (first != last &amp;&amp; !<span class="built_in">pred</span>(*first)) ++first;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>都是循序查找，效率低</p>
</blockquote>
<blockquote>
<ul>
<li>容器<strong>不带</strong>成员函数 <code>find()</code>：array，vector，forward_list，deque</li>
<li>容器<strong>自带</strong>成员函数 <code>find()</code>：set &#x2F; multiset，map &#x2F; multimap，unordered_set &#x2F; unordered_multiset，unordered_map &#x2F; unorderd_multimap —— 所有关联式容器</li>
</ul>
</blockquote>
<h5 id="6-1-6-sort"><a href="#6-1-6-sort" class="headerlink" title="6.1.6 sort"></a>6.1.6 sort</h5><p>源码复杂</p>
<p>测试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myfunc</span> <span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//仿函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j);&#125;</span><br><span class="line">&#125; myobj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义向量</span></span><br><span class="line"><span class="type">int</span> myints[] = &#123;<span class="number">32</span>,<span class="number">71</span>,<span class="number">12</span>,<span class="number">45</span>,<span class="number">26</span>,<span class="number">80</span>,<span class="number">53</span>,<span class="number">33</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">myvec</span><span class="params">(myints, myints<span class="number">+8</span>)</span></span>;          <span class="comment">// 32 71 12 45 26 80 53 33</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用默认的比较(operator &lt;)</span></span><br><span class="line"><span class="built_in">sort</span>(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">begin</span>()<span class="number">+4</span>);         <span class="comment">//(12 32 45 71)26 80 53 33</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用自己的函数作比较</span></span><br><span class="line"><span class="built_in">sort</span>(myvec.<span class="built_in">begin</span>()<span class="number">+4</span>, myvec.<span class="built_in">end</span>(), myfunc); 	<span class="comment">// 12 32 45 71(26 33 53 80)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用自己的仿函数作比较</span></span><br><span class="line"><span class="built_in">sort</span>(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">end</span>(), myobj);      <span class="comment">//(12 26 32 33 45 53 71 80)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用反向迭代器 reverse iterator 和默认的比较(operator &lt;)</span></span><br><span class="line"><span class="built_in">sort</span>(myvec.<span class="built_in">rbegin</span>(), myvec.<span class="built_in">rend</span>());           <span class="comment">// 80 71 53 45 33 32 26 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用显式默认比较(operator &lt;)</span></span><br><span class="line"><span class="built_in">sort</span>(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 12 26 32 33 45 53 71 80   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用另一个比较标准(operator &gt;)</span></span><br><span class="line"><span class="built_in">sort</span>(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 80 71 53 45 33 32 26 12 </span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>容器<strong>不带</strong>成员函数 <code>sort()</code>：array，vector，deque，所有关联式容器（本身就排好序了）</li>
<li>容器<strong>自带</strong>成员函数 <code>sort()</code>：list，forward_list（只能用自带）</li>
</ul>
</blockquote>
<blockquote>
<p><em>reverse iterator</em>：</p>
<p>其中用的是 <em>reverse_iterator</em> —— <strong>iterator adapter</strong></p>
</blockquote>
<h5 id="6-1-7-binary-search"><a href="#6-1-7-binary-search" class="headerlink" title="6.1.7 binary_search"></a>6.1.7 binary_search</h5><p>二分查找是否存在目标元素（并不给予位置），使用前必须先排序；其主要使用 <code>lower_bound()</code> 来找到能放入 <em>val</em> 的最低位置，再判断该元素是否存在</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">binary_search</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	first = <span class="built_in">lower_bound</span>(first, last, value);</span><br><span class="line">	<span class="keyword">return</span> (first != last &amp;&amp; !(value &lt; *first));</span><br><span class="line">    <span class="comment">// first == last 就是序列中所有元素都小于value</span></span><br><span class="line">    <span class="comment">// first == last 时，*first是没有值的，所以需要先检查</span></span><br><span class="line">    <span class="comment">// value &lt; *first 就是序列中没有等于value的</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>lower_bound()</code>：用于在有序序列中查找&#x3D;&#x3D;第一个大于等于&#x3D;&#x3D;该值的元素（包括目标值本身），并返回一个指向该位置的迭代器</p>
<ul>
<li>如果目标值在序列中多次出现，返回第一个出现的位置</li>
<li>如果目标值在序列中不存在，它将返回指向比目标值大的第一个元素位置，或者返回 <code>last</code></li>
</ul>
<p><code>upper_bound()</code>：用于在有序序列中查找&#x3D;&#x3D;第一个大于&#x3D;&#x3D;该值的元素（不包括目标值本身），并返回一个指向该位置的迭代器</p>
<ul>
<li>如果目标值在序列中多次出现，返回第一个大于目标值的位置</li>
<li>如果目标值在序列中不存在，它将返回与 <code>lower_bound()</code> 一样的位置</li>
</ul>
<p>一样是<strong>前闭后开</strong>的原则，且他们都用的是二分查找的方法</p>
</blockquote>
<h3 id="7-仿函数"><a href="#7-仿函数" class="headerlink" title="7 仿函数"></a>7 仿函数</h3><p>仿函数专门为算法服务，设计成一个函数&#x2F;仿函数是为了能传入算法</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/0d779136531fac0e3580ddc909c9ffe2.png" alt="image-20230904081042763"></p>
<p>STL中的每个仿函数都继承了 <code>binary_function</code> &#x2F; <code>unary_function</code>—— 融入到STL中</p>
<p>STL规定每个 Adaptable Function（之后可以改造的函数）都应该继承其中一个（因为之后 Function Adapter 将会提问）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个操作数的操作，例如“!”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">unary_function</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个操作数的操作，例如“+”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg1</span>, <span class="keyword">class</span> <span class="title class_">Arg2</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binary_function</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 理论大小都是0，实际上可能是1（如果有人继承，那就一定是0）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>仿函数是我们自己可能会写的，所以自己写的时候，如果想要融入STL，就要继承上面的两个之一</p>
</blockquote>
<h3 id="8-适配器"><a href="#8-适配器" class="headerlink" title="8 适配器"></a>8 适配器</h3><ul>
<li>适配器 Adapter 只是一个小变化，比如改个接口，函数名称等等</li>
<li>其出现在三个地方：仿函数适配器，迭代器适配器，容器适配器</li>
<li>可以使用继承 &#x2F; 复合的两种方式实现，STL中都用复合</li>
</ul>
<blockquote>
<p>其思想就是将该记的东西记起来，然后看要怎么样去改造它，以便日后使用</p>
</blockquote>
<h4 id="8-1-容器适配器"><a href="#8-1-容器适配器" class="headerlink" title="8.1 容器适配器"></a>8.1 容器适配器</h4><p><em>stack</em>，<em>queue</em> 都是属于 deque 的 Adapter</p>
<p>比如 stack 中将 deque 的 <code>push_back</code> 改名为 <code>push</code></p>
<h4 id="8-2-函数适配器"><a href="#8-2-函数适配器" class="headerlink" title="8.2 函数适配器"></a>8.2 函数适配器</h4><h5 id="8-2-1-binder2nd"><a href="#8-2-1-binder2nd" class="headerlink" title="8.2.1 binder2nd"></a>8.2.1 binder2nd</h5><p><em>binder2nd</em> —— 绑定第二参数</p>
<p>这个例子的OP就是less&lt;int&gt;</p>
<p>1.先是传给bind2nd函数</p>
<p>2.bind2nd生成binder2nd对象</p>
<p>3.对象里面记录op是less&lt;int&gt;，第二参数是40</p>
<p>4.然后都搞定以后返回一个函数对象op（其实返回的是op调用小括号重载运算符，这是一个函数对象）给到count_if作为第三参数，然后继续执行程序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数范围内所有小于40的元素个数</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">count_if</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), </span><br><span class="line">                 <span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数bind2nd，使用方便</span></span><br><span class="line"><span class="comment">// 编译器自动推动op的类型（函数模板）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> binder2nd&lt;Operation&gt; <span class="title">bind2nd</span><span class="params">(<span class="type">const</span> Operation&amp; op, <span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Operation::second_argument_type arg2_type;</span><br><span class="line">	<span class="comment">// 调用ctor生成一个binder2nd临时对象并返回</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">binder2nd</span>&lt;Operation&gt;(op, <span class="built_in">arg2_type</span>(x)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// binder2nd适配器：将二元函数对象转换为一元函数对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binder2nd</span> </span><br><span class="line">	: <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Operation::first_argument_type,</span><br><span class="line">	                        <span class="keyword">typename</span> Operation::result_type&gt;</span><br><span class="line"><span class="comment">// 可能binder2nd也要被改造，要回答问题</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Operation op; <span class="comment">// 内部成员，记录op和第二实参</span></span><br><span class="line">	<span class="keyword">typename</span> Operation::second_argument_type value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">binder2nd</span>(<span class="type">const</span> Operation&amp; x, </span><br><span class="line">			  <span class="type">const</span> <span class="keyword">typename</span> Operation::second_argument_type&amp; y)</span><br><span class="line">		: <span class="built_in">op</span>(x), <span class="built_in">value</span>(y) &#123;&#125; <span class="comment">// ctor，将op和第二实参记录下来</span></span><br><span class="line">	<span class="function"><span class="keyword">typename</span> Operation::result_type</span></span><br><span class="line"><span class="function">		<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Operation::first_argument_type&amp; x)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">op</span>(x, value); <span class="comment">// 实际调用op，第二实参为value</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然还有：<em>binder1st</em> —— 绑定第二参数</p>
<p>新型适配器：<code>bind</code>，代替了 <code>bind1st</code>，<code>bind2nd</code>，<code>binder1st</code>，<code>binder2nd</code></p>
<h5 id="8-2-2-not1"><a href="#8-2-2-not1" class="headerlink" title="8.2.2 not1"></a>8.2.2 not1</h5><p><em>not1</em> —— 否定</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数范围内所有大于等于40的元素个数</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">count_if</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), </span><br><span class="line">    			<span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>)));</span><br></pre></td></tr></table></figure>

<h5 id="8-2-3-bind"><a href="#8-2-3-bind" class="headerlink" title="8.2.3 bind"></a>8.2.3 bind</h5><p>C++11提供的 <em>Adapter</em>，其可以绑定：</p>
<ol>
<li>functions</li>
<li>function objects</li>
<li>member functions</li>
<li>data members</li>
</ol>
<p>测试函数 &#x2F; 对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functions</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">my_divide</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x/y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function objects 测试与functions同理</span></span><br><span class="line"><span class="comment">// divides&lt;double&gt; my_divide;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPair</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// data members</span></span><br><span class="line">	<span class="type">double</span> a, b;</span><br><span class="line">    <span class="comment">// member functions</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">multiply</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a*b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>占位符 <em>placeholders</em>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using namespace std::placeholders;</span><br></pre></td></tr></table></figure>

<p>提供了 <code>_1</code>，<code>_2</code>，<code>_3</code>，·······</p>
<p>下面的的 <code>_1</code> 指的是被绑函数中的第一个参数</p>
</blockquote>
<ul>
<li><p>binding <em>functions &#x2F; function objects</em> 测试</p>
<ul>
<li><p>单纯将两个整数 <code>10</code>，<code>2</code> 绑定到 <code>my_divide</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>(my_divide, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>() &lt;&lt; endl; <span class="comment">// 5.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用 <code>_1</code> 占据第一参数，第二参数绑定2，即 <code>x/2</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fn_half = <span class="built_in">bind</span>(my_divide, _1, <span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_half</span>(<span class="number">10</span>) &lt;&lt; endl; <span class="comment">// 5.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用 <code>_1</code> 占据第一参数，<code>_2</code> 占据第二参数，即 <code>y/x</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fn_invert = <span class="built_in">bind</span>(my_divide, _2, _1);</span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_invert</span>(<span class="number">10</span>, <span class="number">2</span>) &lt;&lt; endl; <span class="comment">// 0.2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>给 <code>bind</code> 指定了一个模板参数 <code>int</code>，将 <code>my_divide</code> 的返回类型变为 <code>int</code>，即 <code>int(x/y)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fn_rounding = <span class="built_in">bind</span>&lt;<span class="type">int</span>&gt;(my_divide, _1, _2);</span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_rounding</span>(<span class="number">10</span>, <span class="number">3</span>) &lt;&lt; endl; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>binding <em>member functions &#x2F; data members</em> 测试</p>
<p><code>MyPair ten_two &#123;10, 2&#125;;</code> 用C++11的新语法定义一个实例</p>
<p>当函数是类的成员函数时，直接使用函数名并不能获取其地址（因为成员函数隐含地需要一个类的实例来调用），而是需要使用特定的语法来获取指向成员函数的指针。这时，<code>&amp;</code>的使用就显得尤为重要了。对于普通的全局函数或静态成员函数，直接使用函数名和加<code>&amp;</code>都可以获取其地址。</p>
<ul>
<li><p>绑定 <em>member functions</em>，由于成员函数有 <code>this</code>，所以 <code>_1</code> 就相当于 <code>this</code>，即 <code>x.multiply()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> bound_memfn = <span class="built_in">bind</span>(&amp;MyPair::multiply, _1);</span><br><span class="line">cout &lt;&lt; <span class="built_in">bound_memfn</span>(ten_two) &lt;&lt; endl; <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定 <em>data members</em>，绑定是谁的数据</p>
<p>把实例 <code>ten_two</code> 绑定到 <code>a</code>，即 <code>ten_two.a</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> bound_memdata = <span class="built_in">bind</span>(&amp;MyPair::a, ten_two);</span><br><span class="line">cout &lt;&lt; <span class="built_in">bound_memdata</span>() &lt;&lt; endl; <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>用占位符绑定，即 <code>x.a</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> bound_member_data2 = <span class="built_in">bind</span>(&amp;MyPair::b, _1);</span><br><span class="line">cout &lt;&lt; <span class="built_in">bound_member_data2</span>(ten_two) &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="8-3-迭代器适配器"><a href="#8-3-迭代器适配器" class="headerlink" title="8.3 迭代器适配器"></a>8.3 迭代器适配器</h4><h5 id="8-3-1-reverse-iterator"><a href="#8-3-1-reverse-iterator" class="headerlink" title="8.3.1 reverse_iterator"></a>8.3.1 reverse_iterator</h5><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/b9de6363bddb95f526dab34dc5162fea.png" alt="image-20230922162253063"></p>
<blockquote>
<p>注意：对逆向迭代器取值，就是取其所指正向迭代器的前一个位置</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">reverse_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Iterator current;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 五个associated types与对应的正向迭代器相同</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> Iterator iterator_type; <span class="comment">// 代表正向迭代器</span></span><br><span class="line">	<span class="keyword">typedef</span> reverse_iterator&lt;Iterator&gt; self; <span class="comment">// 代表逆向迭代器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">reverse_iterator</span><span class="params">(iterator_type x)</span> : current(x) &#123;</span>&#125;</span><br><span class="line">	<span class="built_in">reverse_iterator</span>(<span class="type">const</span> self&amp; x) : <span class="built_in">current</span>(x.current) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator_type <span class="title">base</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> current; &#125; <span class="comment">// 取出正向迭代器</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 对逆向迭代器取值，就是取其所指正向迭代器的前一个位置</span></span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="type">const</span> </span><br><span class="line">	&#123; Iterator tmp = current; <span class="keyword">return</span> *--tmp; &#125;</span><br><span class="line"></span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125; <span class="comment">// 同上</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 前进变后退，后退变前进</span></span><br><span class="line">	self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">	&#123; --current; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">	self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">	&#123; ++current; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">	self <span class="keyword">operator</span>+(difference_type n)<span class="type">const</span></span><br><span class="line">	&#123; <span class="keyword">return</span> <span class="built_in">self</span>(current-n); &#125;</span><br><span class="line">	self <span class="keyword">operator</span>-(difference_type n)<span class="type">const</span></span><br><span class="line">	&#123; <span class="keyword">return</span> <span class="built_in">self</span>(current+n); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="8-3-2-inserter"><a href="#8-3-2-inserter" class="headerlink" title="8.3.2 inserter"></a>8.3.2 inserter</h5><p>对于 <code>copy(InputIterator first, InputIterator last, OutputIterator result)</code>，其会不管 <code>OutputIterator</code> 后是否有充裕空间，对 <code>result</code> 开始依次<strong>赋值</strong></p>
<p>但如果使用 <code>inserter</code>，就会有如下用 <code>copy</code> 实现的插入的效果</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/d0a54f540e37805fb74f551d91eaf5c6.png" alt="image-20230922165235291"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; foo, bar;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    foo.<span class="built_in">push_back</span>(i);</span><br><span class="line">    bar.<span class="built_in">push_back</span>(i*<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it = foo.<span class="built_in">begin</span>();</span><br><span class="line"><span class="built_in">advance</span>(it, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(bar.<span class="built_in">begin</span>(), bar.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(foo, it));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：其是 <em>output_iterator_tag</em></p>
</blockquote>
<p>其实现原理核心就是 —— 对 <code>=</code> 的<strong>操作符重载</strong></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241020160248042.png" alt="image-20241020160248042"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">insert_iterator&lt;Container&gt;&amp;</span><br><span class="line"><span class="keyword">operator</span>=(<span class="type">const</span> <span class="keyword">typename</span> Container::value_type&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 关键：转调用insert()</span></span><br><span class="line">	iter = container-&gt;<span class="built_in">insert</span>(iter, val);</span><br><span class="line">	++iter; <span class="comment">// 使其一直随target贴身移动</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-4-X适配器"><a href="#8-4-X适配器" class="headerlink" title="8.4 X适配器"></a>8.4 X适配器</h4><h5 id="8-4-1-ostream-iterator"><a href="#8-4-1-ostream-iterator" class="headerlink" title="8.4.1 ostream_iterator"></a>8.4.1 ostream_iterator</h5><p>其会将 <code>copy</code> 变为一个输出工具，分隔符是 <code>,</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_it</span><span class="params">(cout, <span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), out_it); <span class="comment">// 1,2,3,4,5,6,7,8,9,10,</span></span><br></pre></td></tr></table></figure>

<p>其核心依然是<strong>操作符重载</strong>，这样就相当于 <code>cout&lt;&lt;*first;</code> <code>cout&lt;&lt;&quot;,&quot;;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">basic_ostream&lt;charT,traits&gt;* out_stream;</span><br><span class="line"><span class="type">const</span> charT* delim;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">ostream_iterator&lt;T, charT, traits&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">	*out_stream &lt;&lt; value;</span><br><span class="line">	<span class="keyword">if</span>(delim!=<span class="number">0</span>) *out_stream &lt;&lt; delim; <span class="comment">// 分隔符delimiter</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream_iterator&lt;T,charT,traits&gt;&amp; <span class="keyword">operator</span>*()&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">ostream_iterator&lt;T,charT,traits&gt;&amp; <span class="keyword">operator</span>++()&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其中 <code>out_stream</code> 存的 <code>cout</code>，<code>delim</code> 存的 <code>,</code></p>
<h5 id="8-4-2-istream-iterator"><a href="#8-4-2-istream-iterator" class="headerlink" title="8.4.2 istream_iterator"></a>8.4.2 istream_iterator</h5><p>例一：</p>
<p>在创建 <code>iit</code> 的时候就已经把所有的键盘输入读进去了，之后就是一个一个取出来赋值给 value 的操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> value1, value2;</span><br><span class="line">istream_iterator&lt;<span class="type">double</span>&gt; eos; <span class="comment">// end of stream iterator</span></span><br><span class="line"><span class="function">istream_iterator&lt;<span class="type">double</span>&gt; <span class="title">iit</span><span class="params">(cin)</span></span>; <span class="comment">// 相当于cin&gt;&gt;value</span></span><br><span class="line"><span class="keyword">if</span>(iit != eos)</span><br><span class="line">    value1 = *iit; <span class="comment">// 相当于return value</span></span><br><span class="line">iit++; <span class="comment">// 迭代器不断++，就是不断地读内容</span></span><br><span class="line"><span class="keyword">if</span>(iit != eos)</span><br><span class="line">    value2 = *iit;</span><br></pre></td></tr></table></figure>

<p>例二：</p>
<p>从 <code>cin</code> 读 data，插入到目的容器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;<span class="type">double</span>&gt; eos; <span class="comment">// end of stream iterator</span></span><br><span class="line"><span class="function">istream_iterator&lt;<span class="type">double</span>&gt; <span class="title">iit</span><span class="params">(cin)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(iit, eos, <span class="built_in">inserter</span>(c,c.<span class="built_in">begin</span>()));</span><br></pre></td></tr></table></figure>

<p>原理依旧是大量的**操作符重载 **—— 就可以改变原函数的作用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">basic_istream&lt;charT, traits&gt;* in_stream;</span><br><span class="line">T value;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="built_in">istream_iterator</span>():<span class="built_in">in_stream</span>(<span class="number">0</span>)&#123;&#125; <span class="comment">// eos</span></span><br><span class="line"><span class="built_in">istream_iterator</span>(istream_type&amp; s):<span class="built_in">in_stream</span>(&amp;s)&#123;++*<span class="keyword">this</span>;&#125; <span class="comment">// 进++</span></span><br><span class="line"></span><br><span class="line">istream_iterator&lt;T,charT,traits,Distance&gt;&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(in_stream &amp;&amp; !(*in_stream &gt;&gt; value)) <span class="comment">// 开始读了</span></span><br><span class="line">        in_stream = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="9-STL周围"><a href="#9-STL周围" class="headerlink" title="9 STL周围"></a>9 STL周围</h3><h4 id="9-1-万用Hash-Function"><a href="#9-1-万用Hash-Function" class="headerlink" title="9.1 万用Hash Function"></a>9.1 万用Hash Function</h4><p>Hash Function的常规写法：其中 <code>hash_val</code> 就是万用Hash Function</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustumerHash</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Customer&amp; c)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> <span class="built_in">hash_val</span>(c.<span class="built_in">fname</span>(), c.<span class="built_in">lname</span>(), c.<span class="built_in">no</span>()); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>还可以直接用函数实现，或者写一个 <code>hash</code> 的特化版本</p>
</blockquote>
<p>原理：</p>
<p>通过三个函数重载实现从给入数据中逐一提取来不断改变 <code>seed</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个函数 首先进入该函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">hash_val</span><span class="params">(<span class="type">const</span> Type&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">size_t</span> seed = <span class="number">0</span>; <span class="comment">// 设置初始seed</span></span><br><span class="line">	<span class="built_in">hash_val</span>(seed, args...); <span class="comment">// 进入第二个函数</span></span><br><span class="line">	<span class="keyword">return</span> seed; <span class="comment">// seed就是最后的HashCode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个函数 该函数中逐一提取一个参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">hash_val</span><span class="params">(<span class="type">size_t</span>&amp; seed, <span class="type">const</span> T&amp; val, <span class="type">const</span> Types&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">hash_combine</span>(seed, val); <span class="comment">// 逐一取val，改变seed</span></span><br><span class="line">	<span class="built_in">hash_val</span>(seed, args...); <span class="comment">// 递归调用自己，直到取完进入第三个函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">hash_val</span><span class="params">(<span class="type">size_t</span>&amp; seed, <span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">hash_combine</span>(seed, val); <span class="comment">// 取最后一个val，改变seed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变seed的函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">hash_combine</span><span class="params">(<span class="type">size_t</span>&amp; seed, <span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 乱七八糟的运算，越乱越好</span></span><br><span class="line">	seed ^= <span class="built_in">hash</span>&lt;T&gt;()(val) + <span class="number">0x9e3779b9</span> + (seed&lt;&lt;<span class="number">6</span>) + (seed&gt;&gt;<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最后的seed就是hash code</p>
<p>C++11中 <em>variadic templates</em>：</p>
<p>从传入的内容（任意个数，任意元素类型）分为一个和其他，递归再分为一个和其他······</p>
</blockquote>
<blockquote>
<p><em>0x9e3779b9</em>：是黄金比例！</p>
</blockquote>
<p>C++11及其后续版本并没有为每个类型都自动提供哈希函数，但它确实为一些标准类型提供了<code>std::hash</code>的特化，并且允许开发者为用户定义的类型提供自己的<code>std::hash</code>特化。</p>
<h4 id="9-2-Tuple"><a href="#9-2-Tuple" class="headerlink" title="9.2 Tuple"></a>9.2 Tuple</h4><p>可以将一些东西组合在一起</p>
<h5 id="9-2-1-用例"><a href="#9-2-1-用例" class="headerlink" title="9.2.1 用例"></a>9.2.1 用例</h5><ul>
<li><p>创建 <code>tuple</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;string, <span class="type">int</span>, <span class="type">int</span>, complex&lt;<span class="type">double</span>&gt;&gt; t; </span><br><span class="line"></span><br><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">float</span>, string&gt; <span class="title">t1</span><span class="params">(<span class="number">41</span>, <span class="number">6.3</span>, <span class="string">&quot;nico&quot;</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> t2 = <span class="built_in">make_tuple</span>(<span class="number">22</span>, <span class="number">44</span>, <span class="string">&quot;stacy&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出 <code>tuple</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出t1中的第一个</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t1) &lt;&lt; endl; <span class="comment">// 41</span></span><br><span class="line">cout &lt;&lt; t &lt;&lt; endl; <span class="comment">// 在VS2022上并没有&lt;&lt;的重载 需要自己写一个重载</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t1 = t2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(t1 &lt; t2) <span class="comment">// 以特定的方式进行的比较 里面的东西拿出来一个一个比</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定解包</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">float</span>, string&gt; <span class="title">t3</span><span class="params">(<span class="number">77</span>, <span class="number">1.1</span>, <span class="string">&quot;more light&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">float</span> f;</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="built_in">tie</span>(i, f, s) = t3; <span class="comment">// i == 77, f == 1.1, s == &quot;more light&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><pre><code class="language-cpp">// tuple里有多少类型
tuple_size&lt; tuple&lt;int, float, string&gt; &gt;::value; // 3

// 取tuple里面的类型，前面一堆代表float
tuple_element&lt;1, TupleType&gt;::type fl = 1.0; // float fl = 1.0;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 9.2.2 原理</span><br><span class="line"></span><br><span class="line">依然是使用 *variadic templates*，通过递归继承，不断从 `...` 中提取内容</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">// 空的tuple</span><br><span class="line">template &lt;&gt; class tuple&lt;&gt; &#123;&#125;; // 直到取完</span><br><span class="line"></span><br><span class="line">// tuple主体</span><br><span class="line">template &lt;typename Head, typename... Tail&gt;</span><br><span class="line">class tuple&lt;Head, Tail...&gt;</span><br><span class="line">	: private tuple&lt;Tail...&gt; // 递归继承</span><br><span class="line">&#123;</span><br><span class="line">    typedef tuple&lt;Tail...&gt; inherited;</span><br><span class="line">public:</span><br><span class="line">	tuple() &#123;&#125;</span><br><span class="line">	tuple(Head v, Tail... vtail) </span><br><span class="line">        : m_head(v), inherited(vtail...) &#123;&#125;</span><br><span class="line">	...</span><br><span class="line">protected:</span><br><span class="line">	Head m_head; // 每次取出的元素</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/79844991bf585c8b1cb306fd337febc8.png" alt="image-20230923111219018"> 👈🏻不断的继承就可以实现不同类型的组合了</p>
<p>其余函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">	<span class="function">Head <span class="title">head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_head; &#125;</span><br><span class="line">	<span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125; <span class="comment">// 通过转型获得Tail部分</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/e0e10eb9bc7c8768450cb051eebe8293.png" alt="image-20230923112317405"> 一般不这么用</p>
<p>出去head的41，剩下的都是tail部分，所以出来的是6.3</p>
<h4 id="9-3-type-traits"><a href="#9-3-type-traits" class="headerlink" title="9.3 type traits"></a>9.3 type traits</h4><h5 id="9-3-1-用例"><a href="#9-3-1-用例" class="headerlink" title="9.3.1 用例"></a>9.3.1 用例</h5><p><strong>GCC2.9</strong>中：</p>
<p>默认的 <code>__type_traits</code> 进行了一系列<strong>泛化</strong>的设定（<em>trivial</em> 是不重要的意思）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> <span class="title class_">__true_type</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__false_type</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> __true_type this_dummy_member_must_be_first;</span><br><span class="line">	<span class="keyword">typedef</span> __false_type has_trivial_default_constructor;</span><br><span class="line">	<span class="keyword">typedef</span> __false_type has_trivial_copy_constructor;</span><br><span class="line">	<span class="keyword">typedef</span> __false_type has_trivial_assignment_operator;</span><br><span class="line">	<span class="keyword">typedef</span> __false_type has_trivial_destructor;</span><br><span class="line">	<span class="keyword">typedef</span> __false_type is_POD_type; <span class="comment">// Plain Old Data 类似C的struct</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还会通过<strong>特化</strong>来实现针对不同类型的设定，例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> __true_type has_trivial_default_constructor;</span><br><span class="line">	<span class="keyword">typedef</span> __true_type has_trivial_copy_constructor;</span><br><span class="line">	<span class="keyword">typedef</span> __true_type has_trivial_assignment_operator;</span><br><span class="line">	<span class="keyword">typedef</span> __true_type has_trivial_destructor;</span><br><span class="line">	<span class="keyword">typedef</span> __true_type is_POD_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>C++11</strong>中：<br>有了很多个 <em>type traits</em>，可以回答更多问题</p>
<p>测试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; is_void&lt;T&gt;::value &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; is_integral&lt;T&gt;::value &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; is_floating_point&lt;T&gt;::value &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; is_array&lt;T&gt;::value &lt;&lt; endl;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/ea5226fb1e12611fdd9c9920b6aeb01c.png" alt="image-20230923192837871"></p>
<p>不论是什么类型都可以<strong>自动检测</strong>它的 <em>traits</em>，非常厉害！（里面有虚函数——就能自动检测出它有多态性）</p>
<h5 id="9-3-2-原理"><a href="#9-3-2-原理" class="headerlink" title="9.3.2 原理"></a>9.3.2 原理</h5><p>模板的作用</p>
<p>例 <code>is_integral</code></p>
<p>依然是采用的一种问答的方式实现的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_integral</span></span><br><span class="line">	:<span class="keyword">public</span> __is_intagral_helper&lt;<span class="keyword">typename</span> remove_cv&lt;_Tp&gt;::type&gt;::type</span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure>

<p>首先 <code>remove_cv</code>（<code>const</code> 和 <code>volatile</code>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过偏特化实现remove const</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_const</span></span><br><span class="line">&#123; <span class="keyword">typedef</span> _Tp type &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_const</span>&lt;_Tp <span class="type">const</span>&gt;</span><br><span class="line">&#123; <span class="keyword">typedef</span> _Tp type &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove volatile 同理</span></span><br></pre></td></tr></table></figure>

<p>再通过 <code>__is_intagral_helper</code> 进行问答</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过偏特化实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__is_integral_helper</span></span><br><span class="line">	:<span class="keyword">public</span> false_type &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__is_integral_helper</span>&lt;<span class="type">bool</span>&gt;</span><br><span class="line">	:<span class="keyword">public</span> true_type &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__is_integral_helper</span>&lt;<span class="type">int</span>&gt;</span><br><span class="line">	:<span class="keyword">public</span> true_type &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__is_integral_helper</span>&lt;<span class="type">long</span>&gt;</span><br><span class="line">	:<span class="keyword">public</span> true_type &#123; &#125;;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其他深入 class 内部的一些 traits 比如是否有虚函数，是否是一个类，是否是POD等等，其实现可能都与编译器有关</p>
</blockquote>
<h4 id="9-4-move"><a href="#9-4-move" class="headerlink" title="9.4 move"></a>9.4 move</h4><p><em>moveable class</em> 中有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// move ctor</span></span><br><span class="line"><span class="built_in">MyString</span>(MyString&amp;&amp; str) <span class="keyword">noexcept</span> <span class="comment">// 用&amp;&amp;与普通版本区别开</span></span><br><span class="line">    : _data(str._data), _len(str._len)</span><br><span class="line">&#123;</span><br><span class="line">    str._len = <span class="number">0</span>;</span><br><span class="line">    str._data = <span class="literal">NULL</span>; <span class="comment">// 避免析构函数释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// move assignment</span></span><br><span class="line">MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str)</span><br><span class="line">    &#123;</span><br><span class="line">        _len = str._len;</span><br><span class="line">        _data = str._data;</span><br><span class="line">        str._len = <span class="number">0</span>;</span><br><span class="line">        str._data = <span class="literal">NULL</span>; <span class="comment">// 避免析构函数释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dtor</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">MyString</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_data) <span class="keyword">delete</span> _data; <span class="comment">// 一定要检查</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">C11</span><span class="params">(C1)</span></span>; <span class="comment">// ctor</span></span><br><span class="line"><span class="function">MyString <span class="title">C12</span><span class="params">(move(C1))</span></span>; <span class="comment">// move ctor</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/fd400006aa48c698b6d7e0cd9de1dc13.png" alt="image-20230924094317369"> 是&#x3D;&#x3D;浅拷贝&#x3D;&#x3D;，并且把之前的指向去除了</p>
<p>对于 vector 这样的容器，其用 move 就只是 swap 了三根指针，非常快！</p>
<blockquote>
<p>move 之后原来的东西不能再使用</p>
<p>拿数据插入容器，用<strong>临时对象</strong>，编译器看到就会自动使用 move 版本的</p>
<p><code>MyString C11(C1);</code> 时，创建了一个实例 C11，编译器就不知道是否能用 move，就需要自己 <code>MyString C12(move(C1));</code> 使用 move，但注意之后&#x3D;&#x3D;一定不能用原来的 <code>C1</code>&#x3D;&#x3D;</p>
</blockquote>
<blockquote>
<p><code>&amp;&amp;</code>（右值引用）这是C++11引入的特性，右值引用用于处理临时对象或将资源所有权转移给其他对象，以提高性能和资源管理</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://darling-123456.github.io/">Darling</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://darling-123456.github.io/2024/10/20/C++/%E4%BE%AF%E6%8D%B7%20C++%20STL%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">https://darling-123456.github.io/2024/10/20/C++/侯捷 C++ STL标准库和泛型编程/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://darling-123456.github.io" target="_blank">Darlingの妙妙屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></div><div class="post-share"><div class="social-share" data-image="/img/34.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/10/16/C++/%E6%96%BD%E7%A3%8AC++%20%20%E8%BF%9B%E9%98%B6%20%20%E7%AC%94%E8%AE%B0/" title="施磊C++ | 进阶学习笔记"><img class="cover" src="/img/37.jpg" onerror="onerror=null;src='/img/404_default.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">施磊C++ | 进阶学习笔记</div></div><div class="info-2"><div class="info-item-1">施磊C++ | 进阶学习笔记一、对象的应用优化、右值引用的优化1.1 构造，拷贝，赋值，析构中的优化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;using namespace std;class test&#123;public:	test(int a = 10) :ma(a) &#123; cout &lt;&lt; &quot;test(int)&quot; &lt;&lt; endl; &#125;	~test() &#123; cout &lt;&lt; &quot;~test&quot; &lt;&lt; endl; &#125;	test(const test&amp; t) :ma(t.ma) &#123; cout &lt;&lt; &quot;test(const &amp;)&quot; &lt;&lt; endl; &#125;	test&amp;...</div></div></div></a><a class="pagination-related" href="/2024/10/21/redis%E7%AC%94%E8%AE%B0/" title="Redis"><img class="cover" src="/img/58.jpg" onerror="onerror=null;src='/img/404_default.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Redis</div></div><div class="info-2"><div class="info-item-1">Redis基础一.初始Redis1.1SQL 和 NoSql的区别1.1.1结构化和非结构化 (1) SQL关系性数据库  传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名、字段数据类型、字段约束等等信息，插入的数据必须遵守这些约束  (2) NoSql数据库 NoSql对数据库格式没有严格约束，往往形式松散，自由。 可以是key-value,可以是文档，或者图格式     1.1.2关联和非关联 (1) 关系型数据库  (2) 非关系型数据库 12345678910111213141516171819&#123;  id: 1,  name: &quot;张三&quot;,  orders: [    &#123;       id: 1,       item: &#123;	 id: 10, title: &quot;荣耀6&quot;, price: 4999       &#125;    &#125;,    &#123;       id: 2,       item: &#123;	 id: 20, title:...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/10/16/C++/%E6%96%BD%E7%A3%8AC++%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B%20%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%20%E5%8D%9A%E5%AE%A2%E6%B1%87%E6%80%BB/" title="施磊C++ | 进阶学习笔记"><img class="cover" src="/img/38.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-16</div><div class="info-item-2">施磊C++ | 进阶学习笔记</div></div><div class="info-2"><div class="info-item-1">施磊C++高级进阶课程 | 学习笔记 | 博客汇总以下是CSDN链接 施磊C++ | 进阶学习笔记 | 1.对象的应用优化、右值引用的优化-CSDN博客 施磊C++ | 进阶学习笔记 | 2.智能指针-CSDN博客 施磊C++ | 进阶学习笔记 | 3.绑定器和函数对象、lambda表达式-CSDN博客 施磊C++ | 进阶学习笔记 | 4.c++11内容汇总、多线程应用实践-CSDN博客 施磊C++ | 进阶学习笔记 | 5.设计模式-CSDN博客 剩余有关面试的等到明年投简历前学习 </div></div></div></a><a class="pagination-related" href="/2024/10/24/C++/%E4%BE%AF%E6%8D%B7%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="侯捷内存管理学习笔记 | C++"><img class="cover" src="/img/36.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-24</div><div class="info-item-2">侯捷内存管理学习笔记 | C++</div></div><div class="info-2"><div class="info-item-1">侯捷内存管理学习笔记第一章节 primitives零.new和delete概述C++中的new和delete是用于动态内存分配和释放的操作符，它们的底层机制和工作原理相对复杂，但也可以简单清晰地解释。 new的底层机制和工作原理 内存分配： 当使用new操作符时，它首先会调用底层的内存分配函数（如operator new），这个函数通常是对malloc的封装。malloc会从堆中分配足够的内存空间。 如果内存分配失败，operator...</div></div></div></a><a class="pagination-related" href="/2024/10/16/C++/%E6%96%BD%E7%A3%8AC++%20%20%E8%BF%9B%E9%98%B6%20%20%E7%AC%94%E8%AE%B0/" title="施磊C++ | 进阶学习笔记"><img class="cover" src="/img/37.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-16</div><div class="info-item-2">施磊C++ | 进阶学习笔记</div></div><div class="info-2"><div class="info-item-1">施磊C++ | 进阶学习笔记一、对象的应用优化、右值引用的优化1.1 构造，拷贝，赋值，析构中的优化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;using namespace std;class test&#123;public:	test(int a = 10) :ma(a) &#123; cout &lt;&lt; &quot;test(int)&quot; &lt;&lt; endl; &#125;	~test() &#123; cout &lt;&lt; &quot;~test&quot; &lt;&lt; endl; &#125;	test(const test&amp; t) :ma(t.ma) &#123; cout &lt;&lt; &quot;test(const &amp;)&quot; &lt;&lt; endl; &#125;	test&amp;...</div></div></div></a><a class="pagination-related" href="/2024/10/10/C++/%E4%BE%AF%E6%8D%B7%20%20C++11%20%E6%96%B0%E7%89%B9%E6%80%A7%20%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="侯捷 C++11 新特性 学习笔记"><img class="cover" src="/img/35.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-10</div><div class="info-item-2">侯捷 C++11 新特性 学习笔记</div></div><div class="info-2"><div class="info-item-1">C++11 新特性 学习笔记1.Variadic TemplatesC++11支持函数模板的默认模板参数在 C++98&#x2F;03 标准中，类模板可以有默认的模板参数，如下： 12345template &lt;typename T, typename U = int, U N = 0&gt;struct Foo&#123;    // ...&#125;;  但是却不支持函数的默认模板参数： 12345template &lt;typename T = int&gt;  // error in C++98/03: default template argumentsvoid func()&#123;    // ...&#125;  现在这一限制在 C++11 中被解除了。上面的 func 函数在 C++11 中可以直接使用，代码如下： 12345int main(void)&#123;    func();   //T = int    return 0;&#125;  此时模板参数 T 的类型就为默认值...</div></div></div></a><a class="pagination-related" href="/2023/07/22/C++/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E7%B2%BE%E7%BE%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="黑马程序员C++核心编程学习笔记"><img class="cover" src="/img/32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-22</div><div class="info-item-2">黑马程序员C++核心编程学习笔记</div></div><div class="info-2"><div class="info-item-1">黑马程序员C++核心编程学习笔记一、内存1.1 内存四区C++程序在执行时，将内存大致分为4个区域：代码区，全局区，栈区，堆区  代码区：存放函数体的的二进制代码，操作系统管理。  🔵特点：①共享 ：对于频繁被执行的程序，只需要在内存中有一份代码即可。    ②只读：目的是防止程序意外地修改了它的指令。  全局区：存放全局变量、静态变量和常量（除了const修饰的局部变量）。程序结束时由操作系统释放。   1234567891011121314151617181920212223//全局变量int g_a = 10;const int c_g_a = 10;int main()&#123;	int l_a = 10;	//静态变量	static int s_a = 10;		//常量：字符串常量/const修饰的变量（全局/局部变量）	const char* a = &quot;hello&quot;;	const int c_l_a = 10;	cout &lt;&lt; &quot;局部变量l_a的十进制地址为：&quot; &lt;&lt; (int)&amp;l_a...</div></div></div></a><a class="pagination-related" href="/2023/07/22/C++/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B%E7%B2%BE%E7%BE%8E%E7%AC%94%E8%AE%B0/" title="黑马程序员C++提高编程"><img class="cover" src="/img/33.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-22</div><div class="info-item-2">黑马程序员C++提高编程</div></div><div class="info-2"><div class="info-item-1">黑马程序员C++提高编程  提高阶段主要针对泛型编程和STL技术  一、模板  模板就是建立通用的模具，大大提高复用性,也是泛型编程的思想。C++提供两种模板机制：①函数模板 ②类模板 🔴注意：  ① 模板不是万能的。  ② 模板不能直接使用。 1.1 函数模板1.1.1 函数模板基础知识​      语法： 12template  &lt;typename T &gt;   函数声明或定义  ​       解释：template— 声明创建模板；typename — 可以用class代替；T — 通用的数据类型​      使用：①自动类型推导 ②显示指定类型 🟦意义：提高复用性，将类型参数化。 1234567891011121314151617//函数模板的使用template&lt;typename T&gt;void MySwap(T&amp; a, T&amp; b)&#123;	T temp = a;	a = b;	b = temp;&#125;int main()&#123;	int a = 10;	int b = 20;	MySwap(a,...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Darling</div><div class="author-info-description">为什么学习这么难!</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">57</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Darling-123456"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Darling-123456" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_74795952?type=blog" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="mailto:2214050255@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是Darlingの妙妙屋，更新笔者的学习笔记，联系方式：2214050255@qq.com</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%AF%E6%8D%B7-C-STL%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">侯捷 C++ STL标准库和泛型编程 | 学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-STL%E6%A6%82%E8%BF%B0"><span class="toc-number">1.0.1.</span> <span class="toc-text">1 STL概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%90%8D%E7%A7%B0"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">1.1 头文件名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-STL%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">1.2 STL基础介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-typename"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">1.3 typename</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-OOP-vs-GP"><span class="toc-number">1.0.2.</span> <span class="toc-text">2 OOP vs. GP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%B9%E5%99%A8"><span class="toc-number">1.0.3.</span> <span class="toc-text">3 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%AE%B9%E5%99%A8%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">3.1 容器结构分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">3.2 序列式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1-array"><span class="toc-number">1.0.3.2.1.</span> <span class="toc-text">3.2.1 array</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">1.0.3.2.1.1.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2"><span class="toc-number">1.0.3.2.1.2.</span> <span class="toc-text">深度探索</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-vector"><span class="toc-number">1.0.3.2.2.</span> <span class="toc-text">3.2.2 vector</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-1"><span class="toc-number">1.0.3.2.2.1.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-1"><span class="toc-number">1.0.3.2.2.2.</span> <span class="toc-text">深度探索</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-list"><span class="toc-number">1.0.3.2.3.</span> <span class="toc-text">3.2.3 list</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-2"><span class="toc-number">1.0.3.2.3.1.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-2"><span class="toc-number">1.0.3.2.3.2.</span> <span class="toc-text">深度探索</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-4-forward-list"><span class="toc-number">1.0.3.2.4.</span> <span class="toc-text">3.2.4 forward_list</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-3"><span class="toc-number">1.0.3.2.4.1.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-3"><span class="toc-number">1.0.3.2.4.2.</span> <span class="toc-text">深度探索</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-6-deque"><span class="toc-number">1.0.3.2.5.</span> <span class="toc-text">3.2.6 deque</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-4"><span class="toc-number">1.0.3.2.5.1.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-4"><span class="toc-number">1.0.3.2.5.2.</span> <span class="toc-text">深度探索</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-7-stack%EF%BC%8Cqueque"><span class="toc-number">1.0.3.2.6.</span> <span class="toc-text">3.2.7 stack，queque</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-5"><span class="toc-number">1.0.3.2.6.1.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-5"><span class="toc-number">1.0.3.2.6.2.</span> <span class="toc-text">深度探索</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">1.0.3.3.</span> <span class="toc-text">3.3 关联式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-0-RB-Tree"><span class="toc-number">1.0.3.3.1.</span> <span class="toc-text">3.3.0 RB-Tree</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-set-multiset"><span class="toc-number">1.0.3.3.2.</span> <span class="toc-text">3.3.1 set &#x2F; multiset</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-6"><span class="toc-number">1.0.3.3.2.1.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-6"><span class="toc-number">1.0.3.3.2.2.</span> <span class="toc-text">深度探索</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2-map-multimap"><span class="toc-number">1.0.3.3.3.</span> <span class="toc-text">3.3.2 map &#x2F; multimap</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-7"><span class="toc-number">1.0.3.3.3.1.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-7"><span class="toc-number">1.0.3.3.3.2.</span> <span class="toc-text">深度探索</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-3-HashTable"><span class="toc-number">1.0.3.3.4.</span> <span class="toc-text">3.3.3 HashTable</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-4-unordered%E5%AE%B9%E5%99%A8"><span class="toc-number">1.0.3.3.5.</span> <span class="toc-text">3.3.4 unordered容器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-8"><span class="toc-number">1.0.3.3.5.1.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-8"><span class="toc-number">1.0.3.3.5.2.</span> <span class="toc-text">深度探索</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">1.0.4.</span> <span class="toc-text">4 分配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%B5%8B%E8%AF%95"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">4.1 测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">1.0.4.2.</span> <span class="toc-text">4.2 源码解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.0.5.</span> <span class="toc-text">5 迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%87%86%E5%88%99"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">5.1 迭代器的设计准则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">5.2 迭代器的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AF%B9%E7%AE%97%E6%B3%95%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.0.5.3.</span> <span class="toc-text">5.3迭代器对算法的影响</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%AE%97%E6%B3%95"><span class="toc-number">1.0.6.</span> <span class="toc-text">6 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E7%AE%97%E6%B3%95%E6%BA%90%E7%A0%81"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">6.1 算法源码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-1-accumulate"><span class="toc-number">1.0.6.1.1.</span> <span class="toc-text">6.1.1 accumulate</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-2-for-each"><span class="toc-number">1.0.6.1.2.</span> <span class="toc-text">6.1.2 for_each</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-3-replace%E2%80%A6"><span class="toc-number">1.0.6.1.3.</span> <span class="toc-text">6.1.3 replace…</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-4-count%E2%80%A6"><span class="toc-number">1.0.6.1.4.</span> <span class="toc-text">6.1.4 count…</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-5-find%E2%80%A6"><span class="toc-number">1.0.6.1.5.</span> <span class="toc-text">6.1 5 find…</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-6-sort"><span class="toc-number">1.0.6.1.6.</span> <span class="toc-text">6.1.6 sort</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-7-binary-search"><span class="toc-number">1.0.6.1.7.</span> <span class="toc-text">6.1.7 binary_search</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.7.</span> <span class="toc-text">7 仿函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.0.8.</span> <span class="toc-text">8 适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">8.1 容器适配器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.0.8.2.</span> <span class="toc-text">8.2 函数适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-1-binder2nd"><span class="toc-number">1.0.8.2.1.</span> <span class="toc-text">8.2.1 binder2nd</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-2-not1"><span class="toc-number">1.0.8.2.2.</span> <span class="toc-text">8.2.2 not1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-3-bind"><span class="toc-number">1.0.8.2.3.</span> <span class="toc-text">8.2.3 bind</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.0.8.3.</span> <span class="toc-text">8.3 迭代器适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-3-1-reverse-iterator"><span class="toc-number">1.0.8.3.1.</span> <span class="toc-text">8.3.1 reverse_iterator</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-3-2-inserter"><span class="toc-number">1.0.8.3.2.</span> <span class="toc-text">8.3.2 inserter</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-X%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.0.8.4.</span> <span class="toc-text">8.4 X适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-4-1-ostream-iterator"><span class="toc-number">1.0.8.4.1.</span> <span class="toc-text">8.4.1 ostream_iterator</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-4-2-istream-iterator"><span class="toc-number">1.0.8.4.2.</span> <span class="toc-text">8.4.2 istream_iterator</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-STL%E5%91%A8%E5%9B%B4"><span class="toc-number">1.0.9.</span> <span class="toc-text">9 STL周围</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-%E4%B8%87%E7%94%A8Hash-Function"><span class="toc-number">1.0.9.1.</span> <span class="toc-text">9.1 万用Hash Function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-Tuple"><span class="toc-number">1.0.9.2.</span> <span class="toc-text">9.2 Tuple</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-2-1-%E7%94%A8%E4%BE%8B"><span class="toc-number">1.0.9.2.1.</span> <span class="toc-text">9.2.1 用例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-type-traits"><span class="toc-number">1.0.9.3.</span> <span class="toc-text">9.3 type traits</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-3-1-%E7%94%A8%E4%BE%8B"><span class="toc-number">1.0.9.3.1.</span> <span class="toc-text">9.3.1 用例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-3-2-%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.9.3.2.</span> <span class="toc-text">9.3.2 原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-move"><span class="toc-number">1.0.9.4.</span> <span class="toc-text">9.4 move</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/22/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day70%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E5%AE%8C%E6%88%90%E6%97%85%E9%80%94%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/" title="Day70 | 灵神 | 二分查找：完成旅途的最少时间"><img src="/img/1.jpg" onerror="this.onerror=null;this.src='/img/404_default.jpg'" alt="Day70 | 灵神 | 二分查找：完成旅途的最少时间"/></a><div class="content"><a class="title" href="/2025/03/22/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day70%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E5%AE%8C%E6%88%90%E6%97%85%E9%80%94%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/" title="Day70 | 灵神 | 二分查找：完成旅途的最少时间">Day70 | 灵神 | 二分查找：完成旅途的最少时间</a><time datetime="2025-03-21T16:00:00.000Z" title="发表于 2025-03-22 00:00:00">2025-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/22/%E5%B7%A5%E5%85%B7/Bulk%20Rename%20Utility%EF%BC%88BRU%EF%BC%89%E2%80%94%E2%80%94%E5%A4%A7%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F/" title="Bulk Rename Utility（BRU）——大批量重命名实用程序"><img src="/img/51.jpg" onerror="this.onerror=null;this.src='/img/404_default.jpg'" alt="Bulk Rename Utility（BRU）——大批量重命名实用程序"/></a><div class="content"><a class="title" href="/2025/03/22/%E5%B7%A5%E5%85%B7/Bulk%20Rename%20Utility%EF%BC%88BRU%EF%BC%89%E2%80%94%E2%80%94%E5%A4%A7%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F/" title="Bulk Rename Utility（BRU）——大批量重命名实用程序">Bulk Rename Utility（BRU）——大批量重命名实用程序</a><time datetime="2025-03-21T16:00:00.000Z" title="发表于 2025-03-22 00:00:00">2025-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day69%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/" title="Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂"><img src="/img/2.jpg" onerror="this.onerror=null;this.src='/img/404_default.jpg'" alt="Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂"/></a><div class="content"><a class="title" href="/2025/03/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day69%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/" title="Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂">Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂</a><time datetime="2025-03-21T01:16:25.000Z" title="发表于 2025-03-21 09:16:25">2025-03-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/20/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day68%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9AH%E6%8C%87%E6%95%B0II/" title="Day68 | 灵神 | 二分查找：H指数II"><img src="/img/3.jpg" onerror="this.onerror=null;this.src='/img/404_default.jpg'" alt="Day68 | 灵神 | 二分查找：H指数II"/></a><div class="content"><a class="title" href="/2025/03/20/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day68%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9AH%E6%8C%87%E6%95%B0II/" title="Day68 | 灵神 | 二分查找：H指数II">Day68 | 灵神 | 二分查找：H指数II</a><time datetime="2025-03-19T16:00:00.000Z" title="发表于 2025-03-20 00:00:00">2025-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/19/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day67%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%85%AC%E5%B9%B3%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/" title="Day67 | 灵神 | 二分查找：统计公平数对的数目"><img src="/img/4.jpg" onerror="this.onerror=null;this.src='/img/404_default.jpg'" alt="Day67 | 灵神 | 二分查找：统计公平数对的数目"/></a><div class="content"><a class="title" href="/2025/03/19/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day67%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%85%AC%E5%B9%B3%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/" title="Day67 | 灵神 | 二分查找：统计公平数对的数目">Day67 | 灵神 | 二分查找：统计公平数对的数目</a><time datetime="2025-03-18T16:00:00.000Z" title="发表于 2025-03-19 00:00:00">2025-03-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Darling</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'Darling-123456/giscus-component',
      'data-repo-id': 'R_kgDOOMRtzQ',
      'data-category-id': 'DIC_kwDOOMRtzc4CoTsn',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !true) {
    if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script async src="https://npm.elemecdn.com/tzy-blog/lib/js/other/sakura.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":20,"vOffset":-20},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>