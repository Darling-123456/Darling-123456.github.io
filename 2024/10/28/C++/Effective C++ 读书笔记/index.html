<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Effective C++ 读书笔记 | Darlingの妙妙屋</title><meta name="author" content="Darling"><meta name="copyright" content="Darling"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Effective C++ 读书笔记1、让自己习惯C++条款 01 ：视C++为一个语言联邦C++的四个层次：  C：C++是在C语言的基础上发展而来的 Object-Oriented C++：这是C++中不同于C的部分，这里主要指面向对象。 Template C++：C++中的泛型编程。 STL：这是一个标准模板库，它用模板实现了很多容器、迭代器和算法，使用STL往往事半功倍。  条款 02：">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective C++ 读书笔记">
<meta property="og:url" content="https://darling-123456.github.io/2024/10/28/C++/Effective%20C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Darlingの妙妙屋">
<meta property="og:description" content="Effective C++ 读书笔记1、让自己习惯C++条款 01 ：视C++为一个语言联邦C++的四个层次：  C：C++是在C语言的基础上发展而来的 Object-Oriented C++：这是C++中不同于C的部分，这里主要指面向对象。 Template C++：C++中的泛型编程。 STL：这是一个标准模板库，它用模板实现了很多容器、迭代器和算法，使用STL往往事半功倍。  条款 02：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://darling-123456.github.io/img/30.jpg">
<meta property="article:published_time" content="2024-10-27T16:00:00.000Z">
<meta property="article:modified_time" content="2025-03-22T14:42:05.888Z">
<meta property="article:author" content="Darling">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="读书笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://darling-123456.github.io/img/30.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Effective C++ 读书笔记",
  "url": "https://darling-123456.github.io/2024/10/28/C++/Effective%20C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/",
  "image": "https://darling-123456.github.io/img/30.jpg",
  "datePublished": "2024-10-27T16:00:00.000Z",
  "dateModified": "2025-03-22T14:42:05.888Z",
  "author": [
    {
      "@type": "Person",
      "name": "Darling",
      "url": "https://darling-123456.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://darling-123456.github.io/2024/10/28/C++/Effective%20C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Darling","link":"链接: ","source":"来源: Darlingの妙妙屋","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'medium_zoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Effective C++ 读书笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">57</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/30.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/test.jpg" alt="Logo"><span class="site-name">Darlingの妙妙屋</span></a><a class="nav-page-title" href="/"><span class="site-name">Effective C++ 读书笔记</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Effective C++ 读书笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-27T16:00:00.000Z" title="发表于 2024-10-28 00:00:00">2024-10-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-22T14:42:05.888Z" title="更新于 2025-03-22 22:42:05">2025-03-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84C-%E3%81%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/">从零开始的C++の学习之路</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">20.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>70分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="Effective-C-读书笔记"><a href="#Effective-C-读书笔记" class="headerlink" title="Effective C++ 读书笔记"></a>Effective C++ 读书笔记</h2><h3 id="1、让自己习惯C"><a href="#1、让自己习惯C" class="headerlink" title="1、让自己习惯C++"></a>1、让自己习惯C++</h3><h4 id="条款-01-：视C-为一个语言联邦"><a href="#条款-01-：视C-为一个语言联邦" class="headerlink" title="条款 01 ：视C++为一个语言联邦"></a>条款 01 ：视C++为一个语言联邦</h4><p>C++的四个层次：</p>
<ol>
<li>C：C++是在C语言的基础上发展而来的</li>
<li>Object-Oriented C++：这是C++中不同于C的部分，这里主要指面向对象。</li>
<li>Template C++：C++中的泛型编程。</li>
<li>STL：这是一个标准模板库，它用模板实现了很多容器、迭代器和算法，使用STL往往事半功倍。</li>
</ol>
<h4 id="条款-02：-尽量const、enum、inline替换-define"><a href="#条款-02：-尽量const、enum、inline替换-define" class="headerlink" title="条款 02： 尽量const、enum、inline替换#define"></a>条款 02： 尽量const、enum、inline替换#define</h4><ol>
<li><p>const好处</p>
<ol>
<li>define直接常量替换，出现编译错误不易定位(不知道常量是哪个变量)</li>
<li>define没有作用域，const有作用域提供了封装性</li>
</ol>
</li>
<li><p>enum好处：</p>
<ol>
<li>提供了封装性</li>
<li>编译器肯定不会分配额外内存空间(其实const也不会)</li>
</ol>
</li>
<li><p>inline的好处：</p>
<ol>
<li><p>define宏函数容易造成误用(下面有个例子)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//define误用举例</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) a &gt; b ? a : b</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">MAX</span>(++a, b) <span class="comment">//a++调用2次</span></span><br><span class="line"><span class="built_in">MAX</span>(++a, b<span class="number">+10</span>) <span class="comment">//a++调用一次</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>注意：</strong></p>
<ol>
<li>对于单纯的常量，最好以const对象或enums替换#define</li>
<li>对于形似函数的宏，最好改成内联函数</li>
</ol>
</li>
</ol>
<h4 id="条款-03-：尽可能使用const"><a href="#条款-03-：尽可能使用const" class="headerlink" title="条款 03 ：尽可能使用const"></a>条款 03 ：尽可能使用const</h4><ol>
<li><p>const修饰的变量不允许改变</p>
</li>
<li><p>注意指针常量与常量指针，stl中的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%BF%AD%E4%BB%A3%E5%99%A8&spm=1001.2101.3001.7020">迭代器</a>类似指针（T* const point,指向的元素可以修改）</p>
</li>
<li><p>const成员函数</p>
<ol>
<li><p>可以确认类中哪些成员函数可以修改数据成员</p>
</li>
<li><p>const对象只能调用const 对象成员函数，非const对象既可以调用普通成员函数也可以调用const成员函数(这是因为this指针可以转化为const this，但是const this 不能转化为非 const this)</p>
</li>
<li><p>一个函数是不是const是可以被重载的</p>
</li>
<li><p>更改了指针所指物的成员对象不算是const，但是如果只有指针属于对象，则成函数为bitwise const 不会发生编译器异议</p>
</li>
<li><p>用mutable关键字修饰的成员变量，将永远处于可变状态， 哪怕是在一个const函数中</p>
</li>
<li><p>如果const和非const成员功能类似，用非const版本调用const版本，<strong>避免代码复制</strong>；</p>
</li>
<li><p>以const修饰operator*的返回值类型可以阻止客户因“用户自定义类型而犯错”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a*b=c)</span><br><span class="line">    <span class="comment">//本意是想要做一个比较操作，结果因为返回值不是const的话就可以修改了，直接变成赋值行为，也不会报错。</span></span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTextBlock</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position)<span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">        ...</span><br><span class="line">		<span class="keyword">return</span> pText[position];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> CTextBlock&amp;&gt;(*<span class="keyword">this</span>)[position]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> * pText;</span><br><span class="line">	<span class="type">int</span> length;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="条款-04-：-确定对象使用前已被初始化"><a href="#条款-04-：-确定对象使用前已被初始化" class="headerlink" title="条款 04 ： 确定对象使用前已被初始化"></a>条款 04 ： 确定对象使用前已被初始化</h4><ol>
<li>有些情况下会初始化为0 ，有时候不会被初始化</li>
<li>内置类型，手工初始化</li>
<li>内置以外的类型，构造函数初始化<ol>
<li>构造函数体内的是赋值，初始化列表中才是初始化</li>
<li>初始化顺序要和声明顺序一致</li>
<li>初始化的效率高于赋值<ul>
<li>赋值是先定义变量，在定义的时候已经调用的变量的默认构造函数之后是用了赋值操作符；</li>
<li>初始化时直接调用了拷贝构造函数</li>
<li>const、引用、基类传参（因为基类先于派生类初始化）、对象成员必须在初始化列表中</li>
</ul>
</li>
</ol>
</li>
<li>函数体内的static对象是local static对象，其他static对象是non-local static对象<ol>
<li>定义在不同编译单元内的non-local static对象”初始化次序无明确</li>
<li>static对象只有一份拷贝，且只初始化一次（类似于单例模式）使用local static对象，首次使用时初始化，返回其引用即可（local static声明周期是整个程序），以后再使用无需再次初始化。</li>
</ol>
</li>
<li>总结：<ol>
<li>手动初始化non-member对象</li>
<li>使用初始化列表初始化member对象。</li>
<li>消除初始化次序的不确定性。</li>
</ol>
</li>
</ol>
<p>关于编译单元：</p>
<p>在C++中，非局部静态对象（即全局或文件作用域的静态对象）的初始化次序在不同的<strong>编译单元</strong>（通常是不同的源文件）之间是未定义的。这意味着，如果你在一个编译单元中依赖于另一个编译单元中的全局静态对象的初始化结果，你的程序可能会遇到未定义行为，因为那些对象的初始化次序是不确定的。</p>
<p>为了避免这个问题，可以使用局部静态对象（即在函数内部声明的静态对象）。局部静态对象在它们首次被访问时才会被初始化，并且初始化是线程安全的（在C++11及更高版本中）。由于局部静态对象的初始化是在它们被首次访问的点上明确发生的，因此不存在跨编译单元的初始化次序问题。</p>
<h3 id="2、-构造-析构-赋值运算"><a href="#2、-构造-析构-赋值运算" class="headerlink" title="2、 构造&#x2F;析构&#x2F;赋值运算"></a>2、 构造&#x2F;析构&#x2F;赋值运算</h3><h4 id="条款05-：了解C-默认编写并调用哪些函数"><a href="#条款05-：了解C-默认编写并调用哪些函数" class="headerlink" title="条款05 ：了解C++默认编写并调用哪些函数"></a>条款05 ：了解C++默认编写并调用哪些函数</h4><p> 空类经过<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BC%96%E8%AF%91%E5%99%A8&spm=1001.2101.3001.7020">编译器</a>处理后会有默认<a target="_blank" rel="noopener" href="https://blog.csdn.net/kangroger/article/details/26977205">构造函数、复制构造函数、赋值操作符</a>和<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">析构函数</a>。这些函数都是public且inline</p>
<ol>
<li>默认构造函数，由它来调用基类和non-static成员变量的构造函数</li>
<li>析构函数是否是虚函数，继承基类，如果没基类，那么默认是non-virtual，析构函数会调用基类和non-static成员变量的析构函数。</li>
<li>复制构造函数和赋值操作符中，给成员变量初始化或赋值，会调用成员变量的赋值构造函数和赋值操作符。他们都是<a target="_blank" rel="noopener" href="https://blog.csdn.net/kangroger/article/details/23820267">浅拷贝</a></li>
<li>赋值操作符，有些情况下编译器是不会合成的,例如<ol>
<li>两个成员变量，一个是引用：初始化后不能更改，一个是常量：也是初始化后不能更改，因此不可以用赋值更改变量，此时编译器不会合成</li>
<li>基类的赋值操作是private的，派生类不会生成赋值运算符</li>
</ol>
</li>
</ol>
<h4 id="条款-06-：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款-06-：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款 06 ：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款 06 ：若不想使用编译器自动生成的函数，就该明确拒绝</h4><p>房子是个类，天下没有一样的房子，所以拷贝与赋值都不能使用，将其设置为私有（只声明不定义）就可阻止使用这两个函数</p>
<p><strong>注意</strong>：普通调用会在编译阶段出错（private），友元和成员函数可以访问错误会发生在链接阶段(没有定义)，错误出现越早越好，可以用继承来实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">Uncopyable</span>()&#123;&#125;</span><br><span class="line">	~<span class="built_in">Uncopyable</span>()&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">	Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他类来继承就行了</p>
<p>这样继承的类中如果生产对应的拷贝与赋值<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">构造函数</a>，就会调用基类对应的函数，会发生编译错误</p>
<h4 id="条款-07-：为多态基类声明为virtual析构函数"><a href="#条款-07-：为多态基类声明为virtual析构函数" class="headerlink" title="条款 07 ：为多态基类声明为virtual析构函数"></a>条款 07 ：为多态<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%9F%BA%E7%B1%BB&spm=1001.2101.3001.7020">基类</a>声明为virtual析构函数</h4><ol>
<li><p>创建有层次的类时，将基类的析构函数声明为虚函数</p>
<p>原因：当基类指针（引用）指向子类对象时，如果析构对象通过delete 指针的方式，只会调用基类的析构函数，不会调用子类的析构函数。可能会造成内存泄漏</p>
</li>
<li><p>但是当一个类不做基类时，不要将析构函数弄成虚函数，因为调用过程中会多一步指针操作，同时对象也多了一个虚函数指针，</p>
</li>
<li><p>一个类不含虚函数，不适合做基类，STL中的容器没有虚析构函数，一个类中至少有个虚函数,析构函数才将弄为虚函数</p>
</li>
<li><p>一个类含有纯虚函数，抽象类不能被实例化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AWOV</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">AWOV</span>()=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">AWOV::~<span class="built_in">AWOV</span>()&#123;&#125;<span class="comment">//这一步是必要的</span></span><br></pre></td></tr></table></figure>

<p>如果把这个当做是基类，会有问题，析构函数只有声明没有定义，析构函数从派生类到基类的调用时，会发生链接错误。因此需要定义（空定义）</p>
</li>
</ol>
<h4 id="条款-08-：别让异常逃离析构函数"><a href="#条款-08-：别让异常逃离析构函数" class="headerlink" title="条款 08 ：别让异常逃离析构函数"></a>条款 08 ：别让异常逃离析构函数</h4><ol>
<li><p>析构函数可以抛出异常，但是不建议这么做；例如：</p>
<p>容器销毁会调用析构函数，如果抛出异常，剩下的元素没有被销毁，会造成内存泄漏。如果继续销毁，会存在两个异常，两个异常会导致不明确的行为</p>
</li>
<li><p>有时候又必须在析构函数中执行一些动作，这些动作可能会导致异常，如果调用这些动作不成功会抛出异常，使得异常传播。解决方法如下：</p>
<ol>
<li><p>动作函数抛出错误，就终止程序，调用abort函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">DBConn</span>()<span class="comment">//析构函数关闭连接</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			db.<span class="built_in">close</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span>(……)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//记录下对close调用的失败</span></span><br><span class="line">			std::<span class="built_in">abort</span>();<span class="comment">//退出</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>吞下这个异常,它会压制某些失败动作的重要信息。比较好的是重新设计接口，使得客户能对可能的异常做出反应。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">DBConn</span>()<span class="comment">//析构函数关闭连接</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			db.<span class="built_in">close</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span>(……)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//记录下对close调用的失败</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="条款-09-：-绝不再构造和析构函数中调用virtual函数"><a href="#条款-09-：-绝不再构造和析构函数中调用virtual函数" class="headerlink" title="条款 09 ： 绝不再构造和析构函数中调用virtual函数"></a>条款 09 ： 绝不再构造和析构函数中调用virtual函数</h4><p>人话版本：</p>
<ol>
<li>对象的初始化状态</li>
</ol>
<ul>
<li>在构造函数执行期间，派生类对象的成员变量尚未完全初始化。如果此时通过基类构造函数调用virtual函数，并且该调用试图访问派生类的成员变量或方法，那么可能会访问到尚未初始化的数据，导致未定义行为。</li>
<li>类似地，在析构函数执行期间，派生类对象的成员变量可能已经开始被销毁，其状态已经是未定义的。此时调用virtual函数同样可能导致问题。</li>
</ul>
<ol start="2">
<li>虚函数表的未正确设置</li>
</ol>
<ul>
<li>在C++中，虚函数通常是通过虚函数表（vtable）来实现的。在对象构造过程中，虚函数表可能还没有被正确设置以指向派生类的虚函数实现。因此，在构造函数中调用virtual函数可能会调用到错误的函数实现。</li>
<li>同理，在析构函数执行时，虚函数表可能已经开始被清理或修改，此时调用virtual函数同样可能遇到问题。</li>
</ul>
<ol start="3">
<li>C++语言的规范</li>
</ol>
<ul>
<li>从C++语言规范的角度来看，构造函数和析构函数中的virtual函数调用并不会“下降”到派生类。这意味着，即使在构造函数或析构函数中调用了virtual函数，实际上调用的也将是基类中的版本，而不是派生类中重写的版本。这通常与程序员的预期不符，可能导致难以调试的错误。</li>
</ul>
<ol start="4">
<li>潜在的运行时错误</li>
</ol>
<ul>
<li>在构造和析构期间调用virtual函数可能会增加运行时错误的风险。例如，如果派生类的虚函数实现依赖于某些在构造函数或析构函数中尚未初始化或已被销毁的成员变量，那么这些实现可能会失败或产生不可预测的结果。</li>
</ul>
<ol start="5">
<li>设计上的考虑</li>
</ol>
<ul>
<li>从设计角度来看，构造函数和析构函数的主要职责是初始化和清理对象的资源。它们不应该承担与对象业务逻辑相关的任务，这些任务应该由其他成员函数来处理。因此，将virtual函数调用放在构造函数或析构函数中可能违背了这一设计原则。</li>
</ul>
<p>书中版本：</p>
<ol>
<li><p>这类调用从不下降至子类(当前执行的构造函数与析构函数的那一层)，此时无法呈现多态的性质。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Transaction</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span><span class="type">const</span><span class="comment">//virtual function</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//log the Transaction</span></span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;This is Transaction logTransaction&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Transaction::<span class="built_in">Transaction</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">logTransaction</span>();<span class="comment">//called in Ctor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>:<span class="keyword">public</span> Transaction&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;This is BuyTransaction logTransaction&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SellTransaction</span>:<span class="keyword">public</span> Transaction&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;This is SellTransaction logTransaction&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当有个对象：BuyTransaction b 时，会输出父类的函数内容，这是因为<strong>基类先构造，在基类构造期间，不会下降到派生类去调用派生类的虚函数</strong>，所以调用的是基类的虚函数，此时不表现出多态的性质。</p>
<p>解决方法：将父类的那个函数设置成非虚函数，从derived class构造函数传递参数给base class构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="type">const</span> std::string&amp; parameter)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">logTransaction</span><span class="params">(<span class="type">const</span> std::string&amp; parameter)</span><span class="type">const</span><span class="comment">//no-virtual function</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//log the Transaction</span></span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;This is &quot;</span>&lt;&lt;parameter&lt;&lt;<span class="string">&quot; logTransaction&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Transaction::<span class="built_in">Transaction</span>(<span class="type">const</span> std::string&amp; parameter)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">logTransaction</span>(parameter);<span class="comment">//called in Ctor</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>:<span class="keyword">public</span> Transaction&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	 <span class="built_in">BuyTransaction</span>()</span><br><span class="line">	 :<span class="built_in">Transaction</span>(<span class="built_in">CreatPamameter</span>())</span><br><span class="line">	 &#123;</span><br><span class="line">	 &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	 <span class="function"><span class="type">static</span> std::string <span class="title">CreatPamameter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	 </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;BuyTransaction&quot;</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SellTransaction</span>:<span class="keyword">public</span> Transaction&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SellTransaction</span>()</span><br><span class="line">	 :<span class="built_in">Transaction</span>(<span class="built_in">CreatPamameter</span>())</span><br><span class="line">	 &#123;</span><br><span class="line">	 &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	 <span class="function"><span class="type">static</span> std::string <span class="title">CreatPamameter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	 </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;SellTransaction&quot;</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BuyTransaction b;</span><br><span class="line">	SellTransaction s;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当构造<strong>派生类对象</strong>时，先调用基类的构造函数，此时派生类还没有被构造出来，所以调用的是基类的虚函数。<br>而析构时，派生类已经析构掉了，所以基类析构时仍调用的是基类的虚函数。</p>
<h2 id="错！"><a href="#错！" class="headerlink" title="错！"></a>错！</h2><p>实际上，无论派生类有没有被构造出来，还是已经析构了。在构造、析构函数中一定只会调用本类中的虚函数。 因为在函数进入构造、析构函数时，一定会把虚指针填充为<strong>当前类</strong>虚表的首地址</p>
</li>
</ol>
<h4 id="条款10-：令operator-返回一个reference-to-this"><a href="#条款10-：令operator-返回一个reference-to-this" class="headerlink" title="条款10 ：令operator&#x3D;返回一个reference to *this"></a>条款10 ：令operator&#x3D;返回一个reference to *this</h4><ol>
<li>为了实现连锁赋值，操作符必须返回一个reference指向操作符左侧的实参。其实，如果operator&#x3D;不返回一个引用，返回一个临时对象，照样可以实现连锁赋值（但是这个临时对象会调用一个拷贝构造函数）</li>
<li>与之类似的有+&#x3D;、-&#x3D;等改变左侧操作符的运损，就当做是个协议，我们都去遵守吧</li>
</ol>
<h4 id="条款11-：在operator-中实现“自我赋值”"><a href="#条款11-：在operator-中实现“自我赋值”" class="headerlink" title="条款11 ：在operator&#x3D;中实现“自我赋值”"></a>条款11 ：在operator&#x3D;中实现“自我赋值”</h4><ol>
<li><p>如果自己管理资源，可能会“在停止使用资源之前意外释放了它”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> p;<span class="comment">//如果p之前就已经释放掉了，再次释放会被报错</span></span><br><span class="line">		p=<span class="keyword">new</span> <span class="built_in">int</span>(ths.p);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<p>防止以上的方法就是“证同测试”，判断当前判断是不是赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>==&amp;rhs)<span class="comment">//证同测试</span></span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">delete</span> p;</span><br><span class="line">		p=<span class="keyword">new</span> <span class="built_in">int</span>(rhs.p);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有一个方案是copy与swap技术，用来解决异常安全问题，条款29 详细说明</p>
<p>如果是引用传递</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">const</span> Widget&amp; rhs)</span></span>;<span class="comment">//交换rhs和this</span></span><br><span class="line">	Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">	&#123;</span><br><span class="line">		Widget <span class="built_in">tmp</span>(rhs);<span class="comment">//赋值一份数据</span></span><br><span class="line">		<span class="built_in">swap</span>(tmp)<span class="comment">//交换</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//临时变量会自动销毁</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果是值传递，则不需要新建临时变量，直接使用函数参数即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">const</span> Widget&amp; rhs)</span></span>;<span class="comment">//交换rhs和this</span></span><br><span class="line">	Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget rhs)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">swap</span>(rhs)</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="条款-12-复制对象时勿忘其每一个部分"><a href="#条款-12-复制对象时勿忘其每一个部分" class="headerlink" title="条款 12 : 复制对象时勿忘其每一个部分"></a>条款 12 : 复制对象时勿忘其每一个部分</h4><ol>
<li>一旦给类添加变量，自己写的copying函数（拷贝与赋值构造函数）也要修改，因为编译器不会提醒你；</li>
<li><strong>在派生类层次中，派生类中的构造函数没有初始化的基类部分是通过默认构造函数初始化的（没有就会报错）但是在赋值操作符中，不会调用基类的默认构造函数。因为赋值操作只是给对象赋值，不是初始化，因此不会调用基类的构造函数（重要）</strong></li>
<li>赋值操作符与拷贝构造函数不能相互调用，因为拷贝构造函数是构造一个不存在的对象，而操作符是给一个存在的对象重新赋值。如果你发现拷贝构造和拷贝赋值的重复代码很多，应该去建立一个新的成员函数给两者使用，并且一般命名为init().</li>
</ol>
<h3 id="3、-资源管理"><a href="#3、-资源管理" class="headerlink" title="3、 资源管理"></a>3、 资源管理</h3><h4 id="条款-13：以对象管理资源"><a href="#条款-13：以对象管理资源" class="headerlink" title="条款 13：以对象管理资源"></a>条款 13：以对象管理资源</h4><ol>
<li><p>在一个作用域内，在delete 之前就return了，会造成内存泄漏，所以delete管理内存远远不够</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Investment* pInv=<span class="built_in">CreateInvestment</span>();</span><br><span class="line">	……<span class="comment">//这里提前 return</span></span><br><span class="line">	<span class="keyword">delete</span> pInv;<span class="comment">//释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用对象控制对象，离开了作用域自然会调用析构函数析构，比如使用智能指针auto_ptr(唯一资源使用权，对它的拷贝动作为让旧指针变为nullptr)</p>
<ol>
<li>RAII：资源获取时机即是初始化时机(resource acquisition is initialization)。获取资源后立即放进对象内进行管理。</li>
<li>管理对象运用析构函数确保资源释放。管理对象是开辟在栈上面的，离开作用域系统会自动释放管理对象，自然会调用管理对象的析构函数。</li>
<li>还有一种指针是引用计数器型指针，会记录多少个对象在使用资源，计数器为0，就释放，如share_ptr</li>
<li>auto_ptr和shared_ptr释放资源用的都是delete，而不是delete[],对于数组指针，shared_array来对应。类似的还有scope_array</li>
</ol>
</li>
</ol>
<p>请记住：</p>
<p>为防止资源泄漏,请使用RAII对象,它们在构造函数中获得资源并在析构函数中释放资源。</p>
<p>两个常被使用的RAII classes 分别是tr1 :: shared_ptr和auto_ptr。前者通常是较佳选择,因为其copy行为比较直观。若选择auto_ptr,复制动作会使它(被复制物)指向null。</p>
<h4 id="条款-14：-在资源管理类中小心coping行为"><a href="#条款-14：-在资源管理类中小心coping行为" class="headerlink" title="条款 14： 在资源管理类中小心coping行为"></a>条款 14： 在资源管理类中小心coping行为</h4><ol>
<li><p>但是并不是所有资源都是开辟在堆上，有时候我们需要自己建立资源管理类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* mu)</span>:mutexPtr(mu)</span></span><br><span class="line"><span class="function">	&#123;</span></span><br><span class="line">		<span class="built_in">lock</span>(mutexPtr);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Lock</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">unlock</span>(mutexPtr);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Mutex* mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样客户对Lock的使用方法符合RAII方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Mutex m;<span class="comment">//定义互斥器</span></span><br><span class="line">……</span><br><span class="line">&#123;<span class="comment">//建立区块来定义critical section</span></span><br><span class="line">	<span class="built_in">Lock</span>(&amp;m);</span><br><span class="line">	……<span class="comment">//执行critical section 内的操作</span></span><br><span class="line">&#125;<span class="comment">//在区块末尾，自动解除互斥器的锁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当一个RAII对象被复制，会发生什么？有以下做法</p>
<ol>
<li><p>禁止复制，将coping函数设置为私有，条款6</p>
</li>
<li><p>对管理资源使用引用计数法，复制的时候就加1 。mutexPrt变为类型从Mutex*变为shared即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span>：<span class="keyword">private</span> Uncopyable&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* mu)</span>:mutexPtr(mu,unlock)//以某个Mutex初始化，unlock作为删除其</span></span><br><span class="line"><span class="function">	&#123;</span></span><br><span class="line">		<span class="built_in">lock</span>(mutexPtr);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	shared_prt&lt;Mutex&gt; mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意的是在这个类中并没有自己编写析构函数。因为mutexPtr是类中的普通成员变量，编译器会自动生成析构函数类析构这样的变量。这个在条款5中有说明。</p>
</li>
<li><p>拷贝底部资源（深浅拷贝）</p>
<p>使用资源管理类的目的是保证不需要这个资源时能正确释放。如果这种资源可以任意复制，我们只需编写好适当的copying函数即可。确保拷贝时是深拷贝。<br>比如：C++中的string类，内部是指向heap的指针。当string复制时，底层的指针指向的内容都会多出一份拷贝。</p>
</li>
<li><p>转移底层资源的拥有权。</p>
<p>有时候资源的拥有权只能给一个对象，这时候当资源复制时，就需要剥夺原RAII类对该资源的拥有权。像auto_ptr。在C++11新标准中的std::move便是这个功能。可以把一个左值转换为一个右值。</p>
</li>
</ol>
<p>copying函数如果你不编写，编译器会帮你合成，其合成版本行为可参考条款5。要记住的是不论是自己编写还是编译器合成，都要符合自己资源管理类的需要。</p>
</li>
</ol>
<p>请记住：</p>
<p>复制RALL对象必须一并复制它所管理的资源，所以资源的copying行为决定RALL对象的copying行为</p>
<p>普通而常见的RALL class copying行为是：抑制copying、实行引用计数等。</p>
<h4 id="条款-15-在资源管理类中提供对原始资源的访问"><a href="#条款-15-在资源管理类中提供对原始资源的访问" class="headerlink" title="条款 15 :在资源管理类中提供对原始资源的访问"></a>条款 15 :在资源管理类中提供对原始资源的访问</h4><ol>
<li><p>原始资源，没有经过封装的指针（可以这样理解）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用智能指针来保存返回值</span></span><br><span class="line">shared_prt&lt;Investment&gt; pInv=(<span class="built_in">createInvestment</span>());</span><br><span class="line"><span class="comment">//有这样一个函数,显然是无法将只能指针对象的，这时就需要一个函数将管理的原始资源暴露出来</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dayHeld</span><span class="params">(<span class="type">const</span> Investment* pi)</span></span>;</span><br><span class="line"><span class="comment">//shared_ptr和auto_ptr都提供一个get函数，用于执行这样的显示转换</span></span><br><span class="line"><span class="built_in">dayHeld</span>(pInv.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了使智能指针使用起来像普通指针一样，它们要重载指针取值（pointerdereferencing）操作符（operator-&gt;和operator*)，它们允许转换至底部<strong>原始指针</strong>。</p>
</li>
<li><p>RAII class内的返回资源的函数和封装资源之间有矛盾。的确是这样，但这样不是什么灾难。<strong>RAII class不是为了封装资源，而是为确保资源释放。</strong></p>
</li>
</ol>
<p>请记住：</p>
<p>APIs往往要求访问原始资源(raw resources),所以每一个RAII class应该提供一个“取得其所管理之资源”的办法。</p>
<p>对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全,但隐式转换对客户比较方便。</p>
<h4 id="条款-16-：-成对使用new和delete时要采取相同形式"><a href="#条款-16-：-成对使用new和delete时要采取相同形式" class="headerlink" title="条款 16 ： 成对使用new和delete时要采取相同形式"></a>条款 16 ： 成对使用new和delete时要采取相同形式</h4><ol>
<li>如果使用new开辟内存，就使用delete释放。如果使用new[]开辟内存，就使用delete[]释放。</li>
<li><strong>尽量不使用对数组做typedef动作</strong>。在C++的STL中有string、vector等templates（条款54），可以将数组需求降至几乎为零</li>
</ol>
<h4 id="条款-17-：以独立语句将newed对象置入智能指针"><a href="#条款-17-：以独立语句将newed对象置入智能指针" class="headerlink" title="条款 17 ：以独立语句将newed对象置入智能指针"></a>条款 17 ：以独立语句将newed对象置入智能指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样写是不行的，因为shared_ptr用普通指针构造的构造函数是explict的，不允许隐式转换</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processWidget</span><span class="params">(shared_ptr&lt;Widget&gt; pw, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(<span class="keyword">new</span> Widget,<span class="built_in">priority</span>());</span><br><span class="line"><span class="comment">//这样写可以过编译但是会有资源泄露的问题</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processWidget</span><span class="params">(shared_ptr&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="type">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>在使用智能指针时，应该用独立的语句把新创建的对象指针放入智能指针，否则可能会造成内存泄露</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于这个的传参</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processWidget</span><span class="params">(shared_ptr&lt;Widget&gt; pw, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"></span><br><span class="line">在调用processWidget之前有三件事：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、执行<span class="built_in">priority</span>()函数</span><br><span class="line"><span class="number">2</span>、执行<span class="keyword">new</span> Widget</span><br><span class="line"><span class="number">3</span>、执行shared_ptr构造函数</span><br></pre></td></tr></table></figure>

<p>C++编译器会以什么样的次序来完成这些事情呢？弹性很大。在Java和C#中，总是以特定的次序来完成这样函数参数的计算，但在C++中却不一定。唯一可以确定的是new Widget在shared_ptr之前调用。但是函数priority排在第几却不一定。假设排在第二，那么顺序就是1、执行new Widget。2、执行函数priority()。3执行shared_ptr构造函数。</p>
<p>如果对函数priority()调用出现异常，那么new Widget返回的指针还没来得及放入shared_ptr中。这样会造成内存泄露。</p>
<p>因此可以分开写，先创建，然后在传参</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_prt&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(pw,<span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure></li>
</ol>
<p>请记住：</p>
<p>以独立语句将 newed 对象存储于(置入)智能指针内。如果不这样做,一旦异常被抛出,有可能导致难以察觉的资源泄漏。</p>
<h3 id="4、设计与声明"><a href="#4、设计与声明" class="headerlink" title="4、设计与声明"></a>4、设计与声明</h3><h4 id="条款18：让接口容易被正确使用，不容易被误用"><a href="#条款18：让接口容易被正确使用，不容易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不容易被误用"></a>条款18：让接口容易被正确使用，不容易被误用</h4><p><strong>1、保证参数一致性：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void print_date(int year, int month, int day)</span><br><span class="line">&#123;......&#125;</span><br><span class="line">print_date(2022, 28, 9);//1</span><br><span class="line">print_date(2022, 9, 28);//2</span><br></pre></td></tr></table></figure>

<p>在这样一个打印时间的函数接口中，我们按照年月日的顺序输出，但是1式却输出年日月。错误的参数传递顺序造成了接口的误用。</p>
<p>解决办法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">day</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">month</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">year</span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pd</span><span class="params">(<span class="type">const</span> year&amp; y, <span class="type">const</span> month&amp; m, <span class="type">const</span> day&amp; d)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>当然，传递某个有返回值的函数也是可以解决的，但这种方法看起来很奇怪。</p>
<p><strong>2、保证接口行为一致性：</strong></p>
<p>内置数据类型（ints， double…）可以进行加减乘除的操作，STL中不同容器也有相同函数（比如size，都是返回其有多少对象），所以，尽量保证用户自定义接口的行为一致性。</p>
<p><strong>3、如果一个接口必须有什么操作，那么在它外面套一个新类型：</strong></p>
<p><strong>比如：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">employee* <span class="title">createmp</span><span class="params">()</span></span>;<span class="comment">//其创建的堆对象要求用户必须删除</span></span><br></pre></td></tr></table></figure>

<p>如果用户忘记使用资源管理类，就有错误使用这个接口的可能，所以必须先下手为强，直接将 createmp() 返回一个资源管理对象，比如智能指针share_ptr 等等：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tr1::share_ptr&lt;employee&gt; <span class="title">createmp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>如此就避免了误用的可能性。</p>
<p><strong>4、有些接口可以定制删除器，就像 STL 容器可以自定义排序，比较函数一样</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tr1::share_ptr&lt;employee&gt; <span class="title">p</span><span class="params">(<span class="number">0</span>, my_delete())</span></span>;<span class="comment">//error! 0 不是指针</span></span><br><span class="line"><span class="function">tr1::share_ptr&lt;employee&gt; <span class="title">p</span><span class="params">(<span class="keyword">static_cast</span>&lt;employee*&gt;(<span class="number">0</span>), my_delete())</span></span>;<span class="comment">//定义一个 null 指针</span></span><br></pre></td></tr></table></figure>

<p>第一个参数是被管理的指针，第二个是自定义删除器。</p>
<ol>
<li>好的接口容易被正确使用，不容易被误用。</li>
<li>促进正确使用“的办法包括接口一致性，以及于内置类型兼容。</li>
<li>阻止误用“方法包括建立新类型、限制类型上的操作、束缚对象值，以及消除客户的资源管理责任。</li>
<li>shared_ptr支持特定的删除器。可以防范cross-DLL problem，可以被用来自动解除互斥锁（就是在释放资源的时候解锁）。<ul>
<li>shared_ptr一个特别好的性质是：它会自动使用它的“每个指针专属的删除器”，因而消除另一个潜在客户的错误：Corss-DLL Problem。这个问题发生于：对象在一个动态链接库DLL中被new创建，却在另一个DLL内被delete销毁。在许多平台上，这一类跨DLL之new&#x2F;delete成对使用会导致运行期错误。shared_ptr没有这个问题，因为它的删除器来自其所诞生的那个DLL的delete。</li>
</ul>
</li>
</ol>
<h4 id="条款19-：设计class犹如设计type"><a href="#条款19-：设计class犹如设计type" class="headerlink" title="条款19 ：设计class犹如设计type"></a>条款19 ：设计class犹如设计type</h4><p> 要注意解决以下问题：</p>
<ol>
<li><strong>新type的对象应该如何被创建和销毁？</strong></li>
<li><strong>对象初始化和对象赋值该有什么样的区别？</strong> 条款4</li>
<li><strong>新type的对象如果被pass by value，意味着什么</strong></li>
<li><strong>什么是新type的合法值？</strong></li>
<li><strong>新type需要配合某个继承图系（inheritance graph）吗？</strong> （条款34和条款36）</li>
<li><strong>新type需要什么样的转换？</strong></li>
<li><strong>什么样的操作符和函数对此新type而言是合理的？</strong></li>
<li><strong>什么样的函数应该被驳回？</strong></li>
<li><strong>谁该取用新type的成员？</strong></li>
<li><strong>什么是新type的“未声明接口”（undeclared interface）？</strong></li>
<li><strong>你的新type有多么一般化？</strong></li>
<li><strong>你真的需要一个新type吗？</strong></li>
</ol>
<h4 id="条款20：-宁以pass-by-reference-to-const替换pass-by-value（本条第六点要常看）"><a href="#条款20：-宁以pass-by-reference-to-const替换pass-by-value（本条第六点要常看）" class="headerlink" title="条款20： 宁以pass-by-reference-to-const替换pass-by-value（本条第六点要常看）"></a>条款20： 宁以pass-by-reference-to-const替换pass-by-value（本条第六点要常看）</h4><ol>
<li>在默认情况下，C++函数传递参数是继承C的方式，是值传递（pass by value)。这样传递的都是实际实参的副本，这个副本是通过调用复制构造函数来创建的。有时候创建副本代价非常昂贵</li>
<li>以pass by reference-to-const方式传递，可以回避所有构造函数和析构函数。这种方式传递，没有新对象创建，所以自然没有构造和析构函数的调用参数中，以const修饰是比较重要的，原先的pass by value，原先的值自然不会被修改。现在以pass by reference方式传递，函数validateStudent内使用的对象和传进来的同同一个对象，为了防止在函数内修改，加上const限制。</li>
<li>以pass by reference方式传递，还可以避免对象切割（slicing）问题。一个派生类（derived class）对象以pass by value方式传递，当被视为一个基类对象（base class）时，基类对象的copy构造函数会被调用，此时派生类部分全部被切割掉了，仅仅留下一个base class部分（因为传参的时候是base类创建的副本对象）。</li>
<li>对于内置类型，pass by value往往比pass by reference更高效（（引用本质是指针）。所以在使用STL函数和迭代器时，习惯上都被设计出pass by value</li>
<li>对象小并不意味着copy构造函数代价小，许多对象（包括STL容器），内涵的成员只不过是一两个指针，但是复制这种对象时，要复制指针指向的每一样东西，这个代价很可能十分昂贵。</li>
<li>一般情况下，可以假设内置类型和STL迭代器和函数对象以pass by value是代价不昂贵。其他时候最好以pass by reference to const替换掉pass by value。</li>
</ol>
<h4 id="条款21：-必须返回对象时，别妄想返回其reference"><a href="#条款21：-必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21： 必须返回对象时，别妄想返回其reference"></a>条款21： 必须返回对象时，别妄想返回其reference</h4><p>如下这种会出现错误，因为引用只是对象的别名，返回的是局部Rational对象的别名，但是离开函数后该对象就被析构了，返回的是一个无用值，所以要返回一个值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.n* rhs.n, lhs.d* rhs.d);<span class="comment">//对象析构了，引用别名也是空对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.n* rhs.n, lhs.d* rhs.d);<span class="comment">//返回一个rational对象的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在返回一个reference和返回一个object之间抉择时，挑出行为正确的那个。让编译器厂商为你尽可能降低成本吧！</p>
<h4 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款22：将成员变量声明为private</h4><ol>
<li>封装。如果通过函数访问成员变量，日后可以用某个计算替换这个变量，这时class的客户却不知道内部实现已经变化。</li>
<li>将成员变量声明为private。这可以赋予客户访问数据的一致性、可细微划分访问控制、允许约束条件获得保证，并提供class作者以充分弹性实现。</li>
<li>protected并不比public更具有封装性。</li>
</ol>
<h4 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款23：宁以non-member、non-friend替换member函数</h4><p>非成员函数，非友元函数，成员函数</p>
<p>释义：如果一个成员函数调用了其他的成员函数，那么就要用一个非成员函数替换这个成员函数。</p>
<p>根据条款22，对类变量的操作只能通过类成员函数实现（因为它是私有变量），那么如果一个成员函数内部实现是调用其他的成员函数，则一个非成员函数也可以做到这样的效果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">preson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">func1</span>();</span><br><span class="line">        <span class="built_in">func2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_all</span><span class="params">(<span class="type">const</span> person&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p.<span class="built_in">func1</span>();</span><br><span class="line">    p.<span class="built_in">func2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> func3() 和 use_all() 的效果是一样的，但这时候我们倾向于选择 use_all 函数，因为func3()作为一个成员函数，其本身也是个可以访问私有变量的函数。use_all() 函数其本身不可以访问私有变量。所以 use_all() 比 func3() 更有封装性。（能够访问私有变量的函数越少越好）</p>
<p>在了解这点之后，我们做一些更深层次的探讨：</p>
<p>我们称 use_func()（func3()的非成员函数版本）为便利函数。假设一个类有多个诸如 func1() 的函数，根据排列组合，也就有很多便利函数。为了让这些便利函数和它的类看上去更像一个整体，我们把便利函数和类放在一个 namespace 中。于是，我们可以更为轻松地拓展这些便利函数——多做一些排列组合。</p>
<p><strong>若一个成员函数调用其他成员函数，那么这个成员函数的非成员函数版本比之拥有更多的封装性，和机能扩充性。</strong></p>
<p>总结：</p>
<ol>
<li>用non-member、non-friend函数替换member函数，这样可以增加封装性、包裹弹性和机能扩充性，因为不能访问私有变量。</li>
<li>namespace可以跨越多个源码文件，class不能，将所有的便利函数放在多个头文件但隶属于同一个命名空间，意味着客户可以轻松扩展这一组遍历函数。他们需要做的是添加更多的非成员函数和非友元函数到这个命名空间内</li>
</ol>
<h4 id="条款24：若所有参数皆需要类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数皆需要类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数皆需要类型转换，请为此采用non-member函数"></a>条款24：若所有参数皆需要类型转换，请为此采用non-member函数</h4><ol>
<li><p>通常情况下，class不应该支持隐式类型转换</p>
</li>
<li><p>也有例外，比如建立一个分数管理器，允许隐式类型转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Rational</span>(<span class="type">int</span> numerator=<span class="number">0</span>, <span class="type">int</span> denominator=<span class="number">1</span>);<span class="comment">//非explicit，允许隐式转换</span></span><br><span class="line">	……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然，若作为成员函数，this指针为隐形的参数，只需要一个变量参数传进去</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	……</span><br><span class="line">	<span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs);</span><br><span class="line">	……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>进行混合运算时</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result=oneHalf*<span class="number">2</span>;<span class="comment">//正确，相当于oneHalf.operator*(2);</span></span><br><span class="line">result=<span class="number">2</span>*oneHalf;<span class="comment">//错误，相当于2.operator*(oneHalf);</span></span><br></pre></td></tr></table></figure>

<p>这是错误的，2是this指向的对象，必须是该类本身的类型。这是因为</p>
<ol>
<li>只有参数列于参数表，才是隐式类型的参与者</li>
<li>2不是该类型，不能调用成员函数operator *;</li>
</ol>
<p>因此可以定义为一个非成员函数，可以进行隐式转换的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>总结：如果需要为某个函数的所有参数（包括this指针所指向的隐喻参数）进行类型转换，这个函数必须是个non-member函数</strong></p>
<p><strong>另一说法：如果所有参数（运算符左边或者右边的参数）都需要类型转换，用 non-member 函数。</strong></p>
</li>
</ol>
<h4 id="条款25：考虑写出一个不抛出异常的swap函数"><a href="#条款25：考虑写出一个不抛出异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛出异常的swap函数"></a>条款25：考虑写出一个不抛出异常的swap函数</h4><p>周所周知，swap 可以交换两个数的值，标准库的 swap 函数是通过拷贝完成这种运算的。想想，如果是交换两个类对象的值，如果类中变量的个数很少，那么 swap 是有一定效率的，但如果变量个数很多呢？</p>
<p>你一定联想到了之前提过的，引用传递替换值传递。没错，交换两个类对象的地址就可以很有效率地完成大量变量的 swap 操作。不幸的是，标准库的 swap 并无交换对象地址的行为，所以我们需要自己写 swap 函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_swap</span><span class="params">(person&amp; p1, person&amp; p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(p<span class="number">1.</span>ptr, p<span class="number">2.</span>ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数无法通过编译，因为类变量是 private，无法通过对象访问。所以要把它变成成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">my_swap</span><span class="params">(person&amp; p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;ptr, p.ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果你觉得 p1.my_swap(p2) 的调用形式太low了，你可以设计一个non-member 函数（如果是在同一个命名空间那就再好不过了），实现swap(p1, p2)，这里不做演示。你还可以特化 std 里的 swap 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;person&gt; (person&amp; p1, person&amp; p2)</span><br><span class="line">    &#123;</span><br><span class="line">        p<span class="number">1.</span><span class="built_in">my_swap</span>(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，如果你设计的是类模板，而尝试对swap特化，那么会在 std 里发生重载，这是不允许的，因为用户可以特化 std 的模板，但不可以添加新的东西到 std 里。</p>
<p>还有一点：在上面工作全部完成后，如果想使用 swap ，请确定包含一个 using 声明式，一边让 std::swap 可见，然后直接使用 swap。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 其中过程：</p>
<p>如果T在其命名空间有专属的 swap，则调用，否则调用 std 的swap。</p>
<p>如果在 std 有特化的 swap，则调用，否则调用一般的 swap。（也即是拷贝）</p>
<p>这一点虽然看着很奇怪……</p>
<p>总结</p>
<ol>
<li>如果std::swap不高效时，提供一个swap成员函数，并且确定这个函数不抛出异常。</li>
<li>如果提供一个member-swap,也应该提供一个non-member swap来调用前者。对于class（非class template），要特化std::swap。</li>
<li>调用swap时，针对std::swap使用using形式，然后调用swap并且不带任何命名空间资格修饰。</li>
<li>为“用户定义类型”进行std template全特化时，不要试图在std内加入某些对std而言是全新的东西。</li>
</ol>
<h3 id="5、实现"><a href="#5、实现" class="headerlink" title="5、实现"></a>5、实现</h3><h4 id="条款26：变量尽可能在使用时定义"><a href="#条款26：变量尽可能在使用时定义" class="headerlink" title="条款26：变量尽可能在使用时定义"></a>条款26：变量尽可能在使用时定义</h4><p>提前定义变量，有可能导致变量并没有使用(如中间抛异常了)，而平白多了一个构造和析构成本。</p>
<p>但是循环怎么办？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式A</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    w = xxx;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式B</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    Widget w = xxx;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做法A：1个构造 + 1个析构 + n个赋值操作</p>
<p>做法B：n个构造函数 + n个析构函数</p>
<p>打破本条款选择A的依据：</p>
<p>（1）你知道赋值成本比“构造+析构”成本低。</p>
<p>（2）你正在处理代码中效率高度敏感的部分。</p>
<p>否则你应该使用做法B，维持变量尽可能在使用时定义的原则。</p>
<p><strong>请记住</strong></p>
<blockquote>
<p>尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。</p>
</blockquote>
<h4 id="条款27：尽量少做转型动作"><a href="#条款27：尽量少做转型动作" class="headerlink" title="条款27：尽量少做转型动作"></a>条款27：尽量少做转型动作</h4><p>C语言风格类型转换(老式)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(T)expression   <span class="comment">// 显示强转</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">T</span>(expression)   <span class="comment">// 构造隐式转换</span></span><br></pre></td></tr></table></figure>

<p>C++新式转换，提倡统一都用新式风格，职能分类，更安全，更清晰。</p>
<ul>
<li>const_cast(expression) 用于将对象的常量性移除。也是唯一有此能力的C+±style转型操作符。</li>
<li>dynamic_cast(expression) 一般用于安全向下转型，如基类到派生类。要谨慎，可能效率低下。</li>
<li>static_cast(expression) 用来强制隐式转换，一般用于相关联类型转换，没有类型检测。如将int转double，派生类转基类(安全)，基类转派生类(不安全)等。</li>
<li>reinterpret_cast(expression) 一般用于不相干类型转换，没有限制。如int* 转int，int转函数指针等。常用于转换函数指针，即可以将一种类型的函数指针转换为另一种类型的函数指针。</li>
</ul>
<p>转型破环了类型系统。那可能导致任何种类的麻烦，有些容易识别，有些非常隐晦。所以尽量少做转型操作。</p>
<h5 id="关于传递给const引用临时对象的问题"><a href="#关于传递给const引用临时对象的问题" class="headerlink" title="关于传递给const引用临时对象的问题"></a>关于传递给<code>const</code>引用临时对象的问题</h5><p>我们可以安全地将一个临时对象传递给一个接受<code>const</code>引用的函数。在C++中，临时对象在函数调用的整个持续时间内都是有效的，因此可以安全地传递给<code>const</code>引用参数。这样做的好处包括：</p>
<ul>
<li><strong>避免不必要的拷贝</strong>：通过传递引用而不是值，可以避免对临时对象的拷贝，从而提高效率。</li>
<li><strong>保持类型安全</strong>：使用<code>const</code>引用可以确保在函数内部不会修改传递的对象。</li>
</ul>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。如果有个设计需要转型动作，试着发展无需转型的替代设计。</li>
<li>如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要将转型操作放进客户代码中。</li>
<li>宁可使用C+±style转型，不要使用旧式转型。前者很容易识别出来，而且也比较有着分门别类的职掌。</li>
</ul>
</blockquote>
<h4 id="条款28：-尽量避免返回handles指向对象内部成分"><a href="#条款28：-尽量避免返回handles指向对象内部成分" class="headerlink" title="条款28： 尽量避免返回handles指向对象内部成分"></a>条款28： 尽量避免返回handles指向对象内部成分</h4><p>handers是指：对象内的子对象的引用、指针或迭代器。返回子对象的引用、指针、迭代器会降低封装性，外部能越级访问深层级的对象并修改属性。</p>
<p>这并不意味着你绝对不可以让成员函数返回handle。有时候你必须那么做。例如operator[]就允许你获取strings和vectors的元素。尽管如此，这样的函数毕竟是例外，不是常态。</p>
<p><strong>请记住</strong></p>
<blockquote>
<p>避免返回handles(包括引用、指针、迭代器)指向对象内部。遵守这条条款可增加封装性，帮助const成员函数的行为像个const，并将发生”虚吊号码牌“的可能性降至最低。</p>
</blockquote>
<h4 id="条款29-为”异常安全”而努力是值得的"><a href="#条款29-为”异常安全”而努力是值得的" class="headerlink" title="条款29. 为”异常安全”而努力是值得的"></a>条款29. 为”异常安全”而努力是值得的</h4><p>我们要时刻要求自己写的函数都是异常安全函数。</p>
<p>异常安全函数有两个条件：</p>
<ol>
<li>不泄漏任何资源。</li>
<li>不允许数据败坏。</li>
</ol>
<p>同时，异常安全函数内分了3个级别保证，你至少满足其中之一。</p>
<ol>
<li>基本承诺：如果抛出异常，程序内的任何事物仍然保持在有效状态下。</li>
<li>强烈保证：如果抛出异常，程序状态不改变。如果函数成功，就是完全成功，如果函数失败，程序会回到调用函数之前的状态。</li>
<li>不抛异常保证：承诺绝不抛出异常，所有操作都是作用于内置类型身上。</li>
</ol>
<p>一般而言，我们都应该尽量做到强烈保证这个级别。而最高级别很多时候很难做到，任何使用动态内存的东西如果内存不足都有可能抛出异常。</p>
<p>下面是为编写异常安全函数而努力的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span>;  <span class="comment">// 改变背景图片</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;    <span class="comment">// 多线程环境，互斥锁</span></span><br><span class="line">    Image* bgImage;  <span class="comment">// 当前背景图片</span></span><br><span class="line">    <span class="type">int</span> imageChanges; <span class="comment">// 背景图片改变次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是我们最常规思路的实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">delete</span> bgImage;</span><br><span class="line">    ++imageChanges;</span><br><span class="line">    bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个常规思路的实现，如果new Image抛异常，lock资源泄漏，bgImage，imageChanges数据也招到破坏。不满足异常安全函数条件任何一个。下面我们来看怎么解决这两个问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    std::tr1::shared_ptr&lt;Image&gt; bgImage;  <span class="comment">// 智能指针</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;   <span class="comment">// 封装锁，见条款14</span></span><br><span class="line">    bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc));</span><br><span class="line">    ++imageChanges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做到这里还只能说满足基本承诺，如果Image构造函数抛异常(这里抛异常由编译器内部实现)，有可能破环外部引用的imgSrc数据源(todo:这里有点牵强~感觉做到这一步已经是强烈保证了！)。</p>
<p>还记得我们前面写过一个不抛异常的swap么？就可以用在这里，我们让改变背景图片的操作先在副本对象中操作，都正确操作完后，在用swap交换数据，这样就保证了即使失败了也不会影响原有数据状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PMImpl</span> &#123;</span><br><span class="line">    std::tr1::shared_ptr&lt;Image&gt; bgImage;</span><br><span class="line">    <span class="type">int</span> imageChanges;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    std::tr1::shared_ptr&lt;PMImpl&gt; pImpl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    std::<span class="function">tr1::shared_ptr&lt;PMImpl&gt; <span class="title">pNew</span><span class="params">(<span class="keyword">new</span> PMImpl(*pImpl))</span></span>; <span class="comment">// 副本对象</span></span><br><span class="line">    pNew-&gt;bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc));</span><br><span class="line">    ++pNew-&gt;imageChanges;</span><br><span class="line">    <span class="built_in">swap</span>(pImpl, pNew);  <span class="comment">// 交互数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>强烈保证并非时刻都显得实际，也要衡量空间、效率成本。当强烈保证不切实际时，你就必须保证提供基本保证。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>异常安全函数即使发生异常也不会泄漏资源或允许任何数据结构破坏。这样的函数有3中可能的保证：基本型、强烈型、不抛异常型。</li>
<li>强烈保证往往能够以swap来实现出来，但强烈保证并非对所有函数都可实现或具备现实意义。</li>
<li>函数提供的“异常安全保证”通常最高只等于其所调用的各个函数的异常安全保证中的最低者。</li>
</ul>
</blockquote>
<h4 id="条款30：透彻了解inline的里里外外"><a href="#条款30：透彻了解inline的里里外外" class="headerlink" title="条款30：透彻了解inline的里里外外"></a>条款30：透彻了解inline的里里外外</h4><p>inline行为发生在编译期间，编译器是否要进行inline，不是取决于函数带不带inline，有时带了inline也不一定会inline(virtual函数，运行时才知道调用哪个)，没带也可能inline(实现在头文件中)。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>将大多数inline限制在<strong>小型</strong>、<strong>被频繁调用</strong>的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</li>
<li>不要只因为函数模板出现在头文件中定义，就将它们声明为inline。</li>
</ul>
</blockquote>
<h4 id="条款31：-将文件间的编译依赖关系降至最低"><a href="#条款31：-将文件间的编译依赖关系降至最低" class="headerlink" title="条款31： 将文件间的编译依赖关系降至最低"></a>条款31： 将文件间的编译依赖关系降至最低</h4><h5 id="一、定义与目的"><a href="#一、定义与目的" class="headerlink" title="一、定义与目的"></a>一、定义与目的</h5><ol>
<li><strong>Handle class（句柄类）</strong>：<ul>
<li>句柄类是一种设计模式，用于将类的接口和实现分离。</li>
<li>它通常包含一个指向实现类的指针或引用，客户通过句柄类调用接口，而不需要直接知道实现类的细节。</li>
<li>目的是减少文件间的编译依存关系，当实现类发生变化时，客户代码不需要重新编译。</li>
</ul>
</li>
<li><strong>Interface class（接口类）</strong>：<ul>
<li>接口类是一种抽象类，通常包含纯虚函数（在Java等语言中称为接口）。</li>
<li>它定义了类必须实现的接口，而不包含具体的实现。</li>
<li>目的是提供一种规范或契约，确保不同的类能够以一致的方式被使用。</li>
</ul>
</li>
</ol>
<h5 id="二、实现方式"><a href="#二、实现方式" class="headerlink" title="二、实现方式"></a>二、实现方式</h5><ol>
<li><strong>Handle class</strong>：<ul>
<li>句柄类通常包含一个指向实现类的智能指针（如C++中的<code>std::shared_ptr</code>或<code>std::unique_ptr</code>）。</li>
<li>句柄类的方法通过调用实现类的方法来实现功能。</li>
<li>实现类可以单独编译和链接，减少了客户代码对实现类细节的依赖。</li>
</ul>
</li>
<li><strong>Interface class</strong>：<ul>
<li>接口类通常包含纯虚函数，这些函数在接口类中声明但没有实现。</li>
<li>具体类通过继承接口类并实现其纯虚函数来提供具体的功能。</li>
<li>客户代码通常通过接口类的指针或引用来操作具体类的对象，从而实现多态性。</li>
</ul>
</li>
</ol>
<h5 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h5><ol>
<li><strong>Handle class</strong>：<ul>
<li>适用于需要将接口和实现分离的场景，以减少编译依赖和提高代码的可维护性。</li>
<li>例如，在大型项目中，将类的接口和实现分离可以减少编译时间和避免不必要的重新编译。</li>
</ul>
</li>
<li><strong>Interface class</strong>：<ul>
<li>适用于需要定义一组相关操作的规范或契约的场景。</li>
<li>例如，在面向对象的框架中，接口类用于定义组件之间的交互规范。</li>
</ul>
</li>
</ol>
<p>直接看示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相关头文件引入</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;date.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;address.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;</span><br><span class="line">    Date theBirthDate;</span><br><span class="line">    Address theAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面Person定义文件和其包含的文件之间形成了一种编译依赖关系。如果这些头文件中任何一个被改变，或这些头文件所依赖的其他头文件有任何改变，那么每一个包含Person class的文件就得重新编译。这样的连串编译依赖关系会对许多项目造成难以形容的灾难。</p>
<p>解决这个问题的<strong>本质是让类的接口与实现分离</strong>(加快编译速度)。通常有两种做法：</p>
<p>第一种拆分两个类，一个用于声明，一个用于实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class 只是声明这个类，没有定义信息，可以使用类的引用和指针(大小固定)，不能有定义。减少编译依赖手段。</span></span><br><span class="line"><span class="comment">// include 则是把整个类导入，包含了定义信息，也注入了依赖相关，增加了编译时间。 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl;  <span class="comment">// 指向实现类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PersonImpl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">    : <span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">PersonImpl</span>(name, birthday, addr))</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Person::name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;<span class="built_in">name</span>();  <span class="comment">// simunps的fileManger封装就是类似这种做法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将实现分开后，即使修改了实现部分逻辑，对包含了Person接口类的其它类也没有影响，不需要重新编译。</p>
<p>第二种是用接口类。</p>
<p>这种类的目的是详细一一描述派生类的接口，因此它通常没有成员变量，也没有构造函数，只有一个virtual析构函数以及一组纯虚函数声明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口定义，外部使用通过基类的create接口即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line">    <span class="type">static</span> std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> Address&amp; addr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">Person::create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Address&amp; addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> <span class="built_in">RealPerson</span>(name, birthday, addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span> : Person &#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">     : <span class="built_in">theName</span>(name), <span class="built_in">theBirthDate</span>(birthday), <span class="built_in">theAddress</span>(addr)</span><br><span class="line">     &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>() &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;</span><br><span class="line">    Date theBirthDate;</span><br><span class="line">    Address theAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>支持编译依赖最小化的一般构想是：依赖声明式的头文件，不要依赖定义式的头文件。(声明与定义拆两个类，外部只include声明的类头文件) 基于此构想有两种手段：接口与实现拆分两个类和接口类。</li>
<li>程序库头文件应该以“完全且仅有声明式的形式存在。就是include的类都是声明式的类，其真实实现在另一个类中。</li>
</ul>
</blockquote>
<h3 id="6-继承与面向对象设计"><a href="#6-继承与面向对象设计" class="headerlink" title="6.继承与面向对象设计"></a>6.继承与面向对象设计</h3><h4 id="条款32-确定你的public继承塑模出is-a关系"><a href="#条款32-确定你的public继承塑模出is-a关系" class="headerlink" title="条款32. 确定你的public继承塑模出is-a关系"></a>条款32. 确定你的public继承塑模出is-a关系</h4><p>公有继承：继承过来的基类成员访问属性不变。</p>
<p>保护继承：继承过来的基类中的私有成员访问属性不变，公有成员和保护成员变为保护成员。</p>
<p>私有继承：继承过来的基类中的私有成员属性不变，公有成员和保护成员变为私有成员。</p>
<p>不管是哪种继承方式，派生类中成员可以访问基类的公有成员和保护成员，无法访问私有成员。而继承方式影响的是派生类继承成员的<strong>访问属性</strong>。</p>
<p><strong>请记住</strong></p>
<blockquote>
<p>public继承：适用于base classes身上的每一件事情一定也适用与derived classes身上，因为每一个derived class对象也都是一个base class对象。</p>
</blockquote>
<h4 id="条款33-避免遮掩继承而来的名称"><a href="#条款33-避免遮掩继承而来的名称" class="headerlink" title="条款33. 避免遮掩继承而来的名称"></a>条款33. 避免遮掩继承而来的名称</h4><p>派生类中函数会遮掩基类中的同名函数。从名称查找来看，像是基类中对应的同名函数没被继承过来一样。简单来说就是作用域问题，派生类覆盖基类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>();      <span class="comment">// 没问题，调用Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);     <span class="comment">// 报错！Derived::mf1遮掩了同名的Base::mf1</span></span><br><span class="line">d.<span class="built_in">mf2</span>();      <span class="comment">// 没问题，调用Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>();      <span class="comment">// 没问题，调用Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);     <span class="comment">// 报错，Derived::mf3遮掩了Base::mf3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果不想被派生类同名函数把基类中所有其它重载函数都遮掩了，可以使用using声明，也可以使用作用域说明符。（如在函数前加上Base::       就知道调用的是基类的）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用using后，上面两处报错的都可以找到Base::mf1/Base::mf3了。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::mf1;     <span class="comment">//Base class中名为mf1和mf3的所有东西，</span></span><br><span class="line">    <span class="keyword">using</span> Base::mf3;     <span class="comment">//在Derived中都可见</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转交函数，一般用于私有继承中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span>  <span class="comment">// 转交函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	Base::<span class="built_in">mf1</span>();    <span class="comment">// 派生类函数调用基类对应函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果不想要外边访问基类中任何成员，可以用私有继承实现(private)。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>derived class 内的名称会遮掩base class 内的名称。在public继承下从来没有人希望如此。所以这点要特别注意(使用using)。</li>
<li>为了让被遮掩的名称再见天日，可使用using声明式或转交函数。</li>
</ul>
</blockquote>
<h4 id="条款34-区分接口继承和实现继承"><a href="#条款34-区分接口继承和实现继承" class="headerlink" title="条款34. 区分接口继承和实现继承"></a>条款34. 区分接口继承和实现继承</h4><p>业内默认约定基类中的成员函数用途：</p>
<ul>
<li>纯虚函数：derived class只想继承其声明，实现由derived class自己实现。</li>
<li>虚函数：derived class希望同时继承函数的接口和实现，但又希望能够覆写它们所继承的实现。</li>
<li>普通函数：derived class只想继承函数的接口和实现，并且不允许我自己再覆写。</li>
</ul>
<p><strong>普通成员函数：子类只能用父类的接口和实现</strong></p>
<p><strong>虚函数：子类可以用父类的接口和实现，如果自己有实现，那就用自己的</strong></p>
<p><strong>纯虚函数：父类只提供接口，子类只继承接口，并且必须提供实现（否则自己也是抽象类）。</strong></p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>接口继承和实现继承不同。在public继承之下，derived class总是继承base class的接口。</li>
<li>纯虚函数只具体指定接口继承。</li>
<li>虚函数具体指定接口继承及默认的实现继承。</li>
<li>普通函数具体指定接口继承以及强制性实现继承。</li>
</ul>
</blockquote>
<h4 id="条款35-考虑virtual函数以外的其他选择"><a href="#条款35-考虑virtual函数以外的其他选择" class="headerlink" title="条款35. 考虑virtual函数以外的其他选择"></a>条款35. 考虑virtual函数以外的其他选择</h4><p>条款34刚说了，在我们希望同时继承函数的接口和实现，但又希望能够覆写它们所继承的实现时用virtual函数。</p>
<p>而这里是这种场景的一些其它流派主张思想。</p>
<p>第一种，Non-Virtual Interface(NVI)，主张virtual函数应该几乎总是private。这个较好的设计是用一个non-vitual函数去调用一个private virtual函数。这样我们就提供了在调用private virtual函数前后做一些额外操作空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这里inline只是为了演示示例</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span>    <span class="comment">// 普通成员函数派生类不要重新定义它，见条款36</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...                    <span class="comment">// 做一些事前工作</span></span><br><span class="line">        <span class="type">int</span> retVal = <span class="built_in">doHealthValue</span>();</span><br><span class="line">        ...                    <span class="comment">// 做一些事后工作</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">doHealthValue</span><span class="params">()</span> <span class="type">const</span>   <span class="comment">// 虚函数，派生类可重写</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种，把这个虚函数提到类外边以一个普通函数存在，然后类的构造函数接收一个函数指针指向这个函数。把实现从类成员中剥离出去。— Strategy设计模式</p>
<p>为了更清晰地解释这段话，我们可以将其拆分为以下几个要点：</p>
<ol>
<li><strong>虚函数提到类外边</strong>：<br>在经典的面向对象编程中，虚函数是定义在类内部的，用于实现多态性。但在这里，提到的是将这些虚函数（或更准确地说是它们的功能）实现为类外部的普通函数。</li>
<li><strong>函数指针</strong>：<br>函数指针是指向函数的指针，它允许你将函数作为参数传递给其他函数，或者将函数作为对象成员（尽管这里说的是构造函数接收，但实际上是类内部可能持有这个指针以调用函数）。</li>
<li><strong>类的构造函数接收函数指针</strong>：<br>类的构造函数被设计为接收一个函数指针作为参数。这意味着在创建类的对象时，你可以指定一个具体的函数来实现某个特定的行为。</li>
<li><strong>实现从类成员中剥离出去</strong>：<br>通过将行为（原本可能是类的虚函数）实现为外部函数，并通过函数指针与类关联，这些行为就不再是类不可分割的一部分。这样做的好处是增加了代码的灵活性和可重用性。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>; <span class="comment">// 函数指针形式</span></span><br><span class="line">    <span class="comment">// 另一种使用tr1::function更灵活，它是一个类模板，其成员变量是一个函数指针。</span></span><br><span class="line">    <span class="comment">// 函数指针只支持指向外部普通函数，而function对象还支持类成员函数可以(结合bind，绑定this)。</span></span><br><span class="line">    <span class="comment">// typedef std::tr1::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span> : healthFunc(hcf)</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的好处是：</p>
<ul>
<li>同一个类之下不同的对象可以有不同的defaultHealthCalc实现。</li>
<li>某个类对象的defaultHealthCalc可在运行期变更。</li>
</ul>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>virtual 函数的替代方案包括NVI手法和Strategy设计模式的多种形式。NVI手法自身是一个特殊形式的Template Method设计模式。</li>
<li>将机能从成员函数移到class外部函数，带来的一个缺点是，这个非成员函数无法访问class的非公有成员。</li>
<li>tr1::function对象的行为就像一般函数指针。比函数指针能多接纳一些特别的函数。</li>
</ul>
</blockquote>
<h4 id="条款36-绝不重新定义继承而来的非虚函数"><a href="#条款36-绝不重新定义继承而来的非虚函数" class="headerlink" title="条款36. 绝不重新定义继承而来的非虚函数"></a>条款36. 绝不重新定义继承而来的非虚函数</h4><p>当做一个约定就行</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>绝对不要重新定义继承而来的non-virtual函数。</li>
</ul>
</blockquote>
<h4 id="条款37-绝不重新定义继承而来的缺省参数值"><a href="#条款37-绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37. 绝不重新定义继承而来的缺省参数值"></a>条款37. 绝不重新定义继承而来的缺省参数值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ShapeColor</span> &#123;Red, Green, Blue&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>:<span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape* pr = <span class="keyword">new</span> Rectangle;</span><br><span class="line">pr-&gt;<span class="built_in">draw</span>(); </span><br></pre></td></tr></table></figure>

<p>上面代码我们都知道最后的pr-&gt;draw调用的是Rectangle里覆写后的draw，这很正常没什么问题。</p>
<p>诡异的是缺省的参数却是用的Red，而不是自己的Green。</p>
<p>导致这个结果的原因是编译器优化的手段，缺省参数是静态绑定的(运行之前确定)，而virtual函数是动态绑定的(运行时确定)。所有上面pr-&gt;draw的调用就出现接口是用的派生类的，而缺省参数用的基类的。</p>
<p>这种表现会给阅读代码的人带来歧义，所以：</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定的，而virtual函数是你唯一应该覆写的东西，却是动态绑定。</li>
</ul>
</blockquote>
<h4 id="条款38-类的子对象"><a href="#条款38-类的子对象" class="headerlink" title="条款38. 类的子对象"></a>条款38. 类的子对象</h4><p>区分类的继承和复合，B继承A，我们可以说<strong>B是A</strong>，而B中包含A子对象（复合），我们一般说<strong>B中有A</strong>，而不能说B是A了。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>子对象的意义和public继承完全不同。</li>
</ul>
</blockquote>
<h4 id="条款39-明智而审慎地使用private继承"><a href="#条款39-明智而审慎地使用private继承" class="headerlink" title="条款39. 明智而审慎地使用private继承"></a>条款39. 明智而审慎地使用private继承</h4><p>私有继承：继承过来的基类中的所有成员在子类中都是私有成员。</p>
<ul>
<li><p>Private继承意味 is-implemented-in-terms of(根据某物实现出)。它通常比复合<br>(composition)的级别低。但是当derived class需要访问protected base class 的</p>
</li>
<li><p>成员,或需要重新定义继承而来的virtual函数时,这么设计是合理的。<br>和复合(composition)不同,private继承可以造成empty base最优化。这对致<br>力于“对象尺寸最小化”的程序库开发者而言,可能很重要。</p>
</li>
</ul>
<h4 id="条款40-明智而审慎地使用多重继承"><a href="#条款40-明智而审慎地使用多重继承" class="headerlink" title="条款40. 明智而审慎地使用多重继承"></a>条款40. 明智而审慎地使用多重继承</h4><p>多重继承，两个常见问题：</p>
<ol>
<li>C继承A和B，如果A、B里有相同的成员，那么C直接调用这些成员就会有歧义，不知道调用A的还是B的。所以正确调用要明确指明，C.A::xxxFunc();</li>
<li>多层继承中，B、C继承A，D继承B和C，那么常规D中有两份A，如果不想要两份就得用virtual(虚基类里会增加一个指针大小)，虚继承。</li>
</ol>
<p>多重继承最好能避免就尽量避免。不能避免，要清楚它带来的问题和内部实现成本消耗细节。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要。</li>
<li>virtual继承会增加大小、速度、初始化及赋值复杂度等成本。如果virtual base classe不带任何数据，将是最具实用价值的情况。</li>
<li>多重继承的确有正当用途。其中一个场景涉及public继承某个Interface class和private继承某个协助实现的class的两相组合。</li>
</ul>
</blockquote>
<h3 id="7-模板与泛型编程"><a href="#7-模板与泛型编程" class="headerlink" title="7.模板与泛型编程"></a>7.模板与泛型编程</h3><h4 id="条款41-了解隐式接口和编译期多态"><a href="#条款41-了解隐式接口和编译期多态" class="headerlink" title="条款41. 了解隐式接口和编译期多态"></a>条款41. 了解隐式接口和编译期多态</h4><p>隐式接口：函数模板，类型不清楚，对我们来说接口是隐藏的。</p>
<p>显示接口：我们常规的头文件接口声明就是显示接口，明确了返回值，参数。</p>
<hr>
<p>编译期多态：编译时实例化模板确定哪个重载函数被调用。</p>
<p>运行期多态：运行时哪一个virtual函数该被绑定。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>class和template都支持接口和多态。</li>
<li>对class而言接口是显示的。多态则是通过virtual函数发生于运行期。</li>
<li>对template而言，接口是隐式的。多态则通过template实例化和函数重载解析，发生于编译器。</li>
</ul>
</blockquote>
<h4 id="条款42-了解typename的双重意义"><a href="#条款42-了解typename的双重意义" class="headerlink" title="条款42. 了解typename的双重意义"></a>条款42. 了解typename的双重意义</h4><p>模版声明有两种形式：</p>
<ol>
<li>typename</li>
<li>class</li>
</ol>
<p>这里声明模版参数时，它们的意义完全相同。</p>
<p>不过对于typename在模版中除了声明模版参数外还有几处特别的用处要注意！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2nd</span><span class="params">(<span class="type">const</span> C&amp; container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  C::const_iterator* x;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个新名词要了解，嵌套从属类型：即属于模版类型C下的类型，形式：<code>C::xxx</code>。</p>
<p>**上面对应的就是C::const_iterator，这里是有歧义的，**C::const_iterator是一个类型了还是一个变量了，如果作为类型上面就是定义一个指针x，如果作为变量就是乘x。对于这种嵌套从属类型，编译器一般默认当变量处理。<strong>如果要当类型处理就必须在其前面加关键字</strong><code>typename</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> C::const_iterator* x;  <span class="comment">// 这样就显示告诉编译器，C::const_iterator是一个自定义类型</span></span><br></pre></td></tr></table></figure>

<p>另外对于嵌套从属类型前面加typename，有两处特例不能加。即不能出现在基类和成员初始化列表的嵌套从属类型里(除此之外都要加)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;T&gt;::Nested  <span class="comment">// 不能加typename</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  	<span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span><span class="params">(<span class="type">int</span> x)</span> : Base&lt;T&gt;::Nested(x)  // 不能加typename</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">       <span class="keyword">typename</span> Base&lt;T&gt;::Nested temp;   <span class="comment">// 这里要加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>声明template参数时，前缀关键字class和typename可互换，意义一样。</li>
<li>请使用关键字typename标识嵌套从属类型，但不得在基类或成员初始化列表内使用。</li>
</ul>
</blockquote>
<h4 id="条款43-注意处理模版化基类内的名称"><a href="#条款43-注意处理模版化基类内的名称" class="headerlink" title="条款43. 注意处理模版化基类内的名称"></a>条款43. 注意处理模版化基类内的名称</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span> : <span class="keyword">public</span> MsgSender&lt;T&gt;  <span class="comment">// 模版化基类</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  	...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      	...</span><br><span class="line">      	<span class="built_in">sendClear</span>(info);  <span class="comment">// 如果这个接口属于基类的，这里也不认识，因为基类是什么这时编译器不知道</span></span><br><span class="line">       	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像上面的sendClear接口模版化基类里是否存在，编译器是不确定的，所以这种编译会报错。有下面3种方式解决这种问题，就是明确告诉编译器假设它存在。</p>
<ol>
<li>通过<code>this-&gt;sendClear(info);</code>调用，假设sendClear在this中。</li>
<li>调用前加using声明<code>using MsgSender&lt;T&gt;::sendClear;</code>，明确告诉编译器sendClear在模版基类中。</li>
<li>调用时明白指明，<code>MsgSender&lt;T&gt;::sendClear(info);</code></li>
</ol>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>可在派生类模版内通过<code>this-&gt;</code>指明基类模版的成员名称(1)，或者由一个明白写出的属于基类的修饰符完成(2, 3)</li>
</ul>
</blockquote>
<h4 id="条款44-将与参数无关的代码抽离template（尚且不理解，完了需要在复习）"><a href="#条款44-将与参数无关的代码抽离template（尚且不理解，完了需要在复习）" class="headerlink" title="条款44. 将与参数无关的代码抽离template（尚且不理解，完了需要在复习）"></a>条款44. 将与参数无关的代码抽离template（尚且不理解，完了需要在复习）</h4><p>**template是一个节省时间和避免代码重复的一个奇方妙法。**不再需要键入20个类似的class而每一个带有15个成员函数，你只需键入一个class template，留给编译器去实例化那20个你需要的相关class和300个函数。(它们只有在被使用时才会实例化)</p>
<p>template虽然给我们提供了方便，但是注意如果使用不当，很容易导致代码膨胀(执行文件变大)。其结果有可能源码看起来合身而整齐，但目标码却不是那么回事。在template代码中，重复是隐藏的，所以你必须训练自己去感受当template被实例化多次时可能发生的重复。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;  <span class="comment">// 这里T称为模版的类型参数，n是非类型参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  	...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">5</span>&gt; sm1;</span><br><span class="line">sml.<span class="built_in">invert</span>();</span><br><span class="line"></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">10</span>&gt; sm2;</span><br><span class="line">sm<span class="number">2.</span><span class="built_in">invert</span>();</span><br></pre></td></tr></table></figure>

<p>上面这段模版封装，多次实例化，其中invert也会实例多份，虽然它们二进制实现一样。这就是隐晦的重复代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixbase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  	...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">(std::<span class="type">size_t</span> matrixSize)</span></span>;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqureMatrix</span> : <span class="keyword">public</span> SquareMatrixbase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;</span><br><span class="line">  	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  	...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">this</span>-&gt;<span class="built_in">invert</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把重复逻辑移到基类中，所有模版类共有，这样就减少了代码膨胀了。</p>
<p>本条款想表达的是使用template时要注意多次实例化后可能带来的代码重复，要尽量避免这种重复代码。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>template生成多个class和多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生相依关系。</li>
<li>因非类型模版参数而造成的代码膨胀，往往可消除，做法是以函数参数或class成员变量替换template参数。</li>
<li>因类型参数而造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制实现的代码共享，如放基类中。</li>
</ul>
</blockquote>
<h4 id="条款45-运用成员函数模版接受所有兼容类型"><a href="#条款45-运用成员函数模版接受所有兼容类型" class="headerlink" title="条款45. 运用成员函数模版接受所有兼容类型"></a>条款45. 运用成员函数模版接受所有兼容类型</h4><p><strong>在C++中，成员函数模板允许我们编写可以接受多种类型参数的成员函数，而不需要为每种类型都显式地重载函数。这就是“运用成员函数模板接受所有兼容类型”这句话的含义。</strong></p>
<p><strong>简单来说，当你有一个类或结构体，并且你希望它的某个成员函数能够接受不同类型的参数（只要这些类型是兼容的，即可以进行相应的操作），你就可以使用成员函数模板来实现这一点。这样做的好处是代码更加简洁、易于维护，并且提高了代码的复用性。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Print</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Print p;  </span><br><span class="line">    p.<span class="built_in">print</span>(<span class="number">42</span>);              <span class="comment">// 打印整数  </span></span><br><span class="line">    p.<span class="built_in">print</span>(<span class="number">3.14</span>);            <span class="comment">// 打印双精度浮点数  </span></span><br><span class="line">    p.<span class="built_in">print</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>)); <span class="comment">// 打印字符串  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还想要表达的是我们封装的模版所有操作行为要和普通类保持一致。即隐式行为要一致。如不同类型可隐式相互转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPrt</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">SmartPrt</span>(<span class="type">const</span> SmartPrt&amp; other);  <span class="comment">//正常的copy构造函数，取消编译器自动生成</span></span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;   <span class="comment">// 泛化的copy构造函数(成员函数模版)，接受不同类型对象转换</span></span><br><span class="line">  	<span class="built_in">SmartPrt</span>(<span class="type">const</span> SmartPrt&lt;U&gt;&amp; other) : <span class="built_in">heldPtr</span>(other.<span class="built_in">get</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      	...</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> heldPtr;&#125;;</span><br><span class="line">  	...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  	T* heldPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过注意泛化的成员函数(即成员函数模版)并不会影响编译器自动生成类默认函数规则。所以如果你要完全自定义类行为，默认产生的函数除了泛化版本，对应的正常化版本也要声明。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>请使用成员函数模版生成可接受所有兼容类型的函数。</li>
<li>如果你声明成员函数模版用于泛化copy构造函数或赋值操作符，你还是需要声明对应正常的copy构造函数和赋值操作符函数。</li>
</ul>
</blockquote>
<h4 id="条款46-需要类型转换时请为模版定义非成员函数"><a href="#条款46-需要类型转换时请为模版定义非成员函数" class="headerlink" title="条款46. 需要类型转换时请为模版定义非成员函数"></a>条款46. 需要类型转换时请为模版定义非成员函数</h4><p>对应条款24，这里只是模版实现。规则一致，但它们写法上有所区别了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">Rational</span>(<span class="type">const</span> T&amp; numerator = <span class="number">0</span>,</span><br><span class="line">    				 <span class="type">const</span> T&amp; denominator = <span class="number">1</span>);</span><br><span class="line">  	<span class="function"><span class="type">const</span> T <span class="title">numerator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  	<span class="function"><span class="type">const</span> T <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要隐式转换的接口定义为非成员函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>* (<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                             <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational&lt;<span class="type">int</span>&gt; result = oneHalf * <span class="number">2</span>;  <span class="comment">// 这里会编译错误，2不能隐式转换</span></span><br></pre></td></tr></table></figure>

<p>上面只是把24条款示例改为模版实现，然而模版版本是编译不过的，因为编译器并不知道2要转换为什么。编译器推断不了模版的隐式转换。</p>
<p>对于模版我们只能通过friend和inline特性来实现非成员函数的定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  	...</span><br><span class="line">    <span class="comment">// 这里Rational是Rational&lt;T&gt;的简写形式，在类模版内部可以简写。</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs,</span><br><span class="line">                                   	<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">      	<span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                       	lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以编译，连接通过了。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>当我们编写一个class template，而它所提供的函数要支持隐式转换时，请将这些函数定义为class template内部的friend函数。</li>
</ul>
</blockquote>
<h4 id="条款47-请使用traits-class表现类型信息"><a href="#条款47-请使用traits-class表现类型信息" class="headerlink" title="条款47. 请使用traits class表现类型信息"></a>条款47. 请使用traits class表现类型信息</h4><p>想要了解STL容器可以转到<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_74795952/article/details/143096462?spm=1001.2014.3001.5502">C++ | STL | 侯捷 | 学习笔记_c++ stl-CSDN博客</a></p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>Traits class 使得类型相关信息在编译器可用。它们以template和template特化完成实现。</li>
<li>整合重载技术后，traits class有可能在编译期对类型执行if…else测试。(重载是编译期确定，if是运行期确定)</li>
</ul>
</blockquote>
<p><strong>例子：</strong><br>以 iterator_traits 为例介绍如何实现和使用 traits classes。STL 提供了很多的容器、迭代器和算法，其中的 advance 便是一个通用的算法，可以让一个迭代器移动给定距离：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span></span>; <span class="comment">// d &lt; 0 就向后移动</span></span><br><span class="line">STL 迭代器回顾：</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123;&#125;; <span class="comment">// 输入迭代器，只能向前移动</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123;&#125;; <span class="comment">// 输出迭代器，只能向前移动</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span>: <span class="keyword">public</span> input_iterator_tag &#123;&#125;; <span class="comment">// 稍强的是前向迭代器，可以多次读写它的当前位置</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span>: <span class="keyword">public</span> forward_iterator_tag &#123;&#125;; <span class="comment">// 双向迭代器，支持前后移动</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span>: <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;; <span class="comment">// 随机访问迭代器，可以支持 +=, -= 等移动操作</span></span><br></pre></td></tr></table></figure>

<p>回到 advance 上，它的实现取决于 Iter 类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 针对 random access 迭代器使用这种方式实现</span></span><br><span class="line">    <span class="keyword">if</span> (iter is a random access iterator) &#123;</span><br><span class="line">        iter += d;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其它迭代器使用 ++ 或 -- 实现</span></span><br><span class="line">        <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) &#123; <span class="keyword">while</span> (d--) ++iter; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">while</span> (d++) --iter; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是怎么判断 Iter 的类型是否是 random access 迭代器了，也就是需要知道它的类型。这真是需要使用到 Traits classes 的地方。</p>
<p><strong>实现 Traits classes：</strong><br>用户自定义类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123;</span><br><span class="line">    <span class="comment">// 类型 IterT 的 iterator_category 就是用来标识迭代器的类别</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> IterT::iterator_category iterator_category;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>指针类型：<br>指针本身就是可以支持随机访问（random access）的，所以我们对指针类型提供一个偏特化版本即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt; <span class="comment">// template偏特化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;IterT*&gt; &#123; <span class="comment">// 针对内置指针</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>advance 实现：</strong></p>
<p>不好的实现方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">typeid</span>(<span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::iterator_category) ==</span><br><span class="line">        <span class="built_in">typeid</span>(std::random_access_iterator_tag))</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>IterT</code> 和 <code>iterator_traits&lt;IterT &gt;::iterator_category</code> 都是可以在编译期间确定的，而 if 判断却要在运行期间核定，这样不仅浪费时间，也会导致代码膨胀。<br>建议做法是建立一组重载函数（doAdvance），接受不同的类型，原函数（advance）调用这些重载函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用不同版本的重载函数</span></span><br><span class="line">    <span class="built_in">doAdvance</span>(iter, d, <span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::<span class="built_in">iterator_category</span>());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 下面是一系列重载函数</span></span><br><span class="line"><span class="comment">// 随机访问迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DistT d, std::random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">    iter += d;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 双向迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DistT d, std::bidirectional_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) &#123; <span class="keyword">while</span> (d--) ++iter; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">while</span> (d++) --iter; &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 输入迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DistT d, std::input_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">       <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Negative distance&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (d--) ++iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="条款48-认识template元编程"><a href="#条款48-认识template元编程" class="headerlink" title="条款48. 认识template元编程"></a>条款48. 认识template元编程</h4><p>47条款的示例就是使用的模版元编程技术，<strong>它是一种把运行期的代码转移到编译期完成的技术</strong>。这种技术可能永远不会成为主流，但是如果你是一个程序库开发员，那这种技术就是家常便饭了。</p>
<p>通过模版或重载技术，把如if这种运行期的判断转换为编译期重载函数自动匹配。</p>
<p>它有两个特点：</p>
<ol>
<li>它让某些事情更容易。如果没有它，那些事情将是困难的，甚至不可能的。</li>
<li>由于它将工作从运行期转移到编译期。这可更早发现错误，而且更高效、较小的可执行文件、较短的运行期、较少的内存需求。不过它会使编译时间变长。</li>
</ol>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>模版元编程可将工作由运行期转移到编译期，因而得以实现早期错误发现和更高的执行效率。</li>
<li>模版元编程可被用来生成客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。</li>
</ul>
</blockquote>
<h3 id="8-定制-new-和-delete"><a href="#8-定制-new-和-delete" class="headerlink" title="8.定制 new 和 delete"></a>8.定制 new 和 delete</h3><p>了解new和delete相关知识可转入<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_74795952/article/details/143168526?spm=1001.2014.3001.5502">侯捷 | C++ | 内存管理 | 学习笔记（一）: 第一章节 primitives-CSDN博客</a>，想要了解内存池相关内容可转入侯捷内存管理第二章节或手写SGI STL，nginx内存池项目博客。</p>
<h4 id="条款49-了解new-handler的行为"><a href="#条款49-了解new-handler的行为" class="headerlink" title="条款49. 了解new-handler的行为"></a>条款49. 了解new-handler的行为</h4><p>new-handler就是当new抛异常之前，它会先调用一个客户指定的错误处理函数。通过<code>set_new_handler</code>标准库函数指定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当new无法分配足够内存时，被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outOfMem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	std::cerr &lt;&lt; <span class="string">&quot;Unable to satisfy request for memory\n&quot;</span>;</span><br><span class="line">  	std::<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	std::<span class="built_in">set_new_handler</span>(outOfMem);</span><br><span class="line">  	<span class="type">int</span>* pBigDataArray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100000000L</span>];</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面异常处理是全局的，但有时候你可能需要为不同类处理不同异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">outOfMem</span><span class="params">()</span></span>;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">outOfMem</span><span class="params">()</span></span>;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X* p1 = <span class="keyword">new</span> X;  <span class="comment">// 如果X错误，你希望调用X的错误函数</span></span><br><span class="line">Y* p2 = <span class="keyword">new</span> Y;	<span class="comment">// 如果Y错误，你希望调用Y的错误函数</span></span><br></pre></td></tr></table></figure>

<p>C++并不支持class的专属new-hander，但也可以通过其它形式自己实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RAII对象，保证new_handler还原</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerHolder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NewHandlerHolder</span><span class="params">(std::new_handler nh)</span> : handler(nh) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">NewHnadlerHolder</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">set_new_handler</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::new_handler handler;</span><br><span class="line">    <span class="comment">// 阻止copiying</span></span><br><span class="line">    <span class="built_in">NewHandlerHolder</span>(<span class="type">const</span> NewHandlerHolder&amp;);</span><br><span class="line">    NewHandlerHolder&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NewHandlerHolder&amp;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerSupport</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler</span><br><span class="line">NewHandlerSupport&lt;T&gt;::<span class="built_in">set_new_hnadler</span>(std::new_handler p) <span class="keyword">throw</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>* NewHandlerSupport&lt;T&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"><span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// new如果失败，则先会调用currentHandler，然后set_new_handler会返回上一次的handler。</span></span><br><span class="line">    <span class="comment">// NewHandlerHolder这个RAII对象则在析构时会把上面返回的上一次new_handler设置回去。</span></span><br><span class="line">    <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(std::set_new_handler(currentHandler))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用，只要继承封装的NewHandlerSupport&lt;T&gt;，就能够实现针对类自己的new_handler了。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> NewHandlerSupport&lt;Widget&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Widget::<span class="built_in">set_new_handler</span>(xxxx); <span class="comment">// xxxx是new失败执行的回调函数</span></span><br><span class="line">Widget* w = <span class="keyword">new</span> Widget; <span class="comment">// 如果失败，先会调用xxxx，然后会还原new_handler回调函数。</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用。</li>
<li>让new不抛异常是一个颇为局限的工具，因为它只是保证了内存分配时不抛异常，后续调用构造函数还是可能抛出异常。&#x3D;&gt; new做了两件事：1. 分配内存 2. 调用类的构造函数。</li>
</ul>
</blockquote>
<h4 id="条款50-了解new和delete的合理替换时机"><a href="#条款50-了解new和delete的合理替换时机" class="headerlink" title="条款50. 了解new和delete的合理替换时机"></a>条款50. 了解new和delete的合理替换时机</h4><p>什么时候我们需要替换编译器提供的new或delete呢？下面是三个最常见的理由：</p>
<ol>
<li>**用来检测运用上的错误。**如new的一段内存，delete时失败了导致内存泄漏。又或多次delete导致不确定行为。</li>
<li>**为了提升性能。**编译器默认提供的new&#x2F;delete是大众的，均衡的，不针对特定场景特定优化。如需要大量申请&#x2F;释放内存场景(碎片)，我们习知的有内存池技术。</li>
<li>**为了收集使用上的统计数据。**统计任何时刻内存分配情况等。</li>
</ol>
<p>但是要自定义一个合适的new&#x2F;delete并非易事，如<strong>内存对齐(对齐指令执行效率最高)，可移植性、线程安全</strong>…等等细节。所以我的建议是在你确定要自定义new&#x2F;delete之前，请先确定你程序瓶颈是否真的由默认new&#x2F;delete引起，而且现在也有商业产品可以替代编译器自带的内存管理器。或者也有一些开源的产品可以使用，如Boost的Pool就是对于常见的分配大量小型对象很有帮助。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>有许多理由需要写个自定义的new和delete，包括改善性能、对堆区运用错误进行调试、收集堆区使用信息。</li>
</ul>
</blockquote>
<h4 id="条款51-编写new和delete时需固守常规"><a href="#条款51-编写new和delete时需固守常规" class="headerlink" title="条款51. 编写new和delete时需固守常规"></a>条款51. 编写new和delete时需固守常规</h4><p>上面条款说了什么时候需要自定义new&#x2F;delete，本节则告诉你写自定义new&#x2F;delete需要遵守的一般规范。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>operator new 1. 应该内含一个无限循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用new-handler。2. 它也应该有能力处理0字节申请。3. Class的专属版本则还应该处理“比正确大小更大的申请”(被继承后, new 派生对象，这时可以走编译器默认new操作)。</li>
<li>operator delete应该在收到null指针时不做任何事情。Class专属版本还应该处理“比正确大小更大的申请”(同上)。</li>
</ul>
</blockquote>
<h4 id="条款52-new与delete成对出现"><a href="#条款52-new与delete成对出现" class="headerlink" title="条款52. new与delete成对出现"></a>条款52. new与delete成对出现</h4><p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>当你写一个operator new, 请确定也写出了对应的operator delete。如果没有这样做，你的程序可能会发生隐晦而时断时续的内存泄漏。</li>
<li>当你声明new和delete，请确定不要无意识地(非故意)遮掩了它们的正常版本。</li>
</ul>
</blockquote>
<h3 id="9-杂项讨论"><a href="#9-杂项讨论" class="headerlink" title="9.杂项讨论"></a>9.杂项讨论</h3><h4 id="条款53-不要忽略编译器的警告"><a href="#条款53-不要忽略编译器的警告" class="headerlink" title="条款53. 不要忽略编译器的警告"></a>条款53. 不要忽略编译器的警告</h4><p>记住后期很多无休止调试就是由于你前期没有重视编译警告引起的。尽管一般认为，写出一个在最高警告级别下也无任何警告信息的程序是理想的，然而如果你对某些警告信息有深刻理解，你倒是可以选择忽略它。不管怎样说，在你打发某个警告信息之前，请确定你了解它意图说出的精确意义。这很重要！</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>严肃对待编译器发出的警告信息。努力在你的编译器的最高警告级别下争取无任何警告的荣誉。</li>
<li>不要过度依赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原本依赖的警告信息有可能消失。</li>
</ul>
</blockquote>
<h4 id="条款54-让自己熟悉包括-TR1-在内的标准程序库"><a href="#条款54-让自己熟悉包括-TR1-在内的标准程序库" class="headerlink" title="条款54. 让自己熟悉包括 TR1 在内的标准程序库"></a>条款54. 让自己熟悉包括 TR1 在内的标准程序库</h4><ul>
<li>C++ 标准程序库主要由 STL，iostream，locales 组成，并包含 C99 标准程序库。</li>
<li>TR1 组件都在 <code>std::tr1::</code> 命名空间下，以下是组件实例：</li>
</ul>
<ol>
<li>智能指针。</li>
<li><code>tr1::function</code>，常用于实现回调函数。</li>
<li><code>tr1::bind</code>，能够做 STL 绑定器 bind1st 和 bind2nd 所做的每一件事，而又更多。</li>
<li>Hash tables，用来实现 sets，multisets，maps 和 multi-maps。</li>
<li>正则表达式。</li>
<li>Tuples 变量组，这是标准程序库 pair 的升级，pair 只能持有两个对象，而 <code>tr1::tuple</code> 可持有任意个数对象。</li>
<li><code>tr1::array</code>，本质是个 STL 化的数组，即一个支持成员函数 begin 和 end 的数组。不过它大小固定，并不使用动态内存。</li>
<li><code>tr1::mem_fn</code>，这是一个语句上构造与成员函数指针（member function pointers）一致的东西。同样容纳并扩充了 C++98 的 <code>mem_fun</code> 和 <code>mem_fun_ref</code> 的能力。</li>
<li><code>tr1::reference_wrapper</code>，一个让引用的行为更像对象的设施。</li>
<li>随机数生成工具，它大大超越了 rand。</li>
<li>数学特殊函数，包括 Laguerre 多项式、Bessel 函数、完全椭圆积分，以及更多数学函数。</li>
<li>C99 兼容扩充，这是一大堆函数和模版用来将许多新的 C99 程序库特性带入 C++。</li>
<li>Type traits，一组 traits classes（条款 47），用以提供类型的编译期信息。</li>
<li><code>tr1::result_of</code>，这是一个用来推导函数调用的返回值类型的模版。</li>
</ol>
<p>这些实现一般很多实现在boost库中都有！</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>C++标准程序库的主要功能由STL、iostreams、locales组成。并包含C99标准程序库。</li>
<li>TR1添加了智能指针、一般化函数指针、hash-based容器、正则表达式以及另外10个组件的支持。</li>
<li>TR1自身只是一份规范。为获得TR1提供的好处，你需要一份实现。一个好的实现来源是Boost。</li>
</ul>
</blockquote>
<h4 id="条款55-让自己熟悉-Boost"><a href="#条款55-让自己熟悉-Boost" class="headerlink" title="条款55. 让自己熟悉 Boost"></a>条款55. 让自己熟悉 Boost</h4><ul>
<li>Boost 是一个社群，也是一个网站。致力于免费、源码开放、同僚复审的 C++ 程序库开发。</li>
<li>Boost 提供许多 TR1 组件的实现品，以及其它许多程序库。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://darling-123456.github.io/">Darling</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://darling-123456.github.io/2024/10/28/C++/Effective%20C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">https://darling-123456.github.io/2024/10/28/C++/Effective C++ 读书笔记/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://darling-123456.github.io" target="_blank">Darlingの妙妙屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></div><div class="post-share"><div class="social-share" data-image="/img/30.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/10/28/C++/Effective%20C++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%8D%9A%E5%AE%A2%E6%B1%87%E6%80%BB/" title="Effective C++读书笔记博客汇总"><img class="cover" src="/img/31.jpg" onerror="onerror=null;src='/img/404_default.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Effective C++读书笔记博客汇总</div></div><div class="info-2"><div class="info-item-1">Effective C++读书笔记博客汇总这是csdn链接，大家感兴趣可以去看看 Effective C++ | 读书笔记 （一）-CSDN博客 Effective C++ | 读书笔记 （二）-CSDN博客 Effective C++ | 读书笔记 （三）-CSDN博客 Effective C++ | 读书笔记 （四）-CSDN博客 个人阅读感受： 我是第一次读到一半就没读了，觉得看不懂，读起来也比较枯燥 做过两个项目以后，第二次读才写的博客，有一些地方确实在项目中会运用到，但其他的还是有不少不太理解的，之后再做做别的项目进行第三次阅读之后再进行补充 </div></div></div></a><a class="pagination-related" href="/2024/10/29/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E7%81%B5%E7%A5%9E%E7%9A%84%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/" title="灵神的刷题指南"><img class="cover" src="/img/25.jpg" onerror="onerror=null;src='/img/404_default.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">灵神的刷题指南</div></div><div class="info-2"><div class="info-item-1">灵神的刷题指南分享｜如何科学刷题？ - 力扣（LeetCode）   合理运用心流通道，科学刷题，快乐刷题！  前言怎么刷算法题？按照什么顺序刷题？如何科学地刷题训练？ 如果你刚接触力扣，还不熟悉基本编程语法和常用库函数，推荐刷力扣官方的入门题单：  「新」动计划 · 编程入门 编程基础 0 到 1  有了一些简单题的积累，就可以开始刷我的题单啦~ 训练方法 A要点：  按照专题刷题。同一个专题下的题目，套路是一样的，刷题效率杠杠滴~ 从易到难，量力而行。题目已经按照难度分整理好了，按照顺序刷就行~  推荐先刷【滑动窗口】和【二分】题单，这是两个最基础的算法，套路也较为固定，刷题过程中还可以学到一些做题技巧。其他题单可以按照自己的兴趣选择。 请结合【基础算法精讲】学习。 推荐安装...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/10/28/C++/Effective%20C++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%8D%9A%E5%AE%A2%E6%B1%87%E6%80%BB/" title="Effective C++读书笔记博客汇总"><img class="cover" src="/img/31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-28</div><div class="info-item-2">Effective C++读书笔记博客汇总</div></div><div class="info-2"><div class="info-item-1">Effective C++读书笔记博客汇总这是csdn链接，大家感兴趣可以去看看 Effective C++ | 读书笔记 （一）-CSDN博客 Effective C++ | 读书笔记 （二）-CSDN博客 Effective C++ | 读书笔记 （三）-CSDN博客 Effective C++ | 读书笔记 （四）-CSDN博客 个人阅读感受： 我是第一次读到一半就没读了，觉得看不懂，读起来也比较枯燥 做过两个项目以后，第二次读才写的博客，有一些地方确实在项目中会运用到，但其他的还是有不少不太理解的，之后再做做别的项目进行第三次阅读之后再进行补充 </div></div></div></a><a class="pagination-related" href="/2024/10/20/C++/%E4%BE%AF%E6%8D%B7%20C++%20STL%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" title="侯捷 C++ STL标准库和泛型编程 | 学习笔记"><img class="cover" src="/img/34.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-20</div><div class="info-item-2">侯捷 C++ STL标准库和泛型编程 | 学习笔记</div></div><div class="info-2"><div class="info-item-1">侯捷 C++ STL标准库和泛型编程 | 学习笔记1 STL概述STL —— Standard Template Library，标准模板库 C++ Standard LIbrary，C++标准库中包含STL（即STL+一些小东西） 1.1 头文件名称 C++标准库的 header files 不带 .h，例如：#include&lt;vector&gt; 新式 C header files 不带 .h，例如：#include&lt;cstdio&gt; 老式 C header files 带 .h 仍然可用，例如：#include&lt;stdio.h&gt;   新式 header 内的组件封装于 namespace std 老式 header 内的组件不封装于 namespace std  1.2...</div></div></div></a><a class="pagination-related" href="/2024/10/16/C++/%E6%96%BD%E7%A3%8AC++%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B%20%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%20%E5%8D%9A%E5%AE%A2%E6%B1%87%E6%80%BB/" title="施磊C++ | 进阶学习笔记"><img class="cover" src="/img/38.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-16</div><div class="info-item-2">施磊C++ | 进阶学习笔记</div></div><div class="info-2"><div class="info-item-1">施磊C++高级进阶课程 | 学习笔记 | 博客汇总以下是CSDN链接 施磊C++ | 进阶学习笔记 | 1.对象的应用优化、右值引用的优化-CSDN博客 施磊C++ | 进阶学习笔记 | 2.智能指针-CSDN博客 施磊C++ | 进阶学习笔记 | 3.绑定器和函数对象、lambda表达式-CSDN博客 施磊C++ | 进阶学习笔记 | 4.c++11内容汇总、多线程应用实践-CSDN博客 施磊C++ | 进阶学习笔记 | 5.设计模式-CSDN博客 剩余有关面试的等到明年投简历前学习 </div></div></div></a><a class="pagination-related" href="/2024/10/24/C++/%E4%BE%AF%E6%8D%B7%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="侯捷内存管理学习笔记 | C++"><img class="cover" src="/img/36.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-24</div><div class="info-item-2">侯捷内存管理学习笔记 | C++</div></div><div class="info-2"><div class="info-item-1">侯捷内存管理学习笔记第一章节 primitives零.new和delete概述C++中的new和delete是用于动态内存分配和释放的操作符，它们的底层机制和工作原理相对复杂，但也可以简单清晰地解释。 new的底层机制和工作原理 内存分配： 当使用new操作符时，它首先会调用底层的内存分配函数（如operator new），这个函数通常是对malloc的封装。malloc会从堆中分配足够的内存空间。 如果内存分配失败，operator...</div></div></div></a><a class="pagination-related" href="/2024/10/16/C++/%E6%96%BD%E7%A3%8AC++%20%20%E8%BF%9B%E9%98%B6%20%20%E7%AC%94%E8%AE%B0/" title="施磊C++ | 进阶学习笔记"><img class="cover" src="/img/37.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-16</div><div class="info-item-2">施磊C++ | 进阶学习笔记</div></div><div class="info-2"><div class="info-item-1">施磊C++ | 进阶学习笔记一、对象的应用优化、右值引用的优化1.1 构造，拷贝，赋值，析构中的优化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;using namespace std;class test&#123;public:	test(int a = 10) :ma(a) &#123; cout &lt;&lt; &quot;test(int)&quot; &lt;&lt; endl; &#125;	~test() &#123; cout &lt;&lt; &quot;~test&quot; &lt;&lt; endl; &#125;	test(const test&amp; t) :ma(t.ma) &#123; cout &lt;&lt; &quot;test(const &amp;)&quot; &lt;&lt; endl; &#125;	test&amp;...</div></div></div></a><a class="pagination-related" href="/2024/10/10/C++/%E4%BE%AF%E6%8D%B7%20%20C++11%20%E6%96%B0%E7%89%B9%E6%80%A7%20%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="侯捷 C++11 新特性 学习笔记"><img class="cover" src="/img/35.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-10</div><div class="info-item-2">侯捷 C++11 新特性 学习笔记</div></div><div class="info-2"><div class="info-item-1">C++11 新特性 学习笔记1.Variadic TemplatesC++11支持函数模板的默认模板参数在 C++98&#x2F;03 标准中，类模板可以有默认的模板参数，如下： 12345template &lt;typename T, typename U = int, U N = 0&gt;struct Foo&#123;    // ...&#125;;  但是却不支持函数的默认模板参数： 12345template &lt;typename T = int&gt;  // error in C++98/03: default template argumentsvoid func()&#123;    // ...&#125;  现在这一限制在 C++11 中被解除了。上面的 func 函数在 C++11 中可以直接使用，代码如下： 12345int main(void)&#123;    func();   //T = int    return 0;&#125;  此时模板参数 T 的类型就为默认值...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Darling</div><div class="author-info-description">为什么学习这么难!</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">57</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Darling-123456"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Darling-123456" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_74795952?type=blog" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="mailto:2214050255@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是Darlingの妙妙屋，更新笔者的学习笔记，联系方式：2214050255@qq.com</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Effective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">Effective C++ 读书笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC"><span class="toc-number">1.1.</span> <span class="toc-text">1、让自己习惯C++</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-01-%EF%BC%9A%E8%A7%86C-%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6"><span class="toc-number">1.1.1.</span> <span class="toc-text">条款 01 ：视C++为一个语言联邦</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-02%EF%BC%9A-%E5%B0%BD%E9%87%8Fconst%E3%80%81enum%E3%80%81inline%E6%9B%BF%E6%8D%A2-define"><span class="toc-number">1.1.2.</span> <span class="toc-text">条款 02： 尽量const、enum、inline替换#define</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-03-%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const"><span class="toc-number">1.1.3.</span> <span class="toc-text">条款 03 ：尽可能使用const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-04-%EF%BC%9A-%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.4.</span> <span class="toc-text">条款 04 ： 确定对象使用前已被初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81-%E6%9E%84%E9%80%A0-%E6%9E%90%E6%9E%84-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.</span> <span class="toc-text">2、 构造&#x2F;析构&#x2F;赋值运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE05-%EF%BC%9A%E4%BA%86%E8%A7%A3C-%E9%BB%98%E8%AE%A4%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">条款05 ：了解C++默认编写并调用哪些函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-06-%EF%BC%9A%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D"><span class="toc-number">1.2.2.</span> <span class="toc-text">条款 06 ：若不想使用编译器自动生成的函数，就该明确拒绝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-07-%EF%BC%9A%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8E%E4%B8%BAvirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">条款 07 ：为多态基类声明为virtual析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-08-%EF%BC%9A%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.</span> <span class="toc-text">条款 08 ：别让异常逃离析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-09-%EF%BC%9A-%E7%BB%9D%E4%B8%8D%E5%86%8D%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text">条款 09 ： 绝不再构造和析构函数中调用virtual函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%EF%BC%81"><span class="toc-number">2.</span> <span class="toc-text">错！</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE10-%EF%BC%9A%E4%BB%A4operator-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAreference-to-this"><span class="toc-number">2.0.1.</span> <span class="toc-text">条款10 ：令operator&#x3D;返回一个reference to *this</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE11-%EF%BC%9A%E5%9C%A8operator-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E2%80%9C%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E2%80%9D"><span class="toc-number">2.0.2.</span> <span class="toc-text">条款11 ：在operator&#x3D;中实现“自我赋值”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-12-%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E9%83%A8%E5%88%86"><span class="toc-number">2.0.3.</span> <span class="toc-text">条款 12 : 复制对象时勿忘其每一个部分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">3、 资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-13%EF%BC%9A%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90"><span class="toc-number">2.1.1.</span> <span class="toc-text">条款 13：以对象管理资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-14%EF%BC%9A-%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83coping%E8%A1%8C%E4%B8%BA"><span class="toc-number">2.1.2.</span> <span class="toc-text">条款 14： 在资源管理类中小心coping行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-15-%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">2.1.3.</span> <span class="toc-text">条款 15 :在资源管理类中提供对原始资源的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-16-%EF%BC%9A-%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E6%97%B6%E8%A6%81%E9%87%87%E5%8F%96%E7%9B%B8%E5%90%8C%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.1.4.</span> <span class="toc-text">条款 16 ： 成对使用new和delete时要采取相同形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-17-%EF%BC%9A%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86newed%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">2.1.5.</span> <span class="toc-text">条款 17 ：以独立语句将newed对象置入智能指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E"><span class="toc-number">2.2.</span> <span class="toc-text">4、设计与声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE18%EF%BC%9A%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E5%AE%B9%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">条款18：让接口容易被正确使用，不容易被误用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE19-%EF%BC%9A%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1type"><span class="toc-number">2.2.2.</span> <span class="toc-text">条款19 ：设计class犹如设计type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE20%EF%BC%9A-%E5%AE%81%E4%BB%A5pass-by-reference-to-const%E6%9B%BF%E6%8D%A2pass-by-value%EF%BC%88%E6%9C%AC%E6%9D%A1%E7%AC%AC%E5%85%AD%E7%82%B9%E8%A6%81%E5%B8%B8%E7%9C%8B%EF%BC%89"><span class="toc-number">2.2.3.</span> <span class="toc-text">条款20： 宁以pass-by-reference-to-const替换pass-by-value（本条第六点要常看）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE21%EF%BC%9A-%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6reference"><span class="toc-number">2.2.4.</span> <span class="toc-text">条款21： 必须返回对象时，别妄想返回其reference</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE22%EF%BC%9A%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BAprivate"><span class="toc-number">2.2.5.</span> <span class="toc-text">条款22：将成员变量声明为private</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE23%EF%BC%9A%E5%AE%81%E4%BB%A5non-member%E3%80%81non-friend%E6%9B%BF%E6%8D%A2member%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.6.</span> <span class="toc-text">条款23：宁以non-member、non-friend替换member函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE24%EF%BC%9A%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.7.</span> <span class="toc-text">条款24：若所有参数皆需要类型转换，请为此采用non-member函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE25%EF%BC%9A%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.8.</span> <span class="toc-text">条款25：考虑写出一个不抛出异常的swap函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.</span> <span class="toc-text">5、实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE26%EF%BC%9A%E5%8F%98%E9%87%8F%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%9C%A8%E4%BD%BF%E7%94%A8%E6%97%B6%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">条款26：变量尽可能在使用时定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE27%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C"><span class="toc-number">2.3.2.</span> <span class="toc-text">条款27：尽量少做转型动作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E4%BC%A0%E9%80%92%E7%BB%99const%E5%BC%95%E7%94%A8%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">关于传递给const引用临时对象的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE28%EF%BC%9A-%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86"><span class="toc-number">2.3.3.</span> <span class="toc-text">条款28： 尽量避免返回handles指向对象内部成分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE29-%E4%B8%BA%E2%80%9D%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E2%80%9D%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84"><span class="toc-number">2.3.4.</span> <span class="toc-text">条款29. 为”异常安全”而努力是值得的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE30%EF%BC%9A%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inline%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96"><span class="toc-number">2.3.5.</span> <span class="toc-text">条款30：透彻了解inline的里里外外</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE31%EF%BC%9A-%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E"><span class="toc-number">2.3.6.</span> <span class="toc-text">条款31： 将文件间的编译依赖关系降至最低</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%9B%AE%E7%9A%84"><span class="toc-number">2.3.6.1.</span> <span class="toc-text">一、定义与目的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.6.2.</span> <span class="toc-text">二、实现方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.3.6.3.</span> <span class="toc-text">三、使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.4.</span> <span class="toc-text">6.继承与面向对象设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE32-%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BAis-a%E5%85%B3%E7%B3%BB"><span class="toc-number">2.4.1.</span> <span class="toc-text">条款32. 确定你的public继承塑模出is-a关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE33-%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">2.4.2.</span> <span class="toc-text">条款33. 避免遮掩继承而来的名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE34-%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.3.</span> <span class="toc-text">条款34. 区分接口继承和实现继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE35-%E8%80%83%E8%99%91virtual%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9"><span class="toc-number">2.4.4.</span> <span class="toc-text">条款35. 考虑virtual函数以外的其他选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE36-%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E9%9D%9E%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.5.</span> <span class="toc-text">条款36. 绝不重新定义继承而来的非虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE37-%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-number">2.4.6.</span> <span class="toc-text">条款37. 绝不重新定义继承而来的缺省参数值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE38-%E7%B1%BB%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.4.7.</span> <span class="toc-text">条款38. 类的子对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE39-%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8private%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.8.</span> <span class="toc-text">条款39. 明智而审慎地使用private继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE40-%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.9.</span> <span class="toc-text">条款40. 明智而审慎地使用多重继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">2.5.</span> <span class="toc-text">7.模板与泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE41-%E4%BA%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81"><span class="toc-number">2.5.1.</span> <span class="toc-text">条款41. 了解隐式接口和编译期多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE42-%E4%BA%86%E8%A7%A3typename%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89"><span class="toc-number">2.5.2.</span> <span class="toc-text">条款42. 了解typename的双重意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE43-%E6%B3%A8%E6%84%8F%E5%A4%84%E7%90%86%E6%A8%A1%E7%89%88%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">2.5.3.</span> <span class="toc-text">条款43. 注意处理模版化基类内的名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE44-%E5%B0%86%E4%B8%8E%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8A%BD%E7%A6%BBtemplate%EF%BC%88%E5%B0%9A%E4%B8%94%E4%B8%8D%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%8C%E4%BA%86%E9%9C%80%E8%A6%81%E5%9C%A8%E5%A4%8D%E4%B9%A0%EF%BC%89"><span class="toc-number">2.5.4.</span> <span class="toc-text">条款44. 将与参数无关的代码抽离template（尚且不理解，完了需要在复习）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE45-%E8%BF%90%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.5.5.</span> <span class="toc-text">条款45. 运用成员函数模版接受所有兼容类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE46-%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%97%B6%E8%AF%B7%E4%B8%BA%E6%A8%A1%E7%89%88%E5%AE%9A%E4%B9%89%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.6.</span> <span class="toc-text">条款46. 需要类型转换时请为模版定义非成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE47-%E8%AF%B7%E4%BD%BF%E7%94%A8traits-class%E8%A1%A8%E7%8E%B0%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">2.5.7.</span> <span class="toc-text">条款47. 请使用traits class表现类型信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE48-%E8%AE%A4%E8%AF%86template%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-number">2.5.8.</span> <span class="toc-text">条款48. 认识template元编程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%AE%9A%E5%88%B6-new-%E5%92%8C-delete"><span class="toc-number">2.6.</span> <span class="toc-text">8.定制 new 和 delete</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE49-%E4%BA%86%E8%A7%A3new-handler%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">2.6.1.</span> <span class="toc-text">条款49. 了解new-handler的行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE50-%E4%BA%86%E8%A7%A3new%E5%92%8Cdelete%E7%9A%84%E5%90%88%E7%90%86%E6%9B%BF%E6%8D%A2%E6%97%B6%E6%9C%BA"><span class="toc-number">2.6.2.</span> <span class="toc-text">条款50. 了解new和delete的合理替换时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE51-%E7%BC%96%E5%86%99new%E5%92%8Cdelete%E6%97%B6%E9%9C%80%E5%9B%BA%E5%AE%88%E5%B8%B8%E8%A7%84"><span class="toc-number">2.6.3.</span> <span class="toc-text">条款51. 编写new和delete时需固守常规</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE52-new%E4%B8%8Edelete%E6%88%90%E5%AF%B9%E5%87%BA%E7%8E%B0"><span class="toc-number">2.6.4.</span> <span class="toc-text">条款52. new与delete成对出现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA"><span class="toc-number">2.7.</span> <span class="toc-text">9.杂项讨论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE53-%E4%B8%8D%E8%A6%81%E5%BF%BD%E7%95%A5%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E8%AD%A6%E5%91%8A"><span class="toc-number">2.7.1.</span> <span class="toc-text">条款53. 不要忽略编译器的警告</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE54-%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%86%9F%E6%82%89%E5%8C%85%E6%8B%AC-TR1-%E5%9C%A8%E5%86%85%E7%9A%84%E6%A0%87%E5%87%86%E7%A8%8B%E5%BA%8F%E5%BA%93"><span class="toc-number">2.7.2.</span> <span class="toc-text">条款54. 让自己熟悉包括 TR1 在内的标准程序库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE55-%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%86%9F%E6%82%89-Boost"><span class="toc-number">2.7.3.</span> <span class="toc-text">条款55. 让自己熟悉 Boost</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/22/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day70%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E5%AE%8C%E6%88%90%E6%97%85%E9%80%94%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/" title="Day70 | 灵神 | 二分查找：完成旅途的最少时间"><img src="/img/1.jpg" onerror="this.onerror=null;this.src='/img/404_default.jpg'" alt="Day70 | 灵神 | 二分查找：完成旅途的最少时间"/></a><div class="content"><a class="title" href="/2025/03/22/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day70%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E5%AE%8C%E6%88%90%E6%97%85%E9%80%94%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/" title="Day70 | 灵神 | 二分查找：完成旅途的最少时间">Day70 | 灵神 | 二分查找：完成旅途的最少时间</a><time datetime="2025-03-21T16:00:00.000Z" title="发表于 2025-03-22 00:00:00">2025-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/22/%E5%B7%A5%E5%85%B7/Bulk%20Rename%20Utility%EF%BC%88BRU%EF%BC%89%E2%80%94%E2%80%94%E5%A4%A7%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F/" title="Bulk Rename Utility（BRU）——大批量重命名实用程序"><img src="/img/51.jpg" onerror="this.onerror=null;this.src='/img/404_default.jpg'" alt="Bulk Rename Utility（BRU）——大批量重命名实用程序"/></a><div class="content"><a class="title" href="/2025/03/22/%E5%B7%A5%E5%85%B7/Bulk%20Rename%20Utility%EF%BC%88BRU%EF%BC%89%E2%80%94%E2%80%94%E5%A4%A7%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F/" title="Bulk Rename Utility（BRU）——大批量重命名实用程序">Bulk Rename Utility（BRU）——大批量重命名实用程序</a><time datetime="2025-03-21T16:00:00.000Z" title="发表于 2025-03-22 00:00:00">2025-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day69%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/" title="Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂"><img src="/img/2.jpg" onerror="this.onerror=null;this.src='/img/404_default.jpg'" alt="Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂"/></a><div class="content"><a class="title" href="/2025/03/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day69%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/" title="Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂">Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂</a><time datetime="2025-03-21T01:16:25.000Z" title="发表于 2025-03-21 09:16:25">2025-03-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/20/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day68%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9AH%E6%8C%87%E6%95%B0II/" title="Day68 | 灵神 | 二分查找：H指数II"><img src="/img/3.jpg" onerror="this.onerror=null;this.src='/img/404_default.jpg'" alt="Day68 | 灵神 | 二分查找：H指数II"/></a><div class="content"><a class="title" href="/2025/03/20/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day68%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9AH%E6%8C%87%E6%95%B0II/" title="Day68 | 灵神 | 二分查找：H指数II">Day68 | 灵神 | 二分查找：H指数II</a><time datetime="2025-03-19T16:00:00.000Z" title="发表于 2025-03-20 00:00:00">2025-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/19/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day67%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%85%AC%E5%B9%B3%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/" title="Day67 | 灵神 | 二分查找：统计公平数对的数目"><img src="/img/4.jpg" onerror="this.onerror=null;this.src='/img/404_default.jpg'" alt="Day67 | 灵神 | 二分查找：统计公平数对的数目"/></a><div class="content"><a class="title" href="/2025/03/19/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day67%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%85%AC%E5%B9%B3%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/" title="Day67 | 灵神 | 二分查找：统计公平数对的数目">Day67 | 灵神 | 二分查找：统计公平数对的数目</a><time datetime="2025-03-18T16:00:00.000Z" title="发表于 2025-03-19 00:00:00">2025-03-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Darling</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'Darling-123456/giscus-component',
      'data-repo-id': 'R_kgDOOMRtzQ',
      'data-category-id': 'DIC_kwDOOMRtzc4CoTsn',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !true) {
    if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script async src="https://npm.elemecdn.com/tzy-blog/lib/js/other/sakura.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":20,"vOffset":-20},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>