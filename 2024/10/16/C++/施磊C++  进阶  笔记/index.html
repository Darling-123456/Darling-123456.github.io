<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>施磊C++ | 进阶学习笔记 | Darlingの妙妙屋</title><meta name="author" content="Darling"><meta name="copyright" content="Darling"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="施磊C++ | 进阶学习笔记一、对象的应用优化、右值引用的优化1.1 构造，拷贝，赋值，析构中的优化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;using namespace std;class tes">
<meta property="og:type" content="article">
<meta property="og:title" content="施磊C++ | 进阶学习笔记">
<meta property="og:url" content="https://darling-123456.github.io/2024/10/16/C++/%E6%96%BD%E7%A3%8AC++%20%20%E8%BF%9B%E9%98%B6%20%20%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Darlingの妙妙屋">
<meta property="og:description" content="施磊C++ | 进阶学习笔记一、对象的应用优化、右值引用的优化1.1 构造，拷贝，赋值，析构中的优化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;using namespace std;class tes">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://darling-123456.github.io/img/37.jpg">
<meta property="article:published_time" content="2024-10-15T16:00:00.000Z">
<meta property="article:modified_time" content="2025-03-22T14:51:59.709Z">
<meta property="article:author" content="Darling">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://darling-123456.github.io/img/37.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "施磊C++ | 进阶学习笔记",
  "url": "https://darling-123456.github.io/2024/10/16/C++/%E6%96%BD%E7%A3%8AC++%20%20%E8%BF%9B%E9%98%B6%20%20%E7%AC%94%E8%AE%B0/",
  "image": "https://darling-123456.github.io/img/37.jpg",
  "datePublished": "2024-10-15T16:00:00.000Z",
  "dateModified": "2025-03-22T14:51:59.709Z",
  "author": [
    {
      "@type": "Person",
      "name": "Darling",
      "url": "https://darling-123456.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://darling-123456.github.io/2024/10/16/C++/%E6%96%BD%E7%A3%8AC++%20%20%E8%BF%9B%E9%98%B6%20%20%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Darling","link":"链接: ","source":"来源: Darlingの妙妙屋","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'medium_zoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '施磊C++ | 进阶学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">57</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/37.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/test.jpg" alt="Logo"><span class="site-name">Darlingの妙妙屋</span></a><a class="nav-page-title" href="/"><span class="site-name">施磊C++ | 进阶学习笔记</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">施磊C++ | 进阶学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-15T16:00:00.000Z" title="发表于 2024-10-16 00:00:00">2024-10-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-22T14:51:59.709Z" title="更新于 2025-03-22 22:51:59">2025-03-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84C-%E3%81%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/">从零开始的C++の学习之路</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">33.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>128分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="施磊C-进阶学习笔记"><a href="#施磊C-进阶学习笔记" class="headerlink" title="施磊C++ | 进阶学习笔记"></a>施磊C++ | 进阶学习笔记</h1><h2 id="一、对象的应用优化、右值引用的优化"><a href="#一、对象的应用优化、右值引用的优化" class="headerlink" title="一、对象的应用优化、右值引用的优化"></a>一、对象的应用优化、右值引用的优化</h2><h3 id="1-1-构造，拷贝，赋值，析构中的优化"><a href="#1-1-构造，拷贝，赋值，析构中的优化" class="headerlink" title="1.1 构造，拷贝，赋值，析构中的优化"></a>1.1 构造，拷贝，赋值，析构中的优化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">test</span>(<span class="type">int</span> a = <span class="number">10</span>) :<span class="built_in">ma</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;test(int)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~test&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="built_in">test</span>(<span class="type">const</span> test&amp; t) :<span class="built_in">ma</span>(t.ma) &#123; cout &lt;&lt; <span class="string">&quot;test(const &amp;)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> test&amp; t)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">		ma = t.ma;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	test t1;<span class="comment">//构造</span></span><br><span class="line">	<span class="function">test <span class="title">t2</span><span class="params">(t1)</span></span>;<span class="comment">//拷贝</span></span><br><span class="line">	test t3 = t1;<span class="comment">//拷贝</span></span><br><span class="line">	<span class="comment">//临时对象生存周期就是这个语句</span></span><br><span class="line">	<span class="comment">/*1.C++编译器对于对象构造的优化：用临时对象生成新对象的时候，临时对象就不产生了，直接构造新对象就可以了*/</span></span><br><span class="line">	test t4 = <span class="built_in">test</span>(<span class="number">20</span>);<span class="comment">//相当于 test t4(20); 而不是先用临时对象构造，临时对象拷贝，然后临时对象析构，这样效率太低了就给优化了</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	t4 = t2;<span class="comment">//赋值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.显式生成临时对象</span></span><br><span class="line">	<span class="comment">//t4.operator=(const Test &amp;t)这个临时对象会产生，因为要给参数t赋值，传参</span></span><br><span class="line">	t4 = <span class="built_in">test</span>(<span class="number">30</span>);<span class="comment">// 依次调用 构造 赋值 析构</span></span><br><span class="line">	t4 = (test)<span class="number">30</span>;<span class="comment">//有合适的构造函数可以隐式的生成一个临时对象然后给t4，没有合适的就报错</span></span><br><span class="line">	<span class="comment">//隐式生成临时对象</span></span><br><span class="line">	t4 = <span class="number">30</span>;<span class="comment">//这3句等价</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3. 临时对象，指针和引用</span></span><br><span class="line">	<span class="comment">// 指针指向临时对象不安全，但是引用是安全的</span></span><br><span class="line">	<span class="comment">//p指向的是一个已经析构的临时对象，变成了野指针</span></span><br><span class="line">	test* p = &amp;<span class="built_in">test</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="comment">//但是引用是可以的，因为是起了一个别名，给一块内存重新按了一个名字，就可以继续用，所以是安全的</span></span><br><span class="line">	<span class="type">const</span> test&amp; ref = <span class="built_in">test</span>(<span class="number">50</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4.全局变量是在main函数之前就完成了初始化的</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//5.test *p1=new test(70) 调用一次构造函数 只有在delete的时候才调用析构</span></span><br><span class="line">	<span class="comment">//6.test *p2=new test[2] 调用两次构造</span></span><br><span class="line">	<span class="comment">//7.delete p1 调用析构然后才释放内存</span></span><br><span class="line">	<span class="comment">//8.delete []p2 两次析构然后调用free释放整个内存 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="课后练习："><a href="#课后练习：" class="headerlink" title="课后练习："></a>课后练习：</h4><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241009213117219.png" alt="image-20241009213117219"></p>
<h3 id="1-2-函数调用过程中对象背后调用的方法"><a href="#1-2-函数调用过程中对象背后调用的方法" class="headerlink" title="1.2 函数调用过程中对象背后调用的方法"></a>1.2 函数调用过程中对象背后调用的方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">test</span>(<span class="type">int</span> a = <span class="number">10</span>) :<span class="built_in">ma</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;test(int)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~test&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="built_in">test</span>(<span class="type">const</span> test&amp; t) :<span class="built_in">ma</span>(t.ma) &#123; cout &lt;&lt; <span class="string">&quot;test(const &amp;)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> test&amp; t)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">		ma = t.ma;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ma; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">test <span class="title">GetObject</span><span class="params">(test t)</span><span class="comment">//不能返回局部的或者临时对象的指针或引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> val = t.<span class="built_in">getData</span>();</span><br><span class="line">	<span class="function">test <span class="title">tmp</span><span class="params">(val)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//背后调用了哪些函数呢？</span></span><br><span class="line">	test t1;<span class="comment">//1.test(int)</span></span><br><span class="line">	test t2;<span class="comment">//2.test(int)</span></span><br><span class="line">	t2 = <span class="built_in">GetObject</span>(t1);<span class="comment">//3.test(const test&amp;) t1-&gt;t 实参到形参是一个初始化的过程不是第一个赋值的过程，这里用t1初始化形参t</span></span><br><span class="line">	<span class="comment">//4.test(int) 初始化tmp</span></span><br><span class="line">	<span class="comment">// 5.test(const test&amp;) tmp拷贝给一个临时对象</span></span><br><span class="line">	<span class="comment">//5.tmp 析构</span></span><br><span class="line">	<span class="comment">//6.t析构</span></span><br><span class="line">	<span class="comment">//7.operator 赋值 给t2</span></span><br><span class="line">	<span class="comment">//8.临时对象析构</span></span><br><span class="line">	<span class="comment">//9.t2析构</span></span><br><span class="line">	<span class="comment">//10.t1析构</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-对象优化三原则"><a href="#1-3-对象优化三原则" class="headerlink" title="1.3 对象优化三原则"></a>1.3 对象优化三原则</h3><p>1.函数参数传递过程中，对象优先按引用传递，不要按照值传递（实参到形参不需要构造和析构函数调用）</p>
<p>2.函数返回对象的时候，优先考虑返回一个临时对象，而不是一个定义过的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意加了引用</span></span><br><span class="line"><span class="function">test <span class="title">GetObject</span><span class="params">(test &amp;t)</span><span class="comment">//改成这样以后，调用会少了tmp的构造和析构，又少了两个调用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> val = t.<span class="built_in">getData</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">test</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.接收函数返回值是对象的函数调用的时候，优先按初始化的方式接收，不要按复制的方式接收</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">test</span>(<span class="type">int</span> a = <span class="number">10</span>) :<span class="built_in">ma</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;test(int)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~test&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="built_in">test</span>(<span class="type">const</span> test&amp; t) :<span class="built_in">ma</span>(t.ma) &#123; cout &lt;&lt; <span class="string">&quot;test(const &amp;)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> test&amp; t)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">		ma = t.ma;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ma; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//注意，加了引用</span></span><br><span class="line"><span class="function">test <span class="title">GetObject</span><span class="params">(test &amp;t)</span><span class="comment">//不能返回局部的或者临时对象的指针或引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> val = t.<span class="built_in">getData</span>();</span><br><span class="line">	<span class="function">test <span class="title">tmp</span><span class="params">(val)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//背后调用了哪些函数呢？</span></span><br><span class="line">	test t1;<span class="comment">//1.test(int) 构造t1 </span></span><br><span class="line">	test t2 = <span class="built_in">GetObject</span>(t1);<span class="comment">//2.test(int) 直接构造t2</span></span><br><span class="line">    <span class="comment">//3.t2析构</span></span><br><span class="line">    <span class="comment">//4.t1析构</span></span><br><span class="line">    <span class="comment">//test t2;</span></span><br><span class="line">    <span class="comment">//t2 = GetObject(t1);</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-右值引用、move移动语意、完美转发"><a href="#1-4-右值引用、move移动语意、完美转发" class="headerlink" title="1.4 右值引用、move移动语意、完美转发"></a>1.4 右值引用、move移动语意、完美转发</h3><p>请转至<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_74795952/article/details/142858121?spm=1001.2014.3001.5501">C++11 新特性 学习笔记-CSDN博客</a>进行学习</p>
<h2 id="二、智能指针"><a href="#二、智能指针" class="headerlink" title="二、智能指针"></a>二、智能指针</h2><h3 id="2-1智能指针介绍"><a href="#2-1智能指针介绍" class="headerlink" title="2.1智能指针介绍"></a>2.1智能指针介绍</h3><p>学习C++的人，一直在接触裸指针，一边感受着它的强大，一边感受着它的坑爹。当然，坑不坑爹在于开发者，指针本身近乎完美，但奈何用的人比较猥琐，给自己埋下无数的坑，还哭喊着指针不好用，那么今天要介绍的智能指针可以释放大家在使用裸指针时的一些压力，当然智能指针无法替代裸指针的全部功能。</p>
<p>裸指针到底有什么不好，写过一些C++代码的人应该都能知道，比如下面的原因：</p>
<ol>
<li>忘记释放资源，导致资源泄露（常发生内存泄漏问题）</li>
<li>同一资源释放多次，导致释放野指针，程序崩溃</li>
<li>明明代码的后面写了释放资源的代码，但是由于程序逻辑满足条件，从中间return掉了，导致释放资源的代码未被执行到，懵</li>
<li>代码运行过程中发生异常，随着异常栈展开，导致释放资源的代码未被执行到，懵</li>
</ol>
<p>总之，智能指针的<strong>智能</strong>二字，主要体现在用户可以不关注资源的释放，因为智能指针会帮你完全管理资源的释放，它会保证无论程序逻辑怎么跑，正常执行或者产生异常，资源在到期的情况下，一定会进行释放。</p>
<p>C++11库里面，提供了<strong>带引用计数的智能指针和不带引用计数的智能指针</strong>，这篇文章主要介绍它们的原理和应用场景，包括<strong>auto_ptr，scoped_ptr，unique_ptr，shared_ptr，weak_ptr</strong>。</p>
<h3 id="2-2自己实现智能指针（基础知识）"><a href="#2-2自己实现智能指针（基础知识）" class="headerlink" title="2.2自己实现智能指针（基础知识）"></a>2.2自己实现智能指针（基础知识）</h3><p>为了更好的理解C++库中智能指针的原理，我们首先需要自己实现一个简单的智能指针，窥探一下智能指针的基本原理，就是利用<strong>栈上的对象出作用域会自动析构</strong>这么一个特点，把资源释放的代码全部放在这个析构函数中执行，就达到了所谓的<strong>智能</strong>指针。对比下面的两块代码：</p>
<ol>
<li>使用裸指针</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">	<span class="comment">/*其它的代码...*/</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	如果这里忘记写delete，或者上面的代码段中程序return掉了，</span></span><br><span class="line"><span class="comment">	没有执行到这里，都会导致这里没有释放内存，内存泄漏</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.使用智能指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CSmartPtr</span>(T *ptr = <span class="literal">nullptr</span>) :<span class="built_in">mptr</span>(ptr) &#123;&#125;</span><br><span class="line">	~<span class="built_in">CSmartPtr</span>() &#123; <span class="keyword">delete</span> mptr; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T *mptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CSmartPtr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">	<span class="comment">/*其它的代码...*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*由于ptr是栈上的智能指针对象，不管是函数正常执行完，还是运行过程中出现</span></span><br><span class="line"><span class="comment">	异常，栈上的对象都会自动调用析构函数，在析构函数中进行了delete</span></span><br><span class="line"><span class="comment">	操作，保证释放资源*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码就是一个非常简单的智能指针，主要用到了这两点：<br>1）<strong>智能指针体现在把裸指针进行了一次面向对象的封装，在构造函数中初始化资源地址，在析构函数中负责释放资源</strong><br>2）<strong>利用栈上的对象出作用域自动析构这个特点，在智能指针的析构函数中保证释放资源</strong></p>
<p>所以，智能指针一般都是定义在栈上的，曾经有一个面试问题，问“<strong>能不能在堆上定义智能指针？</strong>”，如这段代码<strong>CSmartPtr *p &#x3D; new CSmartPtr(new int)</strong>;大家应该能看出来，这里定义的p虽然是智能指针类型，但它实质上还是一个裸指针，因此p还是需要进行手动delete，又回到了最开始裸指针我们面临的问题，那还不如一开始就用裸指针算了。</p>
<p>当然，智能指针要做到和裸指针相似，还得提供裸指针常见的*<strong>和-&gt;两种运算符的重载函数</strong>，使用起来才真正的和裸指针一样，代码扩充如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CSmartPtr</span>(T *ptr = <span class="literal">nullptr</span>) :<span class="built_in">mptr</span>(ptr) &#123;&#125;</span><br><span class="line">	~<span class="built_in">CSmartPtr</span>() &#123; <span class="keyword">delete</span> mptr; &#125;</span><br><span class="line"></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *mptr; &#125;</span><br><span class="line">	<span class="type">const</span> T&amp; <span class="keyword">operator</span>*()<span class="type">const</span> &#123; <span class="keyword">return</span> *mptr; &#125;</span><br><span class="line"></span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> mptr; &#125;</span><br><span class="line">	<span class="type">const</span> T* <span class="keyword">operator</span>-&gt;()<span class="type">const</span> &#123; <span class="keyword">return</span> mptr; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T *mptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CSmartPtr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">	*ptr = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;mptr;<span class="comment">//解析过程是 (ptr.operator-&gt;())-&gt;mptr 其实是-&gt;运算符重载函数的返回值去调用箭头运算符</span></span><br></pre></td></tr></table></figure>

<p>上面的这个智能指针，使用起来就和普通的裸指针非常相似了，但是它还存在很大的问题，看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CSmartPtr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">	<span class="function">CSmartPtr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个main函数运行，代码直接崩溃，<strong>问题出在默认的拷贝构造函数做的是浅拷贝，两个智能指针都持有一个new int资源，ptr2先析构释放了资源，到ptr1析构的时候，就成了delete野指针了，造成程序崩溃</strong>。所以这里引出来智能指针需要解决的两件事情：</p>
<ol>
<li>怎么解决智能指针的浅拷贝问题</li>
<li>多个智能指针指向同一个资源的时候，怎么保证资源只释放一次，而不是每个智能指针都释放一次，造成代码运行不可预期的严重后果</li>
</ol>
<p>我们一起看看C++库中提供的智能指针是怎么解决上面提到的问题的。</p>
<h3 id="2-3不带引用计数的智能指针"><a href="#2-3不带引用计数的智能指针" class="headerlink" title="2.3不带引用计数的智能指针"></a>2.3不带引用计数的智能指针</h3><p>C++库中提供的不带引用计数的智能指针主要包括：<strong>auto_ptr（C++库），scoped_ptr（C++11），unique_ptr(C++11)</strong>，下面一一进行介绍。</p>
<h4 id="1-auto-ptr"><a href="#1-auto-ptr" class="headerlink" title="1.auto_ptr"></a>1.auto_ptr</h4><p>先浏览一下auto_ptr的主要源码，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">auto_ptr</span></span><br><span class="line">	&#123;	<span class="comment">// wrap an object pointer to ensure destruction</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> _Ty element_type;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(_Ty * _Ptr = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">		: _Myptr(_Ptr)</span></span><br><span class="line"><span class="function">		&#123;</span>	<span class="comment">// construct from object pointer</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*这里是auto_ptr的拷贝构造函数，</span></span><br><span class="line"><span class="comment">	_Right.release()函数中，把_Right的_Myptr</span></span><br><span class="line"><span class="comment">	赋为nullptr，也就是换成当前auto_ptr持有资源地址</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">auto_ptr</span>(auto_ptr&amp; _Right) <span class="keyword">noexcept</span></span><br><span class="line">		: _Myptr(_Right.<span class="built_in">release</span>())</span><br><span class="line">		&#123;	<span class="comment">// construct by assuming pointer from _Right auto_ptr</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="function">_Ty * <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">		</span>&#123;	<span class="comment">// return wrapped pointer and give up ownership</span></span><br><span class="line">		_Ty * _Tmp = _Myptr;</span><br><span class="line">		_Myptr = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">return</span> (_Tmp);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	_Ty * _Myptr;	<span class="comment">// the wrapped object pointer</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从auto_ptr的源码可以看到，指向同一块内存的智能指针只有最新构造的一个auto_ptr智能指针持有资源，原来具有相同资源的的auto_ptr在新的aotu_ptr构造的时候都被赋nullptr了，不再管理资源，考虑如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	经过拷贝构造，p2指向了new int资源，</span></span><br><span class="line"><span class="comment">	p1现在为nullptr了，如果使用p1，相当于</span></span><br><span class="line"><span class="comment">	访问空指针了，很危险</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	auto_ptr&lt;<span class="type">int</span>&gt; p2 = p1;</span><br><span class="line">	*p1 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序，如果用户不了解auto_ptr的实现，代码就会出现严重的问题。记得曾经一个面试题问过“<strong>auto_ptr能不能使用在容器当中？</strong>”，看下面的代码描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;auto_ptr&lt;<span class="type">int</span>&gt;&gt; vec;</span><br><span class="line">	vec.<span class="built_in">push_back</span>(<span class="built_in">auto_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>)));</span><br><span class="line">	vec.<span class="built_in">push_back</span>(<span class="built_in">auto_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>)));</span><br><span class="line">	vec.<span class="built_in">push_back</span>(<span class="built_in">auto_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">30</span>)));</span><br><span class="line">	<span class="comment">// 这里可以打印出10</span></span><br><span class="line">	cout &lt;&lt; *vec[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	vector&lt;auto_ptr&lt;<span class="type">int</span>&gt;&gt; vec2 = vec;</span><br><span class="line">	<span class="comment">/* 这里由于上面做了vector容器的拷贝，相当于容器中</span></span><br><span class="line"><span class="comment">	的每一个元素都进行了拷贝构造，原来vec中的智能指针</span></span><br><span class="line"><span class="comment">	全部为nullptr了，再次访问就成访问空指针了，程序崩溃</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	cout &lt;&lt; *vec[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以不要在容器中使用auto_ptr，<strong>C++建议最好不要使用auto_ptr</strong>，除非应用场景非常简单。</p>
<p>【总结】：<strong>auto_ptr智能指针不带引用计数，那么它处理浅拷贝的问题，是直接把前面的auto_ptr都置为nullptr，只让最后一个auto_ptr持有资源。</strong>（也可以理解为这个指针会转交资源的管理权）</p>
<h4 id="2-scoped-ptr"><a href="#2-scoped-ptr" class="headerlink" title="2.scoped_ptr"></a>2.scoped_ptr</h4><p>先浏览一下scoped_ptr的源码，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">scoped_ptr</span> <span class="comment">// noncopyable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T * px;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	私有化拷贝构造函数和赋值函数，这样scoped_ptr的智能指针</span></span><br><span class="line"><span class="comment">	对象就不支持这两种操作，从根本上杜绝浅拷贝的发生</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="built_in">scoped_ptr</span>(scoped_ptr <span class="type">const</span> &amp;);</span><br><span class="line">    scoped_ptr &amp; <span class="keyword">operator</span>=(scoped_ptr <span class="type">const</span> &amp;);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">typedef</span> scoped_ptr&lt;T&gt; this_type;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	私有化逻辑比较运算符重载函数，不支持scoped_ptr的智能指针</span></span><br><span class="line"><span class="comment">	对象的比较操作</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>==( scoped_ptr <span class="type">const</span>&amp; ) <span class="type">const</span>;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>!=( scoped_ptr <span class="type">const</span>&amp; ) <span class="type">const</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T element_type;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_ptr</span><span class="params">( T * p = <span class="number">0</span> )</span>: px( p ) // never throws</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(BOOST_SP_ENABLE_DEBUG_HOOKS)</span></span><br><span class="line">        boost::<span class="built_in">sp_scalar_constructor_hook</span>( px );</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BOOST_NO_AUTO_PTR</span></span><br><span class="line">	<span class="comment">/*支持从auto_ptr构造一个scoped_ptr智能指针对象，</span></span><br><span class="line"><span class="comment">	但是auto_ptr因为调用release()函数，导致其内部指</span></span><br><span class="line"><span class="comment">	针为nullptr*/</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_ptr</span><span class="params">( std::auto_ptr&lt;T&gt; p )</span> BOOST_NOEXCEPT : px( p.release() )</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(BOOST_SP_ENABLE_DEBUG_HOOKS)</span></span><br><span class="line">        boost::<span class="built_in">sp_scalar_constructor_hook</span>( px );</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*析构函数，释放智能指针持有的资源*/</span></span><br><span class="line">    ~<span class="built_in">scoped_ptr</span>() <span class="comment">// never throws</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(BOOST_SP_ENABLE_DEBUG_HOOKS)</span></span><br><span class="line">        boost::<span class="built_in">sp_scalar_destructor_hook</span>( px );</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        boost::<span class="built_in">checked_delete</span>( px );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从scoped_ptr的源码可以看到，该智能指针由于私有化了拷贝构造函数和operator&#x3D;赋值函数，因此<strong>从根本上杜绝了智能指针浅拷贝的发生，所以scoped_ptr也是不能用在容器当中的，如果容器互相进行拷贝或者赋值，就会引起scoped_ptr对象的拷贝构造和赋值，这是不允许的，代码会提示编译错误</strong>。</p>
<p>也可以理解为他把拷贝构造和赋值重载设置为delete了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scoped_ptr</span>(<span class="type">const</span> scoped_ptr&lt;T&gt;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">scoped_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> scoped_ptr&lt;T&gt;&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<p>auto_ptr和scoped_ptr这一点上的区别，有些资料上用<strong>所有权</strong>的概念来描述，道理是相同的，<strong>auto_ptr可以任意转移资源的所有权，而scoped_ptr不会转移所有权</strong>（因为拷贝构造和赋值被禁止了）。</p>
<h4 id="3-unique-ptr"><a href="#3-unique-ptr" class="headerlink" title="3.unique_ptr"></a>3.unique_ptr</h4><p>先看看unique_ptr的部分源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>,</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">_Dx</span>&gt;	<span class="comment">// = default_delete&lt;_Ty&gt;</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">unique_ptr</span></span><br><span class="line">		: <span class="keyword">public</span> _Unique_ptr_base&lt;_Ty, _Dx&gt;</span><br><span class="line">	&#123;	<span class="comment">// non-copyable pointer to an object</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> _Unique_ptr_base&lt;_Ty, _Dx&gt; _Mybase;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> _Mybase::pointer pointer;</span><br><span class="line">	<span class="keyword">typedef</span> _Ty element_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Dx deleter_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*提供了右值引用的拷贝构造函数*/</span></span><br><span class="line">	<span class="built_in">unique_ptr</span>(unique_ptr&amp;&amp; _Right) <span class="keyword">noexcept</span></span><br><span class="line">		: _Mybase(_Right.<span class="built_in">release</span>(),</span><br><span class="line">			_STD forward&lt;_Dx&gt;(_Right.<span class="built_in">get_deleter</span>()))</span><br><span class="line">		&#123;	<span class="comment">// construct by moving _Right</span></span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*提供了右值引用的operator=赋值重载函数*/</span></span><br><span class="line">	unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&amp;&amp; _Right) <span class="keyword">noexcept</span></span><br><span class="line">		&#123;	<span class="comment">// assign by moving _Right</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != _STD <span class="built_in">addressof</span>(_Right))</span><br><span class="line">			&#123;	<span class="comment">// different, do the move</span></span><br><span class="line">			<span class="built_in">reset</span>(_Right.<span class="built_in">release</span>());</span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">get_deleter</span>() = _STD forward&lt;_Dx&gt;(_Right.<span class="built_in">get_deleter</span>());</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	交换两个unique_ptr智能指针对象的底层指针</span></span><br><span class="line"><span class="comment">	和删除器</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unique_ptr&amp; _Right)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">		</span>&#123;	<span class="comment">// swap elements</span></span><br><span class="line">		_Swap_adl(<span class="keyword">this</span>-&gt;_Myptr(), _Right._Myptr());</span><br><span class="line">		_Swap_adl(<span class="keyword">this</span>-&gt;<span class="built_in">get_deleter</span>(), _Right.<span class="built_in">get_deleter</span>());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*通过自定义删除器释放资源*/</span></span><br><span class="line">	~<span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span></span><br><span class="line">		&#123;	<span class="comment">// destroy the object</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">get</span>() != <span class="built_in">pointer</span>())</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">get_deleter</span>()(<span class="built_in">get</span>());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*unique_ptr提供-&gt;运算符的重载函数*/</span></span><br><span class="line">	_NODISCARD pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">		&#123;	<span class="comment">// return pointer to class object</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span>-&gt;_Myptr());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*返回智能指针对象底层管理的指针*/</span></span><br><span class="line">	<span class="function">_NODISCARD pointer <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">		</span>&#123;	<span class="comment">// return pointer to object</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span>-&gt;_Myptr());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*提供bool类型的重载，使unique_ptr对象可以</span></span><br><span class="line"><span class="comment">	直接使用在逻辑语句当中，比如if,for,while等*/</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">		</span>&#123;	<span class="comment">// test for non-null pointer</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="built_in">get</span>() != <span class="built_in">pointer</span>());</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*功能和auto_ptr的release函数功能相同，最终也是只有一个unique_ptr指针指向资源*/</span></span><br><span class="line">	<span class="function">pointer <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">		</span>&#123;	<span class="comment">// yield ownership of pointer</span></span><br><span class="line">		pointer _Ans = <span class="built_in">get</span>();</span><br><span class="line">		<span class="keyword">this</span>-&gt;_Myptr() = <span class="built_in">pointer</span>();</span><br><span class="line">		<span class="keyword">return</span> (_Ans);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*把unique_ptr原来的旧资源释放，重置新的资源_Ptr*/</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(pointer _Ptr = pointer())</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">		</span>&#123;	<span class="comment">// establish new pointer</span></span><br><span class="line">		pointer _Old = <span class="built_in">get</span>();</span><br><span class="line">		<span class="keyword">this</span>-&gt;_Myptr() = _Ptr;</span><br><span class="line">		<span class="keyword">if</span> (_Old != <span class="built_in">pointer</span>())</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">get_deleter</span>()(_Old);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	删除了unique_ptr的拷贝构造和operator=赋值函数，</span></span><br><span class="line"><span class="comment">	因此不能做unique_ptr智能指针对象的拷贝构造和</span></span><br><span class="line"><span class="comment">	赋值，防止浅拷贝的发生</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p>从上面看到，unique_ptr有一点和scoped_ptr做的一样，就是<strong>去掉了拷贝构造函数和operator&#x3D;赋值重载函数，禁止用户对unique_ptr进行显示的拷贝构造和赋值，防止智能指针浅拷贝问题的发生</strong>。</p>
<p><strong>但是unique_ptr提供了带右值引用参数的拷贝构造和赋值</strong>，也就是说，unique_ptr智能指针可以通过右值引用进行拷贝构造和赋值操作，或者在产生unique_ptr临时对象的地方，如把unique_ptr作为函数的返回值时，示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = std::<span class="built_in">move</span>(ptr); <span class="comment">// 使用了右值引用的拷贝构造</span></span><br><span class="line">ptr2 = std::<span class="built_in">move</span>(ptr); <span class="comment">// 使用了右值引用的operator=赋值重载函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">test_uniqueptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> ptr1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	此处调用test_uniqueptr函数，在return ptr1代码</span></span><br><span class="line"><span class="comment">	处，调用右值引用的拷贝构造函数，由ptr1拷贝构造ptr</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	unique_ptr&lt;<span class="type">int</span>&gt; ptr = <span class="built_in">test_uniqueptr</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unique_ptr也是auto_ptr一样，只有最后一个指针有资源管理权，但这个是通过move实现的，不是将原来的指针置为空，原来的unique_ptr也不能管理资源，只有最新的一个可以。</p>
<p>unique_ptr还提供了reset重置资源，swap交换资源等函数，也经常会使用到。<strong>可以看到，unique_ptr从名字就可以看出来，最终也是只能有一个该智能指针引用资源，因此建议在使用不带引用计数的智能指针时，可以优先选择unique_ptr智能指针</strong>。</p>
<h4 id="4-三个指针对比"><a href="#4-三个指针对比" class="headerlink" title="4.三个指针对比"></a>4.三个指针对比</h4><table>
<thead>
<tr>
<th></th>
<th>有没有拷贝和赋值重载</th>
<th>哪个指针管理内存资源</th>
<th>可以赋值吗</th>
</tr>
</thead>
<tbody><tr>
<td>auto</td>
<td>有，并且可用</td>
<td>指向同一块内存的指针只有最新的指针才能管理内存</td>
<td>可以，但是原来的指针被赋值为nullptr</td>
</tr>
<tr>
<td>scoped</td>
<td>有，但是被设为私有，不能用</td>
<td>指向同一块内存的指针只有最新的指针才能管理内存</td>
<td>不可以，直接是不允许的行为</td>
</tr>
<tr>
<td>unique</td>
<td>有，但是被设置为delete了，不能用</td>
<td>指向同一块内存的指针只有最新的指针才能管理内存</td>
<td>不可以用左值赋值，但可以通过move转为右值赋值</td>
</tr>
</tbody></table>
<h3 id="2-4带引用计数的智能指针shared-ptr、weak-ptr"><a href="#2-4带引用计数的智能指针shared-ptr、weak-ptr" class="headerlink" title="2.4带引用计数的智能指针shared_ptr、weak_ptr"></a>2.4带引用计数的智能指针shared_ptr、weak_ptr</h3><p>这里主要介绍shared_ptr和weak_ptr两个智能指针，<strong>什么是带引用计数的智能指针</strong>？当允许多个智能指针指向同一个资源的时候，<strong>每一个智能指针都会给资源的引用计数加1，当一个智能指针析构时，同样会使资源的引用计数减1，这样最后一个智能指针把资源的引用计数从1减到0时，就说明该资源可以释放了</strong>，由最后一个智能指针的析构函数来处理资源的释放问题，这就是引用计数的概念。</p>
<p>要对资源的引用个数进行计数，那么大家知道，<strong>对于整数的++或者- -操作，它并不是线程安全的操作，因此shared_ptr和weak_ptr底层的引用计数已经通过CAS操作，保证了引用计数加减的原子特性，因此shared_ptr和weak_ptr本身就是线程安全的带引用计数的智能指针</strong>。</p>
<p>曾经有一道面试的问题这样问“<strong>shared_ptr智能指针的引用计数在哪里存放？</strong>”，当然，这个问题需要看shared_ptr的源码了，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	下面这两个是shared_ptr的成员变量，_Ptr是指向内存资源的指针，_Rep是</span></span><br><span class="line"><span class="comment">	指向new出来的计数器对象的指针，该计数器对象包含了资源的一个引用计数器count</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	element_type * _Ptr&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">	_Ref_count_base * _Rep&#123;<span class="literal">nullptr</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>因此，<strong>shared_ptr智能指针的资源引用计数器在内存的heap堆上</strong>。shared_ptr一般被称作<strong>强智能指针</strong>，weak_ptr被称作<strong>弱智能指针</strong>，它们有下边两个非常重要的应用场景需要注意。</p>
<p>强：可以改变资源的引用计数</p>
<p>弱：不能改变资源的引用计数</p>
<h3 id="2-5智能指针的交叉引用（循环引用）问题"><a href="#2-5智能指针的交叉引用（循环引用）问题" class="headerlink" title="2.5智能指针的交叉引用（循环引用）问题"></a>2.5智能指针的交叉引用（循环引用）问题</h3><p>请看下面的这个代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前置声明类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	shared_ptr&lt;B&gt; _ptrb; <span class="comment">// 指向B对象的智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	shared_ptr&lt;A&gt; _ptra; <span class="comment">// 指向A对象的智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">shared_ptr&lt;A&gt; <span class="title">ptra</span><span class="params">(<span class="keyword">new</span> A())</span></span>;<span class="comment">// ptra指向A对象，A的引用计数为1</span></span><br><span class="line">	<span class="function">shared_ptr&lt;B&gt; <span class="title">ptrb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;<span class="comment">// ptrb指向B对象，B的引用计数为1</span></span><br><span class="line">	ptra-&gt;_ptrb = ptrb;<span class="comment">// A对象的成员变量_ptrb也指向B对象，B的引用计数为2</span></span><br><span class="line">	ptrb-&gt;_ptra = ptra;<span class="comment">// B对象的成员变量_ptra也指向A对象，A的引用计数为2</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; ptra.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 打印A的引用计数结果:2</span></span><br><span class="line">	cout &lt;&lt; ptrb.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 打印B的引用计数结果:2</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	出main函数作用域，ptra和ptrb两个局部对象析构，分别给A对象和</span></span><br><span class="line"><span class="comment">	B对象的引用计数从2减到1，达不到释放A和B的条件（释放的条件是</span></span><br><span class="line"><span class="comment">	A和B的引用计数为0），因此造成两个new出来的A和B对象无法释放，</span></span><br><span class="line"><span class="comment">	导致内存泄露，这个问题就是“强智能指针的交叉引用(循环引用)问题”</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241012100647629.png" alt="image-20241012100647629"></p>
<p>代码打印结果：<br>A()<br>B()<br>2<br>2<br>可以看到，A和B对象并没有进行析构，通过上面的代码示例，能够看出来“交叉引用”的问题所在，就是对象无法析构，<strong>资源无法释放</strong>，那怎么解决这个问题呢？请注意强弱智能指针的一个重要应用规则：<strong>定义对象时，用强智能指针shared_ptr，在其它地方引用对象时，使用弱智能指针weak_ptr</strong>。</p>
<p><code>注解：</code>这句话的意思是，在创建或分配一个对象时，应该使用<code>std::shared_ptr</code>来管理这个对象的生命周期。而在需要引用这个对象，但又不想拥有它（即不想影响它的生命周期）的地方，应该使用<code>std::weak_ptr</code>。</p>
<p>在这里，“引用对象”指的是在代码中创建或获取一个指向某个对象的引用或指针，以便能够访问该对象的成员（属性或方法）。</p>
<p><strong>弱智能指针weak_ptr区别于shared_ptr之处在于</strong>：</p>
<ol>
<li>weak_ptr不会改变资源的引用计数，只是一个观察者的角色，通过观察shared_ptr来判定资源是否存在</li>
<li>weak_ptr持有的引用计数，不是资源的引用计数，而是同一个资源的观察者的计数</li>
<li>weak_ptr没有提供常用的指针操作，无法直接访问资源，需要先通过lock方法提升为shared_ptr强智能指针，才能访问资源</li>
</ol>
<p>那么上面的代码怎么修改，<strong>也就是如何解决带引用计数的智能指针的交叉引用问题</strong>，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前置声明类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	weak_ptr&lt;B&gt; _ptrb; <span class="comment">// 指向B对象的弱智能指针。引用对象时，用弱智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	weak_ptr&lt;A&gt; _ptra; <span class="comment">// 指向A对象的弱智能指针。引用对象时，用弱智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义对象时，用强智能指针</span></span><br><span class="line">	<span class="function">shared_ptr&lt;A&gt; <span class="title">ptra</span><span class="params">(<span class="keyword">new</span> A())</span></span>;<span class="comment">// ptra指向A对象，A的引用计数为1</span></span><br><span class="line">	<span class="function">shared_ptr&lt;B&gt; <span class="title">ptrb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;<span class="comment">// ptrb指向B对象，B的引用计数为1</span></span><br><span class="line">	<span class="comment">// A对象的成员变量_ptrb也指向B对象，B的引用计数为1，因为是弱智能指针，引用计数没有改变</span></span><br><span class="line">	ptra-&gt;_ptrb = ptrb;</span><br><span class="line">	<span class="comment">// B对象的成员变量_ptra也指向A对象，A的引用计数为1，因为是弱智能指针，引用计数没有改变</span></span><br><span class="line">	ptrb-&gt;_ptra = ptra;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; ptra.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 打印结果:1</span></span><br><span class="line">	cout &lt;&lt; ptrb.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 打印结果:1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	出main函数作用域，ptra和ptrb两个局部对象析构，分别给A对象和</span></span><br><span class="line"><span class="comment">	B对象的引用计数从1减到0，达到释放A和B的条件，因此new出来的A和B对象</span></span><br><span class="line"><span class="comment">	被析构掉，解决了“强智能指针的交叉引用(循环引用)问题”</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码打印如下：<br>A()<br>B()<br>1<br>1<br>~B()<br>~A()<br>可以看到，A和B对象正常析构，问题解决！</p>
<p><strong>weak没有重载*和-&gt;运算符，不能完全替代裸指针的功能</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前置声明类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	weak_ptr&lt;B&gt; _ptrb; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//假设是一个非常好的方法</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	weak_ptr&lt;A&gt; _ptra; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//_ptra-&gt;testA(); weak没有重载*和-&gt;运算符，不能完全替代裸指针的功能</span></span><br><span class="line">        <span class="comment">//如果想要调用A中那个非常好的方法/函数</span></span><br><span class="line">        <span class="comment">//得用lock先把弱指针提升为强指针,资源没了就提升失败返回nullptr，成功了能用了</span></span><br><span class="line">        <span class="comment">//之后就可以用强指针的功能了，但是引用计数也会+1</span></span><br><span class="line">        <span class="comment">//这个强指针由弱指针创建，提升完以后弱指针依然存在</span></span><br><span class="line">        shared_ptr&lt;A&gt; ps=_ptra.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(ps!=<span class="literal">nullptr</span>)</span><br><span class="line">            ps-&gt;<span class="built_in">testA</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">shared_ptr&lt;A&gt; <span class="title">ptra</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">	<span class="function">shared_ptr&lt;B&gt; <span class="title">ptrb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">	ptra-&gt;_ptrb = ptrb;</span><br><span class="line">	ptrb-&gt;_ptra = ptra;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; ptra.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 打印结果:1</span></span><br><span class="line">	cout &lt;&lt; ptrb.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 打印结果:1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6多线程访问共享对象问题"><a href="#2-6多线程访问共享对象问题" class="headerlink" title="2.6多线程访问共享对象问题"></a>2.6多线程访问共享对象问题</h3><p>有一个用C++写的开源网络库，muduo库，作者陈硕，大家可以在网上下载到muduo的源代码，该源码中对于智能指针的应用非常优秀，其中<strong>借助shared_ptr和weak_ptr解决了这样一个问题，多线程访问共享对象的线程安全问题</strong>，解释如下：线程A和线程B访问一个共享的对象，如果线程A正在析构这个对象的时候，线程B又要调用该共享对象的成员方法，此时可能线程A已经把对象析构完了，线程B再去访问该对象，就会发生不可预期的错误。</p>
<p>先看如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造Test对象，_ptr指向一块int堆内存，初始值是20</span></span><br><span class="line">	<span class="built_in">Test</span>() :_ptr(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>)) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 析构Test对象，释放_ptr指向的堆内存</span></span><br><span class="line">	~<span class="built_in">Test</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> _ptr;</span><br><span class="line">		_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 该show会在另外一个线程中被执行</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; *_ptr &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> *<span class="keyword">volatile</span> _ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadProc</span><span class="params">(Test *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 睡眠两秒，此时main主线程已经把Test对象给delete析构掉了</span></span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	此时当前线程访问了main线程已经析构的共享对象，结果未知，隐含bug。</span></span><br><span class="line"><span class="comment">	此时通过p指针想访问Test对象，需要判断Test对象是否存活，如果Test对象</span></span><br><span class="line"><span class="comment">	存活，调用show方法没有问题；如果Test对象已经析构，调用show有问题！</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	p-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 在堆上定义共享对象</span></span><br><span class="line">	Test *p = <span class="keyword">new</span> <span class="built_in">Test</span>();</span><br><span class="line">	<span class="comment">// 使用C++11的线程类，开启一个新线程，并传入共享对象的地址p</span></span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(threadProc, p)</span></span>;</span><br><span class="line">	<span class="comment">// 在main线程中析构Test共享对象</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="comment">// 等待子线程运行结束</span></span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的代码，发现在main主线程已经delete析构Test对象以后，子线程threadProc再去访问Test对象的show方法，<em><em>无法打印出</em>_ptr的值20</em>*。可以用shared_ptr和weak_ptr来解决多线程访问共享对象的线程安全问题，上面代码修改如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造Test对象，_ptr指向一块int堆内存，初始值是20</span></span><br><span class="line">	<span class="built_in">Test</span>() :_ptr(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>)) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 析构Test对象，释放_ptr指向的堆内存</span></span><br><span class="line">	~<span class="built_in">Test</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> _ptr;</span><br><span class="line">		_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 该show会在另外一个线程中被执行</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; *_ptr &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> *<span class="keyword">volatile</span> _ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadProc</span><span class="params">(weak_ptr&lt;Test&gt; pw)</span> <span class="comment">// 通过弱智能指针观察强智能指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 睡眠两秒</span></span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	如果想访问对象的方法，先通过pw的lock方法进行提升操作，把weak_ptr提升</span></span><br><span class="line"><span class="comment">	为shared_ptr强智能指针，提升过程中，是通过检测它所观察的强智能指针保存</span></span><br><span class="line"><span class="comment">	的Test对象的引用计数，来判定Test对象是否存活，ps如果为nullptr，说明Test对象</span></span><br><span class="line"><span class="comment">	已经析构，不能再访问；如果ps!=nullptr，则可以正常访问Test对象的方法。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	shared_ptr&lt;Test&gt; ps = pw.<span class="built_in">lock</span>();</span><br><span class="line">	<span class="keyword">if</span> (ps != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ps-&gt;<span class="built_in">show</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 在堆上定义共享对象</span></span><br><span class="line">	<span class="function">shared_ptr&lt;Test&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Test)</span></span>;</span><br><span class="line">	<span class="comment">// 使用C++11的线程，开启一个新线程，并传入共享对象的弱智能指针</span></span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(threadProc, weak_ptr&lt;Test&gt;(p))</span></span>;</span><br><span class="line">	<span class="comment">// 在main线程中析构Test共享对象</span></span><br><span class="line">	<span class="comment">// 等待子线程运行结束</span></span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的代码，show方法可以打印出20，<strong>因为main线程调用了t1.join()方法等待子线程结束，此时pw通过lock提升为ps成功</strong>，见上面代码示例。</p>
<p>如果设置t1为分离线程，让main主线程结束，p智能指针析构，进而把Test对象析构，此时show方法已经不会被调用，<strong>因为在threadProc方法中，pw提升到ps时，lock方法判定Test对象已经析构，提升失败</strong>！main函数代码可以如下修改测试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 在堆上定义共享对象</span></span><br><span class="line">	<span class="function">shared_ptr&lt;Test&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Test)</span></span>;</span><br><span class="line">	<span class="comment">// 使用C++11的线程，开启一个新线程，并传入共享对象的弱智能指针</span></span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(threadProc, weak_ptr&lt;Test&gt;(p))</span></span>;</span><br><span class="line">	<span class="comment">// 在main线程中析构Test共享对象</span></span><br><span class="line">	<span class="comment">// 设置子线程分离</span></span><br><span class="line">	t<span class="number">1.</span><span class="built_in">detach</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该main函数运行后，最终的threadProc中，show方法不会被执行到。<strong>以上是在多线程中访问共享对象时，对shared_ptr和weak_ptr的一个典型应用</strong>。</p>
<h3 id="2-7自定义删除器"><a href="#2-7自定义删除器" class="headerlink" title="2.7自定义删除器"></a>2.7自定义删除器</h3><p>我们经常用智能指针管理的资源是堆内存，当智能指针出作用域的时候，在其析构函数中会delete释放堆内存资源，但是除了堆内存资源，智能指针还可以管理其它资源，比如打开的文件，此时对于文件指针的关闭，就不能用delete了，这时我们需要自定义智能指针释放资源的方式，先看看unique_ptr智能指针的析构函数代码，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span></span><br><span class="line">&#123;	<span class="comment">// destroy the object</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">get</span>() != <span class="built_in">pointer</span>())</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">get_deleter</span>()(<span class="built_in">get</span>()); <span class="comment">// 这里获取底层的删除器，进行函数对象的调用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从unique_ptr的析构函数可以看到，如果要实现一个自定义的删除器，实际上就是定义一个函数对象（重载的调用运算符（））而已，示例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDeletor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(T *ptr)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;  </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;call MyDeletor.operator()&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">delete</span>[]ptr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFileDeletor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(T *ptr)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;call MyFileDeletor.operator()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    	<span class="built_in">fclose</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>, MyDeletor&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>]); <span class="comment">// delete []ptr;</span></span><br><span class="line">    unique_ptr&lt;FILE, MyFileDeletor&lt;FILE&gt;&gt; <span class="built_in">ptr2</span> (<span class="built_in">fopen</span>(<span class="string">&quot;data,txt&quot;</span>, <span class="string">&quot;w&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然这种方式需要定义额外的函数对象类型，不推荐，可以用C++11提供的函数对象function和lambda表达式更好的处理自定义删除器，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>, function&lt;<span class="type">void</span>(<span class="type">int</span>*)&gt;&gt; <span class="built_in">ptrl</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>],</span><br><span class="line">    	[] (<span class="type">int</span> *p) -&gt;<span class="type">void</span> &#123;</span><br><span class="line">    		cout &lt;&lt; <span class="string">&quot;call lambda release new int[100]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    		<span class="keyword">delete</span> []p;</span><br><span class="line">    	&#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    unique_ptr&lt;FILE, function&lt;<span class="type">void</span>(FILE*)&gt;&gt; <span class="built_in">ptr2</span>(<span class="built_in">fopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;w&quot;</span>),</span><br><span class="line">    	[] (FILE *p) -&gt;<span class="type">void</span> &#123;</span><br><span class="line">    		cout &lt;&lt; <span class="string">&quot;call lambda release new fopen&quot;</span> &lt;&lt; endl;</span><br><span class="line">    		<span class="built_in">fclose</span>(p);</span><br><span class="line">    	&#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、绑定器和函数对象、lambda表达式"><a href="#三、绑定器和函数对象、lambda表达式" class="headerlink" title="三、绑定器和函数对象、lambda表达式"></a>三、绑定器和函数对象、lambda表达式</h2><h3 id="3-1模板的完全特例化和非完全（部分）特例化"><a href="#3-1模板的完全特例化和非完全（部分）特例化" class="headerlink" title="3.1模板的完全特例化和非完全（部分）特例化"></a>3.1模板的完全特例化和非完全（部分）特例化</h3><h4 id="1-完全特例化和非完全（部分）特例化"><a href="#1-完全特例化和非完全（部分）特例化" class="headerlink" title="1.完全特例化和非完全（部分）特例化"></a>1.完全特例化和非完全（部分）特例化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Vector</span> () &#123; cout &lt;&lt; <span class="string">&quot;call Vector template init&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 下面这个是对char*类型提供的完全特例化版本 </span></span><br><span class="line">    <span class="comment">//1.必须得有上面那个才能提供下面这个，光下面这个也不行</span></span><br><span class="line">    <span class="comment">//2. &quot;&lt;&gt;&quot;这是语法不能省略</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&lt;<span class="type">char</span>*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Vector</span> () &#123; cout &lt;&lt; <span class="string">&quot;call Vector&lt;char*&gt; init&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对指针类型提供的部分特例化版本 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//我们并不知道是哪个类型的指针，所以还是要写typename T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Vector</span> () &#123; cout &lt;&lt; <span class="string">&quot;call Vector&lt;T*&gt; init&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对函数指针类型（有返回值，有两个形参变量的函数）提供的部分特例化版本 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> A1,<span class="keyword">typename</span> A2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&lt;<span class="built_in">R</span>(*)(A1,A2)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Vector</span> () &#123; cout &lt;&lt; <span class="string">&quot;call Vector&lt;R(*)(A1,A2)&gt; init&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//完全特例化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&lt;<span class="built_in">int</span>(*)(<span class="type">int</span>,<span class="type">int</span>)&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//部分特例化更灵活一点</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//函数类型部分特例化    </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> A1,<span class="keyword">typename</span> A2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&lt;<span class="built_in">R</span>(A1,A2)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Vector</span> () &#123; cout &lt;&lt; <span class="string">&quot;call Vector&lt;R(A1,A2)&gt; init&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a+b;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector&lt;<span class="type">int</span>&gt; vec1;<span class="comment">//从原模板进行实例化</span></span><br><span class="line">    Vector&lt;<span class="type">char</span> *&gt; vec2;<span class="comment">//使用完全特例化版本</span></span><br><span class="line">    Vector&lt;<span class="type">int</span> *&gt; vec3;<span class="comment">//使用针对指针的部分特例化版本</span></span><br><span class="line">    Vector&lt;<span class="built_in">int</span>(*)(<span class="type">int</span>,<span class="type">int</span>)&gt;vec4;<span class="comment">//使用针对指针的特例化版本 这个类型相当于上面sum函数类型（函数指针），只是同一个类型，不是指sum函数</span></span><br><span class="line">    Vector&lt;<span class="built_in">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;vec4;<span class="comment">//这是函数类型，不是函数指针类型，匹配的是函数类型的模板进行实例化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数类型</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PFUNC1)</span> <span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">    PFUNC1 pfunc1 = sum;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">pfunc1</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//函数指针类型</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="type">int</span> <span class="title">PFUNC2</span> <span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">    PFUNC2 *pfunc2 = sum;</span><br><span class="line">    cout &lt;&lt; (*pfunc2)(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意区分两者</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看有没有完全特例化，没有看部分特例化，最后看原模板</p>
<h4 id="2-模板的实参推演"><a href="#2-模板的实参推演" class="headerlink" title="2.模板的实参推演"></a>2.模板的实参推演</h4><p>typeid().name用来得到传入参数的类型</p>
<p>向上面一样，我们如果得到的T是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*)(<span class="type">int</span>,<span class="type">int</span>)或者<span class="built_in">int</span>(<span class="type">int</span>,<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>那完全没什么作用，就只是知道了，而现在可以通过实参推演，获得各个部分是什么类型，以下面代码为例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得普通类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> A1,<span class="keyword">typename</span> A2&gt;<span class="comment">//指针对函数指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(R (*a)(A1,A2))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">typeid</span>(R).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">typeid</span>(A1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">typeid</span>(A2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//int,int,int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T,<span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt;<span class="comment">//针对类成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(R(T::*a)(A1, A2))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">typeid</span>(R).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">typeid</span>(A1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">typeid</span>(A2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//int,class test,int,int</span></span><br><span class="line"><span class="comment">//可以用这些进行变量定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">	<span class="built_in">func</span>(sum);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">func2</span>(sum);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">func3</span>(&amp;test::sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241012182940976.png" alt="image-20241012182940976"></p>
<p>从结果可以看出，我们可以获得各个类型</p>
<h3 id="3-2-C-STL中的绑定器"><a href="#3-2-C-STL中的绑定器" class="headerlink" title="3.2 C++ STL中的绑定器"></a>3.2 C++ STL中的绑定器</h3><p><strong>bind1st</strong>和<strong>bind2nd</strong>是C++标准库中的两个函数适配器，它们的主要作用是将一个<strong>二元函数对象</strong>（即接受两个参数的函数对象）转换为一元函数对象（即接受一个参数的函数对象）。这两个函数适配器的区别主要在于它们绑定的是二元函数对象的哪一个参数。</p>
<p><code>只能用于二元</code></p>
<h4 id="bind1st"><a href="#bind1st" class="headerlink" title="bind1st"></a>bind1st</h4><ul>
<li><strong>功能</strong>：bind1st函数接受一个二元函数和一个值，返回一个新的函数对象。这个新的函数对象将二元函数的第一个参数绑定为给定的值，因此调用时只需要提供第二个参数。</li>
<li><strong>使用场景</strong>：当你希望将一个二元函数的第一个参数固定为某个值时，可以使用bind1st。这样，你就可以得到一个一元函数，其行为类似于原二元函数但第一个参数已被绑定。</li>
</ul>
<h4 id="bind2nd"><a href="#bind2nd" class="headerlink" title="bind2nd"></a>bind2nd</h4><ul>
<li><strong>功能</strong>：与bind1st类似，bind2nd函数也接受一个二元函数和一个值，但返回的新函数对象将二元函数的第二个参数绑定为给定的值。因此，调用时只需要提供第一个参数。</li>
<li><strong>使用场景</strong>：当你希望将一个二元函数的第二个参数固定为某个值时，可以使用bind2nd。这样，你也可以得到一个一元函数，但其行为是原二元函数且第二个参数已被绑定。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printvec</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> c : v)</span><br><span class="line">		cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printvec</span>(vec);</span><br><span class="line">	<span class="comment">//从小到大</span></span><br><span class="line">	<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printvec</span>(vec);</span><br><span class="line">	<span class="comment">//从大到小</span></span><br><span class="line">	<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">	<span class="built_in">printvec</span>(vec);</span><br><span class="line">	<span class="comment">//greater a&gt;b 从大到小</span></span><br><span class="line">	<span class="comment">//less a&lt;b 从小到大</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*bind绑定器</span></span><br><span class="line"><span class="comment">	把70按顺序插入到vec容器中 找第一个小于70的数字，那只传入一个参数，就没办法用gerater或者less了</span></span><br><span class="line"><span class="comment">	所以可以用绑定器 绑定器 + 二元函数对象 =&gt; 一元函数对象</span></span><br><span class="line"><span class="comment">	bind1st：+ greater bool operator()(70,const _Ty&amp; _Right)</span></span><br><span class="line"><span class="comment">	bind2nd：+ less bool operator()(const _Ty&amp; _Left,70)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">auto</span> it1 = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">bind1st</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">70</span>));</span><br><span class="line">	<span class="keyword">if</span> (it1 != vec.<span class="built_in">end</span>())</span><br><span class="line">		vec.<span class="built_in">insert</span>(it1, <span class="number">70</span>);</span><br><span class="line">	<span class="built_in">printvec</span>(vec);</span><br><span class="line">	<span class="keyword">auto</span> it2 = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">60</span>));</span><br><span class="line">	<span class="keyword">if</span> (it2 != vec.<span class="built_in">end</span>())</span><br><span class="line">		vec.<span class="built_in">insert</span>(it2, <span class="number">60</span>);</span><br><span class="line">	<span class="built_in">printvec</span>(vec);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自己实现一个bind1st"><a href="#自己实现一个bind1st" class="headerlink" title="自己实现一个bind1st"></a>自己实现一个bind1st</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> Compare&gt;</span></span><br><span class="line"><span class="function">Iterator <span class="title">my_find_if</span><span class="params">(Iterator first, Iterator last, Compare comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; first++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">comp</span>(*first))<span class="comment">//comp.operator()(*fist) comp的()重载函数传入参数为*first</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> first;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_mybind1st</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	_mybind1st(Compare comp,T val):_comp(comp),_val(val)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; second)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _comp(_val, second);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Compare _comp;</span><br><span class="line">	T _val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare,<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">_mybind1st&lt;Compare,T&gt; <span class="title">mybind1st</span><span class="params">(Compare comp, <span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _mybind1st&lt;Compare, T&gt;(comp, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printvec</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> c : v)</span><br><span class="line">		cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">		vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printvec</span>(vec);</span><br><span class="line">	<span class="comment">//从小到大</span></span><br><span class="line">	<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printvec</span>(vec);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> it1 = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">mybind1st</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">70</span>));</span><br><span class="line">	<span class="keyword">if</span> (it1 != vec.<span class="built_in">end</span>())</span><br><span class="line">		vec.<span class="built_in">insert</span>(it1, <span class="number">70</span>);</span><br><span class="line">	<span class="built_in">printvec</span>(vec);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过程说明：</p>
<ol>
<li><strong>创建 <code>_mybind1st</code> 对象</strong>：<br>当调用 <code>mybind1st(greater&lt;int&gt;(), 70)</code> 时，会创建一个 <code>_mybind1st&lt;greater&lt;int&gt;, int&gt;</code> 类型的临时对象。这个对象内部存储了 <code>greater&lt;int&gt;</code> 的一个实例（作为 <code>_comp</code> 成员变量）和整数 <code>70</code>（作为 <code>_val</code> 成员变量）。</li>
<li><strong>将 <code>_mybind1st</code> 对象传递给 <code>my_find_if</code></strong>：<br>然后，这个 <code>_mybind1st</code> 对象被传递给 <code>my_find_if</code> 函数作为 <code>comp</code> 参数。</li>
<li><strong>在 <code>my_find_if</code> 中调用 <code>comp(*first)</code></strong>：<br>在 <code>my_find_if</code> 的循环中，当调用 <code>comp(*first)</code> 时，实际上是在调用 <code>_mybind1st</code> 对象的 <code>operator()</code> 成员函数。这是因为 <code>_mybind1st</code> 对象是一个函数对象，它重载了 <code>operator()</code> 以使其表现得像一个函数。</li>
<li><strong><code>_mybind1st</code> 的 <code>operator()</code> 实现</strong>：<br>在 <code>_mybind1st</code> 的 <code>operator()</code> 中，代码是 <code>return _comp(_val, second);</code>。这里，<code>_comp</code> 是存储的 <code>greater&lt;int&gt;</code> 对象，<code>_val</code> 是 <code>70</code>，而 <code>second</code> 是 <code>*first</code>（即当前正在检查的元素）。因此，这个调用实际上是在检查当前元素 <code>*first</code> 是否小于 <code>70</code>（因为 <code>greater&lt;int&gt;</code> 的 <code>operator()</code> 检查第一个参数是否大于第二个参数，而这里我们是在用 <code>_val</code>（即 <code>70</code>）作为第一个参数，<code>*first</code> 作为第二个参数）。</li>
</ol>
<p>补充内容：</p>
<p><code>greater&lt;int&gt;</code>是C++标准库中的一个模板类，用于表示两个整数之间的“大于”关系。当实例化<code>greater&lt;int&gt;</code>时，会得到一个函数对象，该函数对象重载了<code>operator()</code>，接受两个<code>int</code>类型的参数，并返回第一个参数是否大于第二个参数的布尔值。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">greater&lt;<span class="type">int</span>&gt; comp;  </span><br><span class="line"><span class="type">bool</span> result = <span class="built_in">comp</span>(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// result 为 true，因为 5 &gt; 3</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-C-11从Boost库中引入了bind和function函数对象机制"><a href="#3-3-C-11从Boost库中引入了bind和function函数对象机制" class="headerlink" title="3.3 C++11从Boost库中引入了bind和function函数对象机制"></a>3.3 C++11从Boost库中引入了bind和function函数对象机制</h3><h4 id="1-function函数对象类型的应用示例（function基础）"><a href="#1-function函数对象类型的应用示例（function基础）" class="headerlink" title="1.function函数对象类型的应用示例（function基础）"></a>1.function函数对象类型的应用示例（function基础）</h4><p>绑定器，函数对象，lambda表达式 他们只能在一条语句中使用</p>
<p><code>function作用：</code>把上面这三个的类型留下来，说得更清楚点就是再给他们一个名字然后方便之后<strong>通过调用给的名字来使用函数对象或者lambda的功能</strong>。</p>
<p><code>function基础：</code></p>
<p>1.用函数类型实例化function<br>2.通过function调用operator（）函数的时候，需要根据函数类型传入相应的参数</p>
<p>具体实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello2</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">hello2</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//从function的类模板定义处，看到希望用一个函数类型实例化function</span></span><br><span class="line"></span><br><span class="line">	function&lt;<span class="type">void</span>()&gt; func1 = hello1;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.func1.operator() =&gt; hello1 先调用func1的()重载函数，然后调用包装的hello1</span></span><br><span class="line">	<span class="built_in">func1</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.人原来有参数，你写的时候就要加上参数，传入的时候也要传入</span></span><br><span class="line">	function&lt;<span class="type">void</span>(string)&gt; func2 = hello2;</span><br><span class="line">	<span class="built_in">func2</span>(<span class="string">&quot;hello hello2&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//有返回值的</span></span><br><span class="line">	function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func3 = sum;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">func3</span>(<span class="number">20</span>, <span class="number">30</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.lambda的类型保留 注意结尾不要忘了加分号</span></span><br><span class="line">	function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func4 = [](<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">func4</span>(<span class="number">100</span>, <span class="number">200</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.成员函数的类型保留</span></span><br><span class="line">	<span class="comment">//注意点1:在原来的参数列表要多加一个test*</span></span><br><span class="line">	<span class="comment">// 注意点2：调用func5的时候要借助该类对象的指针，这里就构建一个临时对象取地址当做指针来用</span></span><br><span class="line">	function&lt;<span class="type">void</span>(test*, string)&gt; func5 = &amp;test::hello2;</span><br><span class="line">	<span class="built_in">func5</span>(&amp;<span class="built_in">test</span>(), <span class="string">&quot;call test::hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数指针和普通函数指针不同</span></span><br><span class="line">	<span class="comment">//普通指针随便调用就行，但成员函数前面必须要有一个作用域，所以必须依赖一个对象，这也是调用func5要加一个test*的原因</span></span><br><span class="line">	<span class="comment">//成员函数一经编译参数都会多一个指向当前类型的this指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//void (*print)(string str)</span></span><br><span class="line">	<span class="comment">//void (test::*print)(striing str)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合例子来看：</p>
<p>1.func1.operator() &#x3D;&gt; hello1 先调用func1的()重载函数，然后调用包装的hello1</p>
<p>2.人原来有参数，你写的时候就要加上参数，传入的时候也要传入</p>
<p>3.lambda的类型保留 注意结尾不要忘了加分号</p>
<p>4.成员函数的类型保留<br>注意点1:在原来的参数列表要多加一个test*<br>注意点2：调用func5的时候要借助该类对象的指针，这里就构建一个临时对象取地址当做指针来用</p>
<ol start="5">
<li><p>   成员函数指针和普通函数指针不同<br>  普通指针随便调用就行，但成员函数前面必须要有一个作用域，所以必须依赖一个对象，这也是调用func5要加一个test*的原因<br>  成员函数一经编译参数都会多一个指向当前类型的this指针</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*print)(string str)</span><br><span class="line"><span class="built_in">void</span> (test::*print)(striing str)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-fucntion函数对象类型的实现原理"><a href="#2-fucntion函数对象类型的实现原理" class="headerlink" title="2.fucntion函数对象类型的实现原理"></a>2.fucntion函数对象类型的实现原理</h4><p>实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>&#123; cout &lt;&lt; str &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fty&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myfunction</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板的特例版本 针对hello</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> A1&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myfunction</span>&lt;<span class="built_in">R</span>(A1)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*)(A1);</span><br><span class="line">	<span class="built_in">myfunction</span>(PFUNC pfunc):_pfunc(pfunc)&#123;&#125;</span><br><span class="line">	<span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(A1 arg)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _pfunc(arg);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	PFUNC _pfunc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板的特例版本 针对sum</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myfunction</span>&lt;<span class="built_in">R</span>(A1,A2)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*)(A1,A2);</span><br><span class="line">	<span class="built_in">myfunction</span>(PFUNC pfunc) :_pfunc(pfunc) &#123;&#125;</span><br><span class="line">	<span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(A1 arg1,A2 arg2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _pfunc(arg1,arg2);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	PFUNC _pfunc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	myfunction&lt;<span class="built_in">void</span>(string)&gt; func1 = hello;</span><br><span class="line">	<span class="built_in">func1</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	myfunction&lt;<span class="built_in">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; func2 = sum;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">func2</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那肯定会觉得，那这得写多少代码才可以写完，但其实不需要。C+11中提供了可变参的类型参数：包（arg…）</p>
<p>可以理解为把你传进入的所有参数，依次一个一个的传入</p>
<p>感兴趣的读者可以去这里看看相关知识点，这里不再赘述。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_74795952/article/details/142858121?spm=1001.2014.3001.5502">C++11 新特性 学习笔记-CSDN博客</a></p>
<p><strong>通过可变参数实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>&#123; cout &lt;&lt; str &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fty&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myfunction</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... A&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myfunction</span>&lt;<span class="built_in">R</span>(A...)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*)(A...);</span><br><span class="line">	<span class="built_in">myfunction</span>(PFUNC pfunc) :_pfunc(pfunc) &#123;&#125;</span><br><span class="line">	<span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(A... arg)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _pfunc(arg...);<span class="comment">//相当于return sum(10,20);</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	PFUNC _pfunc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	myfunction&lt;<span class="built_in">void</span>(string)&gt; func1 = hello;</span><br><span class="line">	<span class="built_in">func1</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	myfunction&lt;<span class="built_in">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; func2 = sum;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">func2</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以当做是一个可变参数模板的一个实例进行记忆。</p>
<h4 id="3-bind"><a href="#3-bind" class="headerlink" title="3.bind"></a>3.bind</h4><p>bind绑定器返回的也是函数对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> placeholders;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>&#123; cout &lt;&lt; str &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1.bind是函数模板 可以自动推演模板类型参数</span></span><br><span class="line">	<span class="built_in">bind</span>(hello, <span class="string">&quot;hello bind&quot;</span>)();</span><br><span class="line">	cout &lt;&lt; <span class="built_in">bind</span>(sum, <span class="number">10</span>, <span class="number">20</span>)() &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">bind</span>(&amp;test::sum, <span class="built_in">test</span>(), <span class="number">20</span>, <span class="number">30</span>)()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.参数占位符 最多绑定20个参数</span></span><br><span class="line">	<span class="built_in">bind</span>(hello, placeholders::_1)(<span class="string">&quot;hello bind2&quot;</span>);</span><br><span class="line">	<span class="comment">//using namespace placeholders; 有了这句话就可以不写前面的作用域，直接写_1,_2最多20个</span></span><br><span class="line">	cout&lt;&lt;<span class="built_in">bind</span>(sum, _1, _2)(<span class="number">100</span>, <span class="number">200</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.绑定器除了当前语句无法继续使用 解决方法：function</span></span><br><span class="line">	<span class="comment">//此处把bind返回的绑定器就复用起来了</span></span><br><span class="line">	function&lt;<span class="type">void</span>(string)&gt; func1 = <span class="built_in">bind</span>(hello,_1);</span><br><span class="line">	<span class="built_in">func1</span>(<span class="string">&quot;hello china&quot;</span>);</span><br><span class="line">	<span class="built_in">func1</span>(<span class="string">&quot;hello a&quot;</span>);</span><br><span class="line">	<span class="built_in">func1</span>(<span class="string">&quot;hello b&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="bind给成员函数绑定具体的对象（重点）"><a href="#bind给成员函数绑定具体的对象（重点）" class="headerlink" title="bind给成员函数绑定具体的对象（重点）"></a>bind给成员函数绑定具体的对象（重点）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">memberFunction</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Member function called with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    MyClass obj; <span class="comment">// 创建一个 MyClass 的实例  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用 std::bind 将 memberFunction 与 obj 绑定，并绑定第二个参数为 42  </span></span><br><span class="line">    <span class="keyword">auto</span> boundFunction = std::<span class="built_in">bind</span>(&amp;MyClass::memberFunction, &amp;obj, <span class="number">42</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 调用 boundFunction，它现在会调用 obj 的 memberFunction，并传递 42 作为参数  </span></span><br><span class="line">    <span class="built_in">boundFunction</span>(); <span class="comment">// 输出: Member function called with value: 42  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 注意：在这个例子中，我们没有传递第一个参数（即 this 指针的等价物），  </span></span><br><span class="line">    <span class="comment">// 因为我们已经通过 &amp;obj 提供了具体的对象实例。std::bind 会自动处理这个“隐式”的 this 指针。  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 另外，由于我们已经绑定了第二个参数，所以调用 boundFunction 时不需要再传递它。  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 如果你想要一个更通用的可调用对象，可以只绑定对象实例，而不绑定其他参数：  </span></span><br><span class="line">    <span class="keyword">auto</span> boundFunctionGeneric = std::<span class="built_in">bind</span>(&amp;MyClass::memberFunction, &amp;obj, std::placeholders::_1);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 现在你可以传递一个参数来调用 memberFunction：  </span></span><br><span class="line">    <span class="built_in">boundFunctionGeneric</span>(<span class="number">100</span>); <span class="comment">// 输出: Member function called with value: 100  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-bind-和-function实现线程池"><a href="#4-bind-和-function实现线程池" class="headerlink" title="4.bind 和 function实现线程池"></a>4.bind 和 function实现线程池</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Thread</span>(function&lt;<span class="built_in">void</span>()&gt; func) : _func(func) &#123;&#125;</span><br><span class="line">    <span class="function">thread <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(_func)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    function&lt;<span class="type">void</span>()&gt; _func;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        <span class="comment">//释放Thread对象占用的堆资源</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _pool.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">delete</span> _pool[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开启线程池</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startPool</span><span class="params">(<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">//本身不可以是成员方法，但是可以用bind做到，i作为线程编号</span></span><br><span class="line">            _pool.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="built_in">bind</span>(&amp;ThreadPool::runInThread, <span class="keyword">this</span>, i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            _handler.<span class="built_in">push_back</span>(_pool[i]-&gt;<span class="built_in">start</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (thread&amp; t : _handler) &#123;</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Thread*&gt; _pool;</span><br><span class="line">    vector&lt;thread&gt; _handler;</span><br><span class="line">    <span class="comment">//把runInThread这个成员方法充当线程函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">runInThread</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;call runInThread id: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">startPool</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-类的成员函数不能直接作为线程函数，需要bind进行绑定"><a href="#5-类的成员函数不能直接作为线程函数，需要bind进行绑定" class="headerlink" title="5.类的成员函数不能直接作为线程函数，需要bind进行绑定"></a>5.类的成员函数不能直接作为线程函数，需要bind进行绑定</h4><p>在C++中，类的成员函数不能直接作为线程函数（即不能直接传递给<code>std::thread</code>的构造函数）。这是因为成员函数需要一个隐式的<code>this</code>指针来访问类的成员变量和成员函数，而普通的函数指针或可调用对象并不包含这个<code>this</code>指针的信息。</p>
<p><strong>其实呢也好理解，就是一个成员函数你得有个实例对象才能用.或者-&gt;进行调用成员函数，光传一个名字谁知道你要调用哪个对象的这个函数，因为不同的对象内部成员变量什么的都不同，函数内部使用的也不同，所以得有一个this指向它。</strong></p>
<p>当你尝试将成员函数直接作为线程函数时，编译器会报错，因为它无法确定<code>this</code>指针的值（在创建线程时，目标对象可能还没有被正确构造，或者<code>this</code>指针的值在多线程环境下可能变得不确定）。</p>
<p>为了在线程中调用类的成员函数，你有几个选项：</p>
<ol>
<li><strong>使用<code>std::bind</code></strong>：<br><code>std::bind</code>可以绑定成员函数和<code>this</code>指针，生成一个新的可调用对象，这个对象可以被<code>std::thread</code>接受。这是你在问题中提到的方法。</li>
<li><strong>使用lambda表达式</strong>：<br>Lambda表达式是C++11引入的一个特性，它允许你定义一个匿名的函数对象。你可以在lambda表达式中捕获<code>this</code>指针（通常使用<code>[&amp;]</code>或<code>[=]</code>捕获方式），然后在lambda体内调用成员函数。</li>
<li><strong>使用静态成员函数或友元函数</strong>：<br>如果成员函数不依赖于特定的对象实例（即它不需要访问非静态成员变量），你可以将其声明为静态成员函数。静态成员函数不属于任何对象实例，因此可以直接作为线程函数。但是，请注意，静态成员函数不能访问非静态成员变量或成员函数。</li>
<li><strong>使用类外部的普通函数</strong>：<br>如果可能的话，你可以将需要在线程中执行的功能移动到类外部的一个普通函数中。然后，你可以将这个函数作为线程函数，并通过参数传递任何需要的数据。</li>
</ol>
<h5 id="使用-std-bind"><a href="#使用-std-bind" class="headerlink" title="使用 std::bind"></a>使用 <code>std::bind</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnectionTask</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producing connection task in thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startProducing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 使用 std::bind 绑定成员函数和 this 指针  </span></span><br><span class="line">        <span class="function">std::thread <span class="title">producerThread</span><span class="params">(std::bind(&amp;ConnectionPool::produceConnectionTask, <span class="keyword">this</span>))</span></span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 等待线程完成（在实际应用中，可能需要更复杂的线程管理）  </span></span><br><span class="line">        producerThread.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ConnectionPool pool;  </span><br><span class="line">    pool.<span class="built_in">startProducing</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用-Lambda-表达式"><a href="#使用-Lambda-表达式" class="headerlink" title="使用 Lambda 表达式"></a>使用 Lambda 表达式</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnectionTask</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producing connection task in thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startProducing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 使用 lambda 表达式捕获 this 指针  </span></span><br><span class="line">        <span class="function">std::thread <span class="title">producerThread</span><span class="params">([<span class="keyword">this</span>]() &#123;  </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">this</span>-&gt;produceConnectionTask();  </span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 等待线程完成  </span></span><br><span class="line">        producerThread.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ConnectionPool pool;  </span><br><span class="line">    pool.<span class="built_in">startProducing</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用静态成员函数或友元函数"><a href="#使用静态成员函数或友元函数" class="headerlink" title="使用静态成员函数或友元函数"></a>使用静态成员函数或友元函数</h5><p>注意，静态成员函数不能访问非静态成员变量，因此这个方法通常用于不需要访问类实例状态的函数。这里我改为使用友元函数来演示，因为它可以访问类的私有和保护成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">produceConnectionTaskWrapper</span><span class="params">(ConnectionPool&amp; pool)</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnectionTask</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producing connection task in thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startProducing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 使用友元函数作为线程函数  </span></span><br><span class="line">        <span class="function">std::thread <span class="title">producerThread</span><span class="params">(produceConnectionTaskWrapper, std::ref(*<span class="keyword">this</span>))</span></span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 等待线程完成  </span></span><br><span class="line">        producerThread.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 友元函数实现  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">produceConnectionTaskWrapper</span><span class="params">(ConnectionPool&amp; pool)</span> </span>&#123;  </span><br><span class="line">    pool.<span class="built_in">produceConnectionTask</span>();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ConnectionPool pool;  </span><br><span class="line">    pool.<span class="built_in">startProducing</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用类外部的普通函数"><a href="#使用类外部的普通函数" class="headerlink" title="使用类外部的普通函数"></a>使用类外部的普通函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnectionTask</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producing connection task in thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startProducing</span><span class="params">(ConnectionPool* pool)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 使用类外部的普通函数作为线程函数  </span></span><br><span class="line">        <span class="function">std::thread <span class="title">producerThread</span><span class="params">(produceConnectionTaskExternal, pool)</span></span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 等待线程完成  </span></span><br><span class="line">        producerThread.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 类外部的普通函数  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">produceConnectionTaskExternal</span><span class="params">(ConnectionPool* pool)</span> </span>&#123;  </span><br><span class="line">    pool-&gt;<span class="built_in">produceConnectionTask</span>();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ConnectionPool pool;  </span><br><span class="line">    pool.<span class="built_in">startProducing</span>(&amp;pool);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-lambda表达式-底层依赖函数对象机制实现的"><a href="#3-4-lambda表达式-底层依赖函数对象机制实现的" class="headerlink" title="3.4 lambda表达式 底层依赖函数对象机制实现的"></a>3.4 lambda表达式 底层依赖函数对象机制实现的</h3><h4 id="1-lambda概述"><a href="#1-lambda概述" class="headerlink" title="1.lambda概述"></a>1.lambda概述</h4><p>函数对象的的升级版—-lambda</p>
<p>函数对象的缺点：</p>
<p>灵活性太差了，需要定一个类出来，但其实实际上我可能只需要在泛型算法里面用一次就不用了</p>
<h4 id="2-lambda表达式的语法"><a href="#2-lambda表达式的语法" class="headerlink" title="2.lambda表达式的语法"></a>2.lambda表达式的语法</h4><p><code>语法：</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[捕获外部变量](形参列表)-&gt;返回值&#123;操作代码&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意操作代码后面也有分号，句子结束也有分号，不要忘了，不要少写</strong></p>
<p>如果没有返回值”-&gt;返回值”这部分可以省略</p>
<p>关于形参列表部分，如果参数，关键字，返回值一个都没有，那小括号可写可不写，如果有一个那就得写小括号</p>
<p><strong>形参列表对应的是函数对象中operator()()的形参列表</strong></p>
<h6 id="lambda匿名函数中的-外部变量"><a href="#lambda匿名函数中的-外部变量" class="headerlink" title="lambda匿名函数中的[外部变量]"></a>lambda匿名函数中的[外部变量]</h6><p>外部变量指的是和lambda在一个作用域的变量，写[&#x3D;]把同一作用域和更外层的变量拷贝一个副本</p>
<p>这个应该对应函数对象的类里面的成员变量</p>
<table>
<thead>
<tr>
<th>外部变量格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>空方括号表示当前 lambda 匿名函数中不导入任何外部变量。</td>
</tr>
<tr>
<td>[&#x3D;]</td>
<td>只有一个 &#x3D; 等号，表示以值传递的方式导入所有外部变量；</td>
</tr>
<tr>
<td>[&amp;]</td>
<td>只有一个 &amp; 符号，表示以引用传递的方式导入所有外部变量；</td>
</tr>
<tr>
<td>[val1,val2,…]</td>
<td>表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序；</td>
</tr>
<tr>
<td>[&amp;val1,&amp;val2,…]</td>
<td>表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序；</td>
</tr>
<tr>
<td>[val,&amp;val2,…]</td>
<td>以上 2 种方式还可以混合使用，变量之间没有前后次序。</td>
</tr>
<tr>
<td>[&#x3D;,&amp;val1,…]</td>
<td>表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。</td>
</tr>
<tr>
<td>[this]</td>
<td>表示以值传递的方式导入当前的 this 指针。</td>
</tr>
</tbody></table>
<blockquote>
<p>注意，单个外部变量不允许以相同的传递方式导入多次。例如 [&#x3D;，val1] 中，val1 先后被以值传递的方式导入了 2 次，这是非法的。</p>
</blockquote>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241012215219186.png" alt="image-20241012215219186"></p>
<p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> placeholders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">class</span> testLambda01</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">testLambda01</span>()&#123;&#125;</span><br><span class="line">	<span class="type">void</span> <span class="built_in">operator</span>()()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> testLambda02</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">testLambda02</span>() &#123;&#125;</span><br><span class="line">	<span class="type">int</span> <span class="built_in">operator</span>()(<span class="type">int</span> a,<span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> testLambda03</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">testLambda03</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">ma</span>(a),<span class="built_in">mb</span>(b) &#123;&#125;</span><br><span class="line">	<span class="comment">//常方法里面不能修改成员变量</span></span><br><span class="line">	<span class="comment">//1.成员变量加mutable</span></span><br><span class="line">	<span class="comment">//2.lambda加关键字mutable</span></span><br><span class="line">	<span class="type">void</span> <span class="built_in">operator</span>()() <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tmp = ma;</span><br><span class="line">		ma = mb;</span><br><span class="line">		mb = tmp;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> ma;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> mb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">auto</span> func3 = [a, b]()<span class="keyword">mutable</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tmp = a;</span><br><span class="line">			a = b;</span><br><span class="line">			b = tmp;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func3</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;b &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	testLambda03&lt;&gt; <span class="built_in">t3</span>(a, b);</span><br><span class="line">	<span class="built_in">t3</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;b &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> testLambda04</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">testLambda04</span>(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b):<span class="built_in">ma</span>(a),<span class="built_in">mb</span>(b) &#123;&#125;</span><br><span class="line">	<span class="comment">//常方法里面不能修改成员变量</span></span><br><span class="line">	<span class="comment">//1.成员变量加mutable</span></span><br><span class="line">	<span class="comment">//2.lambda加关键字mutable</span></span><br><span class="line">	<span class="type">void</span> <span class="built_in">operator</span>()() <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tmp = ma;</span><br><span class="line">		ma = mb;</span><br><span class="line">		mb = tmp;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> &amp;ma;</span><br><span class="line">	<span class="type">int</span> &amp;mb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> func1 = []()-&gt;<span class="type">void</span> &#123;cout &lt;&lt; <span class="string">&quot;hello world&quot;</span>&lt;&lt;endl; &#125;;</span><br><span class="line">	<span class="built_in">func1</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> func2 = [](<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">func2</span>(<span class="number">20</span>, <span class="number">30</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//func1的函数对象版本</span></span><br><span class="line">	testLambda01&lt;&gt; t1;</span><br><span class="line">	<span class="built_in">t1</span>();</span><br><span class="line">	<span class="comment">//func2的函数对象版本</span></span><br><span class="line">	testLambda02&lt;&gt; t2;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">t2</span>(<span class="number">20</span>,<span class="number">30</span>)&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//虽然实现了func3lambda对应的函数对象，但是a，b根本上还是没变（因为是值传递，不是引用），没有实现交换这个功能</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">auto</span> func3 = [a, b]()<span class="keyword">mutable</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tmp = a;</span><br><span class="line">			a = b;</span><br><span class="line">			b = tmp;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func3</span>();</span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;a &quot;</span>&lt;&lt; a &lt;&lt;<span class="string">&quot;b &quot;</span>&lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	testLambda03&lt;&gt; <span class="built_in">t3</span>(a,b);</span><br><span class="line">	<span class="built_in">t3</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;b &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//实现交换功能，按照引用来传递参数，lambda后面的mutable也不用加了</span></span><br><span class="line">	<span class="comment">//函数对象里面的mutable也不用加了 因为交换改变的是ma，mb的内存里面的东西</span></span><br><span class="line">	<span class="comment">/*int a = 10;</span></span><br><span class="line"><span class="comment">	int b = 20;</span></span><br><span class="line"><span class="comment">	auto func4 = [&amp;a, &amp;b]()</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			int tmp = a;</span></span><br><span class="line"><span class="comment">			a = b;</span></span><br><span class="line"><span class="comment">			b = tmp;</span></span><br><span class="line"><span class="comment">		&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	func4();</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; &quot;a &quot; &lt;&lt; a &lt;&lt; &quot; b &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	testLambda04&lt;&gt; t4(a, b);</span></span><br><span class="line"><span class="comment">	t4();</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; &quot;a &quot; &lt;&lt; a &lt;&lt; &quot; b &quot; &lt;&lt; b &lt;&lt; endl;*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Q：为什么在类中换成引用类型就不需要mtable来修饰成员变量了？</p>
<p>在C++中，当成员变量是引用类型时，即使在<code>const</code>成员函数内部，我们也可以通过这些引用来修改它们所引用的外部对象的状态。这是因为<code>const</code>成员函数中的<code>const</code>关键字限制了成员变量本身的“可修改性”（如果成员变量不是引用或指针的话），但它并不限制通过成员变量（如果它们是引用或指针）所间接访问的对象的可修改性。</p>
<p>具体来说，当一个成员函数被声明为<code>const</code>时，这意味着该成员函数不能修改其所属对象的任何非静态成员变量（除非这些变量被声明为<code>mutable</code>）。然而，这一规则并不适用于引用类型的成员变量，因为引用本身并不是对象，它只是对象的一个别名。当我们说“不能修改成员变量”时，实际上是指不能改变成员变量所引用的对象（如果成员变量是对象的话）或成员变量所指向的地址（如果成员变量是指针的话）。但是，如果成员变量是引用，并且它引用了一个外部对象，那么我们完全可以通过这个引用来修改那个外部对象的状态。</p>
<p>换句话说，<code>const</code>成员函数中的<code>const</code>性仅仅保证了成员函数不会改变其所属对象的“身份”（即不会改变成员变量的值，如果成员变量是值类型的话），但并不保证不会改变成员变量所引用的外部对象的“状态”。</p>
<h4 id="3-lambda的应用实践"><a href="#3-lambda的应用实践" class="headerlink" title="3.lambda的应用实践"></a>3.lambda的应用实践</h4><h5 id="1-泛型算法之中"><a href="#1-泛型算法之中" class="headerlink" title="1.泛型算法之中"></a>1.泛型算法之中</h5><p>就使用这一下，不用麻烦的写函数对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.vector从大到小排序的lambda排序</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),[](<span class="type">int</span> a,<span class="type">int</span> b)-&gt;<span class="type">bool</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> a&gt;b;</span><br><span class="line">		&#125;)</span><br><span class="line"><span class="comment">//2.找到第一个比65小的数字的位置插入65到这里</span></span><br><span class="line"><span class="keyword">auto</span> it=<span class="built_in">find_id</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),[](<span class="type">int</span> a)-&gt;<span class="type">bool</span>&#123;<span class="keyword">return</span> a&lt;<span class="number">65</span>;&#125;);</span><br><span class="line"><span class="keyword">if</span>(it!=v.<span class="built_in">end</span>())</span><br><span class="line">    	v.<span class="built_in">insert</span>(it,<span class="number">65</span>);</span><br></pre></td></tr></table></figure>

<p>为什么a，b在()而不是[]里面？</p>
<p>在C++中，当你使用lambda表达式作为<code>sort</code>函数的比较函数时，lambda表达式的参数（在这个例子中是<code>a</code>和<code>b</code>）是通过<code>operator()</code>函数传入的，而不是通过捕获列表<code>[]</code>传入的。这是因为捕获列表<code>[]</code>用于指定哪些外部变量应该被捕获到lambda表达式的内部作用域中，而不是用于接收函数参数。</p>
<h5 id="2-既然lambda只能用在语句中，如果想跨语句使用之前定义好的lambda表达式怎么办？有什么类型表达lambda？"><a href="#2-既然lambda只能用在语句中，如果想跨语句使用之前定义好的lambda表达式怎么办？有什么类型表达lambda？" class="headerlink" title="2.既然lambda只能用在语句中，如果想跨语句使用之前定义好的lambda表达式怎么办？有什么类型表达lambda？"></a>2.既然lambda只能用在语句中，如果想跨语句使用之前定义好的lambda表达式怎么办？有什么类型表达lambda？</h5><p>解决方法：用函数对象function表示lambda的类型，lambda-&gt;函数对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Data</span>(<span class="type">int</span> val1=<span class="number">10</span>,<span class="type">int</span> val2=<span class="number">10</span>):<span class="built_in">ma</span>(val1),<span class="built_in">mb</span>(val2)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Data &amp;data) <span class="type">const</span> &#123; <span class="keyword">return</span> ma &gt; data.ma; &#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Data &amp;data) <span class="type">const</span> &#123; <span class="keyword">return</span> ma &lt; data.ma; &#125;</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line">    <span class="type">int</span> mb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.function存储类型</span></span><br><span class="line">    map&lt;<span class="type">int</span>, function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; caculateMap;</span><br><span class="line">    caculateMap [<span class="number">1</span>] = [] (<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">    caculateMap [<span class="number">2</span>] = [] (<span class="type">int</span> a, inth)&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a - b; &#125;;</span><br><span class="line">    caculateMap [<span class="number">3</span>] = [] (<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a * b; &#125;;</span><br><span class="line">    caculateMap [<span class="number">4</span>] = [] (<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a / b; &#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;选择:&quot;</span>;</span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    cin &gt;&gt; choice;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;10 + 15:&quot;</span> &lt;&lt; caculateMap[choice] (<span class="number">10</span>, <span class="number">15</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	<span class="comment">// 2.智能指针自定义删除器</span></span></span><br><span class="line"><span class="function">    unique_ptr&lt;FILE,function&lt;<span class="title">void</span> <span class="params">(FILE *)</span>&gt;&gt;</span></span><br><span class="line"><span class="function">    <span class="title">pti1</span> <span class="params">(fopen (<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;w&quot;</span>), [] (FILE *pf) &#123;fclose(pf); &#125;)</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//3.优先级队列 默认要进行比较，因为底层是大根堆 但是&gt;和&lt;运算符重载有点麻烦且灵活性很差，每次都要改动</span></span><br><span class="line">    priority_queue&lt;Data&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line">    queue.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">15</span>,<span class="number">15</span>));</span><br><span class="line">    queue.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    <span class="comment">//修改后，加入了比较函数，比较灵活</span></span><br><span class="line">    <span class="keyword">using</span> PFUNC=function&lt;<span class="built_in">bool</span>(Data&amp;,Data&amp;)&gt;;</span><br><span class="line">    priority_queue&lt;Data,vector&lt;Data&gt;,PFUNC&gt; </span><br><span class="line">        <span class="built_in">q</span>([](Data &amp;d1,Data &amp;d2)-&gt;<span class="type">bool</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> d<span class="number">1.</span>ma&gt;d<span class="number">2.</span>ma;</span><br><span class="line">		&#125;</span><br><span class="line">    );</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">15</span>,<span class="number">15</span>));</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、c-11内容汇总、多线程应用实践"><a href="#四、c-11内容汇总、多线程应用实践" class="headerlink" title="四、c++11内容汇总、多线程应用实践"></a>四、c++11内容汇总、多线程应用实践</h2><h3 id="4-1-c-11内容汇总"><a href="#4-1-c-11内容汇总" class="headerlink" title="4.1 c++11内容汇总"></a>4.1 c++11内容汇总</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">一:关键字和语法</span><br><span class="line"><span class="keyword">auto</span>:可以根据右值,推导出右值的类型,然后左边变量的类型也就已知了</span><br><span class="line"><span class="literal">nullptr</span>:给指针专用(能够和整数进行区别)</span><br><span class="line">foreach:可以遍历数组,容器等</span><br><span class="line"><span class="keyword">for</span>(Type val:container)=&gt;底层就是通过指针或者迭代器来实现的</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">右值引用:move移动语义函数和forward类型完美转发函数</span><br><span class="line">模板的一个新特性:<span class="keyword">typename</span> ... A 表示可变参(类型参数)</span><br><span class="line"></span><br><span class="line">二:绑定器和函数对象</span><br><span class="line">function:函数对象</span><br><span class="line">bind:绑定器</span><br><span class="line">lambda表达式</span><br><span class="line"></span><br><span class="line">三:智能指针</span><br><span class="line">shared ptr和weak_ptr</span><br><span class="line"></span><br><span class="line">四:容器</span><br><span class="line">set和map:红黑树 <span class="built_in">O</span>(<span class="number">1</span>gn)</span><br><span class="line">unordered set和unordered map:哈希表 <span class="built_in">O</span>(<span class="number">1</span>)</span><br><span class="line">array: 数组</span><br><span class="line">forward list:前向链表</span><br><span class="line"></span><br><span class="line">五:C++语言级别支持的多线程编程</span><br><span class="line">createThread</span><br><span class="line">pthread create</span><br><span class="line">clone</span><br></pre></td></tr></table></figure>

<p>读者可参考此文章进行学习</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_74795952/article/details/142858121?spm=1001.2014.3001.5502">C++11 新特性 学习笔记-CSDN博客</a></p>
<h3 id="4-2-C-语言级别的多线程编程"><a href="#4-2-C-语言级别的多线程编程" class="headerlink" title="4.2 C++语言级别的多线程编程"></a>4.2 C++语言级别的多线程编程</h3><p>可以看这些复习。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45754224/article/details/141139153?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-141139153-blog-118861539.235%5Ev43%5Epc_blog_bottom_relevance_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-141139153-blog-118861539.235%5Ev43%5Epc_blog_bottom_relevance_base1&utm_relevant_index=5">C++多线程详解 | 线程创建 | 互斥锁 | 条件变量 | 线程池_c++ 线程-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sjc_0910/article/details/118861539">C++11 多线程（std::thread）详解_c++11线程使用-CSDN博客</a></p>
<p>语言级别多线程最大的优点：可跨平台</p>
<p>就是在语言层面加了一层封装，c++里面加了一些宏可以识别当前的操作系统，然后还是去调用相应的系统调用</p>
<p>比如linux就还是底层调用pthread_creat之类的函数</p>
<p>多线程编程两个问题：</p>
<p><strong>1.线程间的互斥</strong></p>
<p>竞态条件–&gt;临界区代码段–&gt;原子操作–&gt;互斥锁或者CAS</p>
<p><code>竞态条件：</code></p>
<p>竞态条件指的是设备或系统出现不恰当的执行时序，导致得到不正确的结果。从多进程间通信的角度来看，竞态条件发生在两个或多个进程对共享的数据进行读或写的操作时，最终的结果取决于这些进程的执行顺序。在并发编程中，竞态条件通常指的是程序的执行结果依赖于线程执行的顺序。</p>
<p><code>临界区代码段：</code></p>
<p>导致竞态条件发生的代码段被称为临界区代码段。在临界区内，代码的执行顺序对结果有重要影响，因此必须确保同一时间只有一个线程能够执行临界区内的代码。</p>
<p>保证临界区代码段的原子操作通过互斥锁或者CAS实现</p>
<p><strong>2.线程间的同步通信</strong></p>
<p>生产者，消费者线程模型</p>
<p>注：C++的STL容器在默认状态下都是线程不安全的</p>
<h4 id="1-通过thread类编写C-多线程程序"><a href="#1-通过thread类编写C-多线程程序" class="headerlink" title="1.通过thread类编写C++多线程程序"></a>1.通过thread类编写C++多线程程序</h4><h5 id="1-头文件以及命名空间"><a href="#1-头文件以及命名空间" class="headerlink" title="1.头文件以及命名空间"></a>1.头文件以及命名空间</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">头文件：#include&lt;thread&gt;</span><br><span class="line">写using namespace std; 或者 std::thread 都可以使用thread类</span><br></pre></td></tr></table></figure>

<h5 id="2-线程创建"><a href="#2-线程创建" class="headerlink" title="2.线程创建"></a>2.线程创建</h5><p>std :: thread定义一个线程对象,传入线程所需要的线程函数和参数，线程自动开启</p>
<p>定义一个线程对象 参数传入一个线程函数threadHandle1</p>
<p> 一个线程对应一个线程栈 这个名字就是线程的入口函数</p>
<p><strong>传入后，新线程就开始运行了，其实就是入口函数开始运行了</strong></p>
<p>第一个参数是线程函数，第二个参数开始就是线程函数的参数了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadHandle1</span><span class="params">(<span class="type">int</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//让子线程睡眠两秒 一堆命名空间不用管</span></span><br><span class="line">	this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(time));</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello thread&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(threadHandle1,<span class="number">2</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="注意：类的成员函数不能直接作为线程函数，需要bind进行绑定"><a href="#注意：类的成员函数不能直接作为线程函数，需要bind进行绑定" class="headerlink" title="注意：类的成员函数不能直接作为线程函数，需要bind进行绑定"></a>注意：类的成员函数不能直接作为线程函数，需要bind进行绑定</h5><p>在C++中，类的成员函数不能直接作为线程函数（即不能直接传递给<code>std::thread</code>的构造函数）。这是因为成员函数需要一个隐式的<code>this</code>指针来访问类的成员变量和成员函数，而普通的函数指针或可调用对象并不包含这个<code>this</code>指针的信息。</p>
<p><strong>其实呢也好理解，就是一个成员函数你得有个实例对象才能用.或者-&gt;进行调用成员函数，光传一个名字谁知道你要调用哪个对象的这个函数，因为不同的对象内部成员变量什么的都不同，函数内部使用的也不同，所以得有一个this指向它。</strong></p>
<p>当你尝试将成员函数直接作为线程函数时，编译器会报错，因为它无法确定<code>this</code>指针的值（在创建线程时，目标对象可能还没有被正确构造，或者<code>this</code>指针的值在多线程环境下可能变得不确定）。</p>
<p>为了在线程中调用类的成员函数，你有几个选项：</p>
<ol>
<li><strong>使用<code>std::bind</code></strong>：<br><code>std::bind</code>可以绑定成员函数和<code>this</code>指针，生成一个新的可调用对象，这个对象可以被<code>std::thread</code>接受。这是你在问题中提到的方法。</li>
<li><strong>使用lambda表达式</strong>：<br>Lambda表达式是C++11引入的一个特性，它允许你定义一个匿名的函数对象。你可以在lambda表达式中捕获<code>this</code>指针（通常使用<code>[&amp;]</code>或<code>[=]</code>捕获方式），然后在lambda体内调用成员函数。</li>
<li><strong>使用静态成员函数或友元函数</strong>：<br>如果成员函数不依赖于特定的对象实例（即它不需要访问非静态成员变量），你可以将其声明为静态成员函数。静态成员函数不属于任何对象实例，因此可以直接作为线程函数。但是，请注意，静态成员函数不能访问非静态成员变量或成员函数。</li>
<li><strong>使用类外部的普通函数</strong>：<br>如果可能的话，你可以将需要在线程中执行的功能移动到类外部的一个普通函数中。然后，你可以将这个函数作为线程函数，并通过参数传递任何需要的数据。</li>
</ol>
<h5 id="使用-std-bind-1"><a href="#使用-std-bind-1" class="headerlink" title="使用 std::bind"></a>使用 <code>std::bind</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnectionTask</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producing connection task in thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startProducing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 使用 std::bind 绑定成员函数和 this 指针  </span></span><br><span class="line">        <span class="function">std::thread <span class="title">producerThread</span><span class="params">(std::bind(&amp;ConnectionPool::produceConnectionTask, <span class="keyword">this</span>))</span></span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 等待线程完成（在实际应用中，可能需要更复杂的线程管理）  </span></span><br><span class="line">        producerThread.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ConnectionPool pool;  </span><br><span class="line">    pool.<span class="built_in">startProducing</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用-Lambda-表达式-1"><a href="#使用-Lambda-表达式-1" class="headerlink" title="使用 Lambda 表达式"></a>使用 Lambda 表达式</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnectionTask</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producing connection task in thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startProducing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 使用 lambda 表达式捕获 this 指针  </span></span><br><span class="line">        <span class="function">std::thread <span class="title">producerThread</span><span class="params">([<span class="keyword">this</span>]() &#123;  </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">this</span>-&gt;produceConnectionTask();  </span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 等待线程完成  </span></span><br><span class="line">        producerThread.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ConnectionPool pool;  </span><br><span class="line">    pool.<span class="built_in">startProducing</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用静态成员函数或友元函数-1"><a href="#使用静态成员函数或友元函数-1" class="headerlink" title="使用静态成员函数或友元函数"></a>使用静态成员函数或友元函数</h5><p>注意，静态成员函数不能访问非静态成员变量，因此这个方法通常用于不需要访问类实例状态的函数。这里我改为使用友元函数来演示，因为它可以访问类的私有和保护成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">produceConnectionTaskWrapper</span><span class="params">(ConnectionPool&amp; pool)</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnectionTask</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producing connection task in thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startProducing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 使用友元函数作为线程函数  </span></span><br><span class="line">        <span class="function">std::thread <span class="title">producerThread</span><span class="params">(produceConnectionTaskWrapper, std::ref(*<span class="keyword">this</span>))</span></span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 等待线程完成  </span></span><br><span class="line">        producerThread.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 友元函数实现  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">produceConnectionTaskWrapper</span><span class="params">(ConnectionPool&amp; pool)</span> </span>&#123;  </span><br><span class="line">    pool.<span class="built_in">produceConnectionTask</span>();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ConnectionPool pool;  </span><br><span class="line">    pool.<span class="built_in">startProducing</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用类外部的普通函数-1"><a href="#使用类外部的普通函数-1" class="headerlink" title="使用类外部的普通函数"></a>使用类外部的普通函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnectionTask</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producing connection task in thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startProducing</span><span class="params">(ConnectionPool* pool)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 使用类外部的普通函数作为线程函数  </span></span><br><span class="line">        <span class="function">std::thread <span class="title">producerThread</span><span class="params">(produceConnectionTaskExternal, pool)</span></span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 等待线程完成  </span></span><br><span class="line">        producerThread.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 类外部的普通函数  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">produceConnectionTaskExternal</span><span class="params">(ConnectionPool* pool)</span> </span>&#123;  </span><br><span class="line">    pool-&gt;<span class="built_in">produceConnectionTask</span>();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ConnectionPool pool;  </span><br><span class="line">    pool.<span class="built_in">startProducing</span>(&amp;pool);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h5 id="3-子线程如何结束"><a href="#3-子线程如何结束" class="headerlink" title="3.子线程如何结束"></a>3.子线程如何结束</h5><p>子线程函数运行完成，线程就结束了</p>
<h5 id="4-主线程如何处理子线程"><a href="#4-主线程如何处理子线程" class="headerlink" title="4.主线程如何处理子线程"></a>4.主线程如何处理子线程</h5><p>主线程和子线程没有先后顺序，自己运行自己的</p>
<p>子线程可以比主线程早结束，但通常不推荐这么做，最好就是确保子线程都结束了主线程再结束</p>
<p><code>1.join函数</code></p>
<p>主线程阻塞等待子线程t1结束，主线程继续往下进行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>

<p><code>2.detach函数</code></p>
<p>使用<code>detach()</code>会将子线程t1与主线程main分离，主线程结束，整个进程结束，所有子线程都自动结束了</p>
<p>不是很安全，不推荐使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t<span class="number">1.</span><span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure>

<p>实例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadHandle1</span><span class="params">(<span class="type">int</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//让子线程睡眠两秒</span></span><br><span class="line">	this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(time));</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello thread&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(threadHandle1,<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//t1.join();</span></span><br><span class="line">	t<span class="number">1.</span><span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;main thread&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-线程互斥"><a href="#2-线程互斥" class="headerlink" title="2.线程互斥"></a>2.线程互斥</h4><h5 id="1-为什么需要线程互斥"><a href="#1-为什么需要线程互斥" class="headerlink" title="1.为什么需要线程互斥"></a>1.为什么需要线程互斥</h5><p>竞态条件：多线程程序执行的结果是一直的，不会随着CPU对线程不同的调用顺序而产生不同的运行结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//车站有100张车票，由三个窗口一起卖票</span></span><br><span class="line"><span class="type">int</span> countSum = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对车票--不是一个线程安全的操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sellTicket</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果是if的话 就卖三张票就结束了</span></span><br><span class="line">	<span class="keyword">while</span> (countSum &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;窗口：&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;卖出第：&quot;</span> &lt;&lt; countSum &lt;&lt; <span class="string">&quot;张票&quot;</span> &lt;&lt; endl;</span><br><span class="line">		countSum--;</span><br><span class="line">		<span class="comment">//模拟卖票花的时间 100毫秒</span></span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;thread&gt; tlist;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">		tlist.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(sellTicket, i));</span><br><span class="line">	<span class="keyword">for</span> (thread &amp; c : tlist)</span><br><span class="line">		c.<span class="built_in">join</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;所有窗口卖票结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在本个例子中存在竞态条件，因为每次执行结果都不一样的</p>
<p>原因是，对车票–操作不是一个线程安全的操作，每个线程减到一半可能时间片到了就去执行另外一个线程，导致一张票卖出去多次（出现了相同的数字的票）</p>
<h5 id="2-mutex-互斥锁"><a href="#2-mutex-互斥锁" class="headerlink" title="2.mutex 互斥锁"></a>2.mutex 互斥锁</h5><p>在linux中mutex底层也调用的是系统调用，用的是pthread_mutex_t互斥锁</p>
<p>锁的概念参考这篇文章，这里不再赘述</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_74795952/article/details/142872020?spm=1001.2014.3001.5502">黑马程序员 | linux系统编程 | 学习笔记_linux网络操作系统项目教程黑马程序员电子版-CSDN博客</a></p>
<p><code>头文件：</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><code>互斥锁创建及使用</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> 对应线程函数(形参列表)</span><br><span class="line">&#123;</span><br><span class="line">	mtx.<span class="built_in">lock</span>();</span><br><span class="line">	核心代码，需要原子操作的（即必须要一次执行完的，不能执行到一半去别的线程）</span><br><span class="line">	mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mutex mtx;<span class="comment">//全局的一把互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sellTicket</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mtx.<span class="built_in">lock</span>();</span><br><span class="line">	<span class="keyword">while</span>(countSum &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;窗口：&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;卖出第：&quot;</span> &lt;&lt; countSum &lt;&lt; <span class="string">&quot;张票&quot;</span> &lt;&lt; endl;</span><br><span class="line">		countSum--;</span><br><span class="line">		<span class="comment">//模拟卖票花的时间 100毫秒</span></span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样改是不行的，我们把整个函数代码都上锁，那么只会有一个窗口卖票剩下的都不会卖的，因为它占有的mutex资源一直没有释放</p>
<p>所以只保证核心的代码的原子性就行，锁的内容尽量的少</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sellTicket</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(countSum &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		mtx.<span class="built_in">lock</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;窗口：&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;卖出第：&quot;</span> &lt;&lt; countSum &lt;&lt; <span class="string">&quot;张票&quot;</span> &lt;&lt; endl;</span><br><span class="line">		countSum--;</span><br><span class="line">		mtx.<span class="built_in">unlock</span>();</span><br><span class="line">		<span class="comment">//模拟卖票花的时间 100毫秒</span></span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样还是不完全安全，如果线程1在卖最后一张票，拿上锁，但还没有–的时候线程2进来了，他一看还有一张票，就等着锁资源，1卖完了最后一张，释放锁，2进来了卖的就是第0张票</p>
<p>所以要采用   <code>锁+双重判断</code>   的模式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sellTicket</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(countSum &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		mtx.<span class="built_in">lock</span>();</span><br><span class="line">		<span class="keyword">if</span> (countSum &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;窗口：&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;卖出第：&quot;</span> &lt;&lt; countSum &lt;&lt; <span class="string">&quot;张票&quot;</span> &lt;&lt; endl;</span><br><span class="line">			countSum--;</span><br><span class="line">		&#125;</span><br><span class="line">		mtx.<span class="built_in">unlock</span>();</span><br><span class="line">		<span class="comment">//模拟卖票花的时间 100毫秒</span></span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果说，mutex中间满足条件子线程函数结束了，那么后面的线程会一直拿不到锁</p>
<p>在C++中，互斥锁（<code>std::mutex</code>）不会自动因为线程的结束而被释放；锁的释放必须显式地通过调用<code>unlock</code>成员函数来完成，或者使用RAII（Resource Acquisition Is Initialization）机制来自动管理。</p>
<p>如果子线程在没有显式释放锁的情况下结束，那么锁将保持锁定状态，这通常会导致几个问题：</p>
<ol>
<li><strong>死锁</strong>：其他尝试获取该锁的线程将被永久阻塞，因为它们无法获取到已经被持有且未释放的锁。</li>
<li><strong>资源泄露</strong>：锁是一种有限资源，如果它们被永久占用而不释放，那么系统将无法有效地管理这些资源，可能导致性能下降或资源耗尽。</li>
<li><strong>数据不一致</strong>：如果锁保护的共享数据在锁未释放的情况下被其他线程访问或修改，那么可能会导致数据不一致或损坏。</li>
</ol>
<p>所以要用<code>lock_guard</code>（RALL）来对锁进行管理，类似于裸指针和智能指针那样的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mutex mtx;</span><br><span class="line"><span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">需要上锁的核心代码</span><br><span class="line">lock生命周期结束调用析构，自动释放锁资源</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sellTicket</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(countSum &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//lock_guard对象的作用域是这个while循环，出去以后就调用析构，析构里面实现了释放锁的逻辑</span></span><br><span class="line">		<span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (countSum &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;窗口：&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;卖出第：&quot;</span> &lt;&lt; countSum &lt;&lt; <span class="string">&quot;张票&quot;</span> &lt;&lt; endl;</span><br><span class="line">			countSum--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//模拟卖票花的时间 100毫秒</span></span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过加<strong>大括号</strong>来限制lock_guard的作用域，除了大括号就析构释放资源了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sellTicket</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(countSum &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//lock_guard对象的作用域是这个while循环，出去以后就调用析构，析构里面实现了释放锁的逻辑</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (countSum &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;窗口：&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;卖出第：&quot;</span> &lt;&lt; countSum &lt;&lt; <span class="string">&quot;张票&quot;</span> &lt;&lt; endl;</span><br><span class="line">                countSum--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//模拟卖票花的时间 100毫秒</span></span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但函数参数传递或者返回的时候就不能用lock_guard了，因为它不支持赋值和重载</strong></p>
<p>可以用unique_lock（升级版），和unique_ptr一样，拷贝和赋值重载被delete，但是给了右值引用赋值，调用析构也会释放锁资源</p>
<p><code>使用方法：</code></p>
<p>构造和析构时，占有锁和释放锁</p>
<p>也可以显示调用</p>
<p>l.lock()和l.unlock()但是没什么必要</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sellTicket</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (countSum &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">unique_lock&lt;mutex&gt; <span class="title">l</span><span class="params">(mtx)</span></span>;</span><br><span class="line">			<span class="keyword">if</span> (countSum &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;窗口：&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;卖出第：&quot;</span> &lt;&lt; countSum &lt;&lt; <span class="string">&quot;张票&quot;</span> &lt;&lt; endl;</span><br><span class="line">				countSum--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-基于CAS操作的atomic原子类型"><a href="#3-基于CAS操作的atomic原子类型" class="headerlink" title="3.基于CAS操作的atomic原子类型"></a>3.基于CAS操作的atomic原子类型</h5><p>如果只有一两个语句需要原子特性，那没必要加锁，太麻烦了</p>
<p>系统理论：CAS来保证上面的++ –操作的原子特性就足够了，也被称为<code>无锁操作</code></p>
<p>这个无锁指的，不是从软件层面加锁，而是硬件层面。</p>
<p><code>硬件实现具体过程：</code><strong>CPU从内存取出数据，计算，再写回内存的过程</strong>中对总线加锁，这个时候不允许线程去使用总线，通过这种方式来完成的”加锁”</p>
<p>面经当中的无锁操作比如无锁队列都指的是通过CAS来实现的</p>
<p><code>头文件</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><code>volatile</code>关键字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加上volatile关键字那么各个线程不再缓存这两个变量，读的都是内存里面原来的那一份</span></span><br><span class="line"><span class="comment">//好处是主线程一旦更改这两个，子线程里面都能读取到</span></span><br><span class="line"><span class="comment">//防止多线程对共享变量进行缓存</span></span><br><span class="line"><span class="keyword">volatile</span> atomic_bool isReady = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">volatile</span> std::atomic_int num = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>实例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> atomic_bool isReady = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">volatile</span> std::atomic_int num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!isReady)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//线程让出当前CPU时间片，等待下一次调度</span></span><br><span class="line">		this_thread::<span class="built_in">yield</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">		num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//10线程都对num++100次</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;thread&gt; tlist;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">		tlist.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(task, i));</span><br><span class="line">	<span class="comment">//主线程睡两秒</span></span><br><span class="line">	this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">	isReady = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (thread &amp; c : tlist)</span><br><span class="line">		c.<span class="built_in">join</span>();</span><br><span class="line">	cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//0 1000</span></span><br></pre></td></tr></table></figure>

<h4 id="3-线程同步通信"><a href="#3-线程同步通信" class="headerlink" title="3.线程同步通信"></a>3.线程同步通信</h4><p>读者可参考这篇文章的线程同步通信一起学习，是在linux环境下的线程同步通信</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_74795952/article/details/142872020?spm=1001.2014.3001.5502">黑马程序员 | linux系统编程 | 学习笔记_linux网络操作系统项目教程黑马程序员电子版-CSDN博客</a></p>
<p>以及下面这篇</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45031801/article/details/142705048">【C++】多线程编程图文详解（多角度详解，小白一看就懂！！）-CSDN博客</a></p>
<h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><p><code>头文件</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;condition_variable&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>std::condition_variable </code><strong>是C++标准库中的一个类，用于在多线程编程中实现线程间的条件变量和线程同步。它提供了</strong>等待</strong>和<strong>通知</strong>的机制，使得线程可以等待某个条件成立时被唤醒，或者在满足某个条件时通知其他等待的线程。其提供了以下几个函数用于等待和通知线程： </p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>wait</strong></td>
<td>使当前线程进入等待状态，直到被其他线程通过**<code>notify_one()</code><strong>或</strong><code>notify_all()</code>**函数唤醒。该函数需要一个互斥锁作为参数，调用时会自动释放互斥锁，并在被唤醒后重新获取互斥锁。</td>
</tr>
<tr>
<td><strong>wait_for</strong></td>
<td>使当前线程进入等待状态，最多等待一定的时间，直到被其他线程通过<strong>notify_one()<strong>或</strong>notify_all()<strong>函数唤醒，或者等待超时。该函数需要一个互斥锁和一个时间段作为参数，返回时有两种情况：等待超时返回</strong>std::cv_status::timeout</strong>，被唤醒返回<strong>std::cv_status::no_timeout</strong>。</td>
</tr>
<tr>
<td><strong>wait_until</strong></td>
<td>使当前线程进入等待状态，直到被其他线程通过<strong>notify_one()<strong>或notify_all()函数唤醒，或者等待时间达到指定的绝对时间点。该函数需要一个互斥锁和一个绝对时间点作为参数，返回时有两种情况：时间到达返回</strong>std::cv_status::timeout</strong>，被唤醒返回<strong>std::cv_status::no_timeout</strong></td>
</tr>
<tr>
<td><strong>notify_one</strong></td>
<td>唤醒一个等待中的线程，如果有多个线程在等待，则选择其中一个线程唤醒</td>
</tr>
<tr>
<td><strong>notify_all</strong></td>
<td>唤醒所有等待中的线程，使它们从等待状态返回</td>
</tr>
</tbody></table>
<blockquote>
<p><code>std::condition_variable</code>的主要特点如下：</p>
</blockquote>
<ul>
<li>等待和通知机制：<strong>std::condition_variable</strong> 允许线程进入等待状态，直到某个条件满足时才被唤醒。线程可以调用wait函数进入等待状态，并指定一个互斥量作为参数，以确保线程在等待期间互斥量被锁定。当其他线程满足条件并调用 <em>notify_one</em> 或 <em>notify_all</em> 函数时，等待的线程将被唤醒并继续执行。</li>
<li>与互斥量配合使用：<strong>std::condition_variable</strong> 需要与互斥量（std::mutex或std::unique_lockstd::mutex）配合使用，以确保线程之间的互斥性。在等待之前，线程必须先锁定互斥量，以避免竞争条件。当条件满足时，通知其他等待的线程之前，必须再次锁定互斥量。</li>
<li>支持超时等待：<strong>std::condition_variable</strong>提供了带有超时参数的等待函数 <strong>wait_for</strong> 和<strong>wait_until</strong>，允许线程在等待一段时间后自动被唤醒。这对于处理超时情况或限时等待非常有用。</li>
</ul>
<blockquote>
<p>使用std::condition_variable的一般步骤如下：</p>
</blockquote>
<ol>
<li>创建一个std::condition_variable对象。</li>
<li>创建一个互斥量对象（std::mutex或std::unique_lock<a href="std::mutex">std::mutex</a>）。</li>
<li>在等待线程中，使用std::unique_lock锁定互斥量，并调用wait函数进入等待状态。</li>
<li>在唤醒线程中，使用std::unique_lock锁定互斥量，并调用notify_one或notify_all函数通知等待的线程。</li>
<li>等待线程被唤醒后，继续执行相应的操作。</li>
</ol>
<p><strong>示例：</strong> </p>
<blockquote>
<p>模拟一个简单的计数器。一个线程负责增加计数，另一个线程等待并打印计数的值。 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;condition_variable&gt;</span><br><span class="line">// 定义共享变量和相关的同步工具</span><br><span class="line">int count = 0; // 计数器</span><br><span class="line">std::mutex mtx; // 互斥锁</span><br><span class="line">std::condition_variable cv; // 条件变量</span><br><span class="line">// 增加计数的线程函数</span><br><span class="line">void increment() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 5; ++i) &#123;</span><br><span class="line">   std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模拟工作</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; lock(mtx); // 使用 unique_lock</span><br><span class="line">        count++; // 增加计数</span><br><span class="line">        std::cout &lt;&lt; &quot;计数增加到: &quot; &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">        cv.notify_one(); // 通知其他线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 打印计数的线程函数</span><br><span class="line">void print() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 5; ++i) &#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; lock(mtx); // 加锁</span><br><span class="line">        cv.wait(lock); // 等待通知</span><br><span class="line">        std::cout &lt;&lt; &quot;当前计数是: &quot; &lt;&lt; count &lt;&lt; std::endl; // 打印计数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::thread t1(increment); // 创建增加计数的线程</span><br><span class="line">    std::thread t2(print); // 创建打印计数的线程</span><br><span class="line">    t1.join(); // 等待线程完成</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>共享变量</strong>：</p>
<ul>
<li><strong><code>int count = 0;</code></strong>：定义一个共享的计数器。</li>
<li><strong><code>std::mutex mtx;</code></strong>：定义一个互斥锁，用于保护共享变量 <strong><code>count</code></strong>。</li>
<li><code>std::condition_variable cv;</code>：定义一个条件变量，用于线程同步。</li>
</ul>
<p><strong>增加计数的线程</strong> (<code>increment</code> 函数)：</p>
<ul>
<li>使用 <strong><code>std::this_thread::sleep_for</code></strong> 模拟工作，增加计数器的值。</li>
<li>使用 <strong><code>std::lock_guard</code></strong> 加锁，以确保在修改 <code>count</code> 时没有其他线程干扰。</li>
<li>增加计数并打印当前值，然后使用 <code>cv.notify_one()</code> 通知等待的线程。</li>
</ul>
<p><strong>打印计数的线程</strong> (<code>print</code> 函数)：</p>
<ul>
<li>使用 <strong><code>cv.wait(lock)</code></strong> 等待通知，只有当 <strong><code>increment</code></strong> 函数通知时才会继续执行。</li>
<li>打印当前的计数值。</li>
</ul>
<h5 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h5><p>通过信号量实现线程间的通信（即互相通知）</p>
<p><code>生产者消费者模型</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;<span class="comment">//定义互斥锁</span></span><br><span class="line">condition_variable cv;<span class="comment">//定义条件变量，做线程间的同步通信操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//生产物品</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//这个一定要加上，因为put和get是在不同的线程里面调用的，一个生产者调用一个消费者调用</span></span><br><span class="line">		<span class="function">unique_lock&lt;mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//que不为空，生产者应该通知消费者去消费，消费完了，再继续生产</span></span><br><span class="line">			<span class="comment">//生产者线程应该进入等待状态，并且把mtx互斥锁释放掉</span></span><br><span class="line">			<span class="comment">//阻塞等待的时候应该先把mtx释放掉，不然消费者也没法消费</span></span><br><span class="line">			cv.<span class="built_in">wait</span>(lck);<span class="comment">//一进入等待状态就把锁释放掉了</span></span><br><span class="line">		&#125;</span><br><span class="line">		que.<span class="built_in">push</span>(val);</span><br><span class="line">		<span class="comment">//通知其他所有线程，已经生产好了物品，去消费吧</span></span><br><span class="line">		cv.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		cv.notify_all：通知其他所有线程</span></span><br><span class="line"><span class="comment">		cv.notify_one：通知另外的一个线程</span></span><br><span class="line"><span class="comment">		其他线程得到该通知，就会从等待状态变为阻塞态，还得拿到锁以后才可以继续执行</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;生产者 生产:&quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;号物品&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//消费物品</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">unique_lock&lt;mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (que.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//消费者发现没有东西可以消费，通知生产者生产</span></span><br><span class="line">			cv.<span class="built_in">wait</span>(lck);<span class="comment">//一进入等待状态就把锁释放掉了</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> val = que.<span class="built_in">front</span>();</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">		cv.<span class="built_in">notify_all</span>();<span class="comment">//通知其他线程（生产者），我消费完了，赶紧生产</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;消费者 消费&quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;号物品&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(Queue* que)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		que-&gt;<span class="built_in">put</span>(i);</span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(Queue* que)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> val = que-&gt;<span class="built_in">get</span>();</span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Queue que;</span><br><span class="line">	<span class="comment">//传入两者共享的队列</span></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(producer, &amp;que)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(consumer, &amp;que)</span></span>;</span><br><span class="line"></span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="五、设计模式"><a href="#五、设计模式" class="headerlink" title="五、设计模式"></a>五、设计模式</h2><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241014203719890.png" alt="image-20241014203719890"></p>
<p>这里贴出常用的23中设计模式。视频课程仅包含部分，剩余部分需要找其他课程或者资料进行自学。</p>
<h3 id="1-设计模式三大类型概述"><a href="#1-设计模式三大类型概述" class="headerlink" title="1.设计模式三大类型概述"></a>1.设计模式三大类型概述</h3><p>C++设计模式是一套被广泛认可的用于解决常见软件设计问题的最佳实践，它们可以帮助开发者编写更加清晰、可维护和可扩展的代码。根据解决的问题类型，设计模式通常被分为三大类：创建型、结构型和行为型。以下是对每一大类的概述及其特点：</p>
<h4 id="一、创建型设计模式"><a href="#一、创建型设计模式" class="headerlink" title="一、创建型设计模式"></a>一、创建型设计模式</h4><p>创建型设计模式主要关注于对象的创建机制，帮助使系统独立于如何创建、组合和表示对象。</p>
<ul>
<li><strong>特点</strong>：<ul>
<li>将对象的创建和使用分离，增加代码的灵活性和可维护性。</li>
<li>通过定义创建对象的接口或方法，使得子类或具体实现类可以决定实例化哪个类。</li>
</ul>
</li>
<li><strong>常见模式</strong>：<ul>
<li><strong>单例模式（Singleton）</strong>：确保一个类只有一个实例，并提供一个全局访问点。</li>
<li><strong>工厂方法模式（Factory Method）</strong>：定义一个用于创建对象的接口，让子类决定实例化哪一个类。</li>
<li><strong>抽象工厂模式（Abstract Factory）</strong>：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</li>
<li><strong>建造者模式（Builder）</strong>：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</li>
<li><strong>原型模式（Prototype）</strong>：通过复制现有的实例来创建新的实例，而不是通过新建类。</li>
</ul>
</li>
</ul>
<h4 id="二、结构型设计模式"><a href="#二、结构型设计模式" class="headerlink" title="二、结构型设计模式"></a>二、结构型设计模式</h4><p>结构型设计模式关注于类和对象的组合，用于形成更大的结构，以解决如何将对象和类组合成较大的结构，同时保持结构的灵活和高效。</p>
<ul>
<li><strong>特点</strong>：<ul>
<li>通过组合和继承等方式，将对象或类组合成更大的结构。</li>
<li>强调对象之间的静态关系，以及如何通过不同的组合方式获得更加灵活的程序结构。</li>
</ul>
</li>
<li><strong>常见模式</strong>：<ul>
<li><strong>适配器模式（Adapter）</strong>：将一个类的接口转换成客户期望的另一个接口。</li>
<li><strong>桥接模式（Bridge）</strong>：将抽象部分与实现部分分离，使它们可以独立变化。</li>
<li><strong>组合模式（Composite）</strong>：将对象组合成树形结构以表示“部分-整体”的层次结构。</li>
<li><strong>装饰器模式（Decorator）</strong>：动态地给一个对象添加一些额外的职责。</li>
<li><strong>外观模式（Facade）</strong>：提供一个统一的接口，用来访问子系统中的一群接口。</li>
<li><strong>享元模式（Flyweight）</strong>：运用共享技术有效地支持大量细粒度的对象。</li>
<li><strong>代理模式（Proxy）</strong>：为其他对象提供一种代理以控制对这个对象的访问。</li>
</ul>
</li>
</ul>
<h4 id="三、行为型设计模式"><a href="#三、行为型设计模式" class="headerlink" title="三、行为型设计模式"></a>三、行为型设计模式</h4><p>行为型设计模式特别关注对象之间的通信，以及如何通过对象之间的协作来实现特定的功能。</p>
<ul>
<li><strong>特点</strong>：<ul>
<li>强调对象之间的动态关系，以及如何通过对象之间的交互来实现特定的行为。</li>
<li>通过定义对象之间的交互规则和通信方式，使得系统更加灵活和可扩展。</li>
</ul>
</li>
<li><strong>常见模式</strong>：<ul>
<li><strong>责任链模式（Chain of Responsibility）</strong>：为请求创建一个接收者对象的链。</li>
<li><strong>命令模式（Command）</strong>：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化。</li>
<li><strong>解释器模式（Interpreter）</strong>：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</li>
<li><strong>迭代器模式（Iterator）</strong>：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露其内部的表示。</li>
<li><strong>中介者模式（Mediator）</strong>：用一个中介对象来封装一系列的对象交互。</li>
<li><strong>备忘录模式（Memento）</strong>：在不破坏封装的前提下，捕获并保存一个对象的内部状态，以便在将来的时间点上恢复对象到这个状态。</li>
<li><strong>观察者模式（Observer）</strong>：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</li>
<li><strong>状态模式（State）</strong>：允许一个对象在其内部状态改变时改变它的行为。</li>
<li><strong>策略模式（Strategy）</strong>：定义一系列的算法，把它们一个个封装起来，并使它们可相互替换。</li>
<li><strong>模板方法模式（Template Method）</strong>：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。</li>
<li><strong>访问者模式（Visitor）</strong>：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</li>
</ul>
</li>
</ul>
<p>综上所述，C++中的创建型、结构型和行为型设计模式各具特点，分别关注于对象的创建、组合以及对象之间的通信和协作。这些设计模式在软件开发中具有重要的应用价值，可以帮助开发者编写更加清晰、可维护和可扩展的代码。</p>
<h3 id="2-设计模式三大原则"><a href="#2-设计模式三大原则" class="headerlink" title="2.设计模式三大原则"></a>2.设计模式三大原则</h3><p>设计模式的三大原则通常指的是<strong>开闭原则</strong>（Open&#x2F;Closed Principle）、<strong>里氏替换原则</strong>（Liskov Substitution Principle）和<strong>依赖倒置原则</strong>（Dependency Inversion Principle），它们是面向对象设计的基本原则，旨在提高代码的灵活性、可维护性和可扩展性。以下是这三个原则的清晰简洁解释：</p>
<ol>
<li><p>开闭原则（Open&#x2F;Closed Principle）</p>
<p>：</p>
<ul>
<li><strong>解释</strong>：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着当需要添加新功能时，应该通过扩展现有代码（例如添加新类、新接口等）来实现，而不是修改已有代码。</li>
<li><strong>目的</strong>：提高代码的灵活性和可维护性，减少因修改已有代码而引入的潜在错误。</li>
</ul>
</li>
<li><p>里氏替换原则（Liskov Substitution Principle）</p>
<p>：</p>
<ul>
<li><strong>解释</strong>：子类必须能够替换它们的基类而不会导致程序出错。这要求子类必须完全遵守基类所定义的接口契约，即子类在替换基类时，其行为应该与基类保持一致。</li>
<li><strong>目的</strong>：确保系统的稳定性和可靠性，避免子类破坏基类的行为预期。</li>
</ul>
</li>
<li><p>依赖倒置原则（Dependency Inversion Principle）</p>
<p>：</p>
<ul>
<li><strong>解释</strong>：高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。这意味着在设计中，应该通过接口或抽象类来定义高层模块和低层模块之间的交互，而不是直接依赖于具体的实现类。</li>
<li><strong>目的</strong>：降低模块之间的耦合度，提高系统的可扩展性和可维护性。通过依赖抽象而不是具体实现，可以更容易地在不改变高层模块的情况下替换低层模块的实现。</li>
</ul>
</li>
</ol>
<p>这三大原则共同构成了面向对象设计的基础，它们指导我们如何设计更加灵活、可维护和可扩展的软件系统。遵循这些原则，可以帮助我们避免常见的设计问题，提高代码的质量和可维护性。</p>
<h3 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3.单例模式"></a>3.单例模式</h3><p><code>单例模式：</code>一个类不管创建多少次对象，永远只能得到该类型的一个对象的实例</p>
<p>常用到的，比如日志模块，数据库模块</p>
<p><strong>需要注意的五个点</strong>：</p>
<p>1、需要将构造函数私有化，这样保证使用者无法通过构造函数创建新的单例对象<br>2、需要定义一个唯一的static实例对象<br>3、需要提供对外的接口返回这个唯一的实例对象<br>4、需要删除拷贝构造函数和赋值运算符重载函数，保证使用者不能通过者二者构造新的对象<br>5、在类内声明了static对象，还需要在类外进行定义</p>
<p>分为两类：</p>
<p><code>饿汉式单例模式：</code>还没有获取实例对象，实例对象就已经产生了<br><code>懒汉式单例模式：</code>唯一的实例对象，直到第一次获取它的时候，才产生（初始化)</p>
<h4 id="1-饿汉单例模式"><a href="#1-饿汉单例模式" class="headerlink" title="1.饿汉单例模式"></a>1.饿汉单例模式</h4><p><strong>饿汉单例模式 一定是线程安全的</strong></p>
<p>**饿汉式单例模式在类加载时就创建实例。**这种方式的特点是线程安全，因为实例在类加载时就已经被初始化，而类加载是线程安全的（由类加载器保证）。此外，饿汉式单例模式的实现相对简单。然而，它的缺点是即使实例没有被使用，它也会在类加载时被创建，这可能会导致内存浪费。</p>
<p><code>创建步骤：</code></p>
<p>1.构造函数私有化 使得用户不能随意调用构造函数，没有那么轻易的创建对象的实例</p>
<p>2.定义一个唯一的类的实例对象（既然已经让用户难以调用构造函数，那么类应该提供这个唯一的实例化对象）</p>
<p>3.定义接口让用户有办法获取类的唯一实例化对象的方法，通常返回的都是指针类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span><span class="comment">//3.定义接口让用户有办法获取类的唯一实例化对象的方法</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;instance;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> Singleton instance;<span class="comment">//2.定义一个唯一的类的实例对象（既然已经让用户难以调用构造函数，那么类应该提供这个唯一的实例化对象）</span></span><br><span class="line">	<span class="built_in">Singleton</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;<span class="comment">// 1.构造函数私有化 使得用户不能随意调用构造函数，没有那么轻易的创建对象的实例</span></span><br><span class="line">	<span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton Singleton::instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//打印出来的p1 p2 p3 都是同一块地址</span></span><br><span class="line">	Singleton* p1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	Singleton* p2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	Singleton* p3 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-懒汉单例模式"><a href="#2-懒汉单例模式" class="headerlink" title="2.懒汉单例模式"></a>2.懒汉单例模式</h4><p>**懒汉式单例模式在首次使用时才创建实例。**这种方式的特点是实现了延迟加载，即只有在需要实例时才创建它，从而节省了内存。</p>
<p>把静态变量设置为指针，通过初始化为空的方式不去分配内存，直到使用时（调用get）才去分配内存。</p>
<p><code>创建步骤：</code></p>
<p>1.构造函数私有化 使得用户不能随意调用构造函数，没有那么轻易的创建对象的实例</p>
<p>2.定义一个唯一的类的实例对象（既然已经让用户难以调用构造函数，那么类应该提供这个唯一的实例化对象）</p>
<p>3.定义接口让用户有办法获取类的唯一实例化对象的方法，通常返回的都是指针类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span><span class="comment">//3.定义接口让用户有办法获取类的唯一实例化对象的方法</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> Singleton *instance;<span class="comment">//2.定义一个唯一的类的实例对象（既然已经让用户难以调用构造函数，那么类应该提供这个唯一的实例化对象）</span></span><br><span class="line">	<span class="built_in">Singleton</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;<span class="comment">// 1.构造函数私有化 使得用户不能随意调用构造函数，没有那么轻易的创建对象的实例</span></span><br><span class="line">	<span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Singleton* p1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	Singleton* p2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	Singleton* p3 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然而，懒汉式单例模式在多线程环境下可能会出现线程安全问题，即多个线程可能会同时创建实例，导致违反单例原则。为了解决这个问题，可以在创建实例的方法上加上同步关键字（synchronized），但这会降低性能。</p>
<p>为了解决懒汉式单例模式在多线程环境下的线程安全问题和性能问题，可以采用双重检查锁定（Double-Checked Locking）和volatile关键字。双重检查锁定可以确保在创建实例时只进行一次同步操作，而volatile关键字可以确保<strong>变量的可见性和禁止指令重排序</strong>，从而避免在创建实例时出现线程安全问题。</p>
<h3 id="4-线程安全的懒汉单例模式"><a href="#4-线程安全的懒汉单例模式" class="headerlink" title="4.线程安全的懒汉单例模式"></a>4.线程安全的懒汉单例模式</h3><p>**可重入函数：**这个函数还没执行完，可不可以再被调用一次</p>
<p>在单线程中不可能发生（除了递归），在多线程中可能，线程1还没运行完，线程2就来运行了</p>
<p>如果这个函数可以在多线程环境下直接运行而且不发生竞态条件，那就是<code>可重入函数</code></p>
<p>而懒汉单例模式中，getIntance并不是线程安全的</p>
<p>线程1进去了，还没给instance赋值，时间片到了给了线程2，那线程2就给instance赋值了，所以不是可重入函数，<strong>所以懒汉单例模式并不是线程安全的</strong></p>
<h4 id="1-锁-双重判断"><a href="#1-锁-双重判断" class="headerlink" title="1.锁+双重判断"></a>1.锁+双重判断</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line"><span class="comment">//锁+双重判断</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//锁的粒度太大了 在单线程环境中也要不停地加锁解锁</span></span><br><span class="line">		<span class="comment">//lock_guard&lt;mutex&gt; guard(mtx);</span></span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//放到if里面，只要创建过，后面就不会进来if</span></span><br><span class="line">			<span class="function">lock_guard&lt;mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line">			<span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">					1.开辟内存</span></span><br><span class="line"><span class="comment">					2.构造对象</span></span><br><span class="line"><span class="comment">					3.给instance赋值</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//不加volatile的默认情况下，线程会对代码数据段拷贝一份副本，自己看自己的副本，加上以后不拷贝副本，只要instance发生改变，所有线程都能立马看到它改变了</span></span><br><span class="line">	<span class="comment">//注意在下面初始化的时候也要加上volatile关键字</span></span><br><span class="line">	<span class="type">static</span> Singleton * <span class="keyword">volatile</span> instance;</span><br><span class="line">	<span class="built_in">Singleton</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* <span class="keyword">volatile</span> Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Singleton* p1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	Singleton* p2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	Singleton* p3 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：1.不加volatile的默认情况下，线程会对代码数据段拷贝一份副本，自己看自己的副本，加上以后不拷贝副本，只要instance发生改变，所有线程都能立马看到它改变了</p>
<p>2.在下面初始化的时候也要加上volatile关键字</p>
<p>3.new具体步骤补充</p>
<ol>
<li><strong>开辟内存</strong>：<code>new</code> 操作符首先为对象分配足够的内存空间。这是通过调用底层的内存分配函数（如 <code>malloc</code>，尽管在 C++ 中更常见的是使用 <code>operator new</code>）来完成的。这个步骤确保了对象有足够的空间来存储其数据成员。</li>
<li><strong>构造对象</strong>：一旦内存被分配，<code>new</code> 操作符就会在该内存位置上调用类的构造函数来初始化对象。这是对象实际被“创建”或“构造”的时刻，它的数据成员被赋予初始值（如果有的话）。</li>
<li><strong>给 <code>instance</code> 赋值</strong>：最后，<code>new</code> 操作符返回指向新构造对象的指针，这个指针随后被赋值给静态成员变量 <code>instance</code>。这一步是将新创建的对象与类的静态成员变量关联起来的关键。</li>
</ol>
<h4 id="2-简洁的线程安全懒汉单例模式"><a href="#2-简洁的线程安全懒汉单例模式" class="headerlink" title="2.简洁的线程安全懒汉单例模式"></a>2.简洁的线程安全懒汉单例模式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">static</span> Singleton instance;</span><br><span class="line">		<span class="keyword">return</span> &amp;instance;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在C++中，类的静态局部变量的内存确实在程序启动时就已经为其预留，但是变量的初始化会延迟到第一次执行到它所在的代码块，所以这也是一种懒汉单例模式</p>
<p><strong>而函数静态局部变量的初始化，在汇编指令上已经自动添加线程互斥指令了，因此不用担心线程安全的问题</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">static</span> Singleton instance;</span><br><span class="line">		<span class="keyword">return</span> &amp;instance;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Singleton* p1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	Singleton* p2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	Singleton* p3 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-简单工厂-Simple-Factor-、工厂方法-Factory-Method"><a href="#5-简单工厂-Simple-Factor-、工厂方法-Factory-Method" class="headerlink" title="5.简单工厂(Simple Factor)、工厂方法(Factory Method)"></a>5.简单工厂(Simple Factor)、工厂方法(Factory Method)</h3><p><code>工厂模式：</code>主要是封装了对象的创建操作</p>
<h4 id="1-简单工厂"><a href="#1-简单工厂" class="headerlink" title="1.简单工厂"></a>1.简单工厂</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Car</span>(string name):_name(name)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BMW</span>(string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获得了一辆宝马汽车&quot;</span> &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Audi</span>(string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获得了一辆奥迪汽车&quot;</span> &lt;&lt; _name &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CarType</span></span><br><span class="line">&#123;</span><br><span class="line">	Bmw, AUDI</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Car* <span class="title">createCar</span><span class="params">(CarType ct)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (ct)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> Bmw:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BMW</span>(<span class="string">&quot;X1&quot;</span>);</span><br><span class="line">		<span class="keyword">case</span> AUDI:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(<span class="string">&quot;A6&quot;</span>);</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			cerr &lt;&lt; <span class="string">&quot;传入工厂的参数不正确:&quot;</span> &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*1.原来是这样的，但是对于用户来说根本不需要知道什么X1，X6什么的</span></span><br><span class="line"><span class="comment">	Car* p1 = new BMW(&quot;X1&quot;);</span></span><br><span class="line"><span class="comment">	Car* p2 = new Audi(&quot;A6&quot;);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*2.</span></span><br><span class="line"><span class="comment">	SimpleFactory* factory = new SimpleFactory();</span></span><br><span class="line"><span class="comment">	Car* p1 = factory-&gt;createCar(Bmw);</span></span><br><span class="line"><span class="comment">	Car* p2 = factory-&gt;createCar(AUDI);</span></span><br><span class="line"><span class="comment">	p1-&gt;show();</span></span><br><span class="line"><span class="comment">	p2-&gt;show();</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.使用智能指针管理资源</span></span><br><span class="line">	<span class="function">unique_ptr&lt;SimpleFactory&gt; <span class="title">factory</span><span class="params">(<span class="keyword">new</span> SimpleFactory())</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Car&gt; <span class="title">p1</span><span class="params">(factory-&gt;createCar(Bmw))</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Car&gt; <span class="title">p2</span><span class="params">(factory-&gt;createCar(AUDI))</span></span>;</span><br><span class="line"></span><br><span class="line">	p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">	p2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该例子中使用SimpleFactory类封装两个汽车类的创建操作</p>
<p>一共2种使用方法，即代码中的2种，直接用或者通过智能指针间接用</p>
<p>简单工厂模式（Simple Factory）的缺点主要包括以下几个方面：</p>
<ol>
<li>违反开闭原则<ul>
<li>开闭原则要求软件实体（类、模块、函数等）应该是可扩展的，但不可修改的。然而，在简单工厂模式中，每当需要增加新的产品时，都需要修改工厂类中的判断逻辑，从而违反了开闭原则。</li>
</ul>
</li>
<li>高内聚问题<ul>
<li>简单工厂模式中的工厂类通常负责所有产品的创建，这导致工厂类的职责过重，不符合高内聚的原则。高内聚要求一个模块或类应该只负责一个功能或一个紧密相关的功能集合。</li>
</ul>
</li>
<li>不利于扩展和维护<ul>
<li>由于简单工厂模式中的工厂类集中了所有产品的创建逻辑，随着产品种类的增加，工厂类的逻辑将变得越来越复杂，不利于系统的扩展和维护。</li>
<li>当需要添加新产品时，需要修改工厂类的代码，这增加了代码的维护成本。</li>
</ul>
</li>
<li>测试困难<ul>
<li>在简单工厂模式中，由于工厂类与具体产品类之间存在紧密的耦合关系，这增加了单元测试的难度。为了测试某个具体产品类，可能需要先实例化工厂类，并调用其创建方法，这可能会引入不必要的依赖和复杂性。</li>
</ul>
</li>
<li>缺乏灵活性<ul>
<li>简单工厂模式通常使用静态方法或全局方法来创建对象，这限制了对象的创建方式和灵活性。例如，在某些情况下，可能需要使用不同的创建策略或根据不同的上下文创建不同的对象实例，但简单工厂模式无法提供这种灵活性。</li>
</ul>
</li>
</ol>
<p>所以有了工厂方法和抽象工厂</p>
<h4 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2.工厂方法"></a>2.工厂方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Car</span>(string name):_name(name)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BMW</span>(string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获得了一辆宝马汽车&quot;</span> &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Audi</span>(string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获得了一辆奥迪汽车&quot;</span> &lt;&lt; _name &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Car* <span class="title">createCar</span><span class="params">(string name)</span> </span>= <span class="number">0</span>;<span class="comment">//这个就是所谓的工厂方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMWFactory</span> :<span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Car* <span class="title">createCar</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BMW</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudiFactory</span> :<span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Car* <span class="title">createCar</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">unique_ptr&lt;Factory&gt; <span class="title">bmwfty</span><span class="params">(<span class="keyword">new</span> BMWFactory())</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Factory&gt; <span class="title">audifty</span><span class="params">(<span class="keyword">new</span> AudiFactory())</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Car&gt; <span class="title">p1</span><span class="params">(bmwfty-&gt;createCar(<span class="string">&quot;X6&quot;</span>))</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Car&gt; <span class="title">p2</span><span class="params">(audifty-&gt;createCar(<span class="string">&quot;A8&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">	p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">	p2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Factory的纯虚函数就是工厂方法</p>
<p><strong>其实就是对每个类有又单独创建了一个创建它的对象的类，就相当于封装了</strong></p>
<p>1.完成了对对象的封装操作</p>
<p>2.贴合了软件的开闭原则（对原来已有的功能封闭，对扩展新功能开放）</p>
<p>一个工厂对应了一个类的创建，如果类很多的话会导致工厂也很多</p>
<p><code>缺点：</code>灵活性受限</p>
<ul>
<li>工厂方法模式通常用于创建单个产品对象，如果需要创建多个相关或依赖的产品对象，可能需要使用其他模式（如抽象工厂模式）来替代。</li>
</ul>
<h3 id="6-抽象工厂-Abstract-Factory"><a href="#6-抽象工厂-Abstract-Factory" class="headerlink" title="6.抽象工厂(Abstract Factory)"></a>6.抽象工厂(Abstract Factory)</h3><p>对有一组关联关系的产品簇提供产品对象的统一创建</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Car</span>(string name):_name(name)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BMW</span>(string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获得了一辆宝马汽车&quot;</span> &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Audi</span>(string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获得了一辆奥迪汽车&quot;</span> &lt;&lt; _name &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//车的相关系列产品 车灯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Light</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BmwLight</span> :<span class="keyword">public</span> Light</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot; BMW Light&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudiLight</span> :<span class="keyword">public</span> Light</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot; Audi Light&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂 对有一组关联关系的产品簇提供产品对象的统一创建</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//这个就是所谓的工厂方法</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Car* <span class="title">createCar</span><span class="params">(string name)</span> </span>= <span class="number">0</span>;<span class="comment">//工厂方法 创建车</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Light* <span class="title">createCarLight</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//工厂方法 创建汽车关联的产品车灯</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMWFactory</span> :<span class="keyword">public</span> AbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Car* <span class="title">createCar</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BMW</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Light* <span class="title">createCarLight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BmwLight</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudiFactory</span> :<span class="keyword">public</span> AbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Car* <span class="title">createCar</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Light* <span class="title">createCarLight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AudiLight</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">unique_ptr&lt;AbstractFactory&gt; <span class="title">bmwfty</span><span class="params">(<span class="keyword">new</span> BMWFactory())</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;AbstractFactory&gt; <span class="title">audifty</span><span class="params">(<span class="keyword">new</span> AudiFactory())</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Car&gt; <span class="title">p1</span><span class="params">(bmwfty-&gt;createCar(<span class="string">&quot;X6&quot;</span>))</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Car&gt; <span class="title">p2</span><span class="params">(audifty-&gt;createCar(<span class="string">&quot;A8&quot;</span>))</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Light&gt; <span class="title">l1</span><span class="params">(bmwfty-&gt;createCarLight())</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Light&gt; <span class="title">l2</span><span class="params">(audifty-&gt;createCarLight())</span></span>;</span><br><span class="line"></span><br><span class="line">	p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">	p2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">	l1-&gt;<span class="built_in">show</span>();</span><br><span class="line">	l2-&gt;<span class="built_in">show</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>缺点：不支持单一产品的变化</p>
<ul>
<li>抽象工厂模式适用于一组相关产品的创建，但如果只有一个产品发生变化，那么整个工厂都需要进行修改，可能不够灵活。</li>
</ul>
<p>其他的类甚至也要重写AbstractFactory里面新加的这个产品，不然自己的类会变成虚函数，但是实际上其他类本身也不提供这个产品（比如宝马课程生产一个螺丝奥迪可能就没有，这个时候就挺尴尬）</p>
<p><strong>小结：</strong></p>
<p><strong>简单工厂 Simple Factory :</strong></p>
<p>**优点：**把对象的创建封装在一个接口函数里面,通过传入不同的标识,返回创建的对象</p>
<p>客户不用自己负责new对象,不用了解对象创建的详细过程</p>
<p>**缺点：**提供创建对象实例的接口函数不闭合,不能对修改关闭</p>
<p><strong>工厂方法 Factory Method</strong></p>
<p>**优点：**Factory基类,提供了一个纯虚函数(创建产品)，定义派生类(具体产品的工厂)负责创建对应的</p>
<p>产品,可以做到不同的产品,在不同的工厂里面创建,能够对现有工厂,以及产品的修改关闭</p>
<p>**缺点：**实际上,很多产品是有关联关系的,属于一个产品簇,不应该放在不同的工厂里面去创建,这样</p>
<p>一是不符合实际的产品对象创建逻辑,二是工厂类太多了,不好维护</p>
<p><strong>抽象工厂 Abstract Factory</strong></p>
<p>**优点：**把有关联关系的,属于一个产品簇的所有产品创建的接口函数,放在一个抽象工厂里面AbstractFactroy，派生类(具体产品的工厂)应该负责创建该产品簇里面所有的产品</p>
<p>**缺点：**抽象工厂模式适用于一组相关产品的创建，但如果只有一个产品发生变化，那么整个工厂都需要进行修改，可能不够灵活。</p>
<h3 id="7-代理模式（Proxy）"><a href="#7-代理模式（Proxy）" class="headerlink" title="7.代理模式（Proxy）"></a>7.代理模式（Proxy）</h3><p>通过代理类，来控制实际对象的访问权限</p>
<p><strong>代理模式（Proxy Pattern）</strong> 是一种结构型设计模式，它提供一个对象的代理，以控制对这个对象的访问。代理对象作为客户端和目标对象之间的中介，客户端通过代理对象间接地访问目标对象。代理模式常用于延迟加载、访问控制、缓存等功能。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li><strong>隐藏实现细节</strong>：客户端通过代理对象访问目标对象，不需要知道目标对象的具体实现。</li>
<li><strong>增强目标对象</strong>：可以在不修改目标对象代码的情况下，为目标对象添加额外的功能。</li>
<li><strong>控制访问</strong>：可以对目标对象的访问进行权限控制。</li>
<li><strong>减少系统开销</strong>：例如，通过代理实现延迟加载，减少系统资源的消耗。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><strong>性能损耗</strong>：代理对象会增加一层调用开销，虽然这个开销通常很小，但在高性能要求的场景下可能会成为瓶颈。</li>
<li><strong>代码复杂度增加</strong>：引入代理模式后，系统的代码复杂度会增加。</li>
</ol>
<p><strong>步骤：</strong></p>
<p>1.抽象公共类</p>
<p>2.委托类（继承自公共类）</p>
<p>3.代理类（继承自公共类）</p>
<p>4.以组合的方式使用代理对象</p>
<p>5.客户直接访问代理对象 相当于客户只能访问助理，不能直接访问老板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户   助理proxy   老板 委托类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoSite</span><span class="comment">//1.抽象类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//免费看电影</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//vip看</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMovie</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//用券才能看</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FixBugVideoSite</span>:<span class="keyword">public</span> VideoSite<span class="comment">//2.委托类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;观看免费电影&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;观看vip电影&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMovie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;用券观看电影&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FreeVideoSiteProxy</span> :<span class="keyword">public</span> VideoSite</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">FreeVideoSiteProxy</span>() &#123; pVideo = <span class="keyword">new</span> <span class="built_in">FixBugVideoSite</span>(); &#125;</span><br><span class="line">	~<span class="built_in">FreeVideoSiteProxy</span>() &#123; <span class="keyword">delete</span> pVideo; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pVideo-&gt;<span class="built_in">freeMovie</span>();<span class="comment">//通过代理对象的freemovie访问委托类真正的freemovie</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您目前只是普通用户，需要升级VIP才能观看VIP电影&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMovie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您目前没有券，需要购买电影券才能观看该电影&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	VideoSite* pVideo;<span class="comment">//4.以组合的方式使用代理对象</span></span><br><span class="line">	<span class="comment">//或者去掉构造和析构，直接调用委托类也行 </span></span><br><span class="line">	<span class="comment">//FixBugVideoSite Video</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VipVideoSiteProxy</span> :<span class="keyword">public</span> VideoSite</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">VipVideoSiteProxy</span>() &#123; pVideo = <span class="keyword">new</span> <span class="built_in">FixBugVideoSite</span>(); &#125;</span><br><span class="line">	~<span class="built_in">VipVideoSiteProxy</span>() &#123; <span class="keyword">delete</span> pVideo; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pVideo-&gt;<span class="built_in">freeMovie</span>();<span class="comment">//通过代理对象的freemovie访问委托类真正的freemovie</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pVideo-&gt;<span class="built_in">vipMovie</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMovie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您目前没有券，需要购买电影券才能观看该电影&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	VideoSite* pVideo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这些都是通用的API接口，使用的都是基类的指针或者引用 通过多态访问虚函数就是了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">watchMovice</span><span class="params">(unique_ptr&lt;VideoSite&gt; &amp;ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ptr-&gt;<span class="built_in">freeMovie</span>();</span><br><span class="line">	ptr-&gt;<span class="built_in">vipMovie</span>();</span><br><span class="line">	ptr-&gt;<span class="built_in">ticketMovie</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*1.只有委托类，没有代理类</span></span><br><span class="line"><span class="comment">	同一个用户p1看的时候可能就还得对这些调用加if else判断</span></span><br><span class="line"><span class="comment">	来判断身份从而控制访问权限，什么电影能看，什么不能看，很麻烦，不灵活*/</span></span><br><span class="line">	VideoSite* p1 = <span class="keyword">new</span> <span class="built_in">FixBugVideoSite</span>();</span><br><span class="line">	p1-&gt;<span class="built_in">freeMovie</span>();</span><br><span class="line">	p1-&gt;<span class="built_in">vipMovie</span>();</span><br><span class="line">	p1-&gt;<span class="built_in">ticketMovie</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*2.</span></span><br><span class="line"><span class="comment">	通过代理，不同身份的用户可以对不同类型的电影具有不同的访问权限</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第五步，客户直接访问代理对象 相当于客户只能访问助理，不能直接访问老板</span></span><br><span class="line">	<span class="comment">//游客</span></span><br><span class="line">	<span class="function">unique_ptr&lt;VideoSite&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> FreeVideoSiteProxy())</span></span>;</span><br><span class="line">	<span class="built_in">watchMovice</span>(p2);</span><br><span class="line">	<span class="comment">//VIP</span></span><br><span class="line">	<span class="function">unique_ptr&lt;VideoSite&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> VipVideoSiteProxy())</span></span>;</span><br><span class="line">	<span class="built_in">watchMovice</span>(p3);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>类和接口的说明：</code></p>
<ol>
<li><strong>VideoSite</strong>：这是一个抽象基类，定义了三个纯虚函数<code>freeMovie</code>、<code>vipMovie</code>和<code>ticketMovie</code>，分别代表观看免费电影、VIP电影和用券观看电影的功能。这个类作为所有视频站点（包括代理和委托）的接口。</li>
<li><strong>FixBugVideoSite</strong>：这是<code>VideoSite</code>的一个具体实现，即委托类。它实现了所有三个虚函数，分别输出相应的观看信息。这个类代表了一个实际的视频站点，提供了观看电影的具体功能。</li>
<li><strong>FreeVideoSiteProxy</strong>和<strong>VipVideoSiteProxy</strong>：这两个类都是<code>VideoSite</code>的代理类。它们各自持有一个指向<code>VideoSite</code>（实际上是<code>FixBugVideoSite</code>）的指针，用于在需要时调用委托类的功能。代理类通过重写虚函数来控制对委托类功能的访问，例如，普通用户（<code>FreeVideoSiteProxy</code>）不能观看VIP电影或用券观看电影，而VIP用户（<code>VipVideoSiteProxy</code>）则可以观看VIP电影，但仍然不能用券观看（在这个例子中，VIP用户是否能用券观看取决于代理类的实现，这里简单地限制了）。</li>
</ol>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-15%20141753.png" alt="屏幕截图 2024-10-15 141753"></p>
<p>委托类和代理类的虚函数都是一样的，都是抽象类里面的函数</p>
<p>代理类经过检查发现不合法，没有权限，就不会调用委托类对象</p>
<h3 id="8-装饰器模式"><a href="#8-装饰器模式" class="headerlink" title="8.装饰器模式"></a>8.装饰器模式</h3><p><code>装饰器模式：</code>主要是增加现有类的功能</p>
<p>为了增强现有类的功能，通过实现子类的方式，重写接口，是可以完成功能扩展的，但是代码中有太多的子类添加进来了</p>
<p>**装饰器模式（Decorator Pattern）**是一种结构型设计模式，它允许你向一个现有的对象添加新的功能，同时又不改变其结构。装饰器模式通过创建一个包装对象（即装饰器）来包裹原始对象，从而可以在运行时动态地给对象添加职责。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol>
<li><strong>灵活性</strong>：可以在不修改原有类的情况下增加新的功能。</li>
<li><strong>扩展性</strong>：通过组合而非继承来扩展功能，避免了继承带来的高耦合和代码膨胀问题。</li>
<li><strong>复用性</strong>：装饰器和具体组件可以独立变化，互不干扰。</li>
</ol>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><strong>装饰链复杂</strong>：如果装饰链太长，调试和维护会变得复杂。</li>
<li><strong>性能</strong>：因为每次调用都会通过多个装饰器，可能会有一定的性能开销。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bmw</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是一辆宝马汽车，配置有：基类配置&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是一辆奥迪汽车，配置有：基类配置&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Benz</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是一辆奔驰汽车，配置有：基类配置&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//装饰器的基类 装饰器可以让增加的功能互相组合</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarDecorator</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CarDecorator</span>(Car* p) :<span class="built_in">pCar</span>(p) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Car* pCar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//装饰器1 定速巡航</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator01</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ConcreteDecorator01</span>(Car *p):<span class="built_in">pCar</span>(p)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pCar-&gt;<span class="built_in">show</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;,定速巡航&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Car* pCar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//装饰器2 定速巡航</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator02</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ConcreteDecorator02</span>(Car* p) :<span class="built_in">pCar</span>(p) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pCar-&gt;<span class="built_in">show</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;,自动刹车&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Car* pCar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//装饰器3 车道偏离</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator03</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ConcreteDecorator03</span>(Car* p) :<span class="built_in">pCar</span>(p) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pCar-&gt;<span class="built_in">show</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;,车道偏离&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Car* pCar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Car* p1 = <span class="keyword">new</span> <span class="built_in">ConcreteDecorator01</span>(<span class="keyword">new</span> <span class="built_in">Bmw</span>());</span><br><span class="line">	<span class="comment">//功能组合</span></span><br><span class="line">	p1 = <span class="keyword">new</span> <span class="built_in">ConcreteDecorator02</span>(p1);</span><br><span class="line">	p1 = <span class="keyword">new</span> <span class="built_in">ConcreteDecorator03</span>(p1);</span><br><span class="line">	p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Car* p2 = <span class="keyword">new</span> <span class="built_in">ConcreteDecorator02</span>(<span class="keyword">new</span> <span class="built_in">Audi</span>());</span><br><span class="line">	p2-&gt;<span class="built_in">show</span>();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Car* p3 = <span class="keyword">new</span> <span class="built_in">ConcreteDecorator03</span>(<span class="keyword">new</span> <span class="built_in">Benz</span>());</span><br><span class="line">	p3-&gt;<span class="built_in">show</span>();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-代理和装饰的区别"><a href="#9-代理和装饰的区别" class="headerlink" title="9.代理和装饰的区别"></a>9.代理和装饰的区别</h3><p>C++中的装饰器模式（Decorator Pattern）和代理模式（Proxy Pattern）都是结构型设计模式，但它们在目的、功能扩展方式、结构修改以及关注点等方面存在显著的区别。</p>
<h4 id="一、目的"><a href="#一、目的" class="headerlink" title="一、目的"></a>一、目的</h4><ul>
<li><strong>装饰器模式</strong>：主要用于动态地为对象添加额外的职责，而不改变其结构。它允许在不改变现有对象代码的情况下，通过创建一系列的装饰器类来增加、扩展或修改对象的功能。</li>
<li><strong>代理模式</strong>：主要用于控制对其他对象的访问。它在客户端和实际对象之间引入了一个代理对象，客户端通过代理对象访问实际对象。代理对象可以用于控制访问权限、延迟加载、远程访问等。</li>
</ul>
<h4 id="二、功能扩展方式"><a href="#二、功能扩展方式" class="headerlink" title="二、功能扩展方式"></a>二、功能扩展方式</h4><ul>
<li><strong>装饰器模式</strong>：通过组合多个装饰器类来实现功能扩展。每个装饰器类都实现了与被装饰对象相同的接口，并可以在调用接口方法之前或之后添加额外的行为。</li>
<li><strong>代理模式</strong>：主要通过代理对象来控制访问，实际功能一般是由被代理对象提供的。代理对象可以在访问实际对象之前或之后添加额外的逻辑，如权限检查、日志记录等。</li>
</ul>
<h4 id="三、结构修改"><a href="#三、结构修改" class="headerlink" title="三、结构修改"></a>三、结构修改</h4><ul>
<li><strong>装饰器模式</strong>：通常不改变对象的结构，只是在其上添加装饰器。装饰器与被装饰对象具有相同的接口，因此可以替换或组合使用。</li>
<li><strong>代理模式</strong>：虽然也引入了新的代理对象，但代理对象通常包含了额外的逻辑，这些逻辑在访问实际对象之前或之后执行。此外，代理模式可能会改变客户端与实际对象之间的交互方式。</li>
</ul>
<h4 id="四、关注点"><a href="#四、关注点" class="headerlink" title="四、关注点"></a>四、关注点</h4><ul>
<li><strong>装饰器模式</strong>：关注于对象的功能增强。它允许在不修改现有代码的情况下，动态地为对象添加新的行为或功能。</li>
<li><strong>代理模式</strong>：关注于对象的访问控制和管理。它提供了对实际对象访问的间接层，以便在访问过程中添加额外的逻辑或控制。</li>
</ul>
<h4 id="五、应用场景"><a href="#五、应用场景" class="headerlink" title="五、应用场景"></a>五、应用场景</h4><ul>
<li><strong>装饰器模式</strong>：<ul>
<li>组件扩展：在大型项目中，随着业务的增加，需要添加新的功能时，装饰器可以避免修改原有的基础组件。</li>
<li>API增强：当提供API给第三方调用时，装饰器可以用于添加额外的功能，如日志记录、安全校验等。</li>
<li>权限管理：装饰器可以用来控制对原有特定接口的访问权限。</li>
<li>缓存机制：在网络请求或数据库查询等操作中，装饰器可以用来添加额外的缓存、重试、超时处理等功能。</li>
</ul>
</li>
<li><strong>代理模式</strong>：<ul>
<li>延迟加载：可以在需要时才创建实际对象，节省资源。</li>
<li>远程代理：用于控制对远程对象的访问，通常用于网络编程中。</li>
<li>保护代理：用于控制对对象的访问权限，增强安全性。</li>
<li>缓存&#x2F;缓冲代理：用于缓存频繁访问的数据，以减少计算或网络请求的开销。</li>
<li>智能引用代理：用于管理对象的生命周期，确保对象在不再需要时被正确释放。</li>
</ul>
</li>
</ul>
<h3 id="10-适配器模式"><a href="#10-适配器模式" class="headerlink" title="10.适配器模式"></a>10.适配器模式</h3><p><code>适配器模式：</code>让不兼容的接口可以在一起工作</p>
<p>**适配器模式（Adapter Pattern）**是一种结构型设计模式，它允许接口不兼容的类一起工作。适配器模式将类的接口转换成客户端所期望的另一种接口形式，使得原本不兼容的类可以合作无间。</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol>
<li><strong>提高灵活性</strong>：通过适配器，客户端可以透明地访问不兼容的接口，提高了系统的灵活性。</li>
<li><strong>复用性</strong>：适配器使得已有的类可以被复用，而无需修改它们的源代码。</li>
<li><strong>解耦</strong>：适配器模式有助于将接口和实现解耦，使得系统更加模块化。</li>
</ol>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><strong>代码复杂度增加</strong>：引入适配器会增加系统的代码量和复杂度。</li>
<li><strong>性能损耗</strong>：在某些情况下，适配器可能会导致性能上的损耗，因为它需要在客户端和适配对象之间进行额外的转换。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VGA接口的电脑 TV投影仪也是VGA接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VGA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">play</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TV01表示支持VGA接口的投影仪</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TV01</span> :<span class="keyword">public</span> VGA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;通过VGA接口连接投影仪，进行视频播放&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现一个电脑类，只支持VGA接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//由于电脑只支持VGA接口，所以该方法的参数也只能支持VGA接口的指针和引用</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">playVideo</span><span class="params">(VGA* pVGA)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pVGA-&gt;<span class="built_in">play</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进了一批新的投影仪，都只支持HDMT接口，根本都插不到电脑上</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HDMI</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">play</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TV02</span> :<span class="keyword">public</span> HDMI</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;通过HDMI接口连接投影仪，进行视频播放&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于电脑(VGA接口)和投影仪(HDMI接口)无法直接相连，所以需要添加适配器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VGAToHDMTAdapter</span> :<span class="keyword">public</span> VGA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">VGAToHDMTAdapter</span>(HDMI *p):<span class="built_in">pHdmi</span>(p)&#123;&#125;</span><br><span class="line">	<span class="comment">//该方法相当于就是转换头，做不同接口的信号转换的</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pHdmi-&gt;<span class="built_in">play</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	HDMI* pHdmi;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Computer computer;</span><br><span class="line">	<span class="comment">//电脑本身就支持VGA，通过VGA投影到投影仪上</span></span><br><span class="line">	computer.<span class="built_in">playVideo</span>(<span class="keyword">new</span> <span class="built_in">TV01</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*TV02只支持HDMI，不支持AGV</span></span><br><span class="line"><span class="comment">	computer.playVideo(new TV02());</span></span><br><span class="line"><span class="comment">	表现为VGA*不接受一个TV02指针类型的参数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	方法1：换一个支持HDMI接口的电脑，这个就叫代码重构</span></span><br><span class="line"><span class="comment">	方法2：买一个转换头（适配器），能够把VGA信号转成HDMI信号，这是添加适配器类*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过转换头，可以通过HDMI接口投影仪播放视频</span></span><br><span class="line">	computer.<span class="built_in">playVideo</span>(<span class="keyword">new</span> <span class="built_in">VGAToHDMTAdapter</span>(<span class="keyword">new</span> <span class="built_in">TV02</span>()));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是对代码中各个部分的详细讲解：</p>
<ol>
<li><strong>抽象接口定义</strong></li>
</ol>
<ul>
<li><strong>VGA</strong> 和 <strong>HDMI</strong> 是两个抽象基类，分别定义了具有 <code>play()</code> 方法的接口。这两个接口代表两种不同的视频输出标准。</li>
</ul>
<ol start="2">
<li><strong>具体实现类</strong></li>
</ol>
<ul>
<li><strong>TV01</strong> 继承自 <strong>VGA</strong>，表示一个支持VGA接口的投影仪，其 <code>play()</code> 方法实现了通过VGA接口播放视频的功能。</li>
<li><strong>TV02</strong> 继承自 <strong>HDMI</strong>，表示一个支持HDMI接口的投影仪，其 <code>play()</code> 方法实现了通过HDMI接口播放视频的功能。</li>
</ul>
<ol start="3">
<li><strong>电脑类</strong></li>
</ol>
<ul>
<li><strong>Computer</strong> 类有一个方法 <code>playVideo(VGA* pVGA)</code>，这个方法接受一个 <strong>VGA</strong> 接口的指针作为参数，并调用该指针的 <code>play()</code> 方法。这表示电脑只能通过VGA接口播放视频。</li>
</ul>
<ol start="4">
<li><strong>适配器类</strong></li>
</ol>
<ul>
<li><strong>VGAToHDMTAdapter</strong> 类继承自 <strong>VGA</strong>，但它内部持有一个 <strong>HDMI</strong> 接口的指针。这个适配器类实现了 <strong>VGA</strong> 接口的 <code>play()</code> 方法，但在这个方法内部，它调用的是内部 <strong>HDMI</strong> 接口指针的 <code>play()</code> 方法。这样，<strong>VGAToHDMTAdapter</strong> 就起到了将HDMI接口转换为VGA接口的作用。</li>
</ul>
<h3 id="11-观察者模式"><a href="#11-观察者模式" class="headerlink" title="11.观察者模式"></a>11.观察者模式</h3><p>也称为<strong>监听者模式</strong>或<strong>发布-订阅模式</strong></p>
<p>它属于<strong>行为型模式</strong>，而行为型主要关注的是<strong>对象之间的通信</strong></p>
<p><strong>观察者模式</strong>主要关注的是对象的一对多的关系，也就是多个对象都依赖一个对象，当该对象的状态发生改变时，其他对象都能接收到相应的通知</p>
<p>观察者模式（Observer Pattern）是一种行为设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ol>
<li><strong>松耦合</strong>：观察者和被观察者之间通过抽象接口进行交互，降低了它们之间的耦合度。</li>
<li><strong>灵活性</strong>：观察者可以在任何时候增加或删除，而不会影响被观察者的行为。</li>
<li><strong>扩展性强</strong>：可以在不修改被观察者代码的情况下增加新的观察者。</li>
</ol>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><strong>性能开销</strong>：如果被观察者状态频繁变化，并且有很多观察者，那么通知所有观察者可能会带来较大的性能开销。</li>
<li><strong>内存泄漏风险</strong>：如果没有正确管理观察者的生命周期，可能会导致内存泄漏。</li>
<li><strong>循环依赖</strong>：观察者之间可能相互依赖，导致复杂的依赖关系网。</li>
</ol>
<p><code>例如：</code></p>
<p>一组数据（数据对象），通过这一组数据生成 曲线图（对象1）&#x2F; 柱状图（对象2）&#x2F; 圆饼图（对象3）</p>
<p>当数据对象改变时，对象1,2,3应该及时收到相应的通知</p>
<p><strong>Subject主题有更改的时候，应该及时通知相应的观察者，去处理相应的事件</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//观察者抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> msgid)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个观察者实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer1</span> :<span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> msgid)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (msgid)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Observer1 recv 1 msg&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Observer1 recv 2 msg&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Observer1 recv unkown msg&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个观察者实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer2</span> :<span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> msgid)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (msgid)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Observer2 recv 2 msg&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Observer2 recv unkown msg&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三个观察者实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer3</span> :<span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> msgid)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (msgid)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Observer3 recv 1 msg&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Observer3 recv 3 msg&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Observer3 recv unkown msg&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主题类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//给主题增加观察者对象</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">adObserver</span><span class="params">(Observer* obser, <span class="type">int</span> msgid)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_subMap[msgid].<span class="built_in">push_back</span>(obser);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//主题检测发生改变，通知相应的观察者对象处理事件</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dispatch</span><span class="params">(<span class="type">int</span> msgid)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> it = _subMap.<span class="built_in">find</span>(msgid);</span><br><span class="line">		<span class="comment">//没找着说明没人对这件事情感兴趣</span></span><br><span class="line">		<span class="keyword">if</span> (it != _subMap.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (Observer* pObser : it-&gt;second)</span><br><span class="line">			&#123;</span><br><span class="line">				pObser-&gt;<span class="built_in">handle</span>(msgid);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	unordered_map&lt;<span class="type">int</span>, list&lt;Observer*&gt;&gt; _subMap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Subject subject;</span><br><span class="line">	Observer* p1 = <span class="keyword">new</span> <span class="built_in">Observer1</span>();</span><br><span class="line">	Observer* p2 = <span class="keyword">new</span> <span class="built_in">Observer2</span>();</span><br><span class="line">	Observer* p3 = <span class="keyword">new</span> <span class="built_in">Observer3</span>();</span><br><span class="line"></span><br><span class="line">	subject.<span class="built_in">adObserver</span>(p1, <span class="number">1</span>);</span><br><span class="line">	subject.<span class="built_in">adObserver</span>(p1, <span class="number">2</span>);</span><br><span class="line">	subject.<span class="built_in">adObserver</span>(p2, <span class="number">2</span>);</span><br><span class="line">	subject.<span class="built_in">adObserver</span>(p3, <span class="number">1</span>);</span><br><span class="line">	subject.<span class="built_in">adObserver</span>(p3, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> msgid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入消息id:&quot;</span> ;</span><br><span class="line">		cin &gt;&gt; msgid;</span><br><span class="line">		<span class="keyword">if</span> (msgid == <span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		subject.<span class="built_in">dispatch</span>(msgid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当主题改变的时候，对消息关注的对象会收到通知</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://darling-123456.github.io/">Darling</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://darling-123456.github.io/2024/10/16/C++/%E6%96%BD%E7%A3%8AC++%20%20%E8%BF%9B%E9%98%B6%20%20%E7%AC%94%E8%AE%B0/">https://darling-123456.github.io/2024/10/16/C++/施磊C++  进阶  笔记/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://darling-123456.github.io" target="_blank">Darlingの妙妙屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></div><div class="post-share"><div class="social-share" data-image="/img/37.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/10/16/C++/%E6%96%BD%E7%A3%8AC++%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B%20%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%20%E5%8D%9A%E5%AE%A2%E6%B1%87%E6%80%BB/" title="施磊C++ | 进阶学习笔记"><img class="cover" src="/img/38.jpg" onerror="onerror=null;src='/img/404_default.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">施磊C++ | 进阶学习笔记</div></div><div class="info-2"><div class="info-item-1">施磊C++高级进阶课程 | 学习笔记 | 博客汇总以下是CSDN链接 施磊C++ | 进阶学习笔记 | 1.对象的应用优化、右值引用的优化-CSDN博客 施磊C++ | 进阶学习笔记 | 2.智能指针-CSDN博客 施磊C++ | 进阶学习笔记 | 3.绑定器和函数对象、lambda表达式-CSDN博客 施磊C++ | 进阶学习笔记 | 4.c++11内容汇总、多线程应用实践-CSDN博客 施磊C++ | 进阶学习笔记 | 5.设计模式-CSDN博客 剩余有关面试的等到明年投简历前学习 </div></div></div></a><a class="pagination-related" href="/2024/10/20/C++/%E4%BE%AF%E6%8D%B7%20C++%20STL%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" title="侯捷 C++ STL标准库和泛型编程 | 学习笔记"><img class="cover" src="/img/34.jpg" onerror="onerror=null;src='/img/404_default.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">侯捷 C++ STL标准库和泛型编程 | 学习笔记</div></div><div class="info-2"><div class="info-item-1">侯捷 C++ STL标准库和泛型编程 | 学习笔记1 STL概述STL —— Standard Template Library，标准模板库 C++ Standard LIbrary，C++标准库中包含STL（即STL+一些小东西） 1.1 头文件名称 C++标准库的 header files 不带 .h，例如：#include&lt;vector&gt; 新式 C header files 不带 .h，例如：#include&lt;cstdio&gt; 老式 C header files 带 .h 仍然可用，例如：#include&lt;stdio.h&gt;   新式 header 内的组件封装于 namespace std 老式 header 内的组件不封装于 namespace std  1.2...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/10/20/C++/%E4%BE%AF%E6%8D%B7%20C++%20STL%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" title="侯捷 C++ STL标准库和泛型编程 | 学习笔记"><img class="cover" src="/img/34.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-20</div><div class="info-item-2">侯捷 C++ STL标准库和泛型编程 | 学习笔记</div></div><div class="info-2"><div class="info-item-1">侯捷 C++ STL标准库和泛型编程 | 学习笔记1 STL概述STL —— Standard Template Library，标准模板库 C++ Standard LIbrary，C++标准库中包含STL（即STL+一些小东西） 1.1 头文件名称 C++标准库的 header files 不带 .h，例如：#include&lt;vector&gt; 新式 C header files 不带 .h，例如：#include&lt;cstdio&gt; 老式 C header files 带 .h 仍然可用，例如：#include&lt;stdio.h&gt;   新式 header 内的组件封装于 namespace std 老式 header 内的组件不封装于 namespace std  1.2...</div></div></div></a><a class="pagination-related" href="/2024/10/16/C++/%E6%96%BD%E7%A3%8AC++%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B%20%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%20%E5%8D%9A%E5%AE%A2%E6%B1%87%E6%80%BB/" title="施磊C++ | 进阶学习笔记"><img class="cover" src="/img/38.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-16</div><div class="info-item-2">施磊C++ | 进阶学习笔记</div></div><div class="info-2"><div class="info-item-1">施磊C++高级进阶课程 | 学习笔记 | 博客汇总以下是CSDN链接 施磊C++ | 进阶学习笔记 | 1.对象的应用优化、右值引用的优化-CSDN博客 施磊C++ | 进阶学习笔记 | 2.智能指针-CSDN博客 施磊C++ | 进阶学习笔记 | 3.绑定器和函数对象、lambda表达式-CSDN博客 施磊C++ | 进阶学习笔记 | 4.c++11内容汇总、多线程应用实践-CSDN博客 施磊C++ | 进阶学习笔记 | 5.设计模式-CSDN博客 剩余有关面试的等到明年投简历前学习 </div></div></div></a><a class="pagination-related" href="/2024/10/24/C++/%E4%BE%AF%E6%8D%B7%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="侯捷内存管理学习笔记 | C++"><img class="cover" src="/img/36.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-24</div><div class="info-item-2">侯捷内存管理学习笔记 | C++</div></div><div class="info-2"><div class="info-item-1">侯捷内存管理学习笔记第一章节 primitives零.new和delete概述C++中的new和delete是用于动态内存分配和释放的操作符，它们的底层机制和工作原理相对复杂，但也可以简单清晰地解释。 new的底层机制和工作原理 内存分配： 当使用new操作符时，它首先会调用底层的内存分配函数（如operator new），这个函数通常是对malloc的封装。malloc会从堆中分配足够的内存空间。 如果内存分配失败，operator...</div></div></div></a><a class="pagination-related" href="/2024/10/10/C++/%E4%BE%AF%E6%8D%B7%20%20C++11%20%E6%96%B0%E7%89%B9%E6%80%A7%20%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="侯捷 C++11 新特性 学习笔记"><img class="cover" src="/img/35.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-10</div><div class="info-item-2">侯捷 C++11 新特性 学习笔记</div></div><div class="info-2"><div class="info-item-1">C++11 新特性 学习笔记1.Variadic TemplatesC++11支持函数模板的默认模板参数在 C++98&#x2F;03 标准中，类模板可以有默认的模板参数，如下： 12345template &lt;typename T, typename U = int, U N = 0&gt;struct Foo&#123;    // ...&#125;;  但是却不支持函数的默认模板参数： 12345template &lt;typename T = int&gt;  // error in C++98/03: default template argumentsvoid func()&#123;    // ...&#125;  现在这一限制在 C++11 中被解除了。上面的 func 函数在 C++11 中可以直接使用，代码如下： 12345int main(void)&#123;    func();   //T = int    return 0;&#125;  此时模板参数 T 的类型就为默认值...</div></div></div></a><a class="pagination-related" href="/2023/07/22/C++/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E7%B2%BE%E7%BE%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="黑马程序员C++核心编程学习笔记"><img class="cover" src="/img/32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-22</div><div class="info-item-2">黑马程序员C++核心编程学习笔记</div></div><div class="info-2"><div class="info-item-1">黑马程序员C++核心编程学习笔记一、内存1.1 内存四区C++程序在执行时，将内存大致分为4个区域：代码区，全局区，栈区，堆区  代码区：存放函数体的的二进制代码，操作系统管理。  🔵特点：①共享 ：对于频繁被执行的程序，只需要在内存中有一份代码即可。    ②只读：目的是防止程序意外地修改了它的指令。  全局区：存放全局变量、静态变量和常量（除了const修饰的局部变量）。程序结束时由操作系统释放。   1234567891011121314151617181920212223//全局变量int g_a = 10;const int c_g_a = 10;int main()&#123;	int l_a = 10;	//静态变量	static int s_a = 10;		//常量：字符串常量/const修饰的变量（全局/局部变量）	const char* a = &quot;hello&quot;;	const int c_l_a = 10;	cout &lt;&lt; &quot;局部变量l_a的十进制地址为：&quot; &lt;&lt; (int)&amp;l_a...</div></div></div></a><a class="pagination-related" href="/2023/07/22/C++/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B%E7%B2%BE%E7%BE%8E%E7%AC%94%E8%AE%B0/" title="黑马程序员C++提高编程"><img class="cover" src="/img/33.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-22</div><div class="info-item-2">黑马程序员C++提高编程</div></div><div class="info-2"><div class="info-item-1">黑马程序员C++提高编程  提高阶段主要针对泛型编程和STL技术  一、模板  模板就是建立通用的模具，大大提高复用性,也是泛型编程的思想。C++提供两种模板机制：①函数模板 ②类模板 🔴注意：  ① 模板不是万能的。  ② 模板不能直接使用。 1.1 函数模板1.1.1 函数模板基础知识​      语法： 12template  &lt;typename T &gt;   函数声明或定义  ​       解释：template— 声明创建模板；typename — 可以用class代替；T — 通用的数据类型​      使用：①自动类型推导 ②显示指定类型 🟦意义：提高复用性，将类型参数化。 1234567891011121314151617//函数模板的使用template&lt;typename T&gt;void MySwap(T&amp; a, T&amp; b)&#123;	T temp = a;	a = b;	b = temp;&#125;int main()&#123;	int a = 10;	int b = 20;	MySwap(a,...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Darling</div><div class="author-info-description">为什么学习这么难!</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">57</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Darling-123456"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Darling-123456" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_74795952?type=blog" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="mailto:2214050255@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是Darlingの妙妙屋，更新笔者的学习笔记，联系方式：2214050255@qq.com</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%BD%E7%A3%8AC-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">施磊C++ | 进阶学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%94%E7%94%A8%E4%BC%98%E5%8C%96%E3%80%81%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text">一、对象的应用优化、右值引用的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%9E%84%E9%80%A0%EF%BC%8C%E6%8B%B7%E8%B4%9D%EF%BC%8C%E8%B5%8B%E5%80%BC%EF%BC%8C%E6%9E%90%E6%9E%84%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 构造，拷贝，赋值，析构中的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0%EF%BC%9A"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">课后练习：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%AF%B9%E8%B1%A1%E8%83%8C%E5%90%8E%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 函数调用过程中对象背后调用的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96%E4%B8%89%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 对象优化三原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81move%E7%A7%BB%E5%8A%A8%E8%AF%AD%E6%84%8F%E3%80%81%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 右值引用、move移动语意、完美转发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">1.2.</span> <span class="toc-text">二、智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1智能指针介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2自己实现智能指针（基础知识）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E4%B8%8D%E5%B8%A6%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3不带引用计数的智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-auto-ptr"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1.auto_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-scoped-ptr"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.scoped_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-unique-ptr"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3.unique_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%89%E4%B8%AA%E6%8C%87%E9%92%88%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">4.三个指针对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E5%B8%A6%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88shared-ptr%E3%80%81weak-ptr"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4带引用计数的智能指针shared_ptr、weak_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%EF%BC%88%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%EF%BC%89%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5智能指针的交叉引用（循环引用）问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.6多线程访问共享对象问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%A0%E9%99%A4%E5%99%A8"><span class="toc-number">1.2.7.</span> <span class="toc-text">2.7自定义删除器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BB%91%E5%AE%9A%E5%99%A8%E5%92%8C%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">三、绑定器和函数对象、lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%8C%E5%85%A8%E7%89%B9%E4%BE%8B%E5%8C%96%E5%92%8C%E9%9D%9E%E5%AE%8C%E5%85%A8%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1模板的完全特例化和非完全（部分）特例化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%8C%E5%85%A8%E7%89%B9%E4%BE%8B%E5%8C%96%E5%92%8C%E9%9D%9E%E5%AE%8C%E5%85%A8%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">1.完全特例化和非完全（部分）特例化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%BC%94"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">2.模板的实参推演</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-C-STL%E4%B8%AD%E7%9A%84%E7%BB%91%E5%AE%9A%E5%99%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 C++ STL中的绑定器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bind1st"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">bind1st</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bind2nd"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">bind2nd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAbind1st"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">自己实现一个bind1st</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-C-11%E4%BB%8EBoost%E5%BA%93%E4%B8%AD%E5%BC%95%E5%85%A5%E4%BA%86bind%E5%92%8Cfunction%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 C++11从Boost库中引入了bind和function函数对象机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-function%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B%EF%BC%88function%E5%9F%BA%E7%A1%80%EF%BC%89"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">1.function函数对象类型的应用示例（function基础）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-fucntion%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">2.fucntion函数对象类型的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-bind"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">3.bind</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#bind%E7%BB%99%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9A%E5%85%B7%E4%BD%93%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.3.3.3.1.</span> <span class="toc-text">bind给成员函数绑定具体的对象（重点）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-bind-%E5%92%8C-function%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">4.bind 和 function实现线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E4%BD%9C%E4%B8%BA%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%EF%BC%8C%E9%9C%80%E8%A6%81bind%E8%BF%9B%E8%A1%8C%E7%BB%91%E5%AE%9A"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">5.类的成员函数不能直接作为线程函数，需要bind进行绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-std-bind"><span class="toc-number">1.3.3.5.1.</span> <span class="toc-text">使用 std::bind</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.3.5.2.</span> <span class="toc-text">使用 Lambda 表达式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%88%96%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.3.5.3.</span> <span class="toc-text">使用静态成员函数或友元函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%A4%96%E9%83%A8%E7%9A%84%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.3.5.4.</span> <span class="toc-text">使用类外部的普通函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%BA%95%E5%B1%82%E4%BE%9D%E8%B5%96%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 lambda表达式 底层依赖函数对象机制实现的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-lambda%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">1.lambda概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">2.lambda表达式的语法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84-%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.4.2.0.1.</span> <span class="toc-text">lambda匿名函数中的[外部变量]</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-lambda%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">3.lambda的应用实践</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E4%B9%8B%E4%B8%AD"><span class="toc-number">1.3.4.3.1.</span> <span class="toc-text">1.泛型算法之中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%97%A2%E7%84%B6lambda%E5%8F%AA%E8%83%BD%E7%94%A8%E5%9C%A8%E8%AF%AD%E5%8F%A5%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%83%B3%E8%B7%A8%E8%AF%AD%E5%8F%A5%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%89%8D%E5%AE%9A%E4%B9%89%E5%A5%BD%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E8%A1%A8%E8%BE%BElambda%EF%BC%9F"><span class="toc-number">1.3.4.3.2.</span> <span class="toc-text">2.既然lambda只能用在语句中，如果想跨语句使用之前定义好的lambda表达式怎么办？有什么类型表达lambda？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81c-11%E5%86%85%E5%AE%B9%E6%B1%87%E6%80%BB%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.4.</span> <span class="toc-text">四、c++11内容汇总、多线程应用实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-c-11%E5%86%85%E5%AE%B9%E6%B1%87%E6%80%BB"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 c++11内容汇总</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-C-%E8%AF%AD%E8%A8%80%E7%BA%A7%E5%88%AB%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 C++语言级别的多线程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%80%9A%E8%BF%87thread%E7%B1%BB%E7%BC%96%E5%86%99C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">1.通过thread类编写C++多线程程序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.4.2.1.1.</span> <span class="toc-text">1.头文件以及命名空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">1.4.2.1.2.</span> <span class="toc-text">2.线程创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E4%BD%9C%E4%B8%BA%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%EF%BC%8C%E9%9C%80%E8%A6%81bind%E8%BF%9B%E8%A1%8C%E7%BB%91%E5%AE%9A"><span class="toc-number">1.4.2.1.3.</span> <span class="toc-text">注意：类的成员函数不能直接作为线程函数，需要bind进行绑定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-std-bind-1"><span class="toc-number">1.4.2.1.4.</span> <span class="toc-text">使用 std::bind</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F-1"><span class="toc-number">1.4.2.1.5.</span> <span class="toc-text">使用 Lambda 表达式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%88%96%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0-1"><span class="toc-number">1.4.2.1.6.</span> <span class="toc-text">使用静态成员函数或友元函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%A4%96%E9%83%A8%E7%9A%84%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0-1"><span class="toc-number">1.4.2.1.7.</span> <span class="toc-text">使用类外部的普通函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.3.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AD%90%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E7%BB%93%E6%9D%9F"><span class="toc-number">1.4.3.0.1.</span> <span class="toc-text">3.子线程如何结束</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%AD%90%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.4.3.0.2.</span> <span class="toc-text">4.主线程如何处理子线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">2.线程互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">1.4.3.1.1.</span> <span class="toc-text">1.为什么需要线程互斥</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-mutex-%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">1.4.3.1.2.</span> <span class="toc-text">2.mutex 互斥锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%9F%BA%E4%BA%8ECAS%E6%93%8D%E4%BD%9C%E7%9A%84atomic%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.3.1.3.</span> <span class="toc-text">3.基于CAS操作的atomic原子类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">3.线程同步通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.3.2.1.</span> <span class="toc-text">条件变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">1.4.3.2.2.</span> <span class="toc-text">线程间通信</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">五、设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.设计模式三大类型概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">一、创建型设计模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">二、结构型设计模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">三、行为型设计模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.设计模式三大原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.3.</span> <span class="toc-text">3.单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A5%BF%E6%B1%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">1.饿汉单例模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%87%92%E6%B1%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">2.懒汉单例模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%87%92%E6%B1%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.4.</span> <span class="toc-text">4.线程安全的懒汉单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%94%81-%E5%8F%8C%E9%87%8D%E5%88%A4%E6%96%AD"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">1.锁+双重判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%AE%80%E6%B4%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%87%92%E6%B1%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">2.简洁的线程安全懒汉单例模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82-Simple-Factor-%E3%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-Factory-Method"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.简单工厂(Simple Factor)、工厂方法(Factory Method)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">1.简单工厂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">2.工厂方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-Abstract-Factory"><span class="toc-number">1.5.6.</span> <span class="toc-text">6.抽象工厂(Abstract Factory)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy%EF%BC%89"><span class="toc-number">1.5.7.</span> <span class="toc-text">7.代理模式（Proxy）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.5.7.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">1.5.7.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.8.</span> <span class="toc-text">8.装饰器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">1.5.8.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-number">1.5.8.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BB%A3%E7%90%86%E5%92%8C%E8%A3%85%E9%A5%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.9.</span> <span class="toc-text">9.代理和装饰的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%9B%AE%E7%9A%84"><span class="toc-number">1.5.9.1.</span> <span class="toc-text">一、目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95%E6%96%B9%E5%BC%8F"><span class="toc-number">1.5.9.2.</span> <span class="toc-text">二、功能扩展方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BB%93%E6%9E%84%E4%BF%AE%E6%94%B9"><span class="toc-number">1.5.9.3.</span> <span class="toc-text">三、结构修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%85%B3%E6%B3%A8%E7%82%B9"><span class="toc-number">1.5.9.4.</span> <span class="toc-text">四、关注点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.5.9.5.</span> <span class="toc-text">五、应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.10.</span> <span class="toc-text">10.适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-2"><span class="toc-number">1.5.10.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="toc-number">1.5.10.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.11.</span> <span class="toc-text">11.观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-3"><span class="toc-number">1.5.11.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="toc-number">1.5.11.2.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/22/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day70%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E5%AE%8C%E6%88%90%E6%97%85%E9%80%94%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/" title="Day70 | 灵神 | 二分查找：完成旅途的最少时间"><img src="/img/1.jpg" onerror="this.onerror=null;this.src='/img/404_default.jpg'" alt="Day70 | 灵神 | 二分查找：完成旅途的最少时间"/></a><div class="content"><a class="title" href="/2025/03/22/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day70%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E5%AE%8C%E6%88%90%E6%97%85%E9%80%94%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/" title="Day70 | 灵神 | 二分查找：完成旅途的最少时间">Day70 | 灵神 | 二分查找：完成旅途的最少时间</a><time datetime="2025-03-21T16:00:00.000Z" title="发表于 2025-03-22 00:00:00">2025-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/22/%E5%B7%A5%E5%85%B7/Bulk%20Rename%20Utility%EF%BC%88BRU%EF%BC%89%E2%80%94%E2%80%94%E5%A4%A7%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F/" title="Bulk Rename Utility（BRU）——大批量重命名实用程序"><img src="/img/51.jpg" onerror="this.onerror=null;this.src='/img/404_default.jpg'" alt="Bulk Rename Utility（BRU）——大批量重命名实用程序"/></a><div class="content"><a class="title" href="/2025/03/22/%E5%B7%A5%E5%85%B7/Bulk%20Rename%20Utility%EF%BC%88BRU%EF%BC%89%E2%80%94%E2%80%94%E5%A4%A7%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F/" title="Bulk Rename Utility（BRU）——大批量重命名实用程序">Bulk Rename Utility（BRU）——大批量重命名实用程序</a><time datetime="2025-03-21T16:00:00.000Z" title="发表于 2025-03-22 00:00:00">2025-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day69%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/" title="Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂"><img src="/img/2.jpg" onerror="this.onerror=null;this.src='/img/404_default.jpg'" alt="Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂"/></a><div class="content"><a class="title" href="/2025/03/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day69%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/" title="Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂">Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂</a><time datetime="2025-03-21T01:16:25.000Z" title="发表于 2025-03-21 09:16:25">2025-03-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/20/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day68%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9AH%E6%8C%87%E6%95%B0II/" title="Day68 | 灵神 | 二分查找：H指数II"><img src="/img/3.jpg" onerror="this.onerror=null;this.src='/img/404_default.jpg'" alt="Day68 | 灵神 | 二分查找：H指数II"/></a><div class="content"><a class="title" href="/2025/03/20/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day68%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9AH%E6%8C%87%E6%95%B0II/" title="Day68 | 灵神 | 二分查找：H指数II">Day68 | 灵神 | 二分查找：H指数II</a><time datetime="2025-03-19T16:00:00.000Z" title="发表于 2025-03-20 00:00:00">2025-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/19/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day67%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%85%AC%E5%B9%B3%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/" title="Day67 | 灵神 | 二分查找：统计公平数对的数目"><img src="/img/4.jpg" onerror="this.onerror=null;this.src='/img/404_default.jpg'" alt="Day67 | 灵神 | 二分查找：统计公平数对的数目"/></a><div class="content"><a class="title" href="/2025/03/19/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day67%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%85%AC%E5%B9%B3%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/" title="Day67 | 灵神 | 二分查找：统计公平数对的数目">Day67 | 灵神 | 二分查找：统计公平数对的数目</a><time datetime="2025-03-18T16:00:00.000Z" title="发表于 2025-03-19 00:00:00">2025-03-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Darling</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'Darling-123456/giscus-component',
      'data-repo-id': 'R_kgDOOMRtzQ',
      'data-category-id': 'DIC_kwDOOMRtzc4CoTsn',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !true) {
    if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script async src="https://npm.elemecdn.com/tzy-blog/lib/js/other/sakura.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":20,"vOffset":-20},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>