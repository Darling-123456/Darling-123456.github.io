<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01背包模板</title>
    <url>/2024/11/07/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/01%E8%83%8C%E5%8C%85%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="01背包模板"><a href="#01背包模板" class="headerlink" title="01背包模板"></a>01背包模板</h1><p>01背包是<br><a href="https://blog.csdn.net/m0_74795952/article/details/143336356?spm=1001.2014.3001.5501">动态规划应该如何学习？-CSDN博客</a>中的选或不选情况<br><a href="https://blog.csdn.net/m0_74795952/article/details/143600753">完全背包模板总结-CSDN博客</a></p>
<h2 id="选或不选"><a href="#选或不选" class="headerlink" title="选或不选"></a>选或不选</h2><p>灵神视频</p>
<p><a href="https://www.bilibili.com/video/BV16Y411v7Y6?spm_id_from=333.788.videopod.sections&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">0-1背包 完全背包_哔哩哔哩_bilibili</a></p>
<h2 id="01背包（模板，可以配合该视频和代码随想录博客一起看）"><a href="#01背包（模板，可以配合该视频和代码随想录博客一起看）" class="headerlink" title="01背包（模板，可以配合该视频和代码随想录博客一起看）"></a>01背包（模板，可以配合该视频和代码随想录博客一起看）</h2><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/ff29a62a20d03b818ffe92ed0b96e92b.png" alt="image-20241031120326938"></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/1dbe7b6e6adfe7ff9ac7d9f49bcfd53f.png" alt="image-20241031125050721"></p>
<p>恰好装这个容量，求方案数量的最大最小价值和，那就是把选最大值的操作换成加号</p>
<p><a href="https://leetcode.cn/problems/target-sum/description/">494. 目标和 - 力扣（LeetCode）</a><br>后续如果遇到其他两种变形笔者同步更新到这里</p>
<h3 id="第一步：回溯法（深度优先遍历）"><a href="#第一步：回溯法（深度优先遍历）" class="headerlink" title="第一步：回溯法（深度优先遍历）"></a>第一步：回溯法（深度优先遍历）</h3><p><code>思路：</code></p>
<p>配合视频一起看更棒</p>
<p><a href="https://www.bilibili.com/video/BV16Y411v7Y6?spm_id_from=333.788.videopod.sections&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">0-1背包 完全背包_哔哩哔哩_bilibili</a></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/b3d9436af0b40a723699ff30bf216400.png" alt="image-20241031122300319"></p>
<p>下面的就不画了，大家知道这个意思就行</p>
<p>选编号为i的话就是返回dfs(i-1,c-w[i])+v[i]，就是代表已经把编号为i的物品已经放入了背包（表现为容量减了w[i]，价值加了v[i]），然后继续递归下一个物品</p>
<p>不选编号为i的话就是返回dfs(i-1,c)，这个代表的是一共有i-1个物品，总共是c的容量，那背包能装的最大价值是多少</p>
<p>我们本层函数会产生两个递归，一个是选了i，一个是没选i，返回的都是对应情况的最大值，我们要选最大的，所以要在这两个里面再选一个更大的作为返回值返回</p>
<p>从而得出了递推公式。</p>
<p><strong>这个虽然过不了，时间复杂度太高，但是这是学习动态规划的必由之路</strong></p>
<p><strong>1.返回值和参数</strong></p>
<p>w各个物品所占空间</p>
<p>v各个物品价值</p>
<p>i遍历物品</p>
<p>c是当前剩余的容量</p>
<p><strong>返回值返回选或不选编号为i的物品的最大值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w,vector&lt;<span class="type">int</span>&gt;&amp; v,<span class="type">int</span> i,<span class="type">int</span> c)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>2.终止条件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(c&lt;w[i])</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c);</span><br></pre></td></tr></table></figure>

<p>如果编号小于0说明已经到了树形结构最下面了，要开始从第一个物品选了，即自底（第一个物品）向上（i依次增大）开始遍历</p>
<p>如果当前容量已经小于要选的物品，那就直接返回给上层不选i号物品的结果</p>
<p><strong>3.本层逻辑</strong></p>
<p>在选和不选当前物品两种情况中（只要返回回来的一定是最大值），挑一个更大的返回</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c),<span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c-w[i])+v[i]);</span><br></pre></td></tr></table></figure>

<p><strong>完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w,vector&lt;<span class="type">int</span>&gt;&amp; v,<span class="type">int</span> i,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(c&lt;w[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c),<span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c-w[i])+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="number">01</span>knapsack(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(w,v,nums.<span class="built_in">size</span>()<span class="number">-1</span>,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++还可用lambda来写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="number">01</span>knapsack(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i,<span class="type">int</span> c)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(c&lt;w[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">-1</span>,c);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>,c),<span class="built_in">dfs</span>(i<span class="number">-1</span>,c-w[i])+v[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums.<span class="built_in">size</span>()<span class="number">-1</span>,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第二步：改成记忆化搜索"><a href="#第二步：改成记忆化搜索" class="headerlink" title="第二步：改成记忆化搜索"></a>第二步：改成记忆化搜索</h3><p>注意，在递归函数中，我们同时有物品编号i和容量c，所以要用一个二维数组作为哈希表来存储计算结果进行复用。</p>
<p>然后在每次返回结果前都赋值一下，把计算结果给存储起来</p>
<p><strong>完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w,vector&lt;<span class="type">int</span>&gt;&amp; v,<span class="type">int</span> i,<span class="type">int</span> c,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][c]!=<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[i][c];</span><br><span class="line">        <span class="keyword">if</span>(c&lt;w[i])</span><br><span class="line">            <span class="keyword">return</span> dp[i][c]=<span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c,dp);</span><br><span class="line">        <span class="keyword">return</span> dp[i][c]=<span class="built_in">max</span>(<span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c,dp),<span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c-w[i],dp)+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="number">01</span>knapsack(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>,<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(w,v,nums.<span class="built_in">size</span>()<span class="number">-1</span>,c,dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="number">01</span>knapsack(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>,<span class="number">-1</span>));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i,<span class="type">int</span> c)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][c]!=<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> dp[i][c];</span><br><span class="line">            <span class="keyword">if</span>(c&lt;w[i])</span><br><span class="line">                <span class="keyword">return</span> dp[i][c]=<span class="built_in">dfs</span>(i<span class="number">-1</span>,c);</span><br><span class="line">            <span class="keyword">return</span> dp[i][c]=<span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>,c),<span class="built_in">dfs</span>(i<span class="number">-1</span>,c-w[i])+v[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums.<span class="built_in">size</span>()<span class="number">-1</span>,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第三步：一比一翻译成动态规划-递推"><a href="#第三步：一比一翻译成动态规划-递推" class="headerlink" title="第三步：一比一翻译成动态规划(递推)"></a>第三步：一比一翻译成动态规划(递推)</h3><p><strong>1.确定dp数组以及下标的含义</strong></p>
<p>二维数组，dp[i][c]就是第i个物品在容量为c时可以取到的最大价值</p>
<p>i是物品编号</p>
<p>c是当前背包的总容量</p>
<p><strong>2.确定递推公式</strong></p>
<p>对应回溯算法本层逻辑部分</p>
<p>选或者不选第i号物品，如果没选，那就和上一个物品第i-1件遍历到j时一样的价值，因为没有选第i号</p>
<p>如果选了那就是   第i-1件物品在j-w[i]时的价值+选择的第i件物品的价值v[i]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-w[i]]+v[i]);</span><br></pre></td></tr></table></figure>

<p><strong>3.dp数组如何初始化</strong></p>
<p>全都初始化为0</p>
<p>第一行在容量大于第一件物品所需容量的时候就当做把第一件给放了进行初始化</p>
<p>因为dp[0][i]的物品编号只有0，即第一件物品，所以只能选择第一件物品得到最大价值，不选的话价值就为0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=w[<span class="number">0</span>];i&lt;=c;i++)</span><br><span class="line">	dp[<span class="number">0</span>][i]=v[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p><strong>4.确定遍历顺序</strong></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/d0508583d3251cb25b2b802ac1503e93.png" alt="20240730174246"></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/0b8604cea5a75673f5e62c5f6cc17885.png" alt="20240730174436"></p>
<p>从前往后遍历，先遍历物品或者先遍历容量都是可以的，因为先物品是按照行一行一行来遍历，递推公式中的两个值都可以在遍历得出来，按照容量一列一列遍历也同样可以得出来这两个值</p>
<p>但仅限于二维，如果是一维那就只能先遍历物品后遍历容量，而且只能从后往前遍历容量</p>
<p>因为递推公式中用到的两个值在一维中变成了这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(c<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=c;j&gt;=w[i];j--)</span><br><span class="line">		dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/795a243b07425dc648b165738714a451.png" alt="image-20241031155145293"></p>
<p>第一行是刷新前的数组，第二行是要对第一行进行覆盖的值，通过第一行的dp[j]和dp[j-w[i]]这两个值进行更新</p>
<p>如果从前往后，那dp[j-w[i]]就会被覆盖，从而得到一个错误的答案</p>
<p>如果不太理解可以转至：<a href="https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
<p><a href="https://www.bilibili.com/video/BV16Y411v7Y6/?spm_id_from=333.788.videopod.sections&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">0-1背包 完全背包_哔哩哔哩_bilibili</a>视频里面也会讲到滚动数组相关</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=c;j++)</span><br><span class="line">	<span class="keyword">if</span>(j&gt;w[i])</span><br><span class="line">		dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-w[i]]+v[i]);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">    	dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br></pre></td></tr></table></figure>

<p><strong>完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="number">01</span>knapsack(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=w[<span class="number">0</span>];i&lt;=c;i++)</span><br><span class="line">            dp[<span class="number">0</span>][i]=v[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=c;j++)</span><br><span class="line">                <span class="keyword">if</span>(j&gt;w[i])</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-w[i]]+v[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">return</span> dp[w.<span class="built_in">size</span>()<span class="number">-1</span>][c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="滚动数组代码"><a href="#滚动数组代码" class="headerlink" title="滚动数组代码"></a>滚动数组代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="number">01</span>knapsack(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(c<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=c;j&gt;=w[i];j--)</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">        <span class="keyword">return</span> dp[c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>刷题总结</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树路径问题模板总结</title>
    <url>/2024/12/02/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="二叉树路径问题模板总结"><a href="#二叉树路径问题模板总结" class="headerlink" title="二叉树路径问题模板总结"></a>二叉树路径问题模板总结</h1><h2 id="问题分类"><a href="#问题分类" class="headerlink" title="问题分类"></a>问题分类</h2><p>二叉树路径的问题大致可以分为两类：</p>
<h3 id="1、自顶向下"><a href="#1、自顶向下" class="headerlink" title="1、自顶向下"></a>1、自顶向下</h3><p>一般是前序遍历</p>
<p>顾名思义，就是从某一个节点(不一定是根节点)，从上向下寻找路径，到某一个节点(不一定是叶节点)结束<br>具体题目如下：</p>
<p><a href="https://leetcode.cn/problems/binary-tree-paths/description/">257. 二叉树的所有路径 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/path-sum/description/">112. 路径总和 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/path-sum-ii/description/">113. 路径总和 II - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/path-sum-iii/description/?envType=study-plan-v2&envId=top-100-liked">437. 路径总和 III - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/paths-with-sum-lcci/description/">面试题 04.12. 求和路径 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/smallest-string-starting-from-leaf/description/">988. 从叶结点开始的最小字符串 - 力扣（LeetCode）</a></p>
<p>而继续细分的话还可以分成一般路径与给定和的路径</p>
<p><strong>自顶而下：</strong><br>dfs，每次记得想想递归函数的本层逻辑，收集结果的条件，继续递归要传什么参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一般路径,即单纯收集路径：</span></span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">tra</span><span class="params">(TreeNode *t,vector&lt;<span class="type">int</span>&gt; path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//递归函数的本层逻辑</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">        <span class="comment">//收集结果</span></span><br><span class="line">        <span class="keyword">if</span>(t-&gt;left==<span class="literal">nullptr</span>&amp;&amp;t-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="comment">//继续递归</span></span><br><span class="line">        <span class="built_in">tra</span>(t-&gt;left,path);</span><br><span class="line">        <span class="built_in">tra</span>(t-&gt;right,path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定和的路径：</span></span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tra</span><span class="params">(TreeNode *t,vector&lt;<span class="type">int</span>&gt; path,<span class="type">int</span> targetSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//递归函数的本层逻辑</span></span><br><span class="line">        targetSum-=t-&gt;val;</span><br><span class="line">        path.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">        <span class="comment">//收集结果</span></span><br><span class="line">        <span class="keyword">if</span>(t-&gt;left==<span class="literal">nullptr</span>&amp;&amp;t-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">if</span>(targetSum==<span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="comment">//继续递归</span></span><br><span class="line">        <span class="built_in">tra</span>(t-&gt;left,path,targetSum);</span><br><span class="line">        <span class="built_in">tra</span>(t-&gt;right,path,targetSum);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>这类题型DFS注意点：</strong><br>1、如果是找路径和等于给定target的路径的，那么可以不用新增一个临时变量cursum来判断当前路径和，只需要用给定和target减去节点值，最终结束条件判断target&#x3D;&#x3D;0即可</p>
<p>2、是否要回溯：二叉树的问题大部分是不需要回溯的，原因如下：<br>二叉树的递归部分(DFS)：tra(t-&gt;left),tra(t-&gt;right)已经把可能的路径穷尽了,<br>因此到任意叶节点的路径只可能有一条，绝对不可能出现另外的路径也到这个满足条件的叶节点的;</p>
<p>而对比二维数组(例如迷宫问题)的DFS,for循环向四个方向查找每次只能朝向一个方向，并没有穷尽路径，因此某一个满足条件的点可能是有多条路径到该点的</p>
<p>并且visited数组标记已经走过的路径是会受到另外路径是否访问的影响，这时候必须回溯</p>
<p>3、找到路径后是否要return:<br>取决于题目是否要求找到叶节点满足条件的路径,如果必须到叶节点,那么就要return;<br>但如果是到任意节点都可以，那么必不能return,因为这条路径下面还可能有更深的路径满足条件，还要在此基础上继续递归</p>
<p>4、是否要双重递归：看题目要不要求从根节点开始的，还是从任意节点开始（典型题目：<a href="https://leetcode.cn/problems/path-sum-iii/description/?envType=study-plan-v2&envId=top-100-liked">437. 路径总和 III - 力扣（LeetCode）</a>）</p>
<h4 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257.二叉树的所有路径"></a>257.二叉树的所有路径</h4><p><a href="https://leetcode.cn/problems/binary-tree-paths/description/">257. 二叉树的所有路径 - 力扣（LeetCode）</a></p>
<p>这道题就是直接套用模板，只不过是vector path变成了string s，然后加上了-&gt;</p>
<p>这道题把递归函数的本层逻辑放到收集结果的前面是因为这样可以在加最后一个字符的时候不加-&gt;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tra</span><span class="params">(string s,TreeNode *t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;left==<span class="literal">nullptr</span>&amp;&amp;t-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s+=<span class="built_in">to_string</span>(t-&gt;val);</span><br><span class="line">            res.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s+=<span class="built_in">to_string</span>(t-&gt;val);</span><br><span class="line">        s+=<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        <span class="built_in">tra</span>(s,t-&gt;left);</span><br><span class="line">        <span class="built_in">tra</span>(s,t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="built_in">tra</span>(s,root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a>112.路径总和</h4><p><a href="https://leetcode.cn/problems/path-sum/description/">112. 路径总和 - 力扣（LeetCode）</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tra</span><span class="params">(TreeNode *t,<span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        target-=t-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;left==<span class="literal">nullptr</span>&amp;&amp;t-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target==<span class="number">0</span>)</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">tra</span>(t-&gt;left,target);</span><br><span class="line">        <span class="built_in">tra</span>(t-&gt;right,target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">tra</span>(root,targetSum);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="113-路径总和II"><a href="#113-路径总和II" class="headerlink" title="113.路径总和II"></a>113.路径总和II</h4><p><a href="https://leetcode.cn/problems/path-sum-ii/description/">113. 路径总和 II - 力扣（LeetCode）</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tra</span><span class="params">(TreeNode *t,vector&lt;<span class="type">int</span>&gt; path,<span class="type">int</span> targetSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        targetSum-=t-&gt;val;</span><br><span class="line">        path.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;left==<span class="literal">nullptr</span>&amp;&amp;t-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">if</span>(targetSum==<span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="built_in">tra</span>(t-&gt;left,path,targetSum);</span><br><span class="line">        <span class="built_in">tra</span>(t-&gt;right,path,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="built_in">tra</span>(root,path,targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="437-路径总和III"><a href="#437-路径总和III" class="headerlink" title="437.路径总和III"></a>437.路径总和III</h4><p><a href="https://leetcode.cn/problems/path-sum-iii/description/?envType=study-plan-v2&envId=top-100-liked">437. 路径总和 III - 力扣（LeetCode）</a></p>
<p>本题就不是从根节点到叶子节点，而是任意节点到任意节点，只要满足自顶向下即可</p>
<p>而我们之前用的模板其实是从根节点到叶子结点，接下来这么做</p>
<p>1.把判断是不是叶子节点的if去掉，那就是根节点到任意节点的路径</p>
<p>2.那么怎么从任意节点开始呢？</p>
<p>我们的backtracking是之前的从根节点到叶子节点的路径查询去掉了叶子结点的判断if，那就是根节点到任意路径，其实在这道题里面就是当传入的targetSum为0的时候，backtracking就会从传入的节点开始向下搜索，那我们再重新写一个遍历函数，把每个节点都当成根节点传一遍，那每个节点都会向下搜索路径，所以tra就是遍历这课树，遍历的时候让backtracking从当前结点开始向下搜索找到合适的路径</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tra</span><span class="params">(TreeNode *t,<span class="type">long</span> <span class="type">long</span> targetSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(t,targetSum);</span><br><span class="line">        <span class="built_in">tra</span>(t-&gt;left,targetSum);</span><br><span class="line">        <span class="built_in">tra</span>(t-&gt;right,targetSum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(TreeNode *t,<span class="type">long</span> <span class="type">long</span> targetSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        targetSum-=t-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(targetSum==<span class="number">0</span>)</span><br><span class="line">            sum++;</span><br><span class="line">        <span class="built_in">backtracking</span>(t-&gt;left,targetSum);</span><br><span class="line">        <span class="built_in">backtracking</span>(t-&gt;right,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">tra</span>(root,targetSum);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注：这样做的复杂度较高，大家最好学习一下其他题解的时间复杂度较低的做法。</p>
<h4 id="面试题-04-12-求和路径"><a href="#面试题-04-12-求和路径" class="headerlink" title="面试题 04.12.求和路径"></a>面试题 04.12.求和路径</h4><p><a href="https://leetcode.cn/problems/paths-with-sum-lcci/description/">面试题 04.12. 求和路径 - 力扣（LeetCode）</a></p>
<p>本题和路径总和III一样，不过多赘述</p>
<h4 id="998-从叶节点开始的最小字符串"><a href="#998-从叶节点开始的最小字符串" class="headerlink" title="998.从叶节点开始的最小字符串"></a>998.从叶节点开始的最小字符串</h4><p><a href="https://leetcode.cn/problems/smallest-string-starting-from-leaf/description/">988. 从叶结点开始的最小字符串 - 力扣（LeetCode）</a></p>
<p>直接套用模板找出所有的路径最后sort排序即可</p>
<p>注意我们是从上面往下遍历的，要注意收集结果之前要把字符串反转一下</p>
<p>完整代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tra</span><span class="params">(TreeNode *t,string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        s+=<span class="string">&#x27;a&#x27;</span>+t-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;left==<span class="literal">nullptr</span>&amp;&amp;t-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">            res.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">tra</span>(t-&gt;left,s);</span><br><span class="line">        <span class="built_in">tra</span>(t-&gt;right,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">smallestFromLeaf</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="built_in">tra</span>(root,s);</span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2、非自顶向下"><a href="#2、非自顶向下" class="headerlink" title="2、非自顶向下"></a>2、非自顶向下</h3><p>就是从任意节点到任意节点的路径，不需要自顶向下</p>
<p>一般是后序遍历</p>
<p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">543. 二叉树的直径 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/longest-univalue-path/description/">687. 最长同值路径 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/">124. 二叉树中的最大路径和 - 力扣（LeetCode）</a></p>
<p><strong>二、非自顶而下：</strong></p>
<p>这类题目一般解题思路如下：</p>
<p>设计一个后序遍历函数maxpath，调用自身求出以一个节点为根节点的左侧最长路径left和右侧最长路径right，那么经过该节点的最长路径就是left+right</p>
<p>接着只需要从根节点开始dfs,不断比较更新全局变量即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxPath</span><span class="params">(TreeNode *root)</span> <span class="comment">//以root为路径起始点的最长路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left=<span class="built_in">maxPath</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> right=<span class="built_in">maxPath</span>(root-&gt;right);</span><br><span class="line">    res = <span class="built_in">max</span>(res, left + right + root-&gt;val); <span class="comment">//更新全局变量  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left, right);   <span class="comment">//返回左右路径较长者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这类题型DFS注意点：</p>
<p>1、left,right代表的含义要根据题目所求设置，比如最长路径、最大路径和等等</p>
<p>2、全局变量res的初值设置是0还是INT_MIN要看题目节点是否存在负值,如果存在就用INT_MIN，否则就是0</p>
<p>3、注意两点之间路径为1，因此一个点是不能构成路径的，但是如果是路径和的话就另说</p>
<p>4、res &#x3D; max(res, left + right + root-&gt;val); </p>
<p>这个是关键，是以当前根结点为根结点的子树所能做出的最大路径，而在自底向上遍历的过程中，会把每</p>
<p>一个结点当做根节点看看当前子树的最大路径</p>
<p>5.return t-&gt;val+max(left, right);</p>
<p>这是第二个重点，这个保证了我们在树结构的每一层只会选择一个，要么左要么右，而不是既有左子树的</p>
<p>结点又有右子树的结点</p>
<h4 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543.二叉树的直径"></a>543.二叉树的直径</h4><p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">543. 二叉树的直径 - 力扣（LeetCode）</a></p>
<p><strong>1.函数参数以及返回值</strong></p>
<p>maxDepth保存最大值</p>
<p>tra后序遍历进行路径选择</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> maxDepth=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tra</span><span class="params">(TreeNode *t)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>2.终止条件</strong></p>
<p>遇到空就返回0，因为这个对路径和或者最大路径长度的深度没有影响</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(t==<span class="literal">nullptr</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>3.本层递归函数逻辑</strong></p>
<p>left记录左子树深度</p>
<p>right记录右子树深度</p>
<p>更新以当前结点为子树的深度（l+r+1）（包含当前结点的路径长度）和maxDepth之间的大小，最大值赋值给maxDepth</p>
<p>更新后，返回上层递归函数当前子树的最大深度</p>
<p>返回的子树最大深度是因为我们在父节点进行路径选择的时候，当前结点的左右子树不可以同时被选</p>
<p>举个例子 2为当前结点，那我们往1这个父节点返回的时候，4,2和5,2这两条路径只能选择一条，我们挑最大的给父节点</p>
<p>而不是4,2,5这种路径返回给父节点，因为1,2,4,5这种路径是非法的</p>
<p>我们只能是1,2,4或者1,2,5这种的路径</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241202171331677.png" alt="image-20241202171331677"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> left=<span class="built_in">tra</span>(t-&gt;left);</span><br><span class="line"><span class="type">int</span> right=<span class="built_in">tra</span>(t-&gt;right);</span><br><span class="line">maxDepth=<span class="built_in">max</span>(maxDepth,left+right<span class="number">+1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(left,right);</span><br></pre></td></tr></table></figure>

<p><strong>完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxDepth=<span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">tra</span><span class="params">(TreeNode *t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="built_in">tra</span>(t-&gt;left);</span><br><span class="line">        <span class="type">int</span> right=<span class="built_in">tra</span>(t-&gt;right);</span><br><span class="line">        maxDepth=<span class="built_in">max</span>(maxDepth,left+right<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> t=<span class="built_in">tra</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxDepth<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124.二叉树中的最大路径和"></a>124.二叉树中的最大路径和</h4><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/">124. 二叉树中的最大路径和 - 力扣（LeetCode）</a></p>
<p><strong>1.函数参数以及返回值</strong></p>
<p>maxSum保存最大值</p>
<p>choosePath后序遍历进行路径选择</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> maxSum=INT_MIN;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">choosePath</span><span class="params">(TreeNode *t)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>2.终止条件</strong></p>
<p>遇到空就返回0，因为这个对路径和或者最大路径长度的深度没有影响</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(t==<span class="literal">nullptr</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>3.本层递归函数逻辑</strong></p>
<p>1.后序遍历</p>
<p>2.maxSum更新操作表示以当前结点为根结点的子树的最大路径长度或者最大路径和</p>
<p>3.在l和r的地方也要注意，因为题目有负值，所以返回值要和0作比较，如果返回值是个负数，那说明l选择的路径的结点我们都不选，因为对最大路径和是负作用。</p>
<p>4.最后返回值地方返回max(l,r)选择左子树或者右子树其中一个，这样避免了选择同时有左子树和右子树的情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> l=<span class="built_in">max</span>(<span class="built_in">choosePath</span>(t-&gt;left),<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> r=<span class="built_in">max</span>(<span class="built_in">choosePath</span>(t-&gt;right),<span class="number">0</span>);</span><br><span class="line">maxSum=<span class="built_in">max</span>(maxSum,l+r+t-&gt;val);</span><br><span class="line"><span class="keyword">return</span> t-&gt;val+<span class="built_in">max</span>(l,r);</span><br></pre></td></tr></table></figure>

<p><strong>完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxSum=INT_MIN;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">choosePath</span><span class="params">(TreeNode *t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">max</span>(<span class="built_in">choosePath</span>(t-&gt;left),<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">max</span>(<span class="built_in">choosePath</span>(t-&gt;right),<span class="number">0</span>);</span><br><span class="line">        maxSum=<span class="built_in">max</span>(maxSum,l+r+t-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> t-&gt;val+<span class="built_in">max</span>(l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="built_in">choosePath</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="687-最长同值路径"><a href="#687-最长同值路径" class="headerlink" title="687.最长同值路径"></a>687.最长同值路径</h4><p><a href="https://leetcode.cn/problems/longest-univalue-path/description/">687. 最长同值路径 - 力扣（LeetCode）</a></p>
<p><strong>1.函数参数以及返回值</strong></p>
<p>maxDepth保存最大值</p>
<p>tra后序遍历进行路径选择</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tra</span><span class="params">(TreeNode *t)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>2.终止条件</strong></p>
<p>遇到空就返回0，因为这个对路径和或者最大路径长度的深度没有影响</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(t==<span class="literal">nullptr</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>3.本层递归函数逻辑</strong></p>
<p>left记录左子树相同</p>
<p>right记录右子树深度</p>
<p>1.后序遍历</p>
<p>2.res更新操作表示以当前结点为根结点的子树的最大路径长度或者最大路径和。大家可能对这里有疑惑，觉得你怎么知道当前结点和左右子树全都是一样的值呢？如果不知道的话怎么可以写r+l呢？</p>
<p>其实是这样的，如果上面的判断，左边和当前的节点一样，那当前节点和左子树就可以连上，如果不一样那就直接把l&#x3D;0，就相当于把左子树给砍掉了。同理，如果右子树也一样。</p>
<p>而如果可以连上，那说明l+r就是对的，就是以当前结点为根结点的子树中的最长同值路径。</p>
<p>3.在l和r的地方也要注意，因为题目是判断是否相同，所以要进行判断，左右子树返回值分别和当前节点的值进行比较，相等的话就在下层子树返回的基础上++，一旦不相同就要置为0，因为要求连续相等路径，而这条路径相当于已经断了。不用担心前面的没有保存上，res更新的时候会把它给记录下来。</p>
<p>4.最后返回值地方返回max(l,r)选择左子树或者右子树其中一个，这样避免了选择同时有左子树和右子树的情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> l=<span class="built_in">tra</span>(t-&gt;left);</span><br><span class="line"><span class="type">int</span> r=<span class="built_in">tra</span>(t-&gt;right);</span><br><span class="line"><span class="keyword">if</span>(t-&gt;left&amp;&amp;t-&gt;val==t-&gt;left-&gt;val)</span><br><span class="line">	l++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	l=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(t-&gt;right&amp;&amp;t-&gt;right-&gt;val==t-&gt;val)</span><br><span class="line">	r++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	r=<span class="number">0</span>;</span><br><span class="line">res=<span class="built_in">max</span>(res,r+l);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(l,r);</span><br></pre></td></tr></table></figure>

<p><strong>完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">tra</span><span class="params">(TreeNode *t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">tra</span>(t-&gt;left);</span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">tra</span>(t-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;left&amp;&amp;t-&gt;val==t-&gt;left-&gt;val)</span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;right&amp;&amp;t-&gt;right-&gt;val==t-&gt;val)</span><br><span class="line">            r++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r=<span class="number">0</span>;</span><br><span class="line">        res=<span class="built_in">max</span>(res,r+l);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">tra</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>最后补充总结：</code></p>
<p>1.第一题最简单，除了模板以外不需要做什么改动。第二题较难，要根据题目对l，r进行的处理。</p>
<p>第三题最难，也是难在了对l，r的处理上面了。</p>
<p>2.这类型题要点</p>
<p>（1）后序遍历</p>
<p>（2）对l和r的含义和操作要清晰，这是难点</p>
<p>（3）res&#x2F;max值的更新操作要想明白</p>
<p>（4）最后的返回值的含义，其实表现的是路径的选择</p>
]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>刷题总结</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划如何学习</title>
    <url>/2024/11/10/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="动态规划如何学习"><a href="#动态规划如何学习" class="headerlink" title="动态规划如何学习"></a>动态规划如何学习</h1><p>参考灵神的视频和题解做的笔记（灵神YYDS，以后也都会用这套逻辑去思考）</p>
<p><a href="https://www.bilibili.com/video/BV1Xj411K7oF?vd_source=7831c5b97cfc5c745eb48ff04f6515e7&spm_id_from=333.788.videopod.sections">动态规划入门：从记忆化搜索到递推_哔哩哔哩_bilibili</a></p>
<p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/solutions/2569116/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-j99e/">746. 使用最小花费爬楼梯 - 力扣（LeetCode）</a></p>
<h2 id="学习步骤："><a href="#学习步骤：" class="headerlink" title="学习步骤："></a>学习步骤：</h2><p><strong>1.思考递归回溯的暴力穷举法（即深度优先遍历DFS）</strong></p>
<p>注意要<strong>画树形结构</strong>，画完很容易看出哪里是重复的计算，对改成记忆化搜索有好处</p>
<p>可以使用代码随想录的递归三部曲</p>
<p><strong>2.改成记忆化搜索，就是准备一个备忘录数组，保存已经计算过的结果</strong></p>
<p><strong>3.把记忆化搜索1:1翻译成为DP</strong></p>
<p>翻译的时候可以想想代码随想录的动规五部曲，其实到这里五部曲的内容已经全部解决了</p>
<p><code>刷了几道题以后的发现：</code><br>1.思考回溯的时候一般就会把dp数组和下标的含义给想清楚，这一过程就是分割子问题的过程，不然回溯想不出来的，一般而言，dp数组的含义就是题目要求的东西，什么最大价值，最小金额，方案数量都可能是dp数组的含义</p>
<p>2.回溯算法终止条件一般是dp数组的初始化</p>
<p>3.记忆化搜索一般是自底向上，和动态规划的从前往后其实是一样的，只是记忆化是递归里的栈，而动态规划是for循环</p>
<p>4.dfs函数就是dp数组</p>
<p>5.dfs一般传入的参数n在动态规划里面一般是一层for循环，dfs中如果有for循环，那动态规划的递推一般是两层循环，而且n可以和循环中的一个进行替换</p>
<p>6.如果根据回溯的终止条件判断出来是不需要进行初始化的，接下来要注意是不是有不合法的状态，一般而言不合法的状态都可以通过回溯里面的递推公式（一般在返回值的地方）推出来它应该等于多少，然后进行初始化。一般而言还会有另外的初始化方法，就比如让dp数组的下标+1或者+2，这里这么说大家不太理解，等下看看打家劫舍就明白了。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241028203740524.png" alt="image-20241028203740524"></p>
<p>**动态规划有「选或不选」和「枚举选哪个」两种基本思考方式。**在做题时，可根据题目要求，选择适合题目的一种来思考。</p>
<h2 id="枚举选哪个"><a href="#枚举选哪个" class="headerlink" title="枚举选哪个"></a>枚举选哪个</h2><h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746.使用最小花费爬楼梯"></a>746.使用最小花费爬楼梯</h2><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/description/">746. 使用最小花费爬楼梯 - 力扣（LeetCode）</a></p>
<h3 id="第一步：回溯法（深度优先遍历）"><a href="#第一步：回溯法（深度优先遍历）" class="headerlink" title="第一步：回溯法（深度优先遍历）"></a>第一步：回溯法（深度优先遍历）</h3><p>这个过不了，时间复杂度太高，但是这是学习动态规划的必由之路</p>
<p><code>思路：</code></p>
<p>首先思考子问题并画出树形结构图</p>
<p>我们要求到第5个台阶的最小花费，我们可以从第4个加上4的花销上一个台阶，也可以从3加上3的花销上两个台阶</p>
<p>我们要求到第n个台阶的最小花费，我们可以从第n-1个加上n-1的花销上一个台阶，也可以从n-2加上n-2的花销上两个台阶，n-1就是下一个要求的子问题，由n-2和n-3得到，一直到1或2，它的花费就是0，因为可以选择从1或2开始爬楼梯</p>
<p>这样就得到了一个二叉树（以5为例子）</p>
<p>我们要到5的台阶，就要依靠到达4和到达3的结果，来比较得到最小值，所以要得到下层结点向上层返回的结果，那就得用后序遍历来得到4,3的结果</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241029105344787.png" alt="image-20241029105344787"></p>
<p><strong>1.返回值和参数</strong></p>
<p>我们要下层结点的最小值，所以要int</p>
<p>cost是题目中的花费数组，index是记录我们遍历到哪里了，相当于for循环里面的i</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost,<span class="type">int</span> index)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>2.终止条件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(index==<span class="number">0</span>||index==<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>0其实是第一个台阶，1其实是第二个台阶，因为cost数组从0开始。</p>
<p>爬第一个或第二个台阶不需要花费，所以直接返回0</p>
<p><strong>3.本层逻辑</strong></p>
<p>左子树返回爬上第n-1台阶的最小值</p>
<p>右子树返回爬上第n-2台阶的最小值</p>
<p>最后本层返回的就是两者的最小值作为结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> l=<span class="built_in">dfs</span>(cost,index<span class="number">-1</span>)+cost[index<span class="number">-1</span>];</span><br><span class="line"><span class="type">int</span> r=<span class="built_in">dfs</span>(cost,index<span class="number">-2</span>)+cost[index<span class="number">-2</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">min</span>(l,r);</span><br></pre></td></tr></table></figure>

<p><strong>完整代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost,<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span>||index==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">dfs</span>(cost,index<span class="number">-1</span>)+cost[index<span class="number">-1</span>];</span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">dfs</span>(cost,index<span class="number">-2</span>)+cost[index<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(cost,cost.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++还可用lambda来写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> index)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index==<span class="number">0</span>||index==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">dfs</span>(index<span class="number">-1</span>)+cost[index<span class="number">-1</span>],<span class="built_in">dfs</span>(index<span class="number">-2</span>)+cost[index<span class="number">-2</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(cost.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第二步：改成记忆化搜索"><a href="#第二步：改成记忆化搜索" class="headerlink" title="第二步：改成记忆化搜索"></a>第二步：改成记忆化搜索</h3><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/000.png" alt="000"></p>
<p>从图中可以看到，这些地方就是重复计算的地方，可以直接砍掉。</p>
<p>怎么砍呢？</p>
<p><strong>我们在遍历过程中，如果是第一次碰到这个数字呢，我们就把它的计算结果给保存到一个数组当中去，下次要用的话直接从数组里面拿而不用再次进行递归计算了。</strong></p>
<p>砍完之后还剩下啥：只需要计算3,4,5，你会发现时间复杂度竟然变成了O(n)，成了线性的，那这不就和递推一样了么？用1,2计算3，用2,3计算4，用3,4计算5得出结果。</p>
<p>在递归进行记忆化搜索里面，这是自底向上的计算，算5，要去递归3,4，然后一层一层递归</p>
<p>到最后1和2的时候直接返回0，然后得出3的最小，然后根据2,3得出4的最小，最后一层一层返回知道最后。</p>
<p>下面就来看递推。</p>
<p><strong>完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost,vector&lt;<span class="type">int</span>&gt;&amp; dp,<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span>||index==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//碰到了算过的，那就直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(dp[index]!=<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[index];</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">dfs</span>(cost,dp,index<span class="number">-1</span>)+cost[index<span class="number">-1</span>];</span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">dfs</span>(cost,dp,index<span class="number">-2</span>)+cost[index<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[index]=<span class="built_in">min</span>(l,r);</span><br><span class="line">        <span class="comment">//1.return dp[index]=min(dfs(cost,dp,index-1)+cost[index-1],dfs(cost,dp,index-2)+cost[index-2]);这样写也行</span></span><br><span class="line">        <span class="comment">//2.dp[index]=min(l,r);</span></span><br><span class="line">        <span class="comment">//return dp[index];也行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size()<span class="number">+1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(cost,dp,cost.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size()<span class="number">+1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> index)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index==<span class="number">0</span>||index==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[index]!=<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> dp[index];</span><br><span class="line">            <span class="type">int</span>&amp; res=dp[index];</span><br><span class="line">            <span class="keyword">return</span> res=<span class="built_in">min</span>(<span class="built_in">dfs</span>(index<span class="number">-1</span>)+cost[index<span class="number">-1</span>],<span class="built_in">dfs</span>(index<span class="number">-2</span>)+cost[index<span class="number">-2</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(cost.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>注意点</code>：<br>1.传入的dp备忘录必须是引用传入，不然的话下层的结果保存不到数组里面，每一层的dp数组还全都是-1，就和DFS逻辑一样了其实。dp数组不会起到任何作用</p>
<p>2.对dp[index]一定要赋值，不能直接返回min(l,r)，不然dp数组不会更新</p>
<p>3.l和r不可以替换成dp[index-1]和dp[index-2]。（如果有小伙伴不幸和一样犯了这个错误，那就继续看吧）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dp[index<span class="number">-1</span>]=<span class="built_in">dfs</span>(cost,dp,index<span class="number">-1</span>)+cost[index<span class="number">-1</span>];</span><br><span class="line"><span class="type">int</span> dp[index<span class="number">-2</span>]=<span class="built_in">dfs</span>(cost,dp,index<span class="number">-2</span>)+cost[index<span class="number">-2</span>];</span><br><span class="line"><span class="keyword">return</span> dp[index]=<span class="built_in">min</span>(l,r);</span><br></pre></td></tr></table></figure>

<p>我先说答案：这种乍一看挺对的，实际上没有想清楚dfs返回值到底是什么，dfs（index-1）的返回值是dp[index-1]，如果再加上cost[index-1]，那得到的应该是dp[index]，而不是dp[index]。</p>
<p><strong>下面是我没彻底弄懂之前写的，只是记录一下自己的思考过程，不想看的可以跳过了</strong></p>
<p>这种方式会刷新我们已经保存过的dp[index]，就比如起始的0和1，dp[0]和dp[1]花费最小值本来都是0，但是用这个在计算dp[3]的时候会把dp[0]和dp[1]赋值为cost[0]和cost[1]。</p>
<p>然后dp[2]&#x3D;dp[0]+cost[0]&#x3D;2，可是我们一看这肯定是1怎么能是2呢？</p>
<p>后面的dp[3]也是最开始被更新为3，后面直接变成4了，这就是再次刷新了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">cost =</span><br><span class="line">[<span class="number">1</span>,<span class="number">100</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">100</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">100</span>,<span class="number">1</span>]</span><br><span class="line">标准输出</span><br><span class="line">index=<span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">100</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line">index=<span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">100</span> <span class="number">2</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line">index=<span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">100</span> <span class="number">3</span> <span class="number">3</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line">index=<span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">100</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line">index=<span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">100</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">104</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line">index=<span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">100</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">204</span> <span class="number">6</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line">index=<span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">100</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">204</span> <span class="number">7</span> <span class="number">7</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line">index=<span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">100</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">204</span> <span class="number">7</span> <span class="number">8</span> <span class="number">107</span> <span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line">index=<span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">100</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">204</span> <span class="number">7</span> <span class="number">8</span> <span class="number">207</span> <span class="number">9</span> <span class="number">-1</span> </span><br></pre></td></tr></table></figure>

<p>正确的打印：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cost =</span><br><span class="line">[<span class="number">1</span>,<span class="number">100</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">100</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">100</span>,<span class="number">1</span>]</span><br><span class="line">标准输出</span><br><span class="line">index=<span class="number">2</span></span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line">index=<span class="number">3</span></span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> <span class="number">1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line">index=<span class="number">4</span></span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line">index=<span class="number">5</span></span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line">index=<span class="number">6</span></span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line">index=<span class="number">7</span></span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line">index=<span class="number">8</span></span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line">index=<span class="number">9</span></span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line">index=<span class="number">10</span></span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">-1</span> </span><br></pre></td></tr></table></figure>

<h3 id="第三步：一比一翻译成动态规划-递推"><a href="#第三步：一比一翻译成动态规划-递推" class="headerlink" title="第三步：一比一翻译成动态规划(递推)"></a>第三步：一比一翻译成动态规划(递推)</h3><p><strong>1.确定dp数组以及下标的含义</strong></p>
<p>dp数组含义是登上第i个台阶由多少种方法</p>
<p>i下标就是第i+1个台阶</p>
<p><strong>2.确定递推公式</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[i]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>]);</span><br></pre></td></tr></table></figure>

<p>这个就是在回溯的两个选择里面挑一个小的</p>
<p>就是记忆化搜索里面的返回值</p>
<p><strong>3.dp数组如何初始化</strong></p>
<p>就是回溯里面的终止条件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size()<span class="number">+1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>,dp[<span class="number">1</span>]=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>4.确定遍历顺序</strong></p>
<p>后面的5要依靠前面3,4的计算结果，所以肯定是正向遍历</p>
<p><strong>完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size()<span class="number">+1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>,dp[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=cost.<span class="built_in">size</span>();i++)</span><br><span class="line">            dp[i]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>]);</span><br><span class="line">        <span class="keyword">return</span> dp[cost.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>其实也不需要把所有的结果全都给记住，只需要记住i的前一个i-1（b）和前前一个i-2（a）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//a=dp[0],b=dp[1]</span></span><br><span class="line">        <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=cost.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> c=<span class="built_in">min</span>(a+cost[i<span class="number">-2</span>],b+cost[i<span class="number">-1</span>]);</span><br><span class="line">            a=b;</span><br><span class="line">            b=c;</span><br><span class="line">		&#125; </span><br><span class="line">        <span class="comment">//c=dp[i] a=dp[i-1] b=dp[i]然后下一次循环的时候i++，a就变成dp[i-2],b变成dp[i-1]</span></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="选或不选"><a href="#选或不选" class="headerlink" title="选或不选"></a>选或不选</h2><h3 id="一、198-打家劫舍"><a href="#一、198-打家劫舍" class="headerlink" title="一、198.打家劫舍"></a>一、198.打家劫舍</h3><p><a href="https://leetcode.cn/problems/house-robber/description/">198. 打家劫舍 - 力扣（LeetCode）</a></p>
<h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><p><strong>树形结构图</strong></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241110122753429.png" alt="image-20241110122753429"></p>
<p>先明确一下dp数组&#x2F;dfs函数的含义，dp[i]就是在前i个房子里面打家劫舍，能得到的最高金额（就是题目要求的）</p>
<p>我们从最后一个房子倒着往前分析子问题</p>
<p>对于一个房子i，我们只有两种方案，选或者不选</p>
<p>选了的话，那我i-1就不能选了</p>
<p>不选的话，那我前i个房子可以得到的最大金额数量就和前i-1个房子可以得到的最大金额数量相等，因为第i个房子没选</p>
<p>所以可以很轻易的得出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i]);</span><br></pre></td></tr></table></figure>

<p><strong>即在可能的两种方案中挑选一个最大值</strong></p>
<h3 id="1-回溯-DFS"><a href="#1-回溯-DFS" class="headerlink" title="1.回溯 DFS"></a>1.回溯 DFS</h3><p><strong>1.返回值和参数</strong></p>
<p>i是房子编号</p>
<p>nums是房子数字</p>
<p>dfs返回值就是前i个房子里面打家劫舍可以得到的最大金额（和dp数组含义相同）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i,vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>2.终止条件</strong></p>
<p>可以看到我们递归到0就是叶子结点了，下标0是第一个房子，所以小于0就代表没有房子可以选了，没有房子可以选也就没有金额，就返回0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>3.本层逻辑</strong></p>
<p>如上所说，返回两者的最大值给上层递归函数就好</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>,nums),<span class="built_in">dfs</span>(i<span class="number">-2</span>,nums)+nums[i]);</span><br></pre></td></tr></table></figure>

<p><strong>完整代码：</strong></p>
<p>当然，这是超时的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i,vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>,nums),<span class="built_in">dfs</span>(i<span class="number">-2</span>,nums)+nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums.<span class="built_in">size</span>()<span class="number">-1</span>,nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-记忆化搜索"><a href="#2-记忆化搜索" class="headerlink" title="2.记忆化搜索"></a>2.记忆化搜索</h3><p>就是搞一个哈希表dp，全都初始化为-1，每次返回前给哈希表dp赋值，碰到不是-1的那就是算过的，那就直接返回计算过的结果，不需要再次递归了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i,vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">int</span>&gt;&amp; dp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]!=<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[i];</span><br><span class="line">        <span class="keyword">return</span> dp[i]=<span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>,nums,dp),<span class="built_in">dfs</span>(i<span class="number">-2</span>,nums,dp)+nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums.<span class="built_in">size</span>()<span class="number">-1</span>,nums,dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-1翻译为动态规划"><a href="#3-1-1翻译为动态规划" class="headerlink" title="3.1:1翻译为动态规划"></a>3.1:1翻译为动态规划</h3><p><strong>1.确定dp数组以及下标的含义</strong></p>
<p>dp数组就是前i个房子里面可以取得的最大金额</p>
<p>下标就是房子编号</p>
<p><strong>2.确定递推公式</strong></p>
<p>忘记了原因的请看思路分析部分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i]);</span><br></pre></td></tr></table></figure>

<p><strong>3.dp数组如何初始化</strong></p>
<p><strong>第一种写法</strong>，dp数组的下标从0开始，在i&#x3D;0和i&#x3D;1我们的递推公式中会有不合法的状态，所以i需要从2开始</p>
<p>那么dp[0]和dp[1]就需要初始化，那么初始化为多少呢？</p>
<p>如果可以根据dp的含义想通如何初始化是最好的，比如前1间房子最大值就是nums[0]，前两间房子最大值就是max(nums[0],nums[1])</p>
<p>如果想不通的话，回到回溯法把0和1带进去就完事得出结果就完事</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i,vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>,nums),<span class="built_in">dfs</span>(i<span class="number">-2</span>,nums)+nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums.<span class="built_in">size</span>()<span class="number">-1</span>,nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>会得到如下的初始化方案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">      dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">          dp[<span class="number">1</span>]=<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p><strong>第二种写法</strong></p>
<p>dp数组的下标全部都+2（注意nums数组的下标是没变的，此时dp数组的2对应的是nums的0）</p>
<p>这样就避免了下标是负数的情况，完美贴合了dfs回溯的方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size()<span class="number">+2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">          dp[i<span class="number">+2</span>]=<span class="built_in">max</span>(dp[i<span class="number">+1</span>],dp[i]+nums[i]);</span><br></pre></td></tr></table></figure>

<p><strong>4.确定遍历顺序</strong></p>
<p>后续结果需要依赖前面的计算结果，故使用从前往后遍历</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">	dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i]);</span><br></pre></td></tr></table></figure>

<p><strong>完整代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">            dp[<span class="number">1</span>]=<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size()<span class="number">+2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            dp[i<span class="number">+2</span>]=<span class="built_in">max</span>(dp[i<span class="number">+1</span>],dp[i]+nums[i]);</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>()<span class="number">+1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.bilibili.com/video/BV16Y411v7Y6?spm_id_from=333.788.videopod.sections&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">0-1背包 完全背包_哔哩哔哩_bilibili</a></p>
<h3 id="二、01背包（模板，可以配合该视频和代码随想录博客一起看）"><a href="#二、01背包（模板，可以配合该视频和代码随想录博客一起看）" class="headerlink" title="二、01背包（模板，可以配合该视频和代码随想录博客一起看）"></a>二、01背包（模板，可以配合该视频和代码随想录博客一起看）</h3><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241031120326938.png" alt="image-20241031120326938"></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241031125050721.png" alt="image-20241031125050721"></p>
<p>恰好装这个容量，求方案数量的最大最小价值和，那就是把选最大值的操作换成加号</p>
<p><a href="https://leetcode.cn/problems/target-sum/description/">494. 目标和 - 力扣（LeetCode）</a></p>
<p>后续如果做到了其他的变形题目会同步更新到这里</p>
<h3 id="第一步：回溯法（深度优先遍历）-1"><a href="#第一步：回溯法（深度优先遍历）-1" class="headerlink" title="第一步：回溯法（深度优先遍历）"></a>第一步：回溯法（深度优先遍历）</h3><p><code>思路：</code></p>
<p>配合视频一起看更棒</p>
<p><a href="https://www.bilibili.com/video/BV16Y411v7Y6?spm_id_from=333.788.videopod.sections&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">0-1背包 完全背包_哔哩哔哩_bilibili</a></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241031122300319.png" alt="image-20241031122300319"></p>
<p>下面的就不画了，大家知道这个意思就行</p>
<p>选编号为i的话就是返回dfs(i-1,c-w[i])+v[i]，就是代表已经把编号为i的物品已经放入了背包（表现为容量减了w[i]，价值加了v[i]），然后继续递归下一个物品</p>
<p>不选编号为i的话就是返回dfs(i-1,c)，这个代表的是一共有i-1个物品，总共是c的容量，那背包能装的最大价值是多少</p>
<p>我们本层函数会产生两个递归，一个是选了i，一个是没选i，返回的都是对应情况的最大值，我们要选最大的，所以要在这两个里面再选一个更大的作为返回值返回</p>
<p>从而得出了递推公式。</p>
<p><strong>这个虽然过不了，时间复杂度太高，但是这是学习动态规划的必由之路</strong></p>
<p><strong>1.返回值和参数</strong></p>
<p>w各个物品所占空间</p>
<p>v各个物品价值</p>
<p>i遍历物品</p>
<p>c是当前剩余的容量</p>
<p><strong>返回值返回选或不选编号为i的物品的最大值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w,vector&lt;<span class="type">int</span>&gt;&amp; v,<span class="type">int</span> i,<span class="type">int</span> c)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>2.终止条件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(c&lt;w[i])</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c);</span><br></pre></td></tr></table></figure>

<p>如果编号小于0说明已经到了树形结构最下面了，要开始从第一个物品选了，即自底（第一个物品）向上（i依次增大）开始遍历</p>
<p>如果当前容量已经小于要选的物品，那就直接返回给上层不选i号物品的结果</p>
<p><strong>3.本层逻辑</strong></p>
<p>在选和不选当前物品两种情况中（只要返回回来的一定是最大值），挑一个更大的返回</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c),<span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c-w[i])+v[i]);</span><br></pre></td></tr></table></figure>

<p><strong>完整代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w,vector&lt;<span class="type">int</span>&gt;&amp; v,<span class="type">int</span> i,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(c&lt;w[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c),<span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c-w[i])+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="number">01</span>knapsack(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(w,v,nums.<span class="built_in">size</span>()<span class="number">-1</span>,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++还可用lambda来写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="number">01</span>knapsack(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i,<span class="type">int</span> c)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(c&lt;w[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">-1</span>,c);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>,c),<span class="built_in">dfs</span>(i<span class="number">-1</span>,c-w[i])+v[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums.<span class="built_in">size</span>()<span class="number">-1</span>,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第二步：改成记忆化搜索-1"><a href="#第二步：改成记忆化搜索-1" class="headerlink" title="第二步：改成记忆化搜索"></a>第二步：改成记忆化搜索</h3><p>注意，在递归函数中，我们同时有物品编号i和容量c，所以要用一个二维数组作为哈希表来存储计算结果进行复用。</p>
<p>然后在每次返回结果前都赋值一下，把计算结果给存储起来</p>
<p><strong>完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w,vector&lt;<span class="type">int</span>&gt;&amp; v,<span class="type">int</span> i,<span class="type">int</span> c,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][c]!=<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[i][c];</span><br><span class="line">        <span class="keyword">if</span>(c&lt;w[i])</span><br><span class="line">            <span class="keyword">return</span> dp[i][c]=<span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c,dp);</span><br><span class="line">        <span class="keyword">return</span> dp[i][c]=<span class="built_in">max</span>(<span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c,dp),<span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c-w[i],dp)+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="number">01</span>knapsack(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>,<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(w,v,nums.<span class="built_in">size</span>()<span class="number">-1</span>,c,dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="number">01</span>knapsack(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>,<span class="number">-1</span>));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i,<span class="type">int</span> c)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][c]!=<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> dp[i][c];</span><br><span class="line">            <span class="keyword">if</span>(c&lt;w[i])</span><br><span class="line">                <span class="keyword">return</span> dp[i][c]=<span class="built_in">dfs</span>(i<span class="number">-1</span>,c);</span><br><span class="line">            <span class="keyword">return</span> dp[i][c]=<span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>,c),<span class="built_in">dfs</span>(i<span class="number">-1</span>,c-w[i])+v[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums.<span class="built_in">size</span>()<span class="number">-1</span>,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第三步：一比一翻译成动态规划-递推-1"><a href="#第三步：一比一翻译成动态规划-递推-1" class="headerlink" title="第三步：一比一翻译成动态规划(递推)"></a>第三步：一比一翻译成动态规划(递推)</h3><p><strong>1.确定dp数组以及下标的含义</strong></p>
<p>二维数组，dp[i][c]就是第i个物品在容量为c时可以取到的最大价值</p>
<p>i是物品编号</p>
<p>c是当前背包的总容量</p>
<p><strong>2.确定递推公式</strong></p>
<p>对应回溯算法本层逻辑部分</p>
<p>选或者不选第i号物品，如果没选，那就和上一个物品第i-1件遍历到j时一样的价值，因为没有选第i号</p>
<p>如果选了那就是   第i-1件物品在j-w[i]时的价值+选择的第i件物品的价值v[i]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-w[i]]+v[i]);</span><br></pre></td></tr></table></figure>

<p><strong>3.dp数组如何初始化</strong></p>
<p>全都初始化为0</p>
<p>第一行在容量大于第一件物品所需容量的时候就当做把第一件给放了进行初始化</p>
<p>因为dp[0][i]的物品编号只有0，即第一件物品，所以只能选择第一件物品得到最大价值，不选的话价值就为0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=w[<span class="number">0</span>];i&lt;=c;i++)</span><br><span class="line">	dp[<span class="number">0</span>][i]=v[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p><strong>4.确定遍历顺序</strong></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/20240730174246.png" alt="20240730174246"></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/20240730174436.png" alt="20240730174436"></p>
<p>从前往后遍历，先遍历物品或者先遍历容量都是可以的，因为先物品是按照行一行一行来遍历，递推公式中的两个值都可以在遍历得出来，按照容量一列一列遍历也同样可以得出来这两个值</p>
<p>但仅限于二维，如果是一维那就只能先遍历物品后遍历容量，而且只能从后往前遍历容量</p>
<p>因为递推公式中用到的两个值在一维中变成了这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(c<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=c;j&gt;=w[i];j--)</span><br><span class="line">		dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241031155145293.png" alt="image-20241031155145293"></p>
<p>第一行是刷新前的数组，第二行是要对第一行进行覆盖的值，通过第一行的dp[j]和dp[j-w[i]]这两个值进行更新</p>
<p>如果从前往后，那dp[j-w[i]]就会被覆盖，从而得到一个错误的答案</p>
<p>如果不太理解可以转至：<a href="https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
<p><a href="https://www.bilibili.com/video/BV16Y411v7Y6/?spm_id_from=333.788.videopod.sections&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">0-1背包 完全背包_哔哩哔哩_bilibili</a>视频里面也会讲到滚动数组相关</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=c;j++)</span><br><span class="line">	<span class="keyword">if</span>(j&gt;w[i])</span><br><span class="line">		dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-w[i]]+v[i]);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">    	dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br></pre></td></tr></table></figure>

<p><strong>完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="number">01</span>knapsack(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=w[<span class="number">0</span>];i&lt;=c;i++)</span><br><span class="line">            dp[<span class="number">0</span>][i]=v[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=c;j++)</span><br><span class="line">                <span class="keyword">if</span>(j&gt;w[i])</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-w[i]]+v[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">return</span> dp[w.<span class="built_in">size</span>()<span class="number">-1</span>][c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="优化成一维数组：滚动数组"><a href="#优化成一维数组：滚动数组" class="headerlink" title="优化成一维数组：滚动数组"></a>优化成一维数组：滚动数组</h3><p>笔者就不误人子弟了，大家转至此链接<a href="https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a>进行学习</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="number">01</span>knapsack(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(c<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=c;j&gt;=w[i];j--)</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">        <span class="keyword">return</span> dp[c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>刷题总结</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>完全背包求方案数量（排列和组合数量）</title>
    <url>/2024/11/08/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E6%B1%82%E6%96%B9%E6%A1%88%E6%95%B0%E9%87%8F%EF%BC%88%E6%8E%92%E5%88%97%E5%92%8C%E7%BB%84%E5%90%88%E6%95%B0%E9%87%8F%EF%BC%89/</url>
    <content><![CDATA[<h2 id="完全背包求方案数量（排列和组合数量）"><a href="#完全背包求方案数量（排列和组合数量）" class="headerlink" title="完全背包求方案数量（排列和组合数量）"></a>完全背包求方案数量（排列和组合数量）</h2><p>先遍历物品，后遍历背包容量 得到的就是nums能凑成target的组合</p>
<p>先遍历背包容量，后遍历物品 得到的就是nums能凑成target的排列</p>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>经典题目零钱兑换II</p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/143603063?spm=1001.2014.3001.5501">Day39 | 动态规划 ：完全背包应用 零钱兑换&amp;&amp;零钱兑换II-CSDN博客</a></p>
<h3 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h3><p>经典题目组合总和IV</p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/143616316?spm=1001.2014.3001.5501">Day40 | 动态规划 ：完全背包应用 组合总和IV（类比爬楼梯）-CSDN博客</a></p>
]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>刷题总结</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录二刷总结以及感受</title>
    <url>/2024/12/05/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E4%BA%8C%E5%88%B7%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8A%E6%84%9F%E5%8F%97/</url>
    <content><![CDATA[<h1 id="代码随想录二刷总结以及感受"><a href="#代码随想录二刷总结以及感受" class="headerlink" title="代码随想录二刷总结以及感受"></a>代码随想录二刷总结以及感受</h1><h2 id="二刷时进行的刷题记录"><a href="#二刷时进行的刷题记录" class="headerlink" title="二刷时进行的刷题记录"></a>二刷时进行的刷题记录</h2><p>笔者懒得找对应的天数了，大家自行查找想看的吧(嘻~)</p>
<p><a href="https://blog.csdn.net/m0_74795952/category_12687500.html?spm=1001.2014.3001.5482">刷题记录_为了前进而后退，为了走直路而走弯路的博客-CSDN博客</a></p>
<h2 id="刷题总结"><a href="#刷题总结" class="headerlink" title="刷题总结"></a>刷题总结</h2><p><a href="https://blog.csdn.net/m0_74795952/category_12819992.html">刷题总结_为了前进而后退，为了走直路而走弯路的博客-CSDN博客</a></p>
<h2 id="总结及感受"><a href="#总结及感受" class="headerlink" title="总结及感受"></a>总结及感受</h2><p>1.截止2024&#x2F;12&#x2F;5 12:24，算是把代码随想录二刷完毕了</p>
<p><strong>贪心章节第二遍刷的时候没写，因为不是很喜欢没有规律性的题目</strong></p>
<p>2.代码随想录适合大家学习完数据结构进行算法入门，大家也可以边学数据结构边刷代码随想录，效果估计会更好的</p>
<p>3.递归会占很大的占比，大家学会递归可以做二叉树，回溯和动态规划，所以一定要学好递归</p>
<p>4.动态规划章节：代码随想录除了动态规划章节都做的很棒，直接上来就dp感觉还是不太好，对新手更是不友好，还是要遵循</p>
<p><strong>DFS-&gt;记忆化搜索-&gt;递归</strong></p>
<p>这个路线进行系统学习才好，有人可能觉得这样又难又麻烦，这样的确很麻烦，但是会让你有种学会了规律的感觉，觉得是值得的，而不是说是看见dp了在哪里凭空想象，凭感觉总归还是不行的。</p>
<p>视频推荐：<a href="https://www.bilibili.com/video/BV1Xj411K7oF?spm_id_from=333.788.videopod.sections&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">动态规划入门：从记忆化搜索到递推_哔哩哔哩_bilibili</a>（当然我看了这个视频就回不来了，后面基本都看的灵神）</p>
<p>大家也可以去b站找找别的这类型的视频</p>
<p><strong>另外，大家刷动态规划也别着急，这玩意真是难，我第一次刷一道题也做不出来，第二次能做出来简单的，难的听了也能总结总结模板，接下来再刷刷估计就好很多了</strong></p>
<p>5.二叉树和回溯的顺序先刷哪个？</p>
<p>我觉得如果是纯新手的话还是从二叉树开始比较好，不然对递归理解不够深刻的话，回溯算法可能会不太理解</p>
<p>可以先通过二叉树的学习加深对递归的理解</p>
<p>6.训练营有没有必要？<br>我的感受是没啥必要，自己每天刷一刷，写写题解就好，如果不会写题解的话可以参考一下我的题解，主要能体现自己的思考过程就行，当然还是看你自己吧，想报报一个也没坏处</p>
<h2 id="之后的刷题打算"><a href="#之后的刷题打算" class="headerlink" title="之后的刷题打算"></a>之后的刷题打算</h2><p>之后我打算去跟灵神的视频和题单再过一遍笔试高频的算法，然后继续写题解，如果有什么问题可以在评论区或者私信博主</p>
<p>灵神视频：<a href="https://www.bilibili.com/video/BV1bP411c7oJ?spm_id_from=333.788.videopod.sections&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">两数之和 三数之和【基础算法精讲 01】_哔哩哔哩_bilibili</a></p>
<p>灵神题单：<a href="https://leetcode.cn/circle/discuss/RvFUtj/">分享｜如何科学刷题？ - 力扣（LeetCode）</a></p>
<p>如果有时间的话，就继续吧hot100给续上(如果有时间的话…….)</p>
<h2 id="算法小白要不要直接跟灵神？"><a href="#算法小白要不要直接跟灵神？" class="headerlink" title="算法小白要不要直接跟灵神？"></a>算法小白要不要直接跟灵神？</h2><p>你可以试着听几节，如果能听懂，那就跟，听不太懂就还是跟代码随想录吧（动态规划章节除外）</p>
]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>刷题总结</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录回溯算法章节小总结</title>
    <url>/2024/10/14/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="回溯算法章节小总结"><a href="#回溯算法章节小总结" class="headerlink" title="回溯算法章节小总结"></a>回溯算法章节小总结</h1><h2 id="1-树层去重"><a href="#1-树层去重" class="headerlink" title="1.树层去重"></a>1.树层去重</h2><h3 id="1-可以对原数组排序的"><a href="#1-可以对原数组排序的" class="headerlink" title="1.可以对原数组排序的"></a>1.可以对原数组排序的</h3><p><a href="https://leetcode.cn/problems/combination-sum-ii/description/">40. 组合总和 II - 力扣（LeetCode）</a></p>
<p>通过排序+相邻元素相同+used数组来进行去重</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">          result.<span class="built_in">push_back</span>(path);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;</span><br><span class="line">          <span class="comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span></span><br><span class="line">          <span class="comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span></span><br><span class="line">          <span class="comment">// 要对同一树层使用过的元素进行跳过</span></span><br><span class="line">          <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          sum += candidates[i];</span><br><span class="line">          path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">          used[i] = <span class="literal">true</span>;</span><br><span class="line">          <span class="built_in">backtracking</span>(candidates, target, sum, i + <span class="number">1</span>, used); <span class="comment">// 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次</span></span><br><span class="line">          used[i] = <span class="literal">false</span>;</span><br><span class="line">          sum -= candidates[i];</span><br><span class="line">          path.<span class="built_in">pop_back</span>();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-原数组不可以排序的，可以用哈希表"><a href="#2-原数组不可以排序的，可以用哈希表" class="headerlink" title="2.原数组不可以排序的，可以用哈希表"></a>2.原数组不可以排序的，可以用哈希表</h3><p><a href="https://leetcode.cn/problems/subsets-ii/description/">90. 子集 II - 力扣（LeetCode）</a>（本题可以排序）</p>
<p>使用set哈希表来对同一层选过的元素进行标记</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; uset;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uset.<span class="built_in">find</span>(nums[i]) != uset.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            uset.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-树枝去重"><a href="#2-树枝去重" class="headerlink" title="2.树枝去重"></a>2.树枝去重</h2><p>1.一般是在参数index处去除，传入i+1就避免了这一问题</p>
<p>2.排序+used数组</p>
<p><a href="https://leetcode.cn/problems/permutations-ii/description/">47. 全排列 II - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">backtracking</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 此时说明找到了一组</span></span><br><span class="line">       <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">           result.<span class="built_in">push_back</span>(path);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">           <span class="comment">// used[i - 1] == true，说明同一树枝nums[i - 1]使用过</span></span><br><span class="line">           <span class="comment">// used[i - 1] == false，说明同一树层nums[i - 1]使用过</span></span><br><span class="line">           <span class="comment">// 如果同一树层nums[i - 1]使用过则直接跳过</span></span><br><span class="line">           <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (used[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">               used[i] = <span class="literal">true</span>;</span><br><span class="line">               path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">               <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">               path.<span class="built_in">pop_back</span>();</span><br><span class="line">               used[i] = <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-区间切割"><a href="#3-区间切割" class="headerlink" title="3.区间切割"></a>3.区间切割</h2><p><code>问题模板：</code></p>
<p>重点是理解区间[index,i]的使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">res结果集;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is</span><span class="params">([index,i]区间)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断合法性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="keyword">or</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(函数参数)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(终止条件)</span><br><span class="line">    &#123;</span><br><span class="line">        res结果收集;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">is</span>(传入[index,i]这个区间))</span><br><span class="line">            path收集;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span> <span class="keyword">or</span> <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//下一层递归</span></span><br><span class="line">        <span class="built_in">backtracking</span>(函数参数);</span><br><span class="line">        回溯过程;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-棋盘问题"><a href="#4-棋盘问题" class="headerlink" title="4.棋盘问题"></a>4.棋盘问题</h2><p><a href="https://leetcode.cn/problems/sudoku-solver/description/">37. 解数独 - 力扣（LeetCode）</a></p>
<p>二维的回溯，其实就是一维铺开，还是一维的思考方式，只不过遍历的时候遍历的是二维而已。</p>
]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>刷题总结</tag>
        <tag>算法</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>完全背包模板</title>
    <url>/2024/11/07/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="完全背包模板"><a href="#完全背包模板" class="headerlink" title="完全背包模板"></a>完全背包模板</h2><h2 id="选或不选"><a href="#选或不选" class="headerlink" title="选或不选"></a>选或不选</h2><p><a href="https://www.bilibili.com/video/BV16Y411v7Y6?spm_id_from=333.788.videopod.sections&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">0-1背包 完全背包_哔哩哔哩_bilibili</a></p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/143336356">动态规划应该如何学习？-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/143403890">01背包模板 | 学习总结-CSDN博客</a></p>
<h2 id="完全背包（模板，可以配合该视频和我的博客一起看，代码随想录的不推荐看）"><a href="#完全背包（模板，可以配合该视频和我的博客一起看，代码随想录的不推荐看）" class="headerlink" title="完全背包（模板，可以配合该视频和我的博客一起看，代码随想录的不推荐看）"></a>完全背包（模板，可以配合该视频和我的博客一起看，代码随想录的不推荐看）</h2><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241107144115280.png" alt="image-20241107144115280"></p>
<h2 id="完全背包的理解"><a href="#完全背包的理解" class="headerlink" title="完全背包的理解"></a>完全背包的理解</h2><p>1.首先要知道dfs&#x2F;dp含义是在前i个物品容量为c的情况下能选出来的最大价值</p>
<p>2.其实就是把递推公式里面的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c-w[i])+v[i]改为<span class="built_in">dfs</span>(w,v,i,c-w[i])+v[i]</span><br></pre></td></tr></table></figure>

<p>原来是第i个物品选或者不选</p>
<p>现在是轮到第i个物品的时候尽可能的多拿</p>
<p>3.有人可能疑惑这样能不能选出来最大值</p>
<p>其实它每次选都会和没有选第i个物品容量为c的dp[i-1][c]进行比较，只有dp[i][c-w[i]]+w[i]大的时候才会更新</p>
<p>4.01背包中我们第i个物品的两个选择全都来自i-1时候（正上方和左上方）</p>
<p>现在一个是i-1一个是i（正上方和同一行左方）</p>
<p>所以遍历的时候只能从前往后不可以从后往前，因为后面的结果要依赖前面的结果</p>
<p>5.由i-1到i为什么能够代表第i个无限拿？</p>
<p>我们传入的i的含义是第i个元素拿不拿</p>
<p>不拿就是：dfs(w,v,i-1,c)</p>
<p>拿了就是：dfs(w,v,i,c-w[i])+v[i]</p>
<p>如果我们这层递归函数里面拿了，我们在往下递归的时候，传入的还是i，也就是说继续看i能不能拿</p>
<h3 id="第一步：回溯法（深度优先遍历）"><a href="#第一步：回溯法（深度优先遍历）" class="headerlink" title="第一步：回溯法（深度优先遍历）"></a>第一步：回溯法（深度优先遍历）</h3><p><code>思路：</code></p>
<p>配合视频一起看更棒</p>
<p><a href="https://www.bilibili.com/video/BV16Y411v7Y6?spm_id_from=333.788.videopod.sections&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">0-1背包 完全背包_哔哩哔哩_bilibili</a></p>
<p><strong>这个虽然过不了，时间复杂度太高，但是这是学习动态规划的必由之路</strong></p>
<p><strong>1.返回值和参数</strong></p>
<p>w各个物品所占空间</p>
<p>v各个物品价值</p>
<p>对第i个物品进行选择</p>
<p>c是当前剩余的容量</p>
<p><strong>返回值返回选或不选编号为i的物品的最大值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w,vector&lt;<span class="type">int</span>&gt;&amp; v,<span class="type">int</span> i,<span class="type">int</span> c)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>2.终止条件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(c&lt;w[i])</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c);</span><br></pre></td></tr></table></figure>

<p>如果编号小于0说明已经到了树形结构最下面了，要开始从第一个物品选了，即自底（第一个物品）向上（i依次增大）开始遍历</p>
<p>如果当前容量已经小于要选的物品，那就直接返回给上层不选i号物品的结果</p>
<p><strong>3.本层逻辑</strong></p>
<p>在选和不选当前物品两种情况中（只要返回回来的一定是最大值），挑一个更大的返回</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c),<span class="built_in">dfs</span>(w,v,i,c-w[i])+v[i]);</span><br></pre></td></tr></table></figure>

<p><strong>完整代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w,vector&lt;<span class="type">int</span>&gt;&amp; v,<span class="type">int</span> i,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(c&lt;w[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c),<span class="built_in">dfs</span>(w,v,i,c-w[i])+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Completeknapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(w,v,nums.<span class="built_in">size</span>()<span class="number">-1</span>,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++还可用lambda来写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Completeknapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i,<span class="type">int</span> c)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(c&lt;w[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">-1</span>,c);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>,c),<span class="built_in">dfs</span>(i,c-w[i])+v[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums.<span class="built_in">size</span>()<span class="number">-1</span>,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第二步：改成记忆化搜索"><a href="#第二步：改成记忆化搜索" class="headerlink" title="第二步：改成记忆化搜索"></a>第二步：改成记忆化搜索</h3><p>注意，在递归函数中，我们同时有物品编号i和容量c，所以要用一个二维数组作为哈希表来存储计算结果进行复用。</p>
<p>然后在每次返回结果前都赋值一下，把计算结果给存储起来</p>
<p>容量的大小为c，vector初始化要为c+1，不要忘记</p>
<p><strong>完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; w,vector&lt;<span class="type">int</span>&gt;&amp; v,<span class="type">int</span> i,<span class="type">int</span> c,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][c]!=<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[i][c];</span><br><span class="line">        <span class="keyword">if</span>(c&lt;w[i])</span><br><span class="line">            <span class="keyword">return</span> dp[i][c]=<span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c,dp);</span><br><span class="line">        <span class="keyword">return</span> dp[i][c]=<span class="built_in">max</span>(<span class="built_in">dfs</span>(w,v,i<span class="number">-1</span>,c,dp),<span class="built_in">dfs</span>(w,v,i,c-w[i],dp)+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Completeknapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>,<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(w,v,nums.<span class="built_in">size</span>()<span class="number">-1</span>,c,dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="number">01</span>knapsack(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>,<span class="number">-1</span>));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i,<span class="type">int</span> c)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][c]!=<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> dp[i][c];</span><br><span class="line">            <span class="keyword">if</span>(c&lt;w[i])</span><br><span class="line">                <span class="keyword">return</span> dp[i][c]=<span class="built_in">dfs</span>(i<span class="number">-1</span>,c);</span><br><span class="line">            <span class="keyword">return</span> dp[i][c]=<span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>,c),<span class="built_in">dfs</span>(i,c-w[i])+v[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums.<span class="built_in">size</span>()<span class="number">-1</span>,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第三步：一比一翻译成动态规划-递推"><a href="#第三步：一比一翻译成动态规划-递推" class="headerlink" title="第三步：一比一翻译成动态规划(递推)"></a>第三步：一比一翻译成动态规划(递推)</h3><p><strong>1.确定dp数组以及下标的含义</strong></p>
<p>二维数组，dp[i][c]就是在前i个物品里面选在最大容量为c时可以取到的最大价值</p>
<p>i是物品编号，对于i的物品做出选择</p>
<p>c是当前背包的总容量</p>
<p><strong>2.确定递推公式</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j-w[i]]+v[i]);</span><br></pre></td></tr></table></figure>

<p><strong>3.dp数组如何初始化</strong></p>
<p>这里有两个版本</p>
<p><strong>1.dp数组中物品编号从1开始</strong></p>
<p>这个只需要把dp初始化为0即可</p>
<p>这里要注意w和v中如果没有统一物品编号从1开始的话，下面递推公式里面就会是i-1</p>
<p><strong>2.dp数组中物品编号从0开始</strong></p>
<p>这个由于要避免i-1的数组越界，需要对i&#x3D;&#x3D;0的情况进行初始化，就是各个容量下可以放多少个物品0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">       <span class="keyword">if</span> (j &gt;= w[<span class="number">0</span>]) &#123;</span><br><span class="line">           dp[<span class="number">0</span>][j] = v[<span class="number">0</span>] * (j / w[<span class="number">0</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.确定遍历顺序</strong></p>
<p>因为要用到正上方和同一行左方的数据，所以最好先遍历物品在遍历容量再从前往后遍历</p>
<p><strong>完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dp数组中的物品编号从1开始</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="number">01</span>knapsack(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=c;j++)</span><br><span class="line">                <span class="keyword">if</span>(j&lt;w[i<span class="number">-1</span>])<span class="comment">//i-1是因为在w和v中物品编号从0开始的</span></span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j-w[i<span class="number">-1</span>]]+v[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[w.<span class="built_in">size</span>()][c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dp数组中的物品编号从0开始</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="number">01</span>knapsack(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w[<span class="number">0</span>]) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = v[<span class="number">0</span>] * (j / w[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=c;j++)</span><br><span class="line">                <span class="keyword">if</span>(j&lt;w[i])</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[w.<span class="built_in">size</span>()<span class="number">-1</span>][c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="优化成一维数组：滚动数组"><a href="#优化成一维数组：滚动数组" class="headerlink" title="优化成一维数组：滚动数组"></a>优化成一维数组：滚动数组</h3><p>与01背包原理基本相同，只是不能从后往前遍历，而是从前往后遍历，因为要用同一行前面的结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dp数组中的物品编号从0开始</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="number">01</span>knapsack(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(c<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=w[i];j&lt;=c;j++)</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dp数组中的物品编号从1开始</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="number">01</span>knapsack(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(c<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=w[i<span class="number">-1</span>];j&lt;=c;j++)</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i<span class="number">-1</span>]]+v[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到一维的就没啥区别了，因为从0和从1开始都只是dp数组里面存储的位置往后挪了一位而已</p>
<h2 id="举例：322-零钱兑换"><a href="#举例：322-零钱兑换" class="headerlink" title="举例：322.零钱兑换"></a>举例：322.零钱兑换</h2><p><a href="https://leetcode.cn/problems/coin-change/description/">322. 零钱兑换 - 力扣（LeetCode）</a></p>
<p>套用模板时候的注意点</p>
<p>1.这道题的金币可以重复选，所以是完全背包不是01背包</p>
<p>2.这道题是返回最少的金币数量，所以dfs&#x2F;dp的含义就是前i种金币可以凑成金额为c的面额的最少金币数量是多少</p>
<p>3.由于求的是金币数量，所以面额amount就是背包的容量，物品的重量就是自己的面额，每个物品的价值都为1，因为dfs和dp的含义是最少的金币的<strong>数量</strong>是多少</p>
<p>4.求的是最少，所以要把max换成min，初始化的时候要初始化为INT_MAX&#x2F;2而不是0（除以2是因为返回的INT_MAX+1后会溢出，导致报错）</p>
<h3 id="1-回溯法"><a href="#1-回溯法" class="headerlink" title="1.回溯法"></a>1.回溯法</h3><p><strong>1.参数和返回值</strong></p>
<p>i是物品编号，表示从前i个物品里面选</p>
<p>c是容量</p>
<p>coins是w[i]</p>
<p>v[i]的值全都为1这里就不写了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> c,vector&lt;<span class="type">int</span>&gt;&amp; coins)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>2.终止条件</strong></p>
<p>i小于0说明到了树形结构的最下面了</p>
<p>如果同时容量c&#x3D;&#x3D;0，那说明正好可以凑够，我们就找到了一个合法的方案，返回0（不返回1的原因是我们dfs的含义是最少金币的数量，而不是能凑够amount的方案数量）</p>
<p>如果容量不是0就凑不够，返回INT_MAX&#x2F;2</p>
<p>如果容量不够当前的硬币，那就递归下一个物品去了，最后返回的就是在前i-1种金币能凑够amount的最小金额数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">if</span>(c==<span class="number">0</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">return</span> INT_MAX/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(c&lt;coins[i])</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">-1</span>,c,coins);</span><br></pre></td></tr></table></figure>

<p><strong>3.本层逻辑</strong></p>
<p>递归公式max换成min</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>,c,coins),<span class="built_in">dfs</span>(i,c-coins[i],coins)<span class="number">+1</span>);</span><br></pre></td></tr></table></figure>

<p><strong>完整代码：</strong></p>
<p>当然是超时的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> c,vector&lt;<span class="type">int</span>&gt;&amp; coins)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> INT_MAX/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(c&lt;coins[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">-1</span>,c,coins);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>,c,coins),<span class="built_in">dfs</span>(i,c-coins[i],coins)<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="built_in">dfs</span>(coins.<span class="built_in">size</span>()<span class="number">-1</span>,amount,coins);</span><br><span class="line">        <span class="keyword">if</span>(res&lt;INT_MAX/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-记忆化搜索"><a href="#2-记忆化搜索" class="headerlink" title="2.记忆化搜索"></a>2.记忆化搜索</h3><p>就是还是全都初始化为-1，每次返回前给dp赋值，碰到不是-1的那就是算过的，那就直接返回计算过的结果，不需要再次递归了</p>
<p><strong>完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> c,vector&lt;<span class="type">int</span>&gt;&amp; coins,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> INT_MAX/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][c]!=<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[i][c];</span><br><span class="line">        <span class="keyword">if</span>(c&lt;coins[i])</span><br><span class="line">            <span class="keyword">return</span> dp[i][c]=<span class="built_in">dfs</span>(i<span class="number">-1</span>,c,coins,dp);</span><br><span class="line">        <span class="keyword">return</span> dp[i][c]=<span class="built_in">min</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>,c,coins,dp),<span class="built_in">dfs</span>(i,c-coins[i],coins,dp)<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(coins.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(amount<span class="number">+1</span>,<span class="number">-1</span>));</span><br><span class="line">        <span class="type">int</span> res=<span class="built_in">dfs</span>(coins.<span class="built_in">size</span>()<span class="number">-1</span>,amount,coins,dp);</span><br><span class="line">        <span class="keyword">if</span>(res&lt;INT_MAX/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3.动态规划"></a>3.动态规划</h3><p><strong>笔者选择的是dp数组的物品编号从1开始</strong></p>
<p>递归的边界条件是</p>
<p>i&lt;0的时候c=&#x3D;0是返回0的。而我们这里的dp数组编号从1开始，那就是i&lt;1且c&#x3D;&#x3D;0的时候是等于0的</p>
<p>所以dp[0][0]的初始值就为0，其他的都是INT_MAX&#x2F;2</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(coins.<span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(amount<span class="number">+1</span>,INT_MAX/<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=coins.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)</span><br><span class="line">                <span class="keyword">if</span>(j&lt;coins[i<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j-coins[i<span class="number">-1</span>]]<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">if</span>(dp[coins.<span class="built_in">size</span>()][amount]&lt;INT_MAX/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[coins.<span class="built_in">size</span>()][amount];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-滚动数组"><a href="#4-滚动数组" class="headerlink" title="4.滚动数组"></a>4.滚动数组</h3><p>把第一维度全都删掉即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount<span class="number">+1</span>,INT_MAX/<span class="number">2</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=coins.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=coins[i<span class="number">-1</span>];j&lt;=amount;j++)</span><br><span class="line">                dp[j]=<span class="built_in">min</span>(dp[j],dp[j-coins[i<span class="number">-1</span>]]<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">if</span>(dp[amount]&lt;INT_MAX/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[amount];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>刷题总结</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>灵神的刷题指南</title>
    <url>/2024/10/29/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E7%81%B5%E7%A5%9E%E7%9A%84%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="灵神的刷题指南"><a href="#灵神的刷题指南" class="headerlink" title="灵神的刷题指南"></a>灵神的刷题指南</h1><p><a href="https://leetcode.cn/circle/discuss/RvFUtj/">分享｜如何科学刷题？ - 力扣（LeetCode）</a></p>
<p><img src="https://pic.leetcode.cn/1720231746-FwkEem-%E5%BF%83%E6%B5%81.jpg" alt="科学刷题 灵茶山艾府"></p>
<blockquote>
<p>合理运用心流通道，科学刷题，快乐刷题！</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>怎么刷算法题？按照什么顺序刷题？如何科学地刷题训练？</p>
<p>如果你刚接触力扣，还不熟悉<strong>基本编程语法</strong>和<strong>常用库函数</strong>，推荐刷力扣官方的<strong>入门题单</strong>：</p>
<ul>
<li><a href="https://leetcode.cn/studyplan/primers-list/">「新」动计划 · 编程入门</a></li>
<li><a href="https://leetcode.cn/studyplan/programming-skills/">编程基础 0 到 1</a></li>
</ul>
<p>有了一些简单题的积累，就可以开始刷我的题单啦~</p>
<h2 id="训练方法-A"><a href="#训练方法-A" class="headerlink" title="训练方法 A"></a>训练方法 A</h2><p>要点：</p>
<ul>
<li>按照<strong>专题</strong>刷题。同一个专题下的题目，套路是一样的，刷题效率杠杠滴~</li>
<li><strong>从易到难</strong>，量力而行。题目已经按照难度分整理好了，按照顺序刷就行~</li>
</ul>
<p>推荐先刷【滑动窗口】和【二分】题单，这是两个最基础的算法，套路也较为固定，刷题过程中还可以学到一些做题技巧。其他题单可以按照自己的兴趣选择。</p>
<p>请结合<a href="https://leetcode.cn/link/?target=https://www.bilibili.com/video/BV1bP411c7oJ/">【基础算法精讲】</a>学习。</p>
<p>推荐安装 <a href="https://leetcode.cn/link/?target=https://greasyfork.org/zh-CN/scripts/450890-leetcoderating-%E6%98%BE%E7%A4%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%9A%BE%E5%BA%A6%E5%88%86">这个插件</a>，可以在题单中自动标记做过的题目。</p>
<ol>
<li><a href="https://leetcode.cn/circle/discuss/0viNMK/">滑动窗口与双指针（定长&#x2F;不定长&#x2F;单序列&#x2F;双序列&#x2F;三指针）</a></li>
<li><a href="https://leetcode.cn/circle/discuss/SqopEo/">二分算法（二分答案&#x2F;最小化最大值&#x2F;最大化最小值&#x2F;第K小）</a></li>
<li><a href="https://leetcode.cn/circle/discuss/9oZFK9/">单调栈（基础&#x2F;矩形面积&#x2F;贡献法&#x2F;最小字典序）</a></li>
<li><a href="https://leetcode.cn/circle/discuss/YiXPXW/">网格图（DFS&#x2F;BFS&#x2F;综合应用）</a></li>
<li><a href="https://leetcode.cn/circle/discuss/dHn9Vk/">位运算（基础&#x2F;性质&#x2F;拆位&#x2F;试填&#x2F;恒等式&#x2F;思维）</a></li>
<li><a href="https://leetcode.cn/circle/discuss/01LUak/">图论算法（DFS&#x2F;BFS&#x2F;拓扑排序&#x2F;最短路&#x2F;最小生成树&#x2F;二分图&#x2F;基环树&#x2F;欧拉路径）</a></li>
<li><a href="https://leetcode.cn/circle/discuss/tXLS3i/">动态规划（入门&#x2F;背包&#x2F;状态机&#x2F;划分&#x2F;区间&#x2F;状压&#x2F;数位&#x2F;数据结构优化&#x2F;树形&#x2F;博弈&#x2F;概率期望）</a></li>
<li><a href="https://leetcode.cn/circle/discuss/mOr1u6/">常用数据结构（前缀和&#x2F;差分&#x2F;栈&#x2F;队列&#x2F;堆&#x2F;字典树&#x2F;并查集&#x2F;树状数组&#x2F;线段树）</a></li>
<li><a href="https://leetcode.cn/circle/discuss/IYT3ss/">数学算法（数论&#x2F;组合&#x2F;概率期望&#x2F;博弈&#x2F;计算几何&#x2F;随机算法）</a></li>
<li><a href="https://leetcode.cn/circle/discuss/g6KTKL/">贪心与思维（基本贪心策略&#x2F;反悔&#x2F;区间&#x2F;字典序&#x2F;数学&#x2F;思维&#x2F;脑筋急转弯&#x2F;构造）</a></li>
<li><a href="https://leetcode.cn/circle/discuss/K0n2gO/">链表、二叉树与一般树（前后指针&#x2F;快慢指针&#x2F;DFS&#x2F;BFS&#x2F;直径&#x2F;LCA）</a></li>
<li><a href="https://leetcode.cn/circle/discuss/SJFwQI/">字符串（KMP&#x2F;Z函数&#x2F;Manacher&#x2F;字符串哈希&#x2F;AC自动机&#x2F;后缀数组&#x2F;子序列自动机）</a></li>
</ol>
<blockquote>
<p>对于<strong>动态规划</strong>，至少要做 100100 道才算入门。</p>
</blockquote>
<p><strong>优点</strong>：突击训练特定知识点，可以掌握常用算法套路。按照题单专题刷，一个套路可以解决多个题目，刷题效率高。此外，<strong>做同一个专题下的题目，相当于在从不同的角度去观察、思考同一个算法，这能让你更加深刻地理解算法的本质</strong>。</p>
<p><strong>缺点</strong>：提前知道题目类型，跳过了一些思考步骤。但比赛&#x2F;笔试是不会告诉你这题是什么类型的，把 DP 想成贪心的大有人在。可以结合下面的训练方法，锻炼自己判断题目类型的能力。</p>
<h2 id="训练方法-B"><a href="#训练方法-B" class="headerlink" title="训练方法 B"></a>训练方法 B</h2><p>随机刷题，注意<strong>控制难度</strong>范围，太简单和太难的题目都不能让你进入「心流通道」。</p>
<ol>
<li>打开 <a href="https://leetcode.cn/link/?target=https://huxulm.github.io/lc-rating/zen">难度练习</a>。</li>
<li>在设置中<strong>关闭算法标签</strong>。</li>
<li>选择适合自己的难度范围，开刷！</li>
</ol>
<p><strong>优点</strong>：做题时不知道题目类型，可以训练实战能力。</p>
<p><strong>缺点</strong>：知识点有些零散，适合已经掌握常用算法的同学查漏补缺，检验自己的学习成果。</p>
<h2 id="训练方法-C"><a href="#训练方法-C" class="headerlink" title="训练方法 C"></a>训练方法 C</h2><p>如果时间很少，可以突击训练 <a href="https://leetcode.cn/studyplan/top-100-liked/">HOT 100</a>。</p>
<p>如果你有任何疑问或者建议，欢迎在下方评论。</p>
]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>刷题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Day52 | 单调栈：每日温度&amp;&amp;下一个更大的元素I&amp;&amp;下一个更大元素II</title>
    <url>/2024/12/04/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day52%20%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20%EF%BC%9A%E5%8D%95%E8%B0%83%E6%A0%88%20%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6&amp;&amp;%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0I&amp;&amp;%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II/</url>
    <content><![CDATA[<h1 id="Day52-单调栈：每日温度-下一个更大的元素I-下一个更大元素II"><a href="#Day52-单调栈：每日温度-下一个更大的元素I-下一个更大元素II" class="headerlink" title="Day52 | 单调栈：每日温度&amp;&amp;下一个更大的元素I&amp;&amp;下一个更大元素II"></a>Day52 | 单调栈：每日温度&amp;&amp;下一个更大的元素I&amp;&amp;下一个更大元素II</h1><p><a href="https://www.bilibili.com/video/BV1VN411J7S7?spm_id_from=333.788.videopod.sections&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">单调栈【基础算法精讲 26】_哔哩哔哩_bilibili</a></p>
<p>及时去掉无用数据，保证栈中元素有序</p>
<h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h2><p><a href="https://leetcode.cn/problems/daily-temperatures/description/">739. 每日温度 - 力扣（LeetCode）</a></p>
<p>从左往右遍历</p>
<p>每次碰到一个数就先和栈顶元素进行比较，如果比栈顶元素大，那说明我们找到了答案，就记录答案，然后把找到答案的元素出栈</p>
<p>我们这样收集下来，栈里面的元素都是单调递减的</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241202175614447.png" alt="image-20241202175614447"></p>
<p>举个例子，如图所示</p>
<p>我们从1往后遍历，栈为空，1入栈，此时栈内为1</p>
<p>碰到4，4大于1，那就把1出栈，然后记录答案，4入栈，栈内为4</p>
<p>碰到3，3小于4, 3入栈，栈内为4,3</p>
<p>碰到5, 5大于3,3出栈，记录答案，栈内为4</p>
<p>栈顶元素变成了4，继续比较，5大于4，4也找到了答案，记录答案，4弹出，5入栈</p>
<p>以此类推</p>
<p>完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(temperatures.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;temperatures.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;temperatures[i]&gt;temperatures[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                res[st.<span class="built_in">top</span>()]=i-st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="496-下一个更大元素I"><a href="#496-下一个更大元素I" class="headerlink" title="496.下一个更大元素I"></a>496.下一个更大元素I</h2><p><a href="https://leetcode.cn/problems/next-greater-element-i/description/">496. 下一个更大元素 I - 力扣（LeetCode）</a></p>
<p>和上一题思路基本一模一样的，就说一下怎么由第一道题变到第二道题</p>
<p><strong>题意：</strong></p>
<p>第二题的意思是第一个数组里面的数字对应到第二个数组里面的相应位置，在第二个数组里面找它的下一个更大数字</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出：[-1,3,-1]</span><br></pre></td></tr></table></figure>

<p>第一个数组里面的1，对应第二个数组里面的第一个元素，第一个元素的下一个更大数字就是3，我们返回的就是3</p>
<p>栈还是单调递减的栈，单调栈遍历的是数组2，我们在哪里找下一个更大数字，就遍历哪个数组</p>
<p><strong>第一题第二题区别：</strong></p>
<p>首先要知道nums1是nums2的子集，如果nums1有，但是nums2没有，那说明肯定就是-1，不用管的</p>
<p>那既然知道nums1有的nums2肯定有，那我们就直接在第二个数组里面找下一个更大数，每一个元素都找。</p>
<p>在更新答案的时候，如果当前元素是nums1里面的，那我们才会记录到res，否则的话就直接弹出就行</p>
<p><strong>完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums<span class="number">1.</span>size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums<span class="number">1.</span><span class="built_in">size</span>(); i++) </span><br><span class="line">            m[nums1[i]] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums<span class="number">2.</span><span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; nums2[i] &gt; nums2[st.<span class="built_in">top</span>()]) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (m.<span class="built_in">find</span>(nums2[st.<span class="built_in">top</span>()])!=m.<span class="built_in">end</span>())</span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="type">int</span> index = m[nums2[st.<span class="built_in">top</span>()]]; </span><br><span class="line">                    res[index] = nums2[i];</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>灵神解法：</strong></p>
<p>单调栈存的是元素而不是下标了。</p>
<p>笔者这里其实不是很理解，似懂非懂，大家看看代码随想录的就挺好。</p>
<p>感觉是单调栈又不是单调栈，单调栈遍历的感觉像是数组1，但是也能得到正确的答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums<span class="number">1.</span>size(),<span class="number">-1</span>)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums<span class="number">1.</span><span class="built_in">size</span>();i++)</span><br><span class="line">            m[nums1[i]]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums<span class="number">2.</span><span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;nums2[i]&gt;st.<span class="built_in">top</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                res[m[st.<span class="built_in">top</span>()]]=nums2[i];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">find</span>(nums2[i])!=m.<span class="built_in">end</span>())</span><br><span class="line">                st.<span class="built_in">push</span>(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="503-下一个更大的元素II"><a href="#503-下一个更大的元素II" class="headerlink" title="503.下一个更大的元素II"></a>503.下一个更大的元素II</h2><p><a href="https://leetcode.cn/problems/next-greater-element-ii/description/">503. 下一个更大元素 II - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<p>每日温度基础上，加个取余就行，碰到循环数组类似的题很好用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">输出: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>例如这个输入</p>
<p>我们就把他当做两个相同的数组拼起来的就行，实际上我们物理上直接把两个一样的数组拼到一起形成一个新数组和加取余符号效果相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,3,   1,2,3,4,3]</span><br></pre></td></tr></table></figure>

<p><strong>完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;nums[i%n]&gt;nums[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                res[st.<span class="built_in">top</span>()]=nums[i%n];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i%n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题记录</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题总结 | 灵神 | 滑动窗口作业</title>
    <url>/2025/03/16/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="刷题总结-灵神-滑动窗口作业"><a href="#刷题总结-灵神-滑动窗口作业" class="headerlink" title="刷题总结 | 灵神 | 滑动窗口作业"></a>刷题总结 | 灵神 | 滑动窗口作业</h1><p>##1.滑动窗口使用前提</p>
<ol>
<li>连续子数组</li>
<li>有单调性。比如数组元素均为正数，这意味着只要某个子数组满足题目要求，<strong>在该子数组内的更短的子数组同样也满足题目要求。</strong></li>
</ol>
<h2 id="2-核心思路"><a href="#2-核心思路" class="headerlink" title="2.核心思路"></a>2.核心思路</h2><p>1.固定右端点</p>
<p>2.遍历右端点</p>
<p>3.寻找左指针收缩条件，即while循环的条件，while循环的作用就是让不满足条件的子数组变成满足条件的子数组</p>
<p>也有些时候是while循环是让满足条件变成不满足条件，这时更新答案就是在while循环内了，因为while循环内才是满足题目条件的情况</p>
<p><strong>一般情况题目条件就是左指针的收缩条件，左指针收缩条件的实现一般都是解题的关键点</strong></p>
<p>4.看满足题目条件的情况是在whie循环外还是while循环内</p>
<p>5.在哪里满足题目条件就在哪里更新res</p>
<p>6.思考如何统计子数组的数量</p>
<p>注：虽然左指针收缩条件的实现一般是解题的关键点，但是如果是比较困难题目，可能在统计子数组数量，如何记录答案，答案更新条件的地方也会比较难想，笔者觉得需要多积累经验才会做着舒服点</p>
<h2 id="3-每道题可能遇到的难点"><a href="#3-每道题可能遇到的难点" class="headerlink" title="3.每道题可能遇到的难点"></a>3.每道题可能遇到的难点</h2><p>1.如何统计子数组的数量，基本有以下两种</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.res+=(r-l+1);</span><br><span class="line">2.res+=l</span><br></pre></td></tr></table></figure>

<p>2.一开始做这方面题可能会想着的是，我在固定r时，把l移动了，那我在固定r+1的时候，需要不需要把l置为0？</p>
<p>这个一般都不需要，因为置为0可能就趋近于暴力做法了，而这道题可以用滑动窗口做，那肯定是不需要把l置为0的，如果非要置为0不可，那可能是左指针收缩条件没有找对。也有可能是自己觉得会漏掉情况，但是这个只要举个例子模拟一下就知道了到底会不会漏掉情况了。</p>
<h2 id="4-题单"><a href="#4-题单" class="headerlink" title="4.题单"></a>4.题单</h2><p><a href="https://blog.csdn.net/m0_74795952/article/details/146161422?spm=1001.2014.3001.5501">Day58 | 灵神 | 滑动窗口：长度最小的子数组&amp;&amp;乘积小于K的子数组&amp;&amp;无重复字符的最长子串-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/146170577?spm=1001.2014.3001.5501">Day59 | 灵神 | 滑动窗口：最多K个重复元素的最长子数组&amp;&amp;找到最长的半重复子字符串-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/146196111?spm=1001.2014.3001.5501">Day60 | 灵神 | 滑动窗口：最大连续1的个数III-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/146225312?spm=1001.2014.3001.5501">Day61 | 灵神 | 滑动窗口：统计最大元素出现至少K次的子数组-CSDN博客</a>（需重点复习，统计子数组的方式方法）</p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/146248341?spm=1001.2014.3001.5501">Day62 | 灵神 | 滑动窗口：统计得分小于K的子数组数目-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/146275553?sharetype=blogdetail&sharerId=146275553&sharerefer=PC&sharesource=m0_74795952&spm=1011.2480.3001.8118">Day63 | 灵神 | 滑动窗口：将x减到0的最小操作数-CSDN博客</a>（需重点复习，思路的转变）</p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/146291648?sharetype=blogdetail&sharerId=146291648&sharerefer=PC&sharesource=m0_74795952&spm=1011.2480.3001.8118">Day64 | 灵神 | 滑动窗口：最小覆盖子串-CSDN博客</a>（hard题还是hard题，思路比较简单，但是其他的细节的处理处理的很不好，需要复习）</p>
]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>刷题总结</tag>
        <tag>算法</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Day53 | 单调栈：接雨水&amp;&amp;柱形图中最大的矩形</title>
    <url>/2024/12/05/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day53%20%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20%EF%BC%9A%E5%8D%95%E8%B0%83%E6%A0%88%20%E6%8E%A5%E9%9B%A8%E6%B0%B4&amp;&amp;%E6%9F%B1%E5%BD%A2%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="Day53-单调栈：接雨水-柱形图中最大的矩形"><a href="#Day53-单调栈：接雨水-柱形图中最大的矩形" class="headerlink" title="Day53 | 单调栈：接雨水&amp;&amp;柱形图中最大的矩形"></a>Day53 | 单调栈：接雨水&amp;&amp;柱形图中最大的矩形</h1><p><a href="https://www.bilibili.com/video/BV1VN411J7S7?spm_id_from=333.788.videopod.sections&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">单调栈【基础算法精讲 26】_哔哩哔哩_bilibili</a></p>
<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42.接雨水"></a>42.接雨水</h2><p><a href="https://leetcode.cn/problems/trapping-rain-water/description/">42. 接雨水 - 力扣（LeetCode）</a></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241205114540833.png" alt="image-20241205114540833"></p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>还是和昨天差不多一样的思路，只是昨天找到下一个更大元素就只是记录了一下，这次我们要用这个更大元素计算一下可以接多少雨水。</p>
<p>单调栈依旧是单调递减的，如图中所示。</p>
<p><strong>我们要如何计算可以接多少雨水呢?</strong></p>
<p><strong>比如我们选定2,1,0,4这几个柱子</strong></p>
<p><strong>那就是先算1,0,4。</strong></p>
<p><strong>宽为4的下标减去1的下标再减1，高为1和4的最小值减去中间的0，宽*高即为答案，为1</strong></p>
<p><strong>再算2,1,4。</strong></p>
<p><strong>宽为4的下标减去2的下标再减1，高为2和4的最小值减去中间的1，宽*高即为答案，为2</strong></p>
<p><strong>再把两者相加就是2,1,0,4这几个柱子可以接多少雨水了</strong></p>
<p>单调栈的入栈出栈过程：</p>
<p>灵神总结为：找上一个更大元素，在找的过程中填坑，我来举个例子大家就明白了。</p>
<p>5，入栈</p>
<p>2&lt;5，入栈</p>
<p>1&lt;2，入栈</p>
<p>0&lt;1，入栈</p>
<p>4&gt;0，我们找到了一个更大的元素</p>
<p>那就是计算以0为中心的柱子1,0,4可以接多少，然后把0弹出</p>
<p>计算以1为中心的柱子2,1,4可以接多少，然后把1弹出</p>
<p>计算以2为中心的柱子5,2,4可以接多少，然后把2弹出</p>
<p><strong>完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;height.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;height[i]&gt;height[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid=st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="type">int</span> left=st.<span class="built_in">top</span>();</span><br><span class="line">                res=res+(i-left<span class="number">-1</span>)*(<span class="built_in">min</span>(height[i],height[left])-height[mid]);</span><br><span class="line">                <span class="comment">//          宽                  高</span></span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="84-柱状图中的最大矩形"><a href="#84-柱状图中的最大矩形" class="headerlink" title="84.柱状图中的最大矩形"></a>84.柱状图中的最大矩形</h2><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">84. 柱状图中最大的矩形 - 力扣（LeetCode）</a></p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>这次的单调栈是递增的</p>
<p>还是和接雨水一样，只是接雨水是中间凹下去的，比如1,0,4，中间的0要小于1和4</p>
<p>而这道题中间是突出来的，比如下图中的1，5，6，2，<strong>并且两边的柱子不能参与合并（就和上一题1,4不能接雨水一样）</strong></p>
<p><strong>即1,5,6,2中只有5,6可以去合并，如果是5,6,2的话那就是只有6了</strong></p>
<p>如果碰到元素小于栈顶元素，我们才会去计算矩形的面积，否则不会计算</p>
<p><strong>栈的具体过程：</strong></p>
<p>那1,5,6,2举例</p>
<p>栈中为1,1&lt;5,5入栈</p>
<p>5&lt;6,6入栈</p>
<p>6&gt;2，开始计算矩形大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">heights[i]=2;</span><br><span class="line">heights[st.top()]=6;</span><br></pre></td></tr></table></figure>

<p>到这里我们发现还需要栈顶元素的下一个元素5，才能够进行计算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st.pop();</span><br><span class="line">heights[st.pop()]=5;</span><br><span class="line">高：6</span><br><span class="line">宽：i-st.top()-1=1;</span><br><span class="line">最大矩形:6*1=6</span><br></pre></td></tr></table></figure>

<p>继续，此时栈内为1,5，而heights[i]还是2，heights[st.pop()]就是5;</p>
<p>我们还是需要栈顶元素的下一个元素1，才能够进行计算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st.pop();</span><br><span class="line">heights[st.pop()]=1;</span><br><span class="line">高：5</span><br><span class="line">宽：i-st.top()-1=2;</span><br><span class="line">最大矩形:5*2=10</span><br></pre></td></tr></table></figure>

<h3 id="难理解的点：为什么要在数组前后多加高度为0的柱子"><a href="#难理解的点：为什么要在数组前后多加高度为0的柱子" class="headerlink" title="难理解的点：为什么要在数组前后多加高度为0的柱子?"></a>难理解的点：为什么要在数组前后多加高度为0的柱子?</h3><p>第一根柱子和最后一根柱子如果是最高的，并且也没有多加高度为0的柱子的话，那是不会被计算的</p>
<p>如果heights为100,1那最后的结果还是0，因为我们没有进行任何的计算（栈顶为100，heights[i]为1，但是我们获取不到栈顶元素的下一个元素），但实际上应该是100</p>
<p>如果是1,100，栈顶为1，heights[i]为100，没有末尾的0，我们不会进行任何计算，因为它本身就是单调递增的</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241205120328724.png" alt="image-20241205120328724"></p>
<p><strong>完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在高度数组的两端添加 0</span></span><br><span class="line">        heights.<span class="built_in">insert</span>(heights.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heights.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; heights[i] &lt; heights[s.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="comment">// 弹出栈顶，计算对应的面积</span></span><br><span class="line">                <span class="type">int</span> dh = heights[s.<span class="built_in">top</span>()];</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> dw = i - s.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dh * dw);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前元素下标压入栈</span></span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题记录</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Day54 | 灵神 | 相向双指针：两数之和II-输入有序数组&amp;&amp;三数之和</title>
    <url>/2024/12/20/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day54%20%20%E7%81%B5%E7%A5%9E%20%20%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84&amp;&amp;%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="Day54-灵神-相向双指针：两数之和II-输入有序数组-三数之和"><a href="#Day54-灵神-相向双指针：两数之和II-输入有序数组-三数之和" class="headerlink" title="Day54 | 灵神 | 相向双指针：两数之和II-输入有序数组&amp;&amp;三数之和"></a>Day54 | 灵神 | 相向双指针：两数之和II-输入有序数组&amp;&amp;三数之和</h1><p><a href="https://www.bilibili.com/video/BV1bP411c7oJ?spm_id_from=333.788.videopod.sections&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">两数之和 三数之和【基础算法精讲 01】_哔哩哔哩_bilibili</a></p>
<h2 id="167-两数之和II-输入有序数组"><a href="#167-两数之和II-输入有序数组" class="headerlink" title="167.两数之和II-输入有序数组"></a>167.两数之和II-输入有序数组</h2><p><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/">167. 两数之和 II - 输入有序数组 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<p>数组给咱们的是排序好的，那自然而然定义两根指针，一个在数组头l，一个在数组尾r</p>
<p>这样定义的好处是</p>
<p>两根指针中间的数字一定比头指针要大，一定比尾指针要小</p>
<p>如果两指针之和大于target的话，那中间某个数加上尾指针肯定也比target要大，那说明两个数加起来大了，那就把右边大的数字减小一点</p>
<p>如果两指针之和小于target的话，那头指针加上中间某个数肯定也比target要小，那说明两个数加起来小了，那就把左边大的数字增大一点</p>
<p>如果两指针之和等于target的话，那说明我们找到了答案直接返回就行</p>
<p><strong>举例：</strong></p>
<p>2	4	6	8	9    target&#x3D;12</p>
<p>一开始 2 + 9&#x3D;11小于12，那么不管是2和4,6,8哪个数字加都不可能达到12了，说明左边的选小了（同时也说明2肯定不会是答案了，就把2排除了，在4,6,8,9中选答案）</p>
<p>后来 4 + 9&#x3D;13,大于12，那么不管是6,8哪个和9加都不可能比12小了，说明右边选大了（同时也说明9肯定不是答案了，就把9排除了，在4,6,8中选答案）</p>
<p><strong>完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=numbers.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[l]+numbers[r]&gt;target)</span><br><span class="line">                r--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[l]+numbers[r]&lt;target)</span><br><span class="line">                l++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> &#123;l<span class="number">+1</span>,r<span class="number">+1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;l<span class="number">+1</span>,r<span class="number">+1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="一个分析时间复杂度的新角度："><a href="#一个分析时间复杂度的新角度：" class="headerlink" title="一个分析时间复杂度的新角度："></a>一个分析时间复杂度的新角度：</h3><p>为什么双指针能从暴力算法的O(n²)优化到O(n)呢？</p>
<p>我们可以试着量化得到的信息</p>
<p>暴力做法中，我们是拿着两个数字加起来和target比一比大小，我们花费了O(1)的时间，得到了O(1)的信息</p>
<p>而双指针做法中，我们利用单调性这个性质，只要这两个数加起来比target大，那我就知道数组中比两个数中较大的数大的那边全都不行，我们花费了O(1)的时间，却得到了O(n)的信息，所以我们可以从O(n²)优化到O(n)。</p>
<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<p>跟着上一题的思路走。上一次是nums[l]和nums[r]和target比大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums[l]+nums[r]=target </span><br></pre></td></tr></table></figure>

<p>的时候我们就找到了答案，这一题只不过是转换为了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums[l]+nums[r]-target = 0</span><br><span class="line">nums[l]+nums[r]+nums[i] = 0</span><br></pre></td></tr></table></figure>

<p>我们要找的就是</p>
<p>nums[i]在什么时候等于-target就行，在转换一下</p>
<p>其实就是找</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums[l]+nums[r]= -nums[i]</span><br></pre></td></tr></table></figure>

<p>所以上一题是一个数组里面找到两个数加起来是一个固定的数target</p>
<p>这一题就一个数组里面找到两个数加起来是一个变化的数字nums[i]</p>
<p>那么只需要在上一题的代码上加一层循环，循环i就完事了</p>
<p><strong>注意：不要忘记了排序，因为有序的情况下我们才用的双向双指针</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=i+<span class="number">1</span>,r=nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[l]+nums[r]+nums[i]&gt;<span class="number">0</span>)</span><br><span class="line">                    r--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[l]+nums[r]+nums[i]&lt;<span class="number">0</span>)</span><br><span class="line">                    l++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(&#123;nums[i],nums[l],nums[r]&#125;);</span><br><span class="line">                    l++;r--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是跟着上一题的思路可以写到的地方</p>
<h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p><code>1.对i去重</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])</span><br><span class="line">	<span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<p>就是i在大于0时，如果和上一个i值一样的话那就直接跳过</p>
<p><code>2.对l和r进行优化</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;r&amp;&amp;nums[l]==nums[l<span class="number">-1</span>]) l++;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r&amp;&amp;nums[r]==nums[r+<span class="number">1</span>]) r--;</span><br></pre></td></tr></table></figure>

<p>对l和r和 对i的操作是一样的</p>
<p><strong>完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=i<span class="number">+1</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (x + nums[i + 1] + nums[i + 2] &gt; 0) break; // 优化一  前三个数字加起来都大于target了，就不用再算后面了</span></span><br><span class="line"><span class="comment">            if (x + nums[n - 2] + nums[n - 1] &lt; 0) continue; // 优化二 第一个数和最后两个数加起来都小于0了，那后面的数也没必要遍历了，直接去遍历下一个i值</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[l]+nums[r]+nums[i]&gt;<span class="number">0</span>)</span><br><span class="line">                    r--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[l]+nums[r]+nums[i]&lt;<span class="number">0</span>)</span><br><span class="line">                    l++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i],nums[l],nums[r]&#125;);</span><br><span class="line">                    l++;r--;</span><br><span class="line">                    <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[l]==nums[l<span class="number">-1</span>]) l++;</span><br><span class="line">                    <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[r]==nums[r<span class="number">+1</span>]) r--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题记录</tag>
        <tag>相向双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Day55 | 灵神 | 相向双指针：盛最多水的容器&amp;&amp;接雨水</title>
    <url>/2024/12/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day55%20%20%E7%81%B5%E7%A5%9E%20%20%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9A%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8&amp;&amp;%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[<h1 id="Day55-灵神-相向双指针：盛最多水的容器-接雨水"><a href="#Day55-灵神-相向双指针：盛最多水的容器-接雨水" class="headerlink" title="Day55 | 灵神 | 相向双指针：盛最多水的容器&amp;&amp;接雨水"></a>Day55 | 灵神 | 相向双指针：盛最多水的容器&amp;&amp;接雨水</h1><p><a href="https://www.bilibili.com/video/BV1Qg411q7ia?spm_id_from=333.788.videopod.sections&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">盛最多水的容器 接雨水_哔哩哔哩_bilibili</a></p>
<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h2><p><a href="https://leetcode.cn/problems/container-with-most-water/description/">11. 盛最多水的容器 - 力扣（LeetCode）</a></p>
<p>这道题就不太能想到思路了（悲）</p>
<p><strong>思路：</strong></p>
<p>还是使用相向双指针</p>
<p>我们随便挑两根柱子，就比如图中的两根，左边的下标为l，右边的下标为r，那么能接的水就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum=min(height[l],height[r])*(r-l)</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241221195333819.png" alt="image-20241221195333819"></p>
<p>首先先找出短的一端，然后固定它，（为什么找短端而不找长端？这个稍后解释）这个例子中r比较短，那么就固定r。此时接水总量为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum1=height[r]*(r-l)</span><br></pre></td></tr></table></figure>

<p><strong>分类讨论:</strong></p>
<p>1.假设在l和r中间，找到一根比height[r]要小的柱子k来当左端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum2=height[k]*(r-k)</span><br></pre></td></tr></table></figure>

<p>由于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">height[r]&gt;height[k]</span><br><span class="line">r-l&gt;r-k  (因为k在l和r中间)</span><br></pre></td></tr></table></figure>

<p>所以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum1&gt;sum2</span><br></pre></td></tr></table></figure>

<p>就是说，高变小了，宽也变小了，那肯定比原来小了</p>
<p>2.假设在l和r中间，找到一根比height[r]要大的柱子i来当左端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum3=height[r]*(r-i)</span><br></pre></td></tr></table></figure>

<p>由于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r-i&gt;r-l (因为i在l和r中间)</span><br></pre></td></tr></table></figure>

<p>所以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum1&gt;sum3</span><br></pre></td></tr></table></figure>

<p>这种是高没变，宽变小了，也肯定比原来小了</p>
<p>3.假设在l和r中间，找到一根和height[r]一样大的柱子j来当左端</p>
<p>那不用说了，高没变宽变小了，自然是不如l和r的大</p>
<p><strong>综上所述，我们发现，图中l和r中间的柱子无论怎么取，都不如l和r的大。</strong></p>
<p>可我们还要继续往遍历去找更大的值，去尝试得到更多的水，那该怎么继续遍历呢？</p>
<p><strong>答案是移动短端，相当于去掉短的一端，看l和r-1这两根柱子。</strong></p>
<p>因为我们发现了，只要固定住短端，长端只要在（l,r）中间取值，那都不可能比l和r大，所以这时候就只能移动短端了，就相当于把r给去掉了，去比较l和r-1，看看在这个区间里面有没有比在(l,r)的最大值更大的。</p>
<p>那结论就出来了，我们每次更新完最大值以后，就把短端给去掉即可。</p>
<p><strong>完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新最大值</span></span><br><span class="line">            <span class="type">int</span> tmp=<span class="built_in">min</span>(height[l],height[r])*(r-l);</span><br><span class="line">            res=<span class="built_in">max</span>(res,tmp);</span><br><span class="line">            <span class="comment">//去掉短端</span></span><br><span class="line">            <span class="keyword">if</span>(height[l]&lt;height[r])</span><br><span class="line">                l++;</span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看到这里你应该明白为什么找短端而不找长端，我们固定的是短端，这是因为算高度的时候看的是短端而不是长端，固定短端可以减少一个变量。</p>
<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42.接雨水"></a>42.接雨水</h2><p><a href="https://leetcode.cn/problems/trapping-rain-water/description/">42. 接雨水 - 力扣（LeetCode）</a></p>
<p>理解不了的话记个单调栈的做法也行。</p>
<p><strong>思路：前后缀分解</strong></p>
<p>笔者说个大概，如果看不懂的话可以去看灵神的视频。</p>
<p>怎么算：我们分别算出每一个柱子能接多少水，然后都加起来就是全部的</p>
<p>前缀就是包含当前柱子在内，当前柱子的前面最高的柱子高度</p>
<p>后缀就是包含当前柱子在内，当前柱子的后面最高的柱子高度</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241221205529594.png" alt="image-20241221205529594"></p>
<p>如图，上面一行是前缀，下面一行是后缀</p>
<p>就拿图中的第5列（下标为4）的柱子来举例子吧</p>
<p>它的前缀最大是2，后缀最大是3，那么如果只看它这一根柱子的话，它能接多少水就是，前缀和后缀选个小的（大的柱子比小的柱子多的部分装不了水），再减去柱子本身的高度</p>
<p>对于第5列就是 min(3,2)-1&#x3D;1，所以这根柱子可以接1格水</p>
<p>其他柱子都这么算一遍然后把每个柱子的水加起来就是答案了</p>
<p><strong>完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> mpre=<span class="number">0</span>,mtail=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(height.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tail</span><span class="params">(height.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">//计算前缀</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;height.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mpre=<span class="built_in">max</span>(mpre,height[i]);</span><br><span class="line">            pre[i]=mpre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算后缀</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=height.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            mtail=<span class="built_in">max</span>(mtail,height[i]);</span><br><span class="line">            tail[i]=mtail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算每个柱子的水</span></span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;height.<span class="built_in">size</span>();i++)</span><br><span class="line">            res+=(<span class="built_in">min</span>(tail[i],pre[i])-height[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="优化：双指针做法"><a href="#优化：双指针做法" class="headerlink" title="优化：双指针做法"></a>优化：双指针做法</h3><p><strong>这个好难用文字讲出来，大家听灵神的视频讲解吧</strong></p>
<p>总体思路还是一个柱子一个柱子算，算完一个再算下一个</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> r=height.size()<span class="number">-1</span>,l=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//分别保存前缀和后缀的两个值</span></span><br><span class="line">        <span class="type">int</span> mpre=height[l],mtail=height[r];</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//前缀小于后缀</span></span><br><span class="line">            <span class="comment">//那计算当前柱子能接多少水就取决于前缀了，因为比前缀多的部分就流走了</span></span><br><span class="line">            <span class="keyword">if</span>(mpre&lt;mtail)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//计算能接多少水</span></span><br><span class="line">                res+=mpre-height[l];</span><br><span class="line">                <span class="comment">//计算完当前柱子可以接多少水就去算下一个柱子</span></span><br><span class="line">                l++;</span><br><span class="line">                <span class="comment">//更新前缀的值</span></span><br><span class="line">                mpre=max(mpre,height[l]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//前缀大于后缀</span></span><br><span class="line">            <span class="comment">//那计算当前柱子能接多少水就取决于后缀了，因为比后缀多的部分就流走了</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//计算能接多少水</span></span><br><span class="line">                res+=mtail-height[r];</span><br><span class="line">                <span class="comment">//计算完当前柱子可以接多少水就去算下一个柱子</span></span><br><span class="line">                r--;</span><br><span class="line">                <span class="comment">//更新后缀的值</span></span><br><span class="line">                mtail=max(mtail,height[r]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题记录</tag>
        <tag>相向双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Day56 | 灵神 | 相向双指针：四数之和&amp;&amp;有效三角形的个数</title>
    <url>/2025/02/20/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day56%20%20%E7%81%B5%E7%A5%9E%20%20%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="Day56-灵神-相向双指针：统计和小于目标的下标对数目-最接近的三数之和"><a href="#Day56-灵神-相向双指针：统计和小于目标的下标对数目-最接近的三数之和" class="headerlink" title="Day56| 灵神 | 相向双指针：统计和小于目标的下标对数目&amp;&amp;最接近的三数之和"></a>Day56| 灵神 | 相向双指针：统计和小于目标的下标对数目&amp;&amp;最接近的三数之和</h1><h2 id="2824-统计和小于目标的下标对数目"><a href="#2824-统计和小于目标的下标对数目" class="headerlink" title="2824.统计和小于目标的下标对数目"></a>2824.统计和小于目标的下标对数目</h2><p><a href="https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/description/">2824. 统计和小于目标的下标对数目 - 力扣（LeetCode）</a></p>
<p><code>思路：</code></p>
<p>和两数之和思路一样</p>
<p>大了就r–</p>
<p>小了就收集答案</p>
<p><code>完整代码：</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l]+nums[r]&gt;=target)</span><br><span class="line">                r--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res+=(r-l);</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>记录一下自己写的，上面的版本是灵神的答案，把我的优化了，其实就是没想到l在取过答案以后，r就不可能从最后开始了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=i,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[l]+nums[r]&gt;=target)</span><br><span class="line">                    r--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res+=(r-l);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16.最接近的三数之和"></a>16.最接近的三数之和</h2><p><a href="https://leetcode.cn/problems/3sum-closest/description/">16. 最接近的三数之和 - 力扣（LeetCode）</a></p>
<p><code>思路：</code></p>
<p>和三数之和思路类似，甚至不需要去重，所以更加简单。</p>
<p>只需要增加一个变量x来记录三个数的和与target之间的最小差值就是了</p>
<p>只要target和三数之和的差值小于x，那就更新x和最后返回的答案</p>
<p><code>完整代码：</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minTemp=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=i<span class="number">+1</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> cur=nums[i]+nums[r]+nums[l];</span><br><span class="line">                <span class="keyword">if</span>(cur&gt;target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur-target&lt;minTemp)</span><br><span class="line">                    &#123;</span><br><span class="line">                        minTemp=cur-target;</span><br><span class="line">                        res=cur;</span><br><span class="line">                    &#125;</span><br><span class="line">                    r--;    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(cur&lt;target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(target-cur&lt;minTemp)</span><br><span class="line">                    &#123;</span><br><span class="line">                        minTemp=target-cur;</span><br><span class="line">                        res=cur;</span><br><span class="line">                    &#125;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题记录</tag>
        <tag>相向双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Day57 | 灵神 | 相向双指针：四数之和&amp;&amp;有效三角形的个数</title>
    <url>/2025/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day57%20%20%E7%81%B5%E7%A5%9E%20%20%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9A%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C&amp;&amp;%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="Day57-灵神-相向双指针：四数之和-有效三角形的个数"><a href="#Day57-灵神-相向双指针：四数之和-有效三角形的个数" class="headerlink" title="Day57 | 灵神 | 相向双指针：四数之和&amp;&amp;有效三角形的个数"></a>Day57 | 灵神 | 相向双指针：四数之和&amp;&amp;有效三角形的个数</h1><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h2><p><a href="https://leetcode.cn/problems/4sum/description/">18. 四数之和 - 力扣（LeetCode）</a></p>
<p><code>思路：</code></p>
<p>在三数之和的基础上再套了一层循环</p>
<p>i在最外层，然后对i去重</p>
<p>j，l，r就是三数之和的代码</p>
<p><strong>区别在于：</strong></p>
<p>1.对于第二个数字num[j]的去重：因为j是从i+1开始的，而j对j的去重只能是在j自己的遍历过程中，即，当j大于i+1时，这说明j-1&gt;i，说明此时去重不会让j&#x3D;&#x3D;i的情况给去掉了</p>
<p>2.如果数组大小小于4那就没必要列举了</p>
<p>3.leetcode增大了数值，要使用long long防止溢出</p>
<p>主要是防止四个数字相加时的溢出，所以四个数字相加时至少得有一个是long long类型</p>
<p><code>完整代码：</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-3</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> a=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(i&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])   <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j&gt;i<span class="number">+1</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">// 跳过重复数字</span></span><br><span class="line">                <span class="type">int</span> l=j<span class="number">+1</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> x=a+nums[j]+nums[l]+nums[r];</span><br><span class="line">                    <span class="keyword">if</span>(x&gt;target)</span><br><span class="line">                        r--;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;target)</span><br><span class="line">                        l++;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(&#123;nums[i],nums[j],nums[l],nums[r]&#125;);</span><br><span class="line">                        <span class="keyword">for</span>(l++;l&lt;r&amp;&amp;nums[l]==nums[l<span class="number">-1</span>];l++);</span><br><span class="line">                        <span class="keyword">for</span>(r--;l&lt;r&amp;&amp;nums[r]==nums[r<span class="number">+1</span>];r--);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="611-有效三角形的个数"><a href="#611-有效三角形的个数" class="headerlink" title="611.有效三角形的个数"></a>611.有效三角形的个数</h2><p><a href="https://leetcode.cn/problems/valid-triangle-number/description/">611. 有效三角形的个数 - 力扣（LeetCode）</a></p>
<p><code>思路：</code></p>
<p>还是和两数之和三数之和一样的思路，只是判定条件不同，本题是利用两数之和大于第三边的性质来做。</p>
<p>三角形三边 a，b，c   a&lt;b&lt;c</p>
<p>把最大的一边（c）当做固定边，通过  比较a+b和c的大小来确定指针的移动</p>
<p>i是c的下标，a的下标是l，b的下标是r</p>
<p>从末尾往前遍历i，相当于从大到小遍历i</p>
<p>每次都在[0,i-1]范围内遍历l和r，即对l和r进行加减操作</p>
<p>只要 a + b &gt; c 说明找到了一个合法方案，res++，并且大的指针减小（r–）继续查找合法方案</p>
<p>否则的话，说明a + b &lt; c 那说明 a太小了，那就 l++</p>
<h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><p>不可以有思维惯性，两数之和和三数之和都是固定最小的i，从前往后遍历</p>
<p>但是本题固定最小边却行不通</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">triangleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=i<span class="number">+1</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[l]&gt;nums[r])</span><br><span class="line">                &#123;</span><br><span class="line">                    res+=(r-l);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[l]==nums[r])</span><br><span class="line">                    l++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>原因在于，当我们固定最小边a的时候，我们会遇到 a + b &#x3D;&#x3D; c的情况</p>
<p>但是这种情况下我们a是固定的，那这种情况下指针一定有可能是b太小了，那就是往大的移动，那就是l++，但是也有可能是c太大了，那就是r–</p>
<p>但是我们在else if(nums[i]+nums[l]&#x3D;&#x3D;nums[r])这个条件判定中不可以即写l++又写r–，因为这样的话肯定会漏掉一些合理的答案</p>
<p>但是我们也不能只写l++和r–其中的一个，因为不管写哪个都会漏掉另外一种的情况，这样还是得不到正确答案</p>
<p>而正确做法的固定最大边c就不同了，a + b &gt; c的时候就说明是b大了移动b就行</p>
<p>a + b &lt;&#x3D; c的时候就说明是a小了，移动a就行</p>
<p><strong>关键就是：指针的移动不能出现二义性，不能往这边移动也行往那边移动也行，这样的话一定会漏掉另外一种情况</strong></p>
<p><code>完整代码：</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">triangleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">2</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>,r=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[r]+nums[l]&gt;nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    res+=(r-l);</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题记录</tag>
        <tag>相向双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Day58 | 灵神 | 滑动窗口：长度最小的子数组&amp;&amp;乘积小于K的子数组&amp;&amp;无重复字符的最长子串</title>
    <url>/2025/03/10/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day58%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84&amp;&amp;%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8EK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84&amp;&amp;%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="Day58-灵神-滑动窗口：长度最小的子数组-乘积小于K的子数组-无重复字符的最长子串"><a href="#Day58-灵神-滑动窗口：长度最小的子数组-乘积小于K的子数组-无重复字符的最长子串" class="headerlink" title="Day58 | 灵神 | 滑动窗口：长度最小的子数组&amp;&amp;乘积小于K的子数组&amp;&amp;无重复字符的最长子串"></a>Day58 | 灵神 | 滑动窗口：长度最小的子数组&amp;&amp;乘积小于K的子数组&amp;&amp;无重复字符的最长子串</h1><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组 - 力扣（LeetCode）</a></p>
<p><code>思路：</code></p>
<p>思考的关键点：固定右指针，移动左指针，而我们要做的就是找到左指针移动的条件，即在什么情况下移动左指针，而这个条件一般都在题目中。</p>
<p>在本题中，我们固定右端点</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250310182605966.png" alt="image-20250310182605966"></p>
<p>以固定4，我们目前左指针l&#x3D;0，指向的是2，右指针为4，指向4</p>
<p>我们发现这个子数组的和是大于target7的，满足了子数组和大于target的条件，子数组大小是5，那这个时候我们就可以通过移动左指针来缩小子数组的大小。我们移动左指针，l++，发现和是10，仍旧大于target，那说明我们可以继续往左移动指针来缩小子数组的大小，一直到l&#x3D;2，指向1时，我们找到了子数组和仍大于等于7的最小的子数组，因为再减一位就不大于7了，就不满足条件了，所以我们更新答案，就是右指针减去左指针再加1就是这个子数组的长度，即4-2+1&#x3D;3。到这里我们就找到了以4为右端点的满足条件的最小的子数组的长度为3。</p>
<p>那么只要从头遍历右端点，每个端点都重复这个过程，在这之间记录最小值，那么就会找到我们想要的答案。</p>
<p><code>完整代码：</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=INT_MAX;<span class="comment">//最后结果</span></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;<span class="comment">//记录数组和</span></span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;<span class="comment">//左指针</span></span><br><span class="line">        <span class="comment">//i是右指针，右端点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="comment">//满足条件 子数组和大于target</span></span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp=i-l<span class="number">+1</span>;</span><br><span class="line">                <span class="comment">//更新答案</span></span><br><span class="line">                res=<span class="built_in">min</span>(res,temp);</span><br><span class="line">                sum-=nums[l];</span><br><span class="line">                <span class="comment">//更新左指针</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//res还是初始值，说明整个数组加起来都不到target，返回0即可</span></span><br><span class="line">        <span class="keyword">if</span>(res==INT_MAX)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="713-乘积小于K的子数组"><a href="#713-乘积小于K的子数组" class="headerlink" title="713.乘积小于K的子数组"></a>713.乘积小于K的子数组</h2><p><a href="https://leetcode.cn/problems/subarray-product-less-than-k/">713. 乘积小于 K 的子数组 - 力扣（LeetCode）</a></p>
<p><code>思路：</code></p>
<p>和上一题思路一样，只是这道题更新答案变为在while循环外。因为上一题在while循环内是，是满足子数组和大于target这一条件的，所以在while内更新答案。而本题sum&lt;k即在while外才是满足条件的情况，所以在while循环外更新答案。</p>
<p>本题的关键点，也就是左指针移动条件是子数组乘积大于K时进行移动。</p>
<p><strong>另一个关键点是子数组的数量如何计算。</strong></p>
<p>假设当前满足条件的子数组为[5,2,6]，那么以6为右端点(即必须包括6)有几个满足条件的数组？</p>
<p>[5,2,6],[2,6],[6]这三个。而我们不需要管[5],[5,2]这类的子数组，因为这类的数组在以5或者2为右端点时已经计算过一次了。</p>
<p>推广一下，[l,r]这个区间的子数组乘积小于k，那么[l+1,r],…..[r,r]都是小于k的，那么数量就是</p>
<p>r-l+1个子数组满足条件</p>
<p><code>完整代码：</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum*=nums[i];</span><br><span class="line">            <span class="comment">//更新l使得子数组满足条件</span></span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//res+=(i-l+1);</span></span><br><span class="line">                sum/=nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//结果更新是在满足题目条件时进行更新，上一道题在while内更新是因为在while内是满足条件的时候</span></span><br><span class="line">            <span class="comment">//这道题是while外才是符合条件的时候，所以在while外更新结果</span></span><br><span class="line">            res+=(i-l<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h2><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p>
<p><code>思路：</code></p>
<p>和上面两道题思路相同，固定右端点，遍历右端点。只要碰到重复的字符，那么左指针就一直往右移动，直到没有重复的字符为止。</p>
<p>记录字符的方式：哈希表，key为字符，value为字数个数，只要不为1就说明有重复，那就左指针一直往右移动，直到没有重复的字符。</p>
<p>在遍历过程中记录子串的长度，碰到长度更大的子串就更新结果。</p>
<p><code>完整代码：</code></p>
<p>注释部分是笔者原来的错误，没有找到正确的记录字符的方式。仅作为一个记录，不必在意</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; p;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*if(p.find(s[i])==p.end())</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                p.insert(&#123;s[i],i&#125;);</span></span><br><span class="line"><span class="comment">                res=max(res,i-l);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                res=max(res,i-l);</span></span><br><span class="line"><span class="comment">                int temp=p[s[i]]+1;</span></span><br><span class="line"><span class="comment">                for(int j=l;j&lt;=p[s[i]];j++)</span></span><br><span class="line"><span class="comment">                    p.erase(s[j]);</span></span><br><span class="line"><span class="comment">                l=temp;</span></span><br><span class="line"><span class="comment">                p.insert(&#123;s[i],i&#125;);</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//记录字符</span></span><br><span class="line">            p[s[i]]++;</span><br><span class="line">            <span class="comment">//移动左指针</span></span><br><span class="line">            <span class="keyword">while</span>(p[s[i]]!=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p[s[l]]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新答案</span></span><br><span class="line">            res=<span class="built_in">max</span>(res,i-l<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题记录</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Day60 | 灵神 | 滑动窗口：最大连续1的个数III</title>
    <url>/2025/03/12/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day60%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0III/</url>
    <content><![CDATA[<h1 id="Day60-灵神-滑动窗口：最大连续1的个数III"><a href="#Day60-灵神-滑动窗口：最大连续1的个数III" class="headerlink" title="Day60 | 灵神 | 滑动窗口：最大连续1的个数III"></a>Day60 | 灵神 | 滑动窗口：最大连续1的个数III</h1><h2 id="1004-最大连续1的个数III"><a href="#1004-最大连续1的个数III" class="headerlink" title="1004.最大连续1的个数III"></a>1004.最大连续1的个数III</h2><p><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/description/">1004. 最大连续1的个数 III - 力扣（LeetCode）</a></p>
<p><code>思路：</code></p>
<p>和前两天核心思路一样，还是固定右端点，遍历右端点，然后去找左指针往右收缩的条件。</p>
<p>而这个条件一般和题目条件相关。</p>
<p>在本题中就是要找最多翻转k个0后，数组中连续1的个数，换句话说，我们左右区间[l,r]内最多只能包含k个0，超过了就无法翻转，无法翻转就无法保证全是连续的1,。我们只需要记录碰到0的次数，只要碰到0，那么记录0的变量num_zero就++，只要碰到0的次数超过了k，那说明我们现在翻转不了这么多的0，所以我们这时候就可以移动左指针，直到我们的左右区间[l,r]内0的数量小于等于k停止。</p>
<p><code>完整代码：</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestOnes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> nums_zero=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//记录0的数量</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums_zero++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左指针收缩条件</span></span><br><span class="line">            <span class="keyword">while</span>(nums_zero&gt;k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[l]==<span class="number">0</span>)</span><br><span class="line">                    nums_zero--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//记录答案</span></span><br><span class="line">            res=<span class="built_in">max</span>(res,i-l<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题记录</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Day61 | 灵神 | 滑动窗口：统计最大元素出现至少K次的子数组</title>
    <url>/2025/03/13/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day61%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A%E7%BB%9F%E8%AE%A1%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E8%87%B3%E5%B0%91K%E6%AC%A1%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="Day61-灵神-滑动窗口：统计最大元素出现至少K次的子数组"><a href="#Day61-灵神-滑动窗口：统计最大元素出现至少K次的子数组" class="headerlink" title="Day61 | 灵神 | 滑动窗口：统计最大元素出现至少K次的子数组"></a>Day61 | 灵神 | 滑动窗口：统计最大元素出现至少K次的子数组</h1><h2 id="2962-统计最大元素出现至少K次的子数组"><a href="#2962-统计最大元素出现至少K次的子数组" class="headerlink" title="2962.统计最大元素出现至少K次的子数组"></a>2962.统计最大元素出现至少K次的子数组</h2><p><a href="https://leetcode.cn/problems/count-subarrays-where-max-element-appears-at-least-k-times/description/">2962. 统计最大元素出现至少 K 次的子数组 - 力扣（LeetCode）</a></p>
<p><code>思路：</code></p>
<p>一开始我并没有想出来，这是笔者的代码，很遗憾超时了，因为这个和暴力的思路差不多</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> l=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max_num = ranges::<span class="built_in">max</span>(nums),max_cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(max_num==nums[i])</span><br><span class="line">                max_cnt++;</span><br><span class="line">            <span class="type">int</span> temp=max_cnt;</span><br><span class="line">            <span class="keyword">while</span>(max_cnt&gt;=k)</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">if</span>(nums[l]==max_num)</span><br><span class="line">                    max_cnt--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            l=<span class="number">0</span>;</span><br><span class="line">            max_cnt=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>核心思路还是和前面滑动窗口的题一样，都是固定并遍历右端点，然后去寻找左指针收缩的条件。</p>
<p>本题左指针收缩的条件就是当前左右端点区间内的最大值的数量max_cnt大于等于k时，左指针收缩，收缩到当前左右端点区间内的最大值数量max_cnt小于k的时候就可以停止了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    long long countSubarrays(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        long long l=0,res=0;</span><br><span class="line">        int max_num = ranges::max(nums),max_cnt=0;</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(max_num==nums[i])</span><br><span class="line">                max_cnt++;</span><br><span class="line">            int temp=max_cnt;</span><br><span class="line">            while(max_cnt&gt;=k)</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                if(nums[l]==max_num)</span><br><span class="line">                    max_cnt--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一开始并没有下面这两行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">l=<span class="number">0</span>;</span><br><span class="line">max_cnt=temp;</span><br></pre></td></tr></table></figure>

<p>后来加上是因为我发现了我的代码的漏洞</p>
<p>比如区间为[1,3,2,3]时，我固定了第二个3，当左指针收缩到第一个3的时候会把max_cnt–，这就导致当区间为[1,3,2,3,3]时，我的max_cnt&#x3D;2，而不是3。</p>
<p>所以我加上了上面这两行，让右边固定的时候左边从头开始计算。可是这样就和暴力解法的时间复杂度差不多了</p>
<p><strong>问题的核心在于如何统计子数组的数量</strong></p>
<p>如果在max_cnt–之后，仍然不影响统计满足条件的子数组的数量呢？</p>
<p>答案是在循环退出后直接 res+&#x3D;l</p>
<p>举两个例子</p>
<p>当右端点固定为第二个3，区间为[1,3,2,3]，这时左指针往左移动，移动到l&#x3D;2，即区间为[2,3]时，max_cnt变为1，退出了循环，而满足条件的子数组为[1,3,2,3],[3,2,3]，而l正好就是2，因为我们左指针移动过的路径就是所有满足条件的子数组。</p>
<p>再举一个例子：</p>
<p>右端点固定为第3个3，区间为[1,3,2,3,3]，这是我们的l从2开始，真实区间其实是[2,3,3]，这其实没有关系，因为l的2在这里其实代表的是[1,3,2,3,3]和[3,2,3,3]这两个子数组。然后移动到最后一个数[3]，此时l&#x3D;4，这四个子数组就是[1,3,2,3,3]、[3,2,3,3]、[2,3,3]、[3,3]，没错，就是左指针走过的路径长度，即l的大小，所以直接res+&#x3D;l就记录了子数组的个数.</p>
<p><code>完整代码：</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> l=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max_num = ranges::<span class="built_in">max</span>(nums),max_cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==max_num)</span><br><span class="line">                max_cnt++;</span><br><span class="line">            <span class="keyword">while</span>(max_cnt==k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[l]==max_num)</span><br><span class="line">                    max_cnt--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            res+=l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题记录</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Day59 | 灵神 | 滑动窗口：最多K个重复元素的最长子数组&amp;&amp;找到最长的半重复子字符串</title>
    <url>/2025/03/11/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day59%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A%E6%9C%80%E5%A4%9AK%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84&amp;&amp;%E6%89%BE%E5%88%B0%E6%9C%80%E9%95%BF%E7%9A%84%E5%8D%8A%E9%87%8D%E5%A4%8D%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="Day59-灵神-滑动窗口：最多K个重复元素的最长子数组-找到最长的半重复子字符串"><a href="#Day59-灵神-滑动窗口：最多K个重复元素的最长子数组-找到最长的半重复子字符串" class="headerlink" title="Day59 | 灵神 | 滑动窗口：最多K个重复元素的最长子数组&amp;&amp;找到最长的半重复子字符串"></a>Day59 | 灵神 | 滑动窗口：最多K个重复元素的最长子数组&amp;&amp;找到最长的半重复子字符串</h1><p>##2958.最多K个重复元素的最长子数组</p>
<p><a href="https://leetcode.cn/problems/length-of-longest-subarray-with-at-most-k-frequency/description/">2958. 最多 K 个重复元素的最长子数组 - 力扣（LeetCode）</a></p>
<p><code>思路：</code></p>
<p>和<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">3. 无重复字符的最长子串 - 力扣（LeetCode）</a>可以说是一模一样，可以查看我昨天的题解</p>
<p>无重复最长子串是这道题K等于2的情况而已</p>
<p>即左指针移动的条件是把右端点包含在好数组内时，右端点nums[i]代表的数字个数超过了k。那我们就移动左指针，直到固定右端点时整个子数组都满足数字个数小于等于k的条件。</p>
<p><code>完整代码：</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubarrayLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p[nums[i]]++;</span><br><span class="line">            <span class="keyword">while</span>(p[nums[i]]&gt;k)</span><br><span class="line">            &#123;</span><br><span class="line">                p[nums[l]]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            res=<span class="built_in">max</span>(res,i-l<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2730-找到最长的半重复子字符串"><a href="#2730-找到最长的半重复子字符串" class="headerlink" title="2730.找到最长的半重复子字符串"></a>2730.找到最长的半重复子字符串</h2><p><a href="https://leetcode.cn/problems/find-the-longest-semi-repetitive-substring/description/">2730. 找到最长的半重复子字符串 - 力扣（LeetCode）</a></p>
<p><code>思路：</code></p>
<p>还是和前面的思路相同，固定遍历右端点，然后根据具体条件收缩左指针。</p>
<p>本题左指针往后移动的条件是 在左右指针之间有一对以上的相邻字符相等。</p>
<p>那我们就自然而然想到拿一个变量来记录相邻字符相等的数量，如果大于1，说明满足了条件，我们应该向后移动左指针，直到左指针满足条件了为止，而怎么判断左指针满足条件该停止移动了又是新的难点。</p>
<p>我们先往右移动1个字符，这样就可以比较l和l-1所指的字符，如果不相等，那说明我们没有找到第一对相等的相邻字符，我们就继续往后移动，只有l和l-1相等的时候，我们才达到了左指针停止移动的条件，就是左右指针之间已经没有1对以上的相邻相等字符了。（当前第一对相等的相邻字符是l和l-1，而我们的窗口是l到r，[l,r]，不包括l-1，自然也就排除了第一对相等的相邻字符）</p>
<p><code>完整代码：</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSemiRepetitiveSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//记录相邻字符相等的对数</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;s[i]==s[i<span class="number">-1</span>])</span><br><span class="line">                flag++;</span><br><span class="line">            <span class="comment">//对数大于1</span></span><br><span class="line">            <span class="keyword">if</span>(flag&gt;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               l++;</span><br><span class="line">               <span class="comment">//左指针移动停止的条件 就是找到第一对相等的相邻字符</span></span><br><span class="line">               <span class="keyword">while</span>(s[l]!=s[l<span class="number">-1</span>]) </span><br><span class="line">                    l++;</span><br><span class="line">                <span class="comment">//更新flag</span></span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res=<span class="built_in">max</span>(res,i-l<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题记录</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Day62 | 灵神 | 滑动窗口：统计得分小于K的子数组数目</title>
    <url>/2025/03/14/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day62%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%BE%97%E5%88%86%E5%B0%8F%E4%BA%8EK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="Day62-灵神-滑动窗口：统计得分小于K的子数组数目"><a href="#Day62-灵神-滑动窗口：统计得分小于K的子数组数目" class="headerlink" title="Day62 | 灵神 | 滑动窗口：统计得分小于K的子数组数目"></a>Day62 | 灵神 | 滑动窗口：统计得分小于K的子数组数目</h1><h2 id="2302-统计得分小于K的子数组数目"><a href="#2302-统计得分小于K的子数组数目" class="headerlink" title="2302.统计得分小于K的子数组数目"></a>2302.统计得分小于K的子数组数目</h2><p><a href="https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/description/">2302. 统计得分小于 K 的子数组数目 - 力扣（LeetCode）</a></p>
<p>这道题目虽然是hard，但是通过前几天的做题，我个人觉得这道题反而比<a href="https://leetcode.cn/problems/count-subarrays-where-max-element-appears-at-least-k-times/description/">2962. 统计最大元素出现至少 K 次的子数组 - 力扣（LeetCode）</a>，因为这道题的统计子数组的方式比2962这道题好想很多</p>
<p><code>思路：</code></p>
<p>还是那个核心思路，固定右端点，遍历右端点，找左指针收缩的条件，这道题的收缩条件很简单，就是左右指针区间[l,r]内的数的和再乘以数量得到的数大于等于k就行。</p>
<p>所以思路比较简单。</p>
<p>另外统计子数组方式就是(r-l+1)，即区间长度</p>
<p><strong>举例：</strong></p>
<p>[2,1,4,3]如果这四个数满足条件的话，那么[1,4,3]，[4,3]，[3]那必然符合，那所有的子数组数量就是(r-l+1)&#x3D;4咯</p>
<p><strong>下面是笔者的代码，这个代码会有一个测试用例超时，咱们来看看有什么地方可以进行优化</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> nums_sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;=i;j++)</span><br><span class="line">                sum+=nums[j];</span><br><span class="line">            nums_sum=sum*(i-l<span class="number">+1</span>);</span><br><span class="line">            <span class="keyword">while</span>(nums_sum&gt;=k)</span><br><span class="line">            &#123;</span><br><span class="line">                nums_sum/=(i-l<span class="number">+1</span>);</span><br><span class="line">                nums_sum-=nums[l];</span><br><span class="line">                l++;</span><br><span class="line">                nums_sum*=(i-l<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res+=(i-l<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1.while循环中每次都要乘除乘除，有很多的重复计算</p>
<p>改为用sum记录[l,r]区间的和，while条件改为乘法的表达式，这样左指针移动后只需要进行sum的加减就行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(sum*(i-l<span class="number">+1</span>)&gt;=k)</span><br><span class="line">&#123;</span><br><span class="line">	sum-=nums[l];</span><br><span class="line">	l++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.每次都用for循环计算[l,r]区间的和，这个没啥必要，因为左指针往右收缩的时候就已经对sum进行了修改，我们只需要加上右端点，就能得到区间的和，而不是每次都要计算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;=i;j++)</span><br><span class="line">	sum+=nums[j];</span><br><span class="line">改为</span><br><span class="line">sum+=nums[i];</span><br></pre></td></tr></table></figure>

<p><code>完整代码：</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算[l,r]的和</span></span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="comment">//左指针收缩使得子数组满足题目条件</span></span><br><span class="line">            <span class="keyword">while</span>(sum*(i-l<span class="number">+1</span>)&gt;=k)</span><br><span class="line">            &#123;</span><br><span class="line">                sum-=nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新答案</span></span><br><span class="line">            res+=(i-l<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题记录</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Day63 | 灵神 | 滑动窗口：将x减到0的最小操作数</title>
    <url>/2025/03/15/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day63%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A%E5%B0%86x%E5%87%8F%E5%88%B00%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0/</url>
    <content><![CDATA[<h1 id="Day63-灵神-滑动窗口：将x减到0的最小操作数"><a href="#Day63-灵神-滑动窗口：将x减到0的最小操作数" class="headerlink" title="Day63 | 灵神 | 滑动窗口：将x减到0的最小操作数"></a>Day63 | 灵神 | 滑动窗口：将x减到0的最小操作数</h1><h2 id="1658-将x减到0的最小操作数"><a href="#1658-将x减到0的最小操作数" class="headerlink" title="1658.将x减到0的最小操作数"></a>1658.将x减到0的最小操作数</h2><p><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/description/">1658. 将 x 减到 0 的最小操作数 - 力扣（LeetCode）</a></p>
<p><code>思路：</code></p>
<p>这道题笔者没什么思路，直接做的，答案是错误的，遗憾落泪</p>
<p>就去看了灵神的思路</p>
<p><strong>要逆向思维，把这道题转化为滑动窗口的题，先求出数组和再减去x，这个数字表示为sum，这时候我们要求的就是在数组中找一个最长子数组，使得这个子数组的和等于sum，然后再用数组长度减去最长子数组长度就是我们要的最小操作数了</strong></p>
<p>说实话我想不出来</p>
<p>既然知道了这个思路</p>
<p>还是继续前几天的核心思路，固定右端点，遍历右端点，然后寻找左指针收缩条件</p>
<p>这道题左指针收缩条件得根据我们转换后的思维来写，不能通过原来的题目得出这个收缩条件</p>
<p>根据我们的思路，左指针收缩条件那就是当前子数组的和大于sum这个数，我们就收缩左指针，从而减小子数组的和，来和sum进行比较</p>
<p>如果正好等于sum才是满足条件的情况，才会去更新最后的结果</p>
<p>子数组的长度还是(r-l+1)</p>
<p>下面看完整代码</p>
<p><code>完整代码:</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">-1</span>,l=<span class="number">0</span>,temp=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//得到我们的最长子数组的和要相等的数字</span></span><br><span class="line">        <span class="type">int</span> sum=<span class="built_in">reduce</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>())-x;</span><br><span class="line">        <span class="comment">//如果一开始sum就小于0，说明整个数组都减了也不能达到x</span></span><br><span class="line">        <span class="keyword">if</span> (sum&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">//记录子数组的和</span></span><br><span class="line">            temp+=nums[i];</span><br><span class="line">            <span class="comment">//左指针收缩</span></span><br><span class="line">            <span class="keyword">while</span>(temp&gt;sum)</span><br><span class="line">            &#123;</span><br><span class="line">                temp-=nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//满足条件的情况，更新答案</span></span><br><span class="line">            <span class="keyword">if</span>(temp==sum)</span><br><span class="line">                res=<span class="built_in">max</span>(res,i-l<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">if</span>(res==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> nums.<span class="built_in">size</span>()-res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题记录</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Day64 | 灵神 | 滑动窗口：最小覆盖子串</title>
    <url>/2025/03/16/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day64%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="Day64-灵神-滑动窗口：最小覆盖子串"><a href="#Day64-灵神-滑动窗口：最小覆盖子串" class="headerlink" title="Day64 | 灵神 | 滑动窗口：最小覆盖子串"></a>Day64 | 灵神 | 滑动窗口：最小覆盖子串</h1><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76.最小覆盖子串"></a>76.最小覆盖子串</h2><p><a href="https://leetcode.cn/problems/minimum-window-substring/description/">76. 最小覆盖子串 - 力扣（LeetCode）</a></p>
<p>总的来说笔者自己很难做出这道题，基本都是参考了灵神的题解，下面记录自己的理解和踩坑记录</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路还是好想的，就和之前的滑动窗口题目一样，<strong>固定右端点，遍历右端点，寻找左指针的收缩条件</strong>，好想的地方在于收缩条件无比的简单，就是看[l,r]内是否涵盖了t中的所有的字符即可，如果涵盖了，我们就收缩左指针，寻找更小的子串，如果不再涵盖的话，那说明已经不满足收缩条件，我们就继续往后遍历右指针，看看新的[l,r]内是否可以涵盖t的所有字符</p>
<h3 id="可能产生的疑惑"><a href="#可能产生的疑惑" class="headerlink" title="可能产生的疑惑"></a>可能产生的疑惑</h3><p>我在固定r的时候，把l收缩到一个位置了，那么当固定r+1时，需要重新把l置为0吗？</p>
<p>其实是不需要的，固定r的时候我们如果找到了一个最小的区间[l,r]是满足条件的，那么[l,r+1]肯定是大于[l,r]的，所以没必要重新把l置为0</p>
<h3 id="笔者认为的本题难点"><a href="#笔者认为的本题难点" class="headerlink" title="笔者认为的本题难点"></a>笔者认为的本题难点</h3><p>困难题还是困难题呀，考察一个人的综合素养，反正是给笔者卡住了</p>
<p><code>1.如何知道我当前的[l,r]区间涵盖了t的所有字符？</code></p>
<p>笔者第一想法是用哈希表统计t的所有字符数量，另一个哈希表统计[l,r]的所有字符数量，然后再遍历一遍[l,r]，把哈希表中的数都给减掉，如果t的字符的哈希值最后都大于0那就说明是涵盖了，可是这个代码实现真的太麻烦了，时间复杂度我也不敢想（现在想想这个想法还有点可笑）</p>
<p>就去参考了灵神的，灵神也是用两个哈希表，灵神是统计完t的字符数量之后，把大写英文和小写英文遍历一遍，然后比较同一个字符的两个哈希表的数值，如果s的哈希表的所有的大小写字符都比t的哈希表的数值大，那就说明肯定涵盖了所有的t的字符。</p>
<p><strong>只需要比大小就好，不需要加加减减的。这个方法要记住。</strong></p>
<p><code>2.内存超出限制</code></p>
<p>看下方的踩坑记录即可</p>
<p><code>3.我的res一开始是空串，如果最后还是空串，我如何得知那么是没有答案，还是有答案但是没有更新呢？</code></p>
<p>看下方的踩坑记录即可</p>
<p><code>4.更新答案的条件该如何写呢？</code></p>
<p>用左右两个端点res_l,res_r记录最后的答案，如果[l,r]区间长度小于[res_l,res_r]我们就去更新res_l和res_r</p>
<h3 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h3><h4 id="1-超出内存限制"><a href="#1-超出内存限制" class="headerlink" title="1.超出内存限制"></a>1.超出内存限制</h4><p>我一开始是用res存储最后的答案，然后在循环过程中去更新答案。但是如果s很大，每次循环中的res也会很大，导致内存超出了限制</p>
<p>只需要保存答案子串的左右端点即可，然后返回时使用</p>
<h4 id="2-我的res一开始是空串，如果最后还是空串，那么可能是没有答案，也有可能是答案但是没有更新"><a href="#2-我的res一开始是空串，如果最后还是空串，那么可能是没有答案，也有可能是答案但是没有更新" class="headerlink" title="2.我的res一开始是空串，如果最后还是空串，那么可能是没有答案，也有可能是答案但是没有更新"></a>2.我的res一开始是空串，如果最后还是空串，那么可能是没有答案，也有可能是答案但是没有更新</h4><p>下面是笔者遇到的有答案但是没有更新的例子</p>
<p>前面说到，我是用res存储答案，后面改为了用res_l,res_r存储左右端点，一开始我的初始化是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">res_l=0,res_r=s.size()-1;</span><br></pre></td></tr></table></figure>

<p>可是这样就出现了一个问题，当</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s=&quot;a&quot;,t=&quot;a&quot;</span><br></pre></td></tr></table></figure>

<p>的时候，就会发现，我的[l,r]和[res_l,和res_r]竟然是一样的，而更新答案的条件是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r-l&lt;res_r-res_l</span><br></pre></td></tr></table></figure>

<p>那么就不会更新答案了</p>
<p><strong>要解决这个问题，只需要把res_l初始化为-1，然后看最后res_l是不是-1即可，是-1就没更新，返回空串，不是-1就更新了，返回[res_l,res_r]区间的子串即可</strong></p>
<p><code>下面是超出内存限制和没有修改前更新答案条件的代码</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_covered</span><span class="params">(vector&lt;<span class="type">int</span>&gt; s,vector&lt;<span class="type">int</span>&gt; t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="string">&#x27;A&#x27;</span>;i&lt;=<span class="string">&#x27;Z&#x27;</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(s[i]&lt;t[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="string">&#x27;a&#x27;</span>;i&lt;=<span class="string">&#x27;z&#x27;</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(s[i]&lt;t[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v_s</span><span class="params">(<span class="number">128</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v_t</span><span class="params">(<span class="number">128</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:t)</span><br><span class="line">            <span class="type">v_t</span>[c]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            v_s[s[i]]++;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">is_covered</span>(v_s,<span class="type">v_t</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(res.<span class="built_in">size</span>()==<span class="number">0</span>||res.<span class="built_in">size</span>()&gt;i-l<span class="number">+1</span>)</span><br><span class="line">                    res=<span class="built_in">string</span>(s.<span class="built_in">begin</span>()+l,s.<span class="built_in">begin</span>()+i<span class="number">+1</span>);</span><br><span class="line">                v_s[s[l]]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_covered</span><span class="params">(<span class="type">int</span> s[],<span class="type">int</span> t[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="string">&#x27;A&#x27;</span>;i&lt;=<span class="string">&#x27;Z&#x27;</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(s[i]&lt;t[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="string">&#x27;a&#x27;</span>;i&lt;=<span class="string">&#x27;z&#x27;</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(s[i]&lt;t[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> res_l=<span class="number">-1</span>,res_r=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> v_s[<span class="number">128</span>]&#123;&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="type">v_t</span>[<span class="number">128</span>]&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:t)</span><br><span class="line">            <span class="type">v_t</span>[c]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            v_s[s[i]]++;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">is_covered</span>(v_s,<span class="type">v_t</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i-l&lt;res_r-res_l<span class="number">+1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res_r=i;</span><br><span class="line">                    res_l=l;</span><br><span class="line">                &#125;</span><br><span class="line">                v_s[s[l]]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res_l==<span class="number">-1</span>?<span class="string">&quot;&quot;</span>:s.<span class="built_in">substr</span>(res_l,res_r-res_l<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题记录</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Day66 | 灵神 | 二分查找：咒语和药水的成功对数</title>
    <url>/2025/03/18/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day66%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E5%92%92%E8%AF%AD%E5%92%8C%E8%8D%AF%E6%B0%B4%E7%9A%84%E6%88%90%E5%8A%9F%E5%AF%B9%E6%95%B0/</url>
    <content><![CDATA[<h1 id="Day66-灵神-二分查找：咒语和药水的成功对数"><a href="#Day66-灵神-二分查找：咒语和药水的成功对数" class="headerlink" title="Day66 | 灵神 | 二分查找：咒语和药水的成功对数"></a>Day66 | 灵神 | 二分查找：咒语和药水的成功对数</h1><h2 id="2300-咒语和药水的成功对数"><a href="#2300-咒语和药水的成功对数" class="headerlink" title="2300.咒语和药水的成功对数"></a>2300.咒语和药水的成功对数</h2><p><a href="https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/description/">2300. 咒语和药水的成功对数 - 力扣（LeetCode）</a></p>
<p><code>思路：</code></p>
<p>这个题目还挺好想的</p>
<p>其实还是在数组里面去找左边界而已，只是在外面多套了一层数组的遍历</p>
<p>遍历spells数组，然后里面套找左边界的二分查找就行，查找options数组里面的满足条件的左边界，找到之后求出左边界到数组末尾这个区间的长度就行</p>
<p><strong>记得先排序options，因为只有有序我们才可以使用二分查找</strong></p>
<p>时间复杂度是遍历数组spells，二分查找options，一共O(nlogm)。再加上排序的时间复杂度O(mlogm)</p>
<p>时间复杂度&#x3D; O(nlogm)+O(mlogm)&#x3D;O((n+m)logm)</p>
<p>如果不太会写左边界的二分查找，可以看看昨天的博客：</p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/146308117?spm=1001.2014.3001.5501">Day65 | 灵神 | 二分查找：红蓝染色法-CSDN博客</a></p>
<p><code>完整代码：</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a*b&gt;=c)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(<span class="type">int</span> spells,vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">long</span> <span class="type">long</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(nums[mid],spells,target))</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">successfulPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; spells, vector&lt;<span class="type">int</span>&gt;&amp; potions, <span class="type">long</span> <span class="type">long</span> success)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; pairs;</span><br><span class="line">        <span class="type">int</span> single_pairs=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(potions.<span class="built_in">begin</span>(),potions.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;spells.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            single_pairs=potions.<span class="built_in">size</span>()-<span class="built_in">lower_bound</span>(spells[i],potions,success);</span><br><span class="line">            pairs.<span class="built_in">push_back</span>(single_pairs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pairs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题记录</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Day67 | 灵神 | 二分查找：统计公平数对的数目</title>
    <url>/2025/03/19/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day67%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%85%AC%E5%B9%B3%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="Day67-灵神-二分查找：统计公平数对的数目"><a href="#Day67-灵神-二分查找：统计公平数对的数目" class="headerlink" title="Day67 | 灵神 | 二分查找：统计公平数对的数目"></a>Day67 | 灵神 | 二分查找：统计公平数对的数目</h1><h2 id="2563-统计公平数对的数目"><a href="#2563-统计公平数对的数目" class="headerlink" title="2563.统计公平数对的数目"></a>2563.统计公平数对的数目</h2><p><a href="https://leetcode.cn/problems/count-the-number-of-fair-pairs/description/">2563. 统计公平数对的数目 - 力扣（LeetCode）</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先说一下为什么排序不会影响本道题目的结果，因为本质上是从数组中选择两个数，满足0&lt;i&lt;j&lt;n，lower &lt;&#x3D; nums[i] + nums[j] &lt;&#x3D; upper的条件。就算你排序之后，那两个数还是那两个数，无非就是从[1,4]变成了[4,1]而已。</p>
<p>先来说一说错误的，希望大家不要和笔者一样</p>
<p>想的是在二分查找过程中把对数给统计了，check函数也是传入的nums[l],nums[r],lower,upper，按照题目给的条件去比较，然后判断符合条件不符合条件</p>
<p>这时候就发现，我符合条件以后我该往哪边收缩呢？不管往那边收缩都会漏掉情况，往左收缩会漏掉往右的情况，往右收缩会漏掉左边的，同时收缩更不用说了</p>
<p>所以这个时候就该发现自己的思路出了问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> c,<span class="type">long</span> <span class="type">long</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a+b&gt;=c&amp;&amp;a+b&lt;=d)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> lower, <span class="type">int</span> upper)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(nums[l],nums[r],lower,upper))</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                r=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countFairPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lower, <span class="type">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">lower_bound</span>(nums,lower,upper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h4><p>参考的灵神的思路</p>
<p>用j遍历数组，那么我们的nums[i]需要满足什么条件呢？</p>
<p><em>lower</em>−<em>nums</em>[<em>j</em>]≤<em>nums</em>[<em>i</em>]≤<em>upper</em>−<em>nums</em>[<em>j</em>]</p>
<p>这时候你就发现呢我们只要用lower-nums[j]去找nums[i]的左边界，用upper-nums[j]去找nums[i]的右边界，那么在左右边界内的数字一定符合条件，也就是数对的数量</p>
<p>不过要注意是在[0,j)这个左开右闭区间进行二分，因为题目说了要i&lt;j</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>笔者的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums,<span class="type">int</span> bound,<span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=bound;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countFairPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lower, <span class="type">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// &lt; lower-nums[j] 的 nums[i] 的个数</span></span><br><span class="line">            <span class="type">int</span> l=<span class="built_in">lower_bound</span>(nums,j,lower-nums[j]);</span><br><span class="line">            <span class="comment">// &lt;= upper-nums[j] 的 nums[i] 的个数</span></span><br><span class="line">            <span class="comment">//这个+1是因为&lt;=x就是(&gt;x+1)的位置-1</span></span><br><span class="line">            <span class="comment">//这里没减1是下面的r-l懒得+1了，减了1就是[l,r]的闭区间，不减就是[l,r)的区间，效果都一样</span></span><br><span class="line">            <span class="type">int</span> r=<span class="built_in">lower_bound</span>(nums,j,upper-nums[j]<span class="number">+1</span>);</span><br><span class="line">            res += r- l;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>灵神的使用二分查找函数的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countFairPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> lower, <span class="type">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="comment">// 注意要在 [0, j) 中二分，因为题目要求两个下标 i &lt; j</span></span><br><span class="line">            <span class="keyword">auto</span> r = <span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + j, upper - nums[j]); <span class="comment">// &lt;= upper-nums[j] 的 nums[i] 的个数</span></span><br><span class="line">            <span class="keyword">auto</span> l = <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + j, lower - nums[j]); <span class="comment">// &lt; lower-nums[j] 的 nums[i] 的个数</span></span><br><span class="line">            ans += r - l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="补充知识：upper-bound和lower-bound"><a href="#补充知识：upper-bound和lower-bound" class="headerlink" title="补充知识：upper_bound和lower_bound"></a>补充知识：<code>upper_bound</code>和<code>lower_bound</code></h3><p><code>upper_bound</code>和<code>lower_bound</code>是C++标准库中用于在<strong>已排序序列</strong>中查找边界的算法，它们的返回值是<strong>迭代器</strong>，具体行为如下：</p>
<hr>
<h3 id="1-返回值类型"><a href="#1-返回值类型" class="headerlink" title="1. 返回值类型"></a><strong>1. 返回值类型</strong></h3><ul>
<li><p>返回值为迭代器：两者均返回指向容器中特定位置的迭代器（ForwardIterator或RandomAccessIterator），而非直接返回下标或元素值</p>
<p><strong>示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>);  <span class="comment">// it指向元素8的迭代器（即v[4]）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-返回值指向的位置"><a href="#2-返回值指向的位置" class="headerlink" title="2. 返回值指向的位置"></a><strong>2. 返回值指向的位置</strong></h3><h4 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a><strong>lower_bound</strong></h4><ul>
<li><p>返回第一个 <em>≥</em> val 的元素位置：若存在等于val的元素，返回第一个等于val的元素的迭代器；若不存在，则返回第一个大于val的元素的迭代器；若所有元素均小于val，返回last（容器的end()迭代器）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>);  <span class="comment">// 指向第一个2的迭代器（v[2]）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a><strong>upper_bound</strong></h4><ul>
<li><p>返回第一个 <em>&gt;</em> val 的元素位置：无论是否存在等于val的元素，均返回第一个大于val的元素的迭代器；若所有元素均小于等于val，返回last（容器的end()迭代器）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>);  <span class="comment">// 指向8的迭代器（v[4]）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-特殊情况处理"><a href="#3-特殊情况处理" class="headerlink" title="3. 特殊情况处理"></a><strong>3. 特殊情况处理</strong></h3><ul>
<li><p>元素不存在时：若序列中无符合条件的元素，两者均返回last（即end()迭代器），表示“结束位置”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">9</span>);  <span class="comment">// 返回v.end()（指向末尾后一位置）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>元素为最大值时：若val等于最后一个元素的值，upper_bound仍返回end()，而lower_bound返回最后一个元素的迭代器</p>
</li>
</ul>
<hr>
<h3 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a><strong>4. 应用场景</strong></h3><ul>
<li><p>计算元素出现次数：结合upper_bound - lower_bound可快速计算有序序列中某元素的出现次数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>) - <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入元素保持有序：使用返回的迭代器插入新元素，可维持序列的有序性</p>
</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">返回值类型</th>
<th align="center">指向位置</th>
<th align="center">特殊返回值（无匹配时）</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>lower_bound</code></td>
<td align="center">迭代器</td>
<td align="center">第一个 <strong>≥ val</strong> 的元素</td>
<td align="center"><code>end()</code></td>
</tr>
<tr>
<td align="center"><code>upper_bound</code></td>
<td align="center">迭代器</td>
<td align="center">第一个 <strong>&gt; val</strong> 的元素</td>
<td align="center"><code>end()</code></td>
</tr>
</tbody></table>
<p>使用时需确保序列<strong>已排序</strong>，否则结果未定义</p>
]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题记录</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Day68 | 灵神 | 二分查找：H指数II</title>
    <url>/2025/03/20/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day68%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9AH%E6%8C%87%E6%95%B0II/</url>
    <content><![CDATA[<h1 id="Day68-灵神-二分查找：H指数II"><a href="#Day68-灵神-二分查找：H指数II" class="headerlink" title="Day68 | 灵神 | 二分查找：H指数II"></a>Day68 | 灵神 | 二分查找：H指数II</h1><h2 id="275-H指数II"><a href="#275-H指数II" class="headerlink" title="275.H指数II"></a>275.H指数II</h2><p><a href="https://leetcode.cn/problems/h-index-ii/description/">275. H 指数 II - 力扣（LeetCode）</a></p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>很遗憾笔者这道题没做出来，看了灵神的还是不太懂，后来看了评论区各位大佬的解释，来这里浅显的说一下自己的理解</p>
<p>在此之前请先看看灵神的题解，如果看懂了还是不要继续往下看了，如果没看懂的话，我来说一说我疑惑的点，看看是不是也是你疑惑的点呢？</p>
<p>灵神题解：<a href="https://leetcode.cn/problems/h-index-ii/solutions/2504326/tu-jie-yi-tu-zhang-wo-er-fen-da-an-si-ch-d15k/">275. H 指数 II - 力扣（LeetCode）</a></p>
<h3 id="可能对灵神的题解中的疑惑的点"><a href="#可能对灵神的题解中的疑惑的点" class="headerlink" title="可能对灵神的题解中的疑惑的点"></a>可能对灵神的题解中的疑惑的点</h3><h4 id="1-理解本道题最重要的一点"><a href="#1-理解本道题最重要的一点" class="headerlink" title="1.理解本道题最重要的一点"></a>1.理解本道题最重要的一点</h4><p>为什么左闭右开区间的时候，l要初始化为1，r要初始化为citations.size()+1呢？</p>
<p>因为这道题二分的其实是h指数的数组，而h指数的数组你可以看做是[0,1,2,3,4,5]，因为h指数可以取到这些数字，也就是说h指数的范围是[0,5]即[0,citations.size()]，但是笔者写的是左开右闭区间所以就是[0,citations.size()+1)了，也就是[0,6)</p>
<p>所以其实我们二分的是[0,1,2,3,4,5]这个数组，我们最后返回的答案一定在这之中</p>
<p><strong>所以说白了citations这个数组起到的作用就是辅助我们把h从[0,citations.size()+1)给挑选出来，也就是用来写判断条件的，除此之外没有什么其他的作用</strong></p>
<p>而为什么l初始化为0而不是1呢？</p>
<p>这个灵神有说</p>
<p>肯定有0篇论文的引用次数&gt;&#x3D;0，那么二分区间就不需要包括0，直接从1开始就好了，也就是说我们二分的区间其实是[1,2,3,4,5]，等价于[1,2,3,4,5,6)</p>
<p>这让我想起洛谷做过的一道题，是砍树的，也是把树的高度进行二分而不是去看树的高度的数组，完了有空再去刷一下</p>
<h4 id="2-比较重要的理解，为啥最后返回的是l-1不是l"><a href="#2-比较重要的理解，为啥最后返回的是l-1不是l" class="headerlink" title="2.比较重要的理解，为啥最后返回的是l-1不是l"></a>2.比较重要的理解，为啥最后返回的是l-1不是l</h4><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250320092859009.png" alt="image-20250320092859009"></p>
<p>首先要理解这个，这个比较容易，大家自行理解就好</p>
<p>其次要知道，二分区间[l,r)内的性质我们还没有判断，就是我们不知道二分区间内的数是否满足条件，而二分区间外面的数字是已经被筛选过的，肯定满足条件的</p>
<p>就像是[1,2,3,4,5,6)当我们二分区间为[3,4,5,6)的时候，我们肯定可以判断1,2是合法或者不合法的才会更新到[3,4,5,6)这个区间</p>
<p><strong>再次，通过上面的第一条我们得知citations是来辅助我们筛选h的，所以更新区间时的mid其实就是满足条件的答案h，下面的代码我也有写，用res记录答案，每次更新时res&#x3D;mid，然后才是l&#x3D;mid+1</strong></p>
<p>也就是说，我们每次判断的时候l-1&#x3D;&#x3D;mid，也就是l-1就是答案，这也是为什么灵神最后返回的是l-1</p>
<p>满足条件在灵神的题解中等价于是询问的结果是   “是”</p>
<h4 id="3-citations-citations-size-mid-mid这个判断条件该如何理解？"><a href="#3-citations-citations-size-mid-mid这个判断条件该如何理解？" class="headerlink" title="3.citations[citations.size()-mid]&gt;&#x3D;mid这个判断条件该如何理解？"></a>3.citations[citations.size()-mid]&gt;&#x3D;mid这个判断条件该如何理解？</h4><p>citations.size()-mid这个下标对应的是数组倒数第mid个数，因为是单调自增的，如果说 这个下标对应的数要大于我们本轮筛选的h即mid，那说明这个数以及以后的数都是大于mid的，即至少有mid篇论文被引用mid次，用灵神的一张图说明吧</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250320094417918.png" alt="image-20250320094417918"></p>
<p>下面的[0,1,2,3,4,5]可以看做我们的h数组，我们正在用二分筛选这个数组，现在筛选的是h=&#x3D;2&#x3D;&#x3D;mid</p>
<p>citations[0,1,3,5,6]中，citations.size()-mid&#x3D;5-2&#x3D;3</p>
<p>citations[3]&#x3D;5,5&gt;2,而5又是倒数第二个数，5,6，都大于2，那说明肯定至少有两篇论文大于等于2，那么h=&#x3D;2=&#x3D;mid就是一个合法的状态，然后下次更新就是更新到l=&#x3D;mid+1，因为[mid+1,r)这个区间还没有判断是否合法，而[0,mid]这个区间已经被判断为是合法的了</p>
<p>那自然我们确定的答案就是l-1，即mid，就是我们目前帅选出来的最大的h指数了</p>
<p>往后就是反复这个过程</p>
<h3 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h3><p>完整代码部分我觉得加一个res比较好理解，也是看的评论区学习到的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; citations)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>,r=citations.<span class="built_in">size</span>()<span class="number">+1</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(citations[citations.<span class="built_in">size</span>()-mid]&gt;=mid)</span><br><span class="line">            &#123;</span><br><span class="line">                res=mid;</span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">lower_bound</span>(citations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题记录</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂</title>
    <url>/2025/03/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day69%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/</url>
    <content><![CDATA[<h1 id="Day69-灵神-二分查找：爱吃香蕉的珂珂"><a href="#Day69-灵神-二分查找：爱吃香蕉的珂珂" class="headerlink" title="Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂"></a>Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂</h1><h2 id="875-爱吃香蕉的珂珂"><a href="#875-爱吃香蕉的珂珂" class="headerlink" title="875.爱吃香蕉的珂珂"></a>875.爱吃香蕉的珂珂</h2><p><a href="https://leetcode.cn/problems/koko-eating-bananas/description/">875. 爱吃香蕉的珂珂 - 力扣（LeetCode）</a></p>
<h3 id="笔者关键点记录：怎么想到的要二分k而不是原来区间呢？"><a href="#笔者关键点记录：怎么想到的要二分k而不是原来区间呢？" class="headerlink" title="笔者关键点记录：怎么想到的要二分k而不是原来区间呢？"></a>笔者关键点记录：怎么想到的要二分k而不是原来区间呢？</h3><p>可以看到灵神的题解：</p>
<p>看示例 1，piles&#x3D;[3,6,7,11], h&#x3D;8。</p>
<p>如果珂珂能用 k&#x3D;4 的速度吃掉所有香蕉，那么也能用更快的速度 k&#x3D;5,6,⋯ 吃掉所有香蕉。<br>如果珂珂不能用 k&#x3D;3 的速度吃掉所有香蕉，那么也不能用更慢的速度 k&#x3D;2,1,⋯ 吃掉所有香蕉。<br>这种单调性意味着我们像 二分查找 那样，把答案 k 猜出来。</p>
<p><strong>我感觉也可以理解为题目让求啥我们就二分什么东西</strong></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>有了昨天的H指数II，这道题只能说是 so easy，还是一样，piles只是用来写判断条件的，我们二分的是速度k</p>
<p>注意，题目说piles的大小小于时间h，这使得我们很容易找到k的最大值，那就是数组的最大值，我每个小时吃这么多肯定可以吃得完，而最小值肯定不能是0，因为怎么都不可能吃完，所以从1开始</p>
<p><strong>那么我们要二分的k的区间就是[1,数组最大值]，在第一个例子中就是[1,11]</strong></p>
<p><strong>那么接下来就是判断条件咋写了</strong></p>
<p>我们二分的是k，是速度，那要如何判断一个k是否满足条件？那就看这个k可以在多少小时（sum）内吃完香蕉，如果这个sum小于等于h，那肯定就是符合条件的k，那么<code>[k,数组最大值]</code>这个区间肯定都符合条件</p>
<p>然后继续往左收缩就是了</p>
<p><code>注意点：</code></p>
<p>每一堆计算时，如果可以整除k，那就是直接除以k，不可以整除就得让结果+1，因为C++默认除法下取整</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>说明：</p>
<p>1.笔者用的是左闭右开区间，是[l,r)，所以求出最大值后要加1</p>
<p>2.满足条件更新r还是l，那就看sum是大于还是小于h了，本题是sum小于等于h，找的是左边界，只要mid满足条件，那么大于mid的肯定都满足条件，所以更新r</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles,<span class="type">int</span> k,<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:piles)、</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c%k==<span class="number">0</span>)</span><br><span class="line">                sum+=(c/k);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sum+=(c/k)<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum&lt;=h?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minEatingSpeed</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:piles)</span><br><span class="line">            r=<span class="built_in">max</span>(r,c)<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(piles,mid,h))</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题记录</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Day65 | 灵神 | 二分查找：红蓝染色法</title>
    <url>/2025/03/17/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day65%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%BA%A2%E8%93%9D%E6%9F%93%E8%89%B2%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Day65-灵神-二分查找：红蓝染色法"><a href="#Day65-灵神-二分查找：红蓝染色法" class="headerlink" title="Day65 | 灵神 | 二分查找：红蓝染色法"></a>Day65 | 灵神 | 二分查找：红蓝染色法</h1><p>灵神讲解的非常好建议大家去听听灵神的，二分查找就是常忘常学常新，我之前学过很多次二分，但这次还是有新的理解，我把可能比较难理解的点写到了下面，大家没看懂视频的地方可以看看我写的</p>
<p>当然主要的其实是check函数，在本题中就是大于等于target这个条件，估计灵神下个视频会讲吧</p>
<p><a href="https://www.bilibili.com/video/BV1AP41137w7?spm_id_from=333.788.videopod.sections&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">二分查找 红蓝染色法【基础算法精讲 04】_哔哩哔哩_bilibili</a></p>
<h2 id="34-在数组排序中查找元素的第一个和最后一个位置"><a href="#34-在数组排序中查找元素的第一个和最后一个位置" class="headerlink" title="34.在数组排序中查找元素的第一个和最后一个位置"></a>34.在数组排序中查找元素的第一个和最后一个位置</h2><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></p>
<h3 id="视频中的可能的难点"><a href="#视频中的可能的难点" class="headerlink" title="视频中的可能的难点"></a>视频中的可能的难点</h3><h4 id="0-区间的定义"><a href="#0-区间的定义" class="headerlink" title="0.区间的定义"></a>0.区间的定义</h4><p>我觉得这个很重要，不管是定义左闭右开还是左闭右闭，在区间内的数字就是我们接下来要去判断的数字，看看是否满足条件</p>
<p>而区间外的数字都是已经判断过的不满足条件的</p>
<h4 id="1-关于while中什么时候有等号，什么时候没等号的问题"><a href="#1-关于while中什么时候有等号，什么时候没等号的问题" class="headerlink" title="1.关于while中什么时候有等号，什么时候没等号的问题"></a>1.关于while中什么时候有等号，什么时候没等号的问题</h4><p>循环条件中的l&lt;r或者l&lt;&#x3D;r有没有等号看的是当l&#x3D;&#x3D;r的时候[l,r]这个区间是否有数字</p>
<p>如果是左闭右闭，那当然有意义，两个指向同一个数字，比如[2,2]</p>
<p>如果是左闭右开，那当然就是空的了，比如[2,2)，在数学上这是个空集</p>
<p>如果是左开右开那更不必说了</p>
<h4 id="2-循环不变量"><a href="#2-循环不变量" class="headerlink" title="2.循环不变量"></a>2.循环不变量</h4><p>而灵神说的循环不变量就是指的是循环过程中要保证区间左闭右闭这个性质不发生改变，不可以原来是左闭右闭，后面直接换成左闭右开了，那样就会出错</p>
<h4 id="3-关于if中-什么时候是mid-1，mid-1什么时候是mid"><a href="#3-关于if中-什么时候是mid-1，mid-1什么时候是mid" class="headerlink" title="3.关于if中 什么时候是mid-1，mid+1什么时候是mid"></a>3.关于if中 什么时候是mid-1，mid+1什么时候是mid</h4><p>看你选定的区间的l和r在mid+1或者mid-1或者mid，什么时候可以<strong>保持循环不变量</strong>，那就是什么</p>
<p><code>举例</code></p>
<p>1.比如我选定的是左闭右开区间[l,r)，那我每次更新l的时候l就是mid+1，因为当l&#x3D;&#x3D;mid时nums[mid]可以取到并且不符合条件，那就直接等于mid+1</p>
<p>而更新r的时候呢？r&#x3D;&#x3D;mid时nums[mid]其实没有意义，因为r这边是开区间，我们取不到r，所以更新r的时候必须是r&#x3D;mid，才可以继续保证[l,r)是一个开区间</p>
<p>2.选定的如果是左闭右闭区间[l,r]，那更新l就是mid+1，更新r就是mid-1，因为不管是l=&#x3D;mid时还是r&#x3D;&#x3D;mid都是有意义的，而且只有这样才能满足更新后的区间继续保持[l,r]这个闭区间</p>
<h4 id="4-关于-大于、小于、大于等于、小于等于这四种情况的举例说明"><a href="#4-关于-大于、小于、大于等于、小于等于这四种情况的举例说明" class="headerlink" title="4.关于 大于、小于、大于等于、小于等于这四种情况的举例说明"></a>4.关于 大于、小于、大于等于、小于等于这四种情况的举例说明</h4><p>关于大于、小于、大于等于、小于等于这四个情况的说明，如果大家没听懂灵神说的可以看看我写的</p>
<p><strong>大于和大于等于找的是左边界，小于和小于等于找的是右边界</strong></p>
<p>我就拿题目中的例子作为说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure>

<p>target&#x3D;8，令x&#x3D;8</p>
<p>大于等于x就是我们原来找的，直接就可以找到下标为3的8，即左边界</p>
<p>大于x可以看做大于等于x+1，即在这个数组里面大于8就相当于大于等于9，直接找到的就是10</p>
<p>小于x可以看做     找到大于等于x的那个数的下标之后再减1，即(&gt;&#x3D;x)-1，在数组中就是要找小于8的数，而我们找到下标为3的第一个8，再用下标3-1&#x3D;2，那就是小于8的数，也就是7，但这个是右边界</p>
<p>在本题中可以直接用(&gt;&#x3D;9)-1这样的方式直接找到8的右边界，即4</p>
<p>小于等于x可以看做     找到大于x的那个数的下标之后再-1，即(&gt;x)-1，在本题中找到的是下标为5的10，再减去1得到的是下标为4的8，即找到的是右边界，并且这个直接就找到了目标值8的右边界</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p><strong>大家记住一个写法就行，我一般常用的是左闭右开的写法，因为很多容器和算法都是左闭右开这个区间，有些习惯吧算是</strong></p>
<p>可能遇到的不清楚的我都写了注释</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)<span class="comment">//l==r时没有意义，不写等号</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;<span class="comment">//防止溢出</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)</span><br><span class="line">                r=mid;<span class="comment">//左闭右开，右边是开的 不需要写mid-1</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//找左边界</span></span><br><span class="line">        <span class="type">int</span> first=<span class="built_in">lower_bound</span>(nums,target);</span><br><span class="line">        <span class="comment">//这两种情况说明数组里面没target</span></span><br><span class="line">        <span class="keyword">if</span>(first==nums.<span class="built_in">size</span>()||nums[first]!= target)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="comment">//找右边界，刚刚说了找右边界肯定就是小于或者小于等于的情况，这两种情况可以由找左边的情况互换过来</span></span><br><span class="line">        <span class="comment">//即去找&gt;=target+1的的左边界，在第一个例子中就是大于等于9，找到后就是右边界的下一位置，那么再减去1，那就是最后的答案</span></span><br><span class="line">        <span class="type">int</span> last=<span class="built_in">lower_bound</span>(nums,target<span class="number">+1</span>)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;first,last&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="笔者自己学过的二分代码的思路"><a href="#笔者自己学过的二分代码的思路" class="headerlink" title="笔者自己学过的二分代码的思路"></a>笔者自己学过的二分代码的思路</h3><p>找左右边界，左边界找法和灵神相同，右边界找法就是我下面写的这种，也就是nums[mid]&lt;&#x3D;target时去更新l</p>
<p><strong>其实找左边界就是根据条件从右往左收缩，找右边界就是从左往右收缩</strong></p>
<p>然而不管是左边界还是右边界，终止条件都是l&#x3D;&#x3D;r，也就是最后的时候l和r是相等的，返回哪个都行</p>
<p>最后还要注意一点是我用的是左闭右开区间，最后找到的右边界取不到，所以记得看看题目要求，如果找的是target这个数字的右边界记得要-1，要是算个数啥的一般不用减</p>
<p>顺带一提这个和stl算法中的二分查找函数的结果相同，即左边界是第一个target，右边界是最后一个target+1的位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;<span class="comment">//防止溢出</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">upper_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;<span class="comment">//防止溢出</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=target)</span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> first=<span class="built_in">lower_bound</span>(nums,target);</span><br><span class="line">        <span class="keyword">if</span>(first==nums.<span class="built_in">size</span>()||nums[first]!= target)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> last=<span class="built_in">upper_bound</span>(nums,target)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;first,last&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2529-正整数和负整数的最大计数"><a href="#2529-正整数和负整数的最大计数" class="headerlink" title="2529.正整数和负整数的最大计数"></a>2529.正整数和负整数的最大计数</h2><p><a href="https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/description/">2529. 正整数和负整数的最大计数 - 力扣（LeetCode）</a></p>
<p>做一道题练练手，检验一下自己的学习成果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums,<span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//找0的左边界 这是负整数的右边界 并且取不到，给出答案 因为下标本身比第几个数字小1，所以不用做别的处理，直接就是负整数的个数</span></span><br><span class="line">        <span class="type">int</span> first=<span class="built_in">lower_bound</span>(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//找1的左边界 这是正整数的左边界</span></span><br><span class="line">        <span class="type">int</span> last=<span class="built_in">lower_bound</span>(nums,<span class="number">0</span><span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">return</span> first&gt;nums.<span class="built_in">size</span>()-last?first:nums.<span class="built_in">size</span>()-last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然，直接遍历也可以</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> neg = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                neg++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(neg, pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题记录</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Day70 | 灵神 | 二分查找：完成旅途的最少时间</title>
    <url>/2025/03/22/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day70%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E5%AE%8C%E6%88%90%E6%97%85%E9%80%94%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h1 id="Day70-灵神-二分查找：完成旅途的最少时间"><a href="#Day70-灵神-二分查找：完成旅途的最少时间" class="headerlink" title="Day70 | 灵神 | 二分查找：完成旅途的最少时间"></a>Day70 | 灵神 | 二分查找：完成旅途的最少时间</h1><h2 id="2187-完成旅途的最少时间"><a href="#2187-完成旅途的最少时间" class="headerlink" title="2187.完成旅途的最少时间"></a>2187.完成旅途的最少时间</h2><p><a href="https://leetcode.cn/problems/minimum-time-to-complete-trips/description/">2187. 完成旅途的最少时间 - 力扣（LeetCode）</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="1-单调性判断二分谁"><a href="#1-单调性判断二分谁" class="headerlink" title="1.单调性判断二分谁"></a>1.单调性判断二分谁</h4><p>本题还是和前两天的那两道题一样，我们平分的还是时间</p>
<p>从单调性来讲，如果t的时间可以正好完成旅途，那么t+1，t+2的时间一定也可以</p>
<p>但是t-1就不行了，我们就是要找这样的t</p>
<h4 id="2-求出二分区间"><a href="#2-求出二分区间" class="headerlink" title="2.求出二分区间"></a>2.求出二分区间</h4><p>现在我们首先要做的就是求出我们的二分区间，即时间t的范围</p>
<p>笔者的思路是，找到单次旅途时间最短的车，然后乘以totalTrips，那这样也不用管别的车跑了几次，因为只需要这一辆车就可以跑够totalTrips，所以这是一个最大值</p>
<p>最小值不用思考了，那当然就是1了</p>
<p><code>注：</code>这里最大值最小值灵神有个优化，感兴趣可以自行查看</p>
<p><a href="https://leetcode.cn/problems/minimum-time-to-complete-trips/solutions/1295955/er-fen-da-an-python-yi-xing-gao-ding-by-xwvs8/">2187. 完成旅途的最少时间 - 力扣（LeetCode）</a></p>
<h4 id="3-写出判断条件即check函数"><a href="#3-写出判断条件即check函数" class="headerlink" title="3.写出判断条件即check函数"></a>3.写出判断条件即check函数</h4><p>判断条件就是所有的车在t的时间内完成的所有旅程数量能否达到totalTrips</p>
<p>那么所有车在t的时间内完成的所有旅程数量怎么计算？</p>
<p>一辆车的旅程其实就是总时间t除以单次时间time[i]，而且是下取整，所以我们不需要做过多的处理</p>
<p>到这里就可以开始写代码了</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; time, <span class="type">int</span> totalTrips,<span class="type">long</span> <span class="type">long</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> c:time)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=(t/c);</span><br><span class="line">            <span class="keyword">if</span>(res&gt;=totalTrips)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minimumTime</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; time, <span class="type">int</span> totalTrips)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> min_time=ranges::<span class="built_in">min</span>(time);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> l=<span class="number">1</span>,r=min_time*totalTrips<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(time,totalTrips,mid))</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果你卡在了116&#x2F;124，即第116个例子左右，那你一定要看看该改long long的地方改没改</p>
<p>特别是传入check函数的t，那个形参的类型必须得是long long，笔者改了这个就通过了</p>
]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题记录</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++读书笔记博客汇总</title>
    <url>/2024/10/28/C++/Effective%20C++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%8D%9A%E5%AE%A2%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="Effective-C-读书笔记博客汇总"><a href="#Effective-C-读书笔记博客汇总" class="headerlink" title="Effective C++读书笔记博客汇总"></a>Effective C++读书笔记博客汇总</h1><p>这是csdn链接，大家感兴趣可以去看看</p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/143133049?spm=1001.2014.3001.5502">Effective C++ | 读书笔记 （一）-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/143239753?spm=1001.2014.3001.5502">Effective C++ | 读书笔记 （二）-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/143311610">Effective C++ | 读书笔记 （三）-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/143311636">Effective C++ | 读书笔记 （四）-CSDN博客</a></p>
<p><code>个人阅读感受：</code></p>
<p>我是第一次读到一半就没读了，觉得看不懂，读起来也比较枯燥</p>
<p>做过两个项目以后，第二次读才写的博客，有一些地方确实在项目中会运用到，但其他的还是有不少不太理解的，之后再做做别的项目进行第三次阅读之后再进行补充</p>
]]></content>
      <categories>
        <category>从零开始的C++の学习之路</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 读书笔记</title>
    <url>/2024/10/28/C++/Effective%20C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Effective-C-读书笔记"><a href="#Effective-C-读书笔记" class="headerlink" title="Effective C++ 读书笔记"></a>Effective C++ 读书笔记</h2><h3 id="1、让自己习惯C"><a href="#1、让自己习惯C" class="headerlink" title="1、让自己习惯C++"></a>1、让自己习惯C++</h3><h4 id="条款-01-：视C-为一个语言联邦"><a href="#条款-01-：视C-为一个语言联邦" class="headerlink" title="条款 01 ：视C++为一个语言联邦"></a>条款 01 ：视C++为一个语言联邦</h4><p>C++的四个层次：</p>
<ol>
<li>C：C++是在C语言的基础上发展而来的</li>
<li>Object-Oriented C++：这是C++中不同于C的部分，这里主要指面向对象。</li>
<li>Template C++：C++中的泛型编程。</li>
<li>STL：这是一个标准模板库，它用模板实现了很多容器、迭代器和算法，使用STL往往事半功倍。</li>
</ol>
<h4 id="条款-02：-尽量const、enum、inline替换-define"><a href="#条款-02：-尽量const、enum、inline替换-define" class="headerlink" title="条款 02： 尽量const、enum、inline替换#define"></a>条款 02： 尽量const、enum、inline替换#define</h4><ol>
<li><p>const好处</p>
<ol>
<li>define直接常量替换，出现编译错误不易定位(不知道常量是哪个变量)</li>
<li>define没有作用域，const有作用域提供了封装性</li>
</ol>
</li>
<li><p>enum好处：</p>
<ol>
<li>提供了封装性</li>
<li>编译器肯定不会分配额外内存空间(其实const也不会)</li>
</ol>
</li>
<li><p>inline的好处：</p>
<ol>
<li><p>define宏函数容易造成误用(下面有个例子)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//define误用举例</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) a &gt; b ? a : b</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">MAX</span>(++a, b) <span class="comment">//a++调用2次</span></span><br><span class="line"><span class="built_in">MAX</span>(++a, b<span class="number">+10</span>) <span class="comment">//a++调用一次</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>注意：</strong></p>
<ol>
<li>对于单纯的常量，最好以const对象或enums替换#define</li>
<li>对于形似函数的宏，最好改成内联函数</li>
</ol>
</li>
</ol>
<h4 id="条款-03-：尽可能使用const"><a href="#条款-03-：尽可能使用const" class="headerlink" title="条款 03 ：尽可能使用const"></a>条款 03 ：尽可能使用const</h4><ol>
<li><p>const修饰的变量不允许改变</p>
</li>
<li><p>注意指针常量与常量指针，stl中的<a href="https://so.csdn.net/so/search?q=%E8%BF%AD%E4%BB%A3%E5%99%A8&spm=1001.2101.3001.7020">迭代器</a>类似指针（T* const point,指向的元素可以修改）</p>
</li>
<li><p>const成员函数</p>
<ol>
<li><p>可以确认类中哪些成员函数可以修改数据成员</p>
</li>
<li><p>const对象只能调用const 对象成员函数，非const对象既可以调用普通成员函数也可以调用const成员函数(这是因为this指针可以转化为const this，但是const this 不能转化为非 const this)</p>
</li>
<li><p>一个函数是不是const是可以被重载的</p>
</li>
<li><p>更改了指针所指物的成员对象不算是const，但是如果只有指针属于对象，则成函数为bitwise const 不会发生编译器异议</p>
</li>
<li><p>用mutable关键字修饰的成员变量，将永远处于可变状态， 哪怕是在一个const函数中</p>
</li>
<li><p>如果const和非const成员功能类似，用非const版本调用const版本，<strong>避免代码复制</strong>；</p>
</li>
<li><p>以const修饰operator*的返回值类型可以阻止客户因“用户自定义类型而犯错”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a*b=c)</span><br><span class="line">    <span class="comment">//本意是想要做一个比较操作，结果因为返回值不是const的话就可以修改了，直接变成赋值行为，也不会报错。</span></span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTextBlock</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position)<span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">        ...</span><br><span class="line">		<span class="keyword">return</span> pText[position];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> CTextBlock&amp;&gt;(*<span class="keyword">this</span>)[position]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> * pText;</span><br><span class="line">	<span class="type">int</span> length;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="条款-04-：-确定对象使用前已被初始化"><a href="#条款-04-：-确定对象使用前已被初始化" class="headerlink" title="条款 04 ： 确定对象使用前已被初始化"></a>条款 04 ： 确定对象使用前已被初始化</h4><ol>
<li>有些情况下会初始化为0 ，有时候不会被初始化</li>
<li>内置类型，手工初始化</li>
<li>内置以外的类型，构造函数初始化<ol>
<li>构造函数体内的是赋值，初始化列表中才是初始化</li>
<li>初始化顺序要和声明顺序一致</li>
<li>初始化的效率高于赋值<ul>
<li>赋值是先定义变量，在定义的时候已经调用的变量的默认构造函数之后是用了赋值操作符；</li>
<li>初始化时直接调用了拷贝构造函数</li>
<li>const、引用、基类传参（因为基类先于派生类初始化）、对象成员必须在初始化列表中</li>
</ul>
</li>
</ol>
</li>
<li>函数体内的static对象是local static对象，其他static对象是non-local static对象<ol>
<li>定义在不同编译单元内的non-local static对象”初始化次序无明确</li>
<li>static对象只有一份拷贝，且只初始化一次（类似于单例模式）使用local static对象，首次使用时初始化，返回其引用即可（local static声明周期是整个程序），以后再使用无需再次初始化。</li>
</ol>
</li>
<li>总结：<ol>
<li>手动初始化non-member对象</li>
<li>使用初始化列表初始化member对象。</li>
<li>消除初始化次序的不确定性。</li>
</ol>
</li>
</ol>
<p>关于编译单元：</p>
<p>在C++中，非局部静态对象（即全局或文件作用域的静态对象）的初始化次序在不同的<strong>编译单元</strong>（通常是不同的源文件）之间是未定义的。这意味着，如果你在一个编译单元中依赖于另一个编译单元中的全局静态对象的初始化结果，你的程序可能会遇到未定义行为，因为那些对象的初始化次序是不确定的。</p>
<p>为了避免这个问题，可以使用局部静态对象（即在函数内部声明的静态对象）。局部静态对象在它们首次被访问时才会被初始化，并且初始化是线程安全的（在C++11及更高版本中）。由于局部静态对象的初始化是在它们被首次访问的点上明确发生的，因此不存在跨编译单元的初始化次序问题。</p>
<h3 id="2、-构造-析构-赋值运算"><a href="#2、-构造-析构-赋值运算" class="headerlink" title="2、 构造&#x2F;析构&#x2F;赋值运算"></a>2、 构造&#x2F;析构&#x2F;赋值运算</h3><h4 id="条款05-：了解C-默认编写并调用哪些函数"><a href="#条款05-：了解C-默认编写并调用哪些函数" class="headerlink" title="条款05 ：了解C++默认编写并调用哪些函数"></a>条款05 ：了解C++默认编写并调用哪些函数</h4><p> 空类经过<a href="https://so.csdn.net/so/search?q=%E7%BC%96%E8%AF%91%E5%99%A8&spm=1001.2101.3001.7020">编译器</a>处理后会有默认<a href="https://blog.csdn.net/kangroger/article/details/26977205">构造函数、复制构造函数、赋值操作符</a>和<a href="https://so.csdn.net/so/search?q=%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">析构函数</a>。这些函数都是public且inline</p>
<ol>
<li>默认构造函数，由它来调用基类和non-static成员变量的构造函数</li>
<li>析构函数是否是虚函数，继承基类，如果没基类，那么默认是non-virtual，析构函数会调用基类和non-static成员变量的析构函数。</li>
<li>复制构造函数和赋值操作符中，给成员变量初始化或赋值，会调用成员变量的赋值构造函数和赋值操作符。他们都是<a href="https://blog.csdn.net/kangroger/article/details/23820267">浅拷贝</a></li>
<li>赋值操作符，有些情况下编译器是不会合成的,例如<ol>
<li>两个成员变量，一个是引用：初始化后不能更改，一个是常量：也是初始化后不能更改，因此不可以用赋值更改变量，此时编译器不会合成</li>
<li>基类的赋值操作是private的，派生类不会生成赋值运算符</li>
</ol>
</li>
</ol>
<h4 id="条款-06-：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款-06-：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款 06 ：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款 06 ：若不想使用编译器自动生成的函数，就该明确拒绝</h4><p>房子是个类，天下没有一样的房子，所以拷贝与赋值都不能使用，将其设置为私有（只声明不定义）就可阻止使用这两个函数</p>
<p><strong>注意</strong>：普通调用会在编译阶段出错（private），友元和成员函数可以访问错误会发生在链接阶段(没有定义)，错误出现越早越好，可以用继承来实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">Uncopyable</span>()&#123;&#125;</span><br><span class="line">	~<span class="built_in">Uncopyable</span>()&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">	Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他类来继承就行了</p>
<p>这样继承的类中如果生产对应的拷贝与赋值<a href="https://so.csdn.net/so/search?q=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">构造函数</a>，就会调用基类对应的函数，会发生编译错误</p>
<h4 id="条款-07-：为多态基类声明为virtual析构函数"><a href="#条款-07-：为多态基类声明为virtual析构函数" class="headerlink" title="条款 07 ：为多态基类声明为virtual析构函数"></a>条款 07 ：为多态<a href="https://so.csdn.net/so/search?q=%E5%9F%BA%E7%B1%BB&spm=1001.2101.3001.7020">基类</a>声明为virtual析构函数</h4><ol>
<li><p>创建有层次的类时，将基类的析构函数声明为虚函数</p>
<p>原因：当基类指针（引用）指向子类对象时，如果析构对象通过delete 指针的方式，只会调用基类的析构函数，不会调用子类的析构函数。可能会造成内存泄漏</p>
</li>
<li><p>但是当一个类不做基类时，不要将析构函数弄成虚函数，因为调用过程中会多一步指针操作，同时对象也多了一个虚函数指针，</p>
</li>
<li><p>一个类不含虚函数，不适合做基类，STL中的容器没有虚析构函数，一个类中至少有个虚函数,析构函数才将弄为虚函数</p>
</li>
<li><p>一个类含有纯虚函数，抽象类不能被实例化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AWOV</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">AWOV</span>()=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">AWOV::~<span class="built_in">AWOV</span>()&#123;&#125;<span class="comment">//这一步是必要的</span></span><br></pre></td></tr></table></figure>

<p>如果把这个当做是基类，会有问题，析构函数只有声明没有定义，析构函数从派生类到基类的调用时，会发生链接错误。因此需要定义（空定义）</p>
</li>
</ol>
<h4 id="条款-08-：别让异常逃离析构函数"><a href="#条款-08-：别让异常逃离析构函数" class="headerlink" title="条款 08 ：别让异常逃离析构函数"></a>条款 08 ：别让异常逃离析构函数</h4><ol>
<li><p>析构函数可以抛出异常，但是不建议这么做；例如：</p>
<p>容器销毁会调用析构函数，如果抛出异常，剩下的元素没有被销毁，会造成内存泄漏。如果继续销毁，会存在两个异常，两个异常会导致不明确的行为</p>
</li>
<li><p>有时候又必须在析构函数中执行一些动作，这些动作可能会导致异常，如果调用这些动作不成功会抛出异常，使得异常传播。解决方法如下：</p>
<ol>
<li><p>动作函数抛出错误，就终止程序，调用abort函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">~<span class="built_in">DBConn</span>()<span class="comment">//析构函数关闭连接</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			db.<span class="built_in">close</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span>(……)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//记录下对close调用的失败</span></span><br><span class="line">			std::<span class="built_in">abort</span>();<span class="comment">//退出</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>吞下这个异常,它会压制某些失败动作的重要信息。比较好的是重新设计接口，使得客户能对可能的异常做出反应。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">~<span class="built_in">DBConn</span>()<span class="comment">//析构函数关闭连接</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			db.<span class="built_in">close</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span>(……)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//记录下对close调用的失败</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="条款-09-：-绝不再构造和析构函数中调用virtual函数"><a href="#条款-09-：-绝不再构造和析构函数中调用virtual函数" class="headerlink" title="条款 09 ： 绝不再构造和析构函数中调用virtual函数"></a>条款 09 ： 绝不再构造和析构函数中调用virtual函数</h4><p>人话版本：</p>
<ol>
<li>对象的初始化状态</li>
</ol>
<ul>
<li>在构造函数执行期间，派生类对象的成员变量尚未完全初始化。如果此时通过基类构造函数调用virtual函数，并且该调用试图访问派生类的成员变量或方法，那么可能会访问到尚未初始化的数据，导致未定义行为。</li>
<li>类似地，在析构函数执行期间，派生类对象的成员变量可能已经开始被销毁，其状态已经是未定义的。此时调用virtual函数同样可能导致问题。</li>
</ul>
<ol start="2">
<li>虚函数表的未正确设置</li>
</ol>
<ul>
<li>在C++中，虚函数通常是通过虚函数表（vtable）来实现的。在对象构造过程中，虚函数表可能还没有被正确设置以指向派生类的虚函数实现。因此，在构造函数中调用virtual函数可能会调用到错误的函数实现。</li>
<li>同理，在析构函数执行时，虚函数表可能已经开始被清理或修改，此时调用virtual函数同样可能遇到问题。</li>
</ul>
<ol start="3">
<li>C++语言的规范</li>
</ol>
<ul>
<li>从C++语言规范的角度来看，构造函数和析构函数中的virtual函数调用并不会“下降”到派生类。这意味着，即使在构造函数或析构函数中调用了virtual函数，实际上调用的也将是基类中的版本，而不是派生类中重写的版本。这通常与程序员的预期不符，可能导致难以调试的错误。</li>
</ul>
<ol start="4">
<li>潜在的运行时错误</li>
</ol>
<ul>
<li>在构造和析构期间调用virtual函数可能会增加运行时错误的风险。例如，如果派生类的虚函数实现依赖于某些在构造函数或析构函数中尚未初始化或已被销毁的成员变量，那么这些实现可能会失败或产生不可预测的结果。</li>
</ul>
<ol start="5">
<li>设计上的考虑</li>
</ol>
<ul>
<li>从设计角度来看，构造函数和析构函数的主要职责是初始化和清理对象的资源。它们不应该承担与对象业务逻辑相关的任务，这些任务应该由其他成员函数来处理。因此，将virtual函数调用放在构造函数或析构函数中可能违背了这一设计原则。</li>
</ul>
<p>书中版本：</p>
<ol>
<li><p>这类调用从不下降至子类(当前执行的构造函数与析构函数的那一层)，此时无法呈现多态的性质。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Transaction</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span><span class="type">const</span><span class="comment">//virtual function</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//log the Transaction</span></span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;This is Transaction logTransaction&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Transaction::<span class="built_in">Transaction</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">logTransaction</span>();<span class="comment">//called in Ctor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>:<span class="keyword">public</span> Transaction&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;This is BuyTransaction logTransaction&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SellTransaction</span>:<span class="keyword">public</span> Transaction&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;This is SellTransaction logTransaction&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当有个对象：BuyTransaction b 时，会输出父类的函数内容，这是因为<strong>基类先构造，在基类构造期间，不会下降到派生类去调用派生类的虚函数</strong>，所以调用的是基类的虚函数，此时不表现出多态的性质。</p>
<p>解决方法：将父类的那个函数设置成非虚函数，从derived class构造函数传递参数给base class构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="type">const</span> std::string&amp; parameter)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">logTransaction</span><span class="params">(<span class="type">const</span> std::string&amp; parameter)</span><span class="type">const</span><span class="comment">//no-virtual function</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//log the Transaction</span></span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;This is &quot;</span>&lt;&lt;parameter&lt;&lt;<span class="string">&quot; logTransaction&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Transaction::<span class="built_in">Transaction</span>(<span class="type">const</span> std::string&amp; parameter)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">logTransaction</span>(parameter);<span class="comment">//called in Ctor</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>:<span class="keyword">public</span> Transaction&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	 <span class="built_in">BuyTransaction</span>()</span><br><span class="line">	 :<span class="built_in">Transaction</span>(<span class="built_in">CreatPamameter</span>())</span><br><span class="line">	 &#123;</span><br><span class="line">	 &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	 <span class="function"><span class="type">static</span> std::string <span class="title">CreatPamameter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	 </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;BuyTransaction&quot;</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SellTransaction</span>:<span class="keyword">public</span> Transaction&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SellTransaction</span>()</span><br><span class="line">	 :<span class="built_in">Transaction</span>(<span class="built_in">CreatPamameter</span>())</span><br><span class="line">	 &#123;</span><br><span class="line">	 &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	 <span class="function"><span class="type">static</span> std::string <span class="title">CreatPamameter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	 </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;SellTransaction&quot;</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BuyTransaction b;</span><br><span class="line">	SellTransaction s;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当构造<strong>派生类对象</strong>时，先调用基类的构造函数，此时派生类还没有被构造出来，所以调用的是基类的虚函数。<br>而析构时，派生类已经析构掉了，所以基类析构时仍调用的是基类的虚函数。</p>
<h2 id="错！"><a href="#错！" class="headerlink" title="错！"></a>错！</h2><p>实际上，无论派生类有没有被构造出来，还是已经析构了。在构造、析构函数中一定只会调用本类中的虚函数。 因为在函数进入构造、析构函数时，一定会把虚指针填充为<strong>当前类</strong>虚表的首地址</p>
</li>
</ol>
<h4 id="条款10-：令operator-返回一个reference-to-this"><a href="#条款10-：令operator-返回一个reference-to-this" class="headerlink" title="条款10 ：令operator&#x3D;返回一个reference to *this"></a>条款10 ：令operator&#x3D;返回一个reference to *this</h4><ol>
<li>为了实现连锁赋值，操作符必须返回一个reference指向操作符左侧的实参。其实，如果operator&#x3D;不返回一个引用，返回一个临时对象，照样可以实现连锁赋值（但是这个临时对象会调用一个拷贝构造函数）</li>
<li>与之类似的有+&#x3D;、-&#x3D;等改变左侧操作符的运损，就当做是个协议，我们都去遵守吧</li>
</ol>
<h4 id="条款11-：在operator-中实现“自我赋值”"><a href="#条款11-：在operator-中实现“自我赋值”" class="headerlink" title="条款11 ：在operator&#x3D;中实现“自我赋值”"></a>条款11 ：在operator&#x3D;中实现“自我赋值”</h4><ol>
<li><p>如果自己管理资源，可能会“在停止使用资源之前意外释放了它”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> p;<span class="comment">//如果p之前就已经释放掉了，再次释放会被报错</span></span><br><span class="line">		p=<span class="keyword">new</span> <span class="built_in">int</span>(ths.p);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<p>防止以上的方法就是“证同测试”，判断当前判断是不是赋值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>==&amp;rhs)<span class="comment">//证同测试</span></span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">delete</span> p;</span><br><span class="line">		p=<span class="keyword">new</span> <span class="built_in">int</span>(rhs.p);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有一个方案是copy与swap技术，用来解决异常安全问题，条款29 详细说明</p>
<p>如果是引用传递</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">const</span> Widget&amp; rhs)</span></span>;<span class="comment">//交换rhs和this</span></span><br><span class="line">	Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">	&#123;</span><br><span class="line">		Widget <span class="built_in">tmp</span>(rhs);<span class="comment">//赋值一份数据</span></span><br><span class="line">		<span class="built_in">swap</span>(tmp)<span class="comment">//交换</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//临时变量会自动销毁</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果是值传递，则不需要新建临时变量，直接使用函数参数即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">const</span> Widget&amp; rhs)</span></span>;<span class="comment">//交换rhs和this</span></span><br><span class="line">	Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget rhs)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">swap</span>(rhs)</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="条款-12-复制对象时勿忘其每一个部分"><a href="#条款-12-复制对象时勿忘其每一个部分" class="headerlink" title="条款 12 : 复制对象时勿忘其每一个部分"></a>条款 12 : 复制对象时勿忘其每一个部分</h4><ol>
<li>一旦给类添加变量，自己写的copying函数（拷贝与赋值构造函数）也要修改，因为编译器不会提醒你；</li>
<li><strong>在派生类层次中，派生类中的构造函数没有初始化的基类部分是通过默认构造函数初始化的（没有就会报错）但是在赋值操作符中，不会调用基类的默认构造函数。因为赋值操作只是给对象赋值，不是初始化，因此不会调用基类的构造函数（重要）</strong></li>
<li>赋值操作符与拷贝构造函数不能相互调用，因为拷贝构造函数是构造一个不存在的对象，而操作符是给一个存在的对象重新赋值。如果你发现拷贝构造和拷贝赋值的重复代码很多，应该去建立一个新的成员函数给两者使用，并且一般命名为init().</li>
</ol>
<h3 id="3、-资源管理"><a href="#3、-资源管理" class="headerlink" title="3、 资源管理"></a>3、 资源管理</h3><h4 id="条款-13：以对象管理资源"><a href="#条款-13：以对象管理资源" class="headerlink" title="条款 13：以对象管理资源"></a>条款 13：以对象管理资源</h4><ol>
<li><p>在一个作用域内，在delete 之前就return了，会造成内存泄漏，所以delete管理内存远远不够</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Investment* pInv=<span class="built_in">CreateInvestment</span>();</span><br><span class="line">	……<span class="comment">//这里提前 return</span></span><br><span class="line">	<span class="keyword">delete</span> pInv;<span class="comment">//释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用对象控制对象，离开了作用域自然会调用析构函数析构，比如使用智能指针auto_ptr(唯一资源使用权，对它的拷贝动作为让旧指针变为nullptr)</p>
<ol>
<li>RAII：资源获取时机即是初始化时机(resource acquisition is initialization)。获取资源后立即放进对象内进行管理。</li>
<li>管理对象运用析构函数确保资源释放。管理对象是开辟在栈上面的，离开作用域系统会自动释放管理对象，自然会调用管理对象的析构函数。</li>
<li>还有一种指针是引用计数器型指针，会记录多少个对象在使用资源，计数器为0，就释放，如share_ptr</li>
<li>auto_ptr和shared_ptr释放资源用的都是delete，而不是delete[],对于数组指针，shared_array来对应。类似的还有scope_array</li>
</ol>
</li>
</ol>
<p>请记住：</p>
<p>为防止资源泄漏,请使用RAII对象,它们在构造函数中获得资源并在析构函数中释放资源。</p>
<p>两个常被使用的RAII classes 分别是tr1 :: shared_ptr和auto_ptr。前者通常是较佳选择,因为其copy行为比较直观。若选择auto_ptr,复制动作会使它(被复制物)指向null。</p>
<h4 id="条款-14：-在资源管理类中小心coping行为"><a href="#条款-14：-在资源管理类中小心coping行为" class="headerlink" title="条款 14： 在资源管理类中小心coping行为"></a>条款 14： 在资源管理类中小心coping行为</h4><ol>
<li><p>但是并不是所有资源都是开辟在堆上，有时候我们需要自己建立资源管理类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* mu)</span>:mutexPtr(mu)</span></span><br><span class="line"><span class="function">	&#123;</span></span><br><span class="line">		<span class="built_in">lock</span>(mutexPtr);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Lock</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">unlock</span>(mutexPtr);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Mutex* mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样客户对Lock的使用方法符合RAII方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mutex m;<span class="comment">//定义互斥器</span></span><br><span class="line">……</span><br><span class="line">&#123;<span class="comment">//建立区块来定义critical section</span></span><br><span class="line">	<span class="built_in">Lock</span>(&amp;m);</span><br><span class="line">	……<span class="comment">//执行critical section 内的操作</span></span><br><span class="line">&#125;<span class="comment">//在区块末尾，自动解除互斥器的锁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当一个RAII对象被复制，会发生什么？有以下做法</p>
<ol>
<li><p>禁止复制，将coping函数设置为私有，条款6</p>
</li>
<li><p>对管理资源使用引用计数法，复制的时候就加1 。mutexPrt变为类型从Mutex*变为shared即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span>：<span class="keyword">private</span> Uncopyable&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* mu)</span>:mutexPtr(mu,unlock)//以某个Mutex初始化，unlock作为删除其</span></span><br><span class="line"><span class="function">	&#123;</span></span><br><span class="line">		<span class="built_in">lock</span>(mutexPtr);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	shared_prt&lt;Mutex&gt; mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意的是在这个类中并没有自己编写析构函数。因为mutexPtr是类中的普通成员变量，编译器会自动生成析构函数类析构这样的变量。这个在条款5中有说明。</p>
</li>
<li><p>拷贝底部资源（深浅拷贝）</p>
<p>使用资源管理类的目的是保证不需要这个资源时能正确释放。如果这种资源可以任意复制，我们只需编写好适当的copying函数即可。确保拷贝时是深拷贝。<br>比如：C++中的string类，内部是指向heap的指针。当string复制时，底层的指针指向的内容都会多出一份拷贝。</p>
</li>
<li><p>转移底层资源的拥有权。</p>
<p>有时候资源的拥有权只能给一个对象，这时候当资源复制时，就需要剥夺原RAII类对该资源的拥有权。像auto_ptr。在C++11新标准中的std::move便是这个功能。可以把一个左值转换为一个右值。</p>
</li>
</ol>
<p>copying函数如果你不编写，编译器会帮你合成，其合成版本行为可参考条款5。要记住的是不论是自己编写还是编译器合成，都要符合自己资源管理类的需要。</p>
</li>
</ol>
<p>请记住：</p>
<p>复制RALL对象必须一并复制它所管理的资源，所以资源的copying行为决定RALL对象的copying行为</p>
<p>普通而常见的RALL class copying行为是：抑制copying、实行引用计数等。</p>
<h4 id="条款-15-在资源管理类中提供对原始资源的访问"><a href="#条款-15-在资源管理类中提供对原始资源的访问" class="headerlink" title="条款 15 :在资源管理类中提供对原始资源的访问"></a>条款 15 :在资源管理类中提供对原始资源的访问</h4><ol>
<li><p>原始资源，没有经过封装的指针（可以这样理解）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用智能指针来保存返回值</span></span><br><span class="line">shared_prt&lt;Investment&gt; pInv=(<span class="built_in">createInvestment</span>());</span><br><span class="line"><span class="comment">//有这样一个函数,显然是无法将只能指针对象的，这时就需要一个函数将管理的原始资源暴露出来</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dayHeld</span><span class="params">(<span class="type">const</span> Investment* pi)</span></span>;</span><br><span class="line"><span class="comment">//shared_ptr和auto_ptr都提供一个get函数，用于执行这样的显示转换</span></span><br><span class="line"><span class="built_in">dayHeld</span>(pInv.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了使智能指针使用起来像普通指针一样，它们要重载指针取值（pointerdereferencing）操作符（operator-&gt;和operator*)，它们允许转换至底部<strong>原始指针</strong>。</p>
</li>
<li><p>RAII class内的返回资源的函数和封装资源之间有矛盾。的确是这样，但这样不是什么灾难。<strong>RAII class不是为了封装资源，而是为确保资源释放。</strong></p>
</li>
</ol>
<p>请记住：</p>
<p>APIs往往要求访问原始资源(raw resources),所以每一个RAII class应该提供一个“取得其所管理之资源”的办法。</p>
<p>对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全,但隐式转换对客户比较方便。</p>
<h4 id="条款-16-：-成对使用new和delete时要采取相同形式"><a href="#条款-16-：-成对使用new和delete时要采取相同形式" class="headerlink" title="条款 16 ： 成对使用new和delete时要采取相同形式"></a>条款 16 ： 成对使用new和delete时要采取相同形式</h4><ol>
<li>如果使用new开辟内存，就使用delete释放。如果使用new[]开辟内存，就使用delete[]释放。</li>
<li><strong>尽量不使用对数组做typedef动作</strong>。在C++的STL中有string、vector等templates（条款54），可以将数组需求降至几乎为零</li>
</ol>
<h4 id="条款-17-：以独立语句将newed对象置入智能指针"><a href="#条款-17-：以独立语句将newed对象置入智能指针" class="headerlink" title="条款 17 ：以独立语句将newed对象置入智能指针"></a>条款 17 ：以独立语句将newed对象置入智能指针</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这样写是不行的，因为shared_ptr用普通指针构造的构造函数是explict的，不允许隐式转换</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processWidget</span><span class="params">(shared_ptr&lt;Widget&gt; pw, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(<span class="keyword">new</span> Widget,<span class="built_in">priority</span>());</span><br><span class="line"><span class="comment">//这样写可以过编译但是会有资源泄露的问题</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processWidget</span><span class="params">(shared_ptr&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="type">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>在使用智能指针时，应该用独立的语句把新创建的对象指针放入智能指针，否则可能会造成内存泄露</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于这个的传参</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processWidget</span><span class="params">(shared_ptr&lt;Widget&gt; pw, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"></span><br><span class="line">在调用processWidget之前有三件事：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、执行<span class="built_in">priority</span>()函数</span><br><span class="line"><span class="number">2</span>、执行<span class="keyword">new</span> Widget</span><br><span class="line"><span class="number">3</span>、执行shared_ptr构造函数</span><br></pre></td></tr></table></figure>

<p>C++编译器会以什么样的次序来完成这些事情呢？弹性很大。在Java和C#中，总是以特定的次序来完成这样函数参数的计算，但在C++中却不一定。唯一可以确定的是new Widget在shared_ptr之前调用。但是函数priority排在第几却不一定。假设排在第二，那么顺序就是1、执行new Widget。2、执行函数priority()。3执行shared_ptr构造函数。</p>
<p>如果对函数priority()调用出现异常，那么new Widget返回的指针还没来得及放入shared_ptr中。这样会造成内存泄露。</p>
<p>因此可以分开写，先创建，然后在传参</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_prt&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(pw,<span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure></li>
</ol>
<p>请记住：</p>
<p>以独立语句将 newed 对象存储于(置入)智能指针内。如果不这样做,一旦异常被抛出,有可能导致难以察觉的资源泄漏。</p>
<h3 id="4、设计与声明"><a href="#4、设计与声明" class="headerlink" title="4、设计与声明"></a>4、设计与声明</h3><h4 id="条款18：让接口容易被正确使用，不容易被误用"><a href="#条款18：让接口容易被正确使用，不容易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不容易被误用"></a>条款18：让接口容易被正确使用，不容易被误用</h4><p><strong>1、保证参数一致性：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void print_date(int year, int month, int day)</span><br><span class="line">&#123;......&#125;</span><br><span class="line">print_date(2022, 28, 9);//1</span><br><span class="line">print_date(2022, 9, 28);//2</span><br></pre></td></tr></table></figure>

<p>在这样一个打印时间的函数接口中，我们按照年月日的顺序输出，但是1式却输出年日月。错误的参数传递顺序造成了接口的误用。</p>
<p>解决办法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">day</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">month</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">year</span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pd</span><span class="params">(<span class="type">const</span> year&amp; y, <span class="type">const</span> month&amp; m, <span class="type">const</span> day&amp; d)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>当然，传递某个有返回值的函数也是可以解决的，但这种方法看起来很奇怪。</p>
<p><strong>2、保证接口行为一致性：</strong></p>
<p>内置数据类型（ints， double…）可以进行加减乘除的操作，STL中不同容器也有相同函数（比如size，都是返回其有多少对象），所以，尽量保证用户自定义接口的行为一致性。</p>
<p><strong>3、如果一个接口必须有什么操作，那么在它外面套一个新类型：</strong></p>
<p><strong>比如：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">employee* <span class="title">createmp</span><span class="params">()</span></span>;<span class="comment">//其创建的堆对象要求用户必须删除</span></span><br></pre></td></tr></table></figure>

<p>如果用户忘记使用资源管理类，就有错误使用这个接口的可能，所以必须先下手为强，直接将 createmp() 返回一个资源管理对象，比如智能指针share_ptr 等等：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">tr1::share_ptr&lt;employee&gt; <span class="title">createmp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>如此就避免了误用的可能性。</p>
<p><strong>4、有些接口可以定制删除器，就像 STL 容器可以自定义排序，比较函数一样</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">tr1::share_ptr&lt;employee&gt; <span class="title">p</span><span class="params">(<span class="number">0</span>, my_delete())</span></span>;<span class="comment">//error! 0 不是指针</span></span><br><span class="line"><span class="function">tr1::share_ptr&lt;employee&gt; <span class="title">p</span><span class="params">(<span class="keyword">static_cast</span>&lt;employee*&gt;(<span class="number">0</span>), my_delete())</span></span>;<span class="comment">//定义一个 null 指针</span></span><br></pre></td></tr></table></figure>

<p>第一个参数是被管理的指针，第二个是自定义删除器。</p>
<ol>
<li>好的接口容易被正确使用，不容易被误用。</li>
<li>促进正确使用“的办法包括接口一致性，以及于内置类型兼容。</li>
<li>阻止误用“方法包括建立新类型、限制类型上的操作、束缚对象值，以及消除客户的资源管理责任。</li>
<li>shared_ptr支持特定的删除器。可以防范cross-DLL problem，可以被用来自动解除互斥锁（就是在释放资源的时候解锁）。<ul>
<li>shared_ptr一个特别好的性质是：它会自动使用它的“每个指针专属的删除器”，因而消除另一个潜在客户的错误：Corss-DLL Problem。这个问题发生于：对象在一个动态链接库DLL中被new创建，却在另一个DLL内被delete销毁。在许多平台上，这一类跨DLL之new&#x2F;delete成对使用会导致运行期错误。shared_ptr没有这个问题，因为它的删除器来自其所诞生的那个DLL的delete。</li>
</ul>
</li>
</ol>
<h4 id="条款19-：设计class犹如设计type"><a href="#条款19-：设计class犹如设计type" class="headerlink" title="条款19 ：设计class犹如设计type"></a>条款19 ：设计class犹如设计type</h4><p> 要注意解决以下问题：</p>
<ol>
<li><strong>新type的对象应该如何被创建和销毁？</strong></li>
<li><strong>对象初始化和对象赋值该有什么样的区别？</strong> 条款4</li>
<li><strong>新type的对象如果被pass by value，意味着什么</strong></li>
<li><strong>什么是新type的合法值？</strong></li>
<li><strong>新type需要配合某个继承图系（inheritance graph）吗？</strong> （条款34和条款36）</li>
<li><strong>新type需要什么样的转换？</strong></li>
<li><strong>什么样的操作符和函数对此新type而言是合理的？</strong></li>
<li><strong>什么样的函数应该被驳回？</strong></li>
<li><strong>谁该取用新type的成员？</strong></li>
<li><strong>什么是新type的“未声明接口”（undeclared interface）？</strong></li>
<li><strong>你的新type有多么一般化？</strong></li>
<li><strong>你真的需要一个新type吗？</strong></li>
</ol>
<h4 id="条款20：-宁以pass-by-reference-to-const替换pass-by-value（本条第六点要常看）"><a href="#条款20：-宁以pass-by-reference-to-const替换pass-by-value（本条第六点要常看）" class="headerlink" title="条款20： 宁以pass-by-reference-to-const替换pass-by-value（本条第六点要常看）"></a>条款20： 宁以pass-by-reference-to-const替换pass-by-value（本条第六点要常看）</h4><ol>
<li>在默认情况下，C++函数传递参数是继承C的方式，是值传递（pass by value)。这样传递的都是实际实参的副本，这个副本是通过调用复制构造函数来创建的。有时候创建副本代价非常昂贵</li>
<li>以pass by reference-to-const方式传递，可以回避所有构造函数和析构函数。这种方式传递，没有新对象创建，所以自然没有构造和析构函数的调用参数中，以const修饰是比较重要的，原先的pass by value，原先的值自然不会被修改。现在以pass by reference方式传递，函数validateStudent内使用的对象和传进来的同同一个对象，为了防止在函数内修改，加上const限制。</li>
<li>以pass by reference方式传递，还可以避免对象切割（slicing）问题。一个派生类（derived class）对象以pass by value方式传递，当被视为一个基类对象（base class）时，基类对象的copy构造函数会被调用，此时派生类部分全部被切割掉了，仅仅留下一个base class部分（因为传参的时候是base类创建的副本对象）。</li>
<li>对于内置类型，pass by value往往比pass by reference更高效（（引用本质是指针）。所以在使用STL函数和迭代器时，习惯上都被设计出pass by value</li>
<li>对象小并不意味着copy构造函数代价小，许多对象（包括STL容器），内涵的成员只不过是一两个指针，但是复制这种对象时，要复制指针指向的每一样东西，这个代价很可能十分昂贵。</li>
<li>一般情况下，可以假设内置类型和STL迭代器和函数对象以pass by value是代价不昂贵。其他时候最好以pass by reference to const替换掉pass by value。</li>
</ol>
<h4 id="条款21：-必须返回对象时，别妄想返回其reference"><a href="#条款21：-必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21： 必须返回对象时，别妄想返回其reference"></a>条款21： 必须返回对象时，别妄想返回其reference</h4><p>如下这种会出现错误，因为引用只是对象的别名，返回的是局部Rational对象的别名，但是离开函数后该对象就被析构了，返回的是一个无用值，所以要返回一个值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.n* rhs.n, lhs.d* rhs.d);<span class="comment">//对象析构了，引用别名也是空对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.n* rhs.n, lhs.d* rhs.d);<span class="comment">//返回一个rational对象的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在返回一个reference和返回一个object之间抉择时，挑出行为正确的那个。让编译器厂商为你尽可能降低成本吧！</p>
<h4 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款22：将成员变量声明为private</h4><ol>
<li>封装。如果通过函数访问成员变量，日后可以用某个计算替换这个变量，这时class的客户却不知道内部实现已经变化。</li>
<li>将成员变量声明为private。这可以赋予客户访问数据的一致性、可细微划分访问控制、允许约束条件获得保证，并提供class作者以充分弹性实现。</li>
<li>protected并不比public更具有封装性。</li>
</ol>
<h4 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款23：宁以non-member、non-friend替换member函数</h4><p>非成员函数，非友元函数，成员函数</p>
<p>释义：如果一个成员函数调用了其他的成员函数，那么就要用一个非成员函数替换这个成员函数。</p>
<p>根据条款22，对类变量的操作只能通过类成员函数实现（因为它是私有变量），那么如果一个成员函数内部实现是调用其他的成员函数，则一个非成员函数也可以做到这样的效果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">preson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">func1</span>();</span><br><span class="line">        <span class="built_in">func2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_all</span><span class="params">(<span class="type">const</span> person&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p.<span class="built_in">func1</span>();</span><br><span class="line">    p.<span class="built_in">func2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> func3() 和 use_all() 的效果是一样的，但这时候我们倾向于选择 use_all 函数，因为func3()作为一个成员函数，其本身也是个可以访问私有变量的函数。use_all() 函数其本身不可以访问私有变量。所以 use_all() 比 func3() 更有封装性。（能够访问私有变量的函数越少越好）</p>
<p>在了解这点之后，我们做一些更深层次的探讨：</p>
<p>我们称 use_func()（func3()的非成员函数版本）为便利函数。假设一个类有多个诸如 func1() 的函数，根据排列组合，也就有很多便利函数。为了让这些便利函数和它的类看上去更像一个整体，我们把便利函数和类放在一个 namespace 中。于是，我们可以更为轻松地拓展这些便利函数——多做一些排列组合。</p>
<p><strong>若一个成员函数调用其他成员函数，那么这个成员函数的非成员函数版本比之拥有更多的封装性，和机能扩充性。</strong></p>
<p>总结：</p>
<ol>
<li>用non-member、non-friend函数替换member函数，这样可以增加封装性、包裹弹性和机能扩充性，因为不能访问私有变量。</li>
<li>namespace可以跨越多个源码文件，class不能，将所有的便利函数放在多个头文件但隶属于同一个命名空间，意味着客户可以轻松扩展这一组遍历函数。他们需要做的是添加更多的非成员函数和非友元函数到这个命名空间内</li>
</ol>
<h4 id="条款24：若所有参数皆需要类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数皆需要类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数皆需要类型转换，请为此采用non-member函数"></a>条款24：若所有参数皆需要类型转换，请为此采用non-member函数</h4><ol>
<li><p>通常情况下，class不应该支持隐式类型转换</p>
</li>
<li><p>也有例外，比如建立一个分数管理器，允许隐式类型转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Rational</span>(<span class="type">int</span> numerator=<span class="number">0</span>, <span class="type">int</span> denominator=<span class="number">1</span>);<span class="comment">//非explicit，允许隐式转换</span></span><br><span class="line">	……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然，若作为成员函数，this指针为隐形的参数，只需要一个变量参数传进去</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	……</span><br><span class="line">	<span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs);</span><br><span class="line">	……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>进行混合运算时</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">result=oneHalf*<span class="number">2</span>;<span class="comment">//正确，相当于oneHalf.operator*(2);</span></span><br><span class="line">result=<span class="number">2</span>*oneHalf;<span class="comment">//错误，相当于2.operator*(oneHalf);</span></span><br></pre></td></tr></table></figure>

<p>这是错误的，2是this指向的对象，必须是该类本身的类型。这是因为</p>
<ol>
<li>只有参数列于参数表，才是隐式类型的参与者</li>
<li>2不是该类型，不能调用成员函数operator *;</li>
</ol>
<p>因此可以定义为一个非成员函数，可以进行隐式转换的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>总结：如果需要为某个函数的所有参数（包括this指针所指向的隐喻参数）进行类型转换，这个函数必须是个non-member函数</strong></p>
<p><strong>另一说法：如果所有参数（运算符左边或者右边的参数）都需要类型转换，用 non-member 函数。</strong></p>
</li>
</ol>
<h4 id="条款25：考虑写出一个不抛出异常的swap函数"><a href="#条款25：考虑写出一个不抛出异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛出异常的swap函数"></a>条款25：考虑写出一个不抛出异常的swap函数</h4><p>周所周知，swap 可以交换两个数的值，标准库的 swap 函数是通过拷贝完成这种运算的。想想，如果是交换两个类对象的值，如果类中变量的个数很少，那么 swap 是有一定效率的，但如果变量个数很多呢？</p>
<p>你一定联想到了之前提过的，引用传递替换值传递。没错，交换两个类对象的地址就可以很有效率地完成大量变量的 swap 操作。不幸的是，标准库的 swap 并无交换对象地址的行为，所以我们需要自己写 swap 函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_swap</span><span class="params">(person&amp; p1, person&amp; p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(p<span class="number">1.</span>ptr, p<span class="number">2.</span>ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数无法通过编译，因为类变量是 private，无法通过对象访问。所以要把它变成成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">my_swap</span><span class="params">(person&amp; p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;ptr, p.ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果你觉得 p1.my_swap(p2) 的调用形式太low了，你可以设计一个non-member 函数（如果是在同一个命名空间那就再好不过了），实现swap(p1, p2)，这里不做演示。你还可以特化 std 里的 swap 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;person&gt; (person&amp; p1, person&amp; p2)</span><br><span class="line">    &#123;</span><br><span class="line">        p<span class="number">1.</span><span class="built_in">my_swap</span>(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，如果你设计的是类模板，而尝试对swap特化，那么会在 std 里发生重载，这是不允许的，因为用户可以特化 std 的模板，但不可以添加新的东西到 std 里。</p>
<p>还有一点：在上面工作全部完成后，如果想使用 swap ，请确定包含一个 using 声明式，一边让 std::swap 可见，然后直接使用 swap。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 其中过程：</p>
<p>如果T在其命名空间有专属的 swap，则调用，否则调用 std 的swap。</p>
<p>如果在 std 有特化的 swap，则调用，否则调用一般的 swap。（也即是拷贝）</p>
<p>这一点虽然看着很奇怪……</p>
<p>总结</p>
<ol>
<li>如果std::swap不高效时，提供一个swap成员函数，并且确定这个函数不抛出异常。</li>
<li>如果提供一个member-swap,也应该提供一个non-member swap来调用前者。对于class（非class template），要特化std::swap。</li>
<li>调用swap时，针对std::swap使用using形式，然后调用swap并且不带任何命名空间资格修饰。</li>
<li>为“用户定义类型”进行std template全特化时，不要试图在std内加入某些对std而言是全新的东西。</li>
</ol>
<h3 id="5、实现"><a href="#5、实现" class="headerlink" title="5、实现"></a>5、实现</h3><h4 id="条款26：变量尽可能在使用时定义"><a href="#条款26：变量尽可能在使用时定义" class="headerlink" title="条款26：变量尽可能在使用时定义"></a>条款26：变量尽可能在使用时定义</h4><p>提前定义变量，有可能导致变量并没有使用(如中间抛异常了)，而平白多了一个构造和析构成本。</p>
<p>但是循环怎么办？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式A</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    w = xxx;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式B</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    Widget w = xxx;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做法A：1个构造 + 1个析构 + n个赋值操作</p>
<p>做法B：n个构造函数 + n个析构函数</p>
<p>打破本条款选择A的依据：</p>
<p>（1）你知道赋值成本比“构造+析构”成本低。</p>
<p>（2）你正在处理代码中效率高度敏感的部分。</p>
<p>否则你应该使用做法B，维持变量尽可能在使用时定义的原则。</p>
<p><strong>请记住</strong></p>
<blockquote>
<p>尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。</p>
</blockquote>
<h4 id="条款27：尽量少做转型动作"><a href="#条款27：尽量少做转型动作" class="headerlink" title="条款27：尽量少做转型动作"></a>条款27：尽量少做转型动作</h4><p>C语言风格类型转换(老式)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(T)expression   <span class="comment">// 显示强转</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">T</span>(expression)   <span class="comment">// 构造隐式转换</span></span><br></pre></td></tr></table></figure>

<p>C++新式转换，提倡统一都用新式风格，职能分类，更安全，更清晰。</p>
<ul>
<li>const_cast(expression) 用于将对象的常量性移除。也是唯一有此能力的C+±style转型操作符。</li>
<li>dynamic_cast(expression) 一般用于安全向下转型，如基类到派生类。要谨慎，可能效率低下。</li>
<li>static_cast(expression) 用来强制隐式转换，一般用于相关联类型转换，没有类型检测。如将int转double，派生类转基类(安全)，基类转派生类(不安全)等。</li>
<li>reinterpret_cast(expression) 一般用于不相干类型转换，没有限制。如int* 转int，int转函数指针等。常用于转换函数指针，即可以将一种类型的函数指针转换为另一种类型的函数指针。</li>
</ul>
<p>转型破环了类型系统。那可能导致任何种类的麻烦，有些容易识别，有些非常隐晦。所以尽量少做转型操作。</p>
<h5 id="关于传递给const引用临时对象的问题"><a href="#关于传递给const引用临时对象的问题" class="headerlink" title="关于传递给const引用临时对象的问题"></a>关于传递给<code>const</code>引用临时对象的问题</h5><p>我们可以安全地将一个临时对象传递给一个接受<code>const</code>引用的函数。在C++中，临时对象在函数调用的整个持续时间内都是有效的，因此可以安全地传递给<code>const</code>引用参数。这样做的好处包括：</p>
<ul>
<li><strong>避免不必要的拷贝</strong>：通过传递引用而不是值，可以避免对临时对象的拷贝，从而提高效率。</li>
<li><strong>保持类型安全</strong>：使用<code>const</code>引用可以确保在函数内部不会修改传递的对象。</li>
</ul>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。如果有个设计需要转型动作，试着发展无需转型的替代设计。</li>
<li>如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要将转型操作放进客户代码中。</li>
<li>宁可使用C+±style转型，不要使用旧式转型。前者很容易识别出来，而且也比较有着分门别类的职掌。</li>
</ul>
</blockquote>
<h4 id="条款28：-尽量避免返回handles指向对象内部成分"><a href="#条款28：-尽量避免返回handles指向对象内部成分" class="headerlink" title="条款28： 尽量避免返回handles指向对象内部成分"></a>条款28： 尽量避免返回handles指向对象内部成分</h4><p>handers是指：对象内的子对象的引用、指针或迭代器。返回子对象的引用、指针、迭代器会降低封装性，外部能越级访问深层级的对象并修改属性。</p>
<p>这并不意味着你绝对不可以让成员函数返回handle。有时候你必须那么做。例如operator[]就允许你获取strings和vectors的元素。尽管如此，这样的函数毕竟是例外，不是常态。</p>
<p><strong>请记住</strong></p>
<blockquote>
<p>避免返回handles(包括引用、指针、迭代器)指向对象内部。遵守这条条款可增加封装性，帮助const成员函数的行为像个const，并将发生”虚吊号码牌“的可能性降至最低。</p>
</blockquote>
<h4 id="条款29-为”异常安全”而努力是值得的"><a href="#条款29-为”异常安全”而努力是值得的" class="headerlink" title="条款29. 为”异常安全”而努力是值得的"></a>条款29. 为”异常安全”而努力是值得的</h4><p>我们要时刻要求自己写的函数都是异常安全函数。</p>
<p>异常安全函数有两个条件：</p>
<ol>
<li>不泄漏任何资源。</li>
<li>不允许数据败坏。</li>
</ol>
<p>同时，异常安全函数内分了3个级别保证，你至少满足其中之一。</p>
<ol>
<li>基本承诺：如果抛出异常，程序内的任何事物仍然保持在有效状态下。</li>
<li>强烈保证：如果抛出异常，程序状态不改变。如果函数成功，就是完全成功，如果函数失败，程序会回到调用函数之前的状态。</li>
<li>不抛异常保证：承诺绝不抛出异常，所有操作都是作用于内置类型身上。</li>
</ol>
<p>一般而言，我们都应该尽量做到强烈保证这个级别。而最高级别很多时候很难做到，任何使用动态内存的东西如果内存不足都有可能抛出异常。</p>
<p>下面是为编写异常安全函数而努力的示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span>;  <span class="comment">// 改变背景图片</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;    <span class="comment">// 多线程环境，互斥锁</span></span><br><span class="line">    Image* bgImage;  <span class="comment">// 当前背景图片</span></span><br><span class="line">    <span class="type">int</span> imageChanges; <span class="comment">// 背景图片改变次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是我们最常规思路的实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">delete</span> bgImage;</span><br><span class="line">    ++imageChanges;</span><br><span class="line">    bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个常规思路的实现，如果new Image抛异常，lock资源泄漏，bgImage，imageChanges数据也招到破坏。不满足异常安全函数条件任何一个。下面我们来看怎么解决这两个问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    std::tr1::shared_ptr&lt;Image&gt; bgImage;  <span class="comment">// 智能指针</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;   <span class="comment">// 封装锁，见条款14</span></span><br><span class="line">    bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc));</span><br><span class="line">    ++imageChanges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做到这里还只能说满足基本承诺，如果Image构造函数抛异常(这里抛异常由编译器内部实现)，有可能破环外部引用的imgSrc数据源(todo:这里有点牵强~感觉做到这一步已经是强烈保证了！)。</p>
<p>还记得我们前面写过一个不抛异常的swap么？就可以用在这里，我们让改变背景图片的操作先在副本对象中操作，都正确操作完后，在用swap交换数据，这样就保证了即使失败了也不会影响原有数据状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PMImpl</span> &#123;</span><br><span class="line">    std::tr1::shared_ptr&lt;Image&gt; bgImage;</span><br><span class="line">    <span class="type">int</span> imageChanges;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    std::tr1::shared_ptr&lt;PMImpl&gt; pImpl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    std::<span class="function">tr1::shared_ptr&lt;PMImpl&gt; <span class="title">pNew</span><span class="params">(<span class="keyword">new</span> PMImpl(*pImpl))</span></span>; <span class="comment">// 副本对象</span></span><br><span class="line">    pNew-&gt;bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc));</span><br><span class="line">    ++pNew-&gt;imageChanges;</span><br><span class="line">    <span class="built_in">swap</span>(pImpl, pNew);  <span class="comment">// 交互数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>强烈保证并非时刻都显得实际，也要衡量空间、效率成本。当强烈保证不切实际时，你就必须保证提供基本保证。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>异常安全函数即使发生异常也不会泄漏资源或允许任何数据结构破坏。这样的函数有3中可能的保证：基本型、强烈型、不抛异常型。</li>
<li>强烈保证往往能够以swap来实现出来，但强烈保证并非对所有函数都可实现或具备现实意义。</li>
<li>函数提供的“异常安全保证”通常最高只等于其所调用的各个函数的异常安全保证中的最低者。</li>
</ul>
</blockquote>
<h4 id="条款30：透彻了解inline的里里外外"><a href="#条款30：透彻了解inline的里里外外" class="headerlink" title="条款30：透彻了解inline的里里外外"></a>条款30：透彻了解inline的里里外外</h4><p>inline行为发生在编译期间，编译器是否要进行inline，不是取决于函数带不带inline，有时带了inline也不一定会inline(virtual函数，运行时才知道调用哪个)，没带也可能inline(实现在头文件中)。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>将大多数inline限制在<strong>小型</strong>、<strong>被频繁调用</strong>的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</li>
<li>不要只因为函数模板出现在头文件中定义，就将它们声明为inline。</li>
</ul>
</blockquote>
<h4 id="条款31：-将文件间的编译依赖关系降至最低"><a href="#条款31：-将文件间的编译依赖关系降至最低" class="headerlink" title="条款31： 将文件间的编译依赖关系降至最低"></a>条款31： 将文件间的编译依赖关系降至最低</h4><h5 id="一、定义与目的"><a href="#一、定义与目的" class="headerlink" title="一、定义与目的"></a>一、定义与目的</h5><ol>
<li><strong>Handle class（句柄类）</strong>：<ul>
<li>句柄类是一种设计模式，用于将类的接口和实现分离。</li>
<li>它通常包含一个指向实现类的指针或引用，客户通过句柄类调用接口，而不需要直接知道实现类的细节。</li>
<li>目的是减少文件间的编译依存关系，当实现类发生变化时，客户代码不需要重新编译。</li>
</ul>
</li>
<li><strong>Interface class（接口类）</strong>：<ul>
<li>接口类是一种抽象类，通常包含纯虚函数（在Java等语言中称为接口）。</li>
<li>它定义了类必须实现的接口，而不包含具体的实现。</li>
<li>目的是提供一种规范或契约，确保不同的类能够以一致的方式被使用。</li>
</ul>
</li>
</ol>
<h5 id="二、实现方式"><a href="#二、实现方式" class="headerlink" title="二、实现方式"></a>二、实现方式</h5><ol>
<li><strong>Handle class</strong>：<ul>
<li>句柄类通常包含一个指向实现类的智能指针（如C++中的<code>std::shared_ptr</code>或<code>std::unique_ptr</code>）。</li>
<li>句柄类的方法通过调用实现类的方法来实现功能。</li>
<li>实现类可以单独编译和链接，减少了客户代码对实现类细节的依赖。</li>
</ul>
</li>
<li><strong>Interface class</strong>：<ul>
<li>接口类通常包含纯虚函数，这些函数在接口类中声明但没有实现。</li>
<li>具体类通过继承接口类并实现其纯虚函数来提供具体的功能。</li>
<li>客户代码通常通过接口类的指针或引用来操作具体类的对象，从而实现多态性。</li>
</ul>
</li>
</ol>
<h5 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h5><ol>
<li><strong>Handle class</strong>：<ul>
<li>适用于需要将接口和实现分离的场景，以减少编译依赖和提高代码的可维护性。</li>
<li>例如，在大型项目中，将类的接口和实现分离可以减少编译时间和避免不必要的重新编译。</li>
</ul>
</li>
<li><strong>Interface class</strong>：<ul>
<li>适用于需要定义一组相关操作的规范或契约的场景。</li>
<li>例如，在面向对象的框架中，接口类用于定义组件之间的交互规范。</li>
</ul>
</li>
</ol>
<p>直接看示例代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相关头文件引入</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;date.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;address.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;</span><br><span class="line">    Date theBirthDate;</span><br><span class="line">    Address theAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面Person定义文件和其包含的文件之间形成了一种编译依赖关系。如果这些头文件中任何一个被改变，或这些头文件所依赖的其他头文件有任何改变，那么每一个包含Person class的文件就得重新编译。这样的连串编译依赖关系会对许多项目造成难以形容的灾难。</p>
<p>解决这个问题的<strong>本质是让类的接口与实现分离</strong>(加快编译速度)。通常有两种做法：</p>
<p>第一种拆分两个类，一个用于声明，一个用于实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class 只是声明这个类，没有定义信息，可以使用类的引用和指针(大小固定)，不能有定义。减少编译依赖手段。</span></span><br><span class="line"><span class="comment">// include 则是把整个类导入，包含了定义信息，也注入了依赖相关，增加了编译时间。 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl;  <span class="comment">// 指向实现类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PersonImpl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">    : <span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">PersonImpl</span>(name, birthday, addr))</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Person::name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;<span class="built_in">name</span>();  <span class="comment">// simunps的fileManger封装就是类似这种做法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将实现分开后，即使修改了实现部分逻辑，对包含了Person接口类的其它类也没有影响，不需要重新编译。</p>
<p>第二种是用接口类。</p>
<p>这种类的目的是详细一一描述派生类的接口，因此它通常没有成员变量，也没有构造函数，只有一个virtual析构函数以及一组纯虚函数声明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口定义，外部使用通过基类的create接口即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line">    <span class="type">static</span> std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> Address&amp; addr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">Person::create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Address&amp; addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> <span class="built_in">RealPerson</span>(name, birthday, addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span> : Person &#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">     : <span class="built_in">theName</span>(name), <span class="built_in">theBirthDate</span>(birthday), <span class="built_in">theAddress</span>(addr)</span><br><span class="line">     &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>() &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;</span><br><span class="line">    Date theBirthDate;</span><br><span class="line">    Address theAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>支持编译依赖最小化的一般构想是：依赖声明式的头文件，不要依赖定义式的头文件。(声明与定义拆两个类，外部只include声明的类头文件) 基于此构想有两种手段：接口与实现拆分两个类和接口类。</li>
<li>程序库头文件应该以“完全且仅有声明式的形式存在。就是include的类都是声明式的类，其真实实现在另一个类中。</li>
</ul>
</blockquote>
<h3 id="6-继承与面向对象设计"><a href="#6-继承与面向对象设计" class="headerlink" title="6.继承与面向对象设计"></a>6.继承与面向对象设计</h3><h4 id="条款32-确定你的public继承塑模出is-a关系"><a href="#条款32-确定你的public继承塑模出is-a关系" class="headerlink" title="条款32. 确定你的public继承塑模出is-a关系"></a>条款32. 确定你的public继承塑模出is-a关系</h4><p>公有继承：继承过来的基类成员访问属性不变。</p>
<p>保护继承：继承过来的基类中的私有成员访问属性不变，公有成员和保护成员变为保护成员。</p>
<p>私有继承：继承过来的基类中的私有成员属性不变，公有成员和保护成员变为私有成员。</p>
<p>不管是哪种继承方式，派生类中成员可以访问基类的公有成员和保护成员，无法访问私有成员。而继承方式影响的是派生类继承成员的<strong>访问属性</strong>。</p>
<p><strong>请记住</strong></p>
<blockquote>
<p>public继承：适用于base classes身上的每一件事情一定也适用与derived classes身上，因为每一个derived class对象也都是一个base class对象。</p>
</blockquote>
<h4 id="条款33-避免遮掩继承而来的名称"><a href="#条款33-避免遮掩继承而来的名称" class="headerlink" title="条款33. 避免遮掩继承而来的名称"></a>条款33. 避免遮掩继承而来的名称</h4><p>派生类中函数会遮掩基类中的同名函数。从名称查找来看，像是基类中对应的同名函数没被继承过来一样。简单来说就是作用域问题，派生类覆盖基类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>();      <span class="comment">// 没问题，调用Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);     <span class="comment">// 报错！Derived::mf1遮掩了同名的Base::mf1</span></span><br><span class="line">d.<span class="built_in">mf2</span>();      <span class="comment">// 没问题，调用Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>();      <span class="comment">// 没问题，调用Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);     <span class="comment">// 报错，Derived::mf3遮掩了Base::mf3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果不想被派生类同名函数把基类中所有其它重载函数都遮掩了，可以使用using声明，也可以使用作用域说明符。（如在函数前加上Base::       就知道调用的是基类的）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用using后，上面两处报错的都可以找到Base::mf1/Base::mf3了。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::mf1;     <span class="comment">//Base class中名为mf1和mf3的所有东西，</span></span><br><span class="line">    <span class="keyword">using</span> Base::mf3;     <span class="comment">//在Derived中都可见</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转交函数，一般用于私有继承中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span>  <span class="comment">// 转交函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	Base::<span class="built_in">mf1</span>();    <span class="comment">// 派生类函数调用基类对应函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果不想要外边访问基类中任何成员，可以用私有继承实现(private)。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>derived class 内的名称会遮掩base class 内的名称。在public继承下从来没有人希望如此。所以这点要特别注意(使用using)。</li>
<li>为了让被遮掩的名称再见天日，可使用using声明式或转交函数。</li>
</ul>
</blockquote>
<h4 id="条款34-区分接口继承和实现继承"><a href="#条款34-区分接口继承和实现继承" class="headerlink" title="条款34. 区分接口继承和实现继承"></a>条款34. 区分接口继承和实现继承</h4><p>业内默认约定基类中的成员函数用途：</p>
<ul>
<li>纯虚函数：derived class只想继承其声明，实现由derived class自己实现。</li>
<li>虚函数：derived class希望同时继承函数的接口和实现，但又希望能够覆写它们所继承的实现。</li>
<li>普通函数：derived class只想继承函数的接口和实现，并且不允许我自己再覆写。</li>
</ul>
<p><strong>普通成员函数：子类只能用父类的接口和实现</strong></p>
<p><strong>虚函数：子类可以用父类的接口和实现，如果自己有实现，那就用自己的</strong></p>
<p><strong>纯虚函数：父类只提供接口，子类只继承接口，并且必须提供实现（否则自己也是抽象类）。</strong></p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>接口继承和实现继承不同。在public继承之下，derived class总是继承base class的接口。</li>
<li>纯虚函数只具体指定接口继承。</li>
<li>虚函数具体指定接口继承及默认的实现继承。</li>
<li>普通函数具体指定接口继承以及强制性实现继承。</li>
</ul>
</blockquote>
<h4 id="条款35-考虑virtual函数以外的其他选择"><a href="#条款35-考虑virtual函数以外的其他选择" class="headerlink" title="条款35. 考虑virtual函数以外的其他选择"></a>条款35. 考虑virtual函数以外的其他选择</h4><p>条款34刚说了，在我们希望同时继承函数的接口和实现，但又希望能够覆写它们所继承的实现时用virtual函数。</p>
<p>而这里是这种场景的一些其它流派主张思想。</p>
<p>第一种，Non-Virtual Interface(NVI)，主张virtual函数应该几乎总是private。这个较好的设计是用一个non-vitual函数去调用一个private virtual函数。这样我们就提供了在调用private virtual函数前后做一些额外操作空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这里inline只是为了演示示例</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span>    <span class="comment">// 普通成员函数派生类不要重新定义它，见条款36</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...                    <span class="comment">// 做一些事前工作</span></span><br><span class="line">        <span class="type">int</span> retVal = <span class="built_in">doHealthValue</span>();</span><br><span class="line">        ...                    <span class="comment">// 做一些事后工作</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">doHealthValue</span><span class="params">()</span> <span class="type">const</span>   <span class="comment">// 虚函数，派生类可重写</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种，把这个虚函数提到类外边以一个普通函数存在，然后类的构造函数接收一个函数指针指向这个函数。把实现从类成员中剥离出去。— Strategy设计模式</p>
<p>为了更清晰地解释这段话，我们可以将其拆分为以下几个要点：</p>
<ol>
<li><strong>虚函数提到类外边</strong>：<br>在经典的面向对象编程中，虚函数是定义在类内部的，用于实现多态性。但在这里，提到的是将这些虚函数（或更准确地说是它们的功能）实现为类外部的普通函数。</li>
<li><strong>函数指针</strong>：<br>函数指针是指向函数的指针，它允许你将函数作为参数传递给其他函数，或者将函数作为对象成员（尽管这里说的是构造函数接收，但实际上是类内部可能持有这个指针以调用函数）。</li>
<li><strong>类的构造函数接收函数指针</strong>：<br>类的构造函数被设计为接收一个函数指针作为参数。这意味着在创建类的对象时，你可以指定一个具体的函数来实现某个特定的行为。</li>
<li><strong>实现从类成员中剥离出去</strong>：<br>通过将行为（原本可能是类的虚函数）实现为外部函数，并通过函数指针与类关联，这些行为就不再是类不可分割的一部分。这样做的好处是增加了代码的灵活性和可重用性。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>; <span class="comment">// 函数指针形式</span></span><br><span class="line">    <span class="comment">// 另一种使用tr1::function更灵活，它是一个类模板，其成员变量是一个函数指针。</span></span><br><span class="line">    <span class="comment">// 函数指针只支持指向外部普通函数，而function对象还支持类成员函数可以(结合bind，绑定this)。</span></span><br><span class="line">    <span class="comment">// typedef std::tr1::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span> : healthFunc(hcf)</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的好处是：</p>
<ul>
<li>同一个类之下不同的对象可以有不同的defaultHealthCalc实现。</li>
<li>某个类对象的defaultHealthCalc可在运行期变更。</li>
</ul>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>virtual 函数的替代方案包括NVI手法和Strategy设计模式的多种形式。NVI手法自身是一个特殊形式的Template Method设计模式。</li>
<li>将机能从成员函数移到class外部函数，带来的一个缺点是，这个非成员函数无法访问class的非公有成员。</li>
<li>tr1::function对象的行为就像一般函数指针。比函数指针能多接纳一些特别的函数。</li>
</ul>
</blockquote>
<h4 id="条款36-绝不重新定义继承而来的非虚函数"><a href="#条款36-绝不重新定义继承而来的非虚函数" class="headerlink" title="条款36. 绝不重新定义继承而来的非虚函数"></a>条款36. 绝不重新定义继承而来的非虚函数</h4><p>当做一个约定就行</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>绝对不要重新定义继承而来的non-virtual函数。</li>
</ul>
</blockquote>
<h4 id="条款37-绝不重新定义继承而来的缺省参数值"><a href="#条款37-绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37. 绝不重新定义继承而来的缺省参数值"></a>条款37. 绝不重新定义继承而来的缺省参数值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ShapeColor</span> &#123;Red, Green, Blue&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>:<span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape* pr = <span class="keyword">new</span> Rectangle;</span><br><span class="line">pr-&gt;<span class="built_in">draw</span>(); </span><br></pre></td></tr></table></figure>

<p>上面代码我们都知道最后的pr-&gt;draw调用的是Rectangle里覆写后的draw，这很正常没什么问题。</p>
<p>诡异的是缺省的参数却是用的Red，而不是自己的Green。</p>
<p>导致这个结果的原因是编译器优化的手段，缺省参数是静态绑定的(运行之前确定)，而virtual函数是动态绑定的(运行时确定)。所有上面pr-&gt;draw的调用就出现接口是用的派生类的，而缺省参数用的基类的。</p>
<p>这种表现会给阅读代码的人带来歧义，所以：</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定的，而virtual函数是你唯一应该覆写的东西，却是动态绑定。</li>
</ul>
</blockquote>
<h4 id="条款38-类的子对象"><a href="#条款38-类的子对象" class="headerlink" title="条款38. 类的子对象"></a>条款38. 类的子对象</h4><p>区分类的继承和复合，B继承A，我们可以说<strong>B是A</strong>，而B中包含A子对象（复合），我们一般说<strong>B中有A</strong>，而不能说B是A了。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>子对象的意义和public继承完全不同。</li>
</ul>
</blockquote>
<h4 id="条款39-明智而审慎地使用private继承"><a href="#条款39-明智而审慎地使用private继承" class="headerlink" title="条款39. 明智而审慎地使用private继承"></a>条款39. 明智而审慎地使用private继承</h4><p>私有继承：继承过来的基类中的所有成员在子类中都是私有成员。</p>
<ul>
<li><p>Private继承意味 is-implemented-in-terms of(根据某物实现出)。它通常比复合<br>(composition)的级别低。但是当derived class需要访问protected base class 的</p>
</li>
<li><p>成员,或需要重新定义继承而来的virtual函数时,这么设计是合理的。<br>和复合(composition)不同,private继承可以造成empty base最优化。这对致<br>力于“对象尺寸最小化”的程序库开发者而言,可能很重要。</p>
</li>
</ul>
<h4 id="条款40-明智而审慎地使用多重继承"><a href="#条款40-明智而审慎地使用多重继承" class="headerlink" title="条款40. 明智而审慎地使用多重继承"></a>条款40. 明智而审慎地使用多重继承</h4><p>多重继承，两个常见问题：</p>
<ol>
<li>C继承A和B，如果A、B里有相同的成员，那么C直接调用这些成员就会有歧义，不知道调用A的还是B的。所以正确调用要明确指明，C.A::xxxFunc();</li>
<li>多层继承中，B、C继承A，D继承B和C，那么常规D中有两份A，如果不想要两份就得用virtual(虚基类里会增加一个指针大小)，虚继承。</li>
</ol>
<p>多重继承最好能避免就尽量避免。不能避免，要清楚它带来的问题和内部实现成本消耗细节。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要。</li>
<li>virtual继承会增加大小、速度、初始化及赋值复杂度等成本。如果virtual base classe不带任何数据，将是最具实用价值的情况。</li>
<li>多重继承的确有正当用途。其中一个场景涉及public继承某个Interface class和private继承某个协助实现的class的两相组合。</li>
</ul>
</blockquote>
<h3 id="7-模板与泛型编程"><a href="#7-模板与泛型编程" class="headerlink" title="7.模板与泛型编程"></a>7.模板与泛型编程</h3><h4 id="条款41-了解隐式接口和编译期多态"><a href="#条款41-了解隐式接口和编译期多态" class="headerlink" title="条款41. 了解隐式接口和编译期多态"></a>条款41. 了解隐式接口和编译期多态</h4><p>隐式接口：函数模板，类型不清楚，对我们来说接口是隐藏的。</p>
<p>显示接口：我们常规的头文件接口声明就是显示接口，明确了返回值，参数。</p>
<hr>
<p>编译期多态：编译时实例化模板确定哪个重载函数被调用。</p>
<p>运行期多态：运行时哪一个virtual函数该被绑定。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>class和template都支持接口和多态。</li>
<li>对class而言接口是显示的。多态则是通过virtual函数发生于运行期。</li>
<li>对template而言，接口是隐式的。多态则通过template实例化和函数重载解析，发生于编译器。</li>
</ul>
</blockquote>
<h4 id="条款42-了解typename的双重意义"><a href="#条款42-了解typename的双重意义" class="headerlink" title="条款42. 了解typename的双重意义"></a>条款42. 了解typename的双重意义</h4><p>模版声明有两种形式：</p>
<ol>
<li>typename</li>
<li>class</li>
</ol>
<p>这里声明模版参数时，它们的意义完全相同。</p>
<p>不过对于typename在模版中除了声明模版参数外还有几处特别的用处要注意！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2nd</span><span class="params">(<span class="type">const</span> C&amp; container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  C::const_iterator* x;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个新名词要了解，嵌套从属类型：即属于模版类型C下的类型，形式：<code>C::xxx</code>。</p>
<p>**上面对应的就是C::const_iterator，这里是有歧义的，**C::const_iterator是一个类型了还是一个变量了，如果作为类型上面就是定义一个指针x，如果作为变量就是乘x。对于这种嵌套从属类型，编译器一般默认当变量处理。<strong>如果要当类型处理就必须在其前面加关键字</strong><code>typename</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> C::const_iterator* x;  <span class="comment">// 这样就显示告诉编译器，C::const_iterator是一个自定义类型</span></span><br></pre></td></tr></table></figure>

<p>另外对于嵌套从属类型前面加typename，有两处特例不能加。即不能出现在基类和成员初始化列表的嵌套从属类型里(除此之外都要加)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;T&gt;::Nested  <span class="comment">// 不能加typename</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  	<span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span><span class="params">(<span class="type">int</span> x)</span> : Base&lt;T&gt;::Nested(x)  // 不能加typename</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">       <span class="keyword">typename</span> Base&lt;T&gt;::Nested temp;   <span class="comment">// 这里要加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>声明template参数时，前缀关键字class和typename可互换，意义一样。</li>
<li>请使用关键字typename标识嵌套从属类型，但不得在基类或成员初始化列表内使用。</li>
</ul>
</blockquote>
<h4 id="条款43-注意处理模版化基类内的名称"><a href="#条款43-注意处理模版化基类内的名称" class="headerlink" title="条款43. 注意处理模版化基类内的名称"></a>条款43. 注意处理模版化基类内的名称</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span> : <span class="keyword">public</span> MsgSender&lt;T&gt;  <span class="comment">// 模版化基类</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  	...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      	...</span><br><span class="line">      	<span class="built_in">sendClear</span>(info);  <span class="comment">// 如果这个接口属于基类的，这里也不认识，因为基类是什么这时编译器不知道</span></span><br><span class="line">       	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像上面的sendClear接口模版化基类里是否存在，编译器是不确定的，所以这种编译会报错。有下面3种方式解决这种问题，就是明确告诉编译器假设它存在。</p>
<ol>
<li>通过<code>this-&gt;sendClear(info);</code>调用，假设sendClear在this中。</li>
<li>调用前加using声明<code>using MsgSender&lt;T&gt;::sendClear;</code>，明确告诉编译器sendClear在模版基类中。</li>
<li>调用时明白指明，<code>MsgSender&lt;T&gt;::sendClear(info);</code></li>
</ol>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>可在派生类模版内通过<code>this-&gt;</code>指明基类模版的成员名称(1)，或者由一个明白写出的属于基类的修饰符完成(2, 3)</li>
</ul>
</blockquote>
<h4 id="条款44-将与参数无关的代码抽离template（尚且不理解，完了需要在复习）"><a href="#条款44-将与参数无关的代码抽离template（尚且不理解，完了需要在复习）" class="headerlink" title="条款44. 将与参数无关的代码抽离template（尚且不理解，完了需要在复习）"></a>条款44. 将与参数无关的代码抽离template（尚且不理解，完了需要在复习）</h4><p>**template是一个节省时间和避免代码重复的一个奇方妙法。**不再需要键入20个类似的class而每一个带有15个成员函数，你只需键入一个class template，留给编译器去实例化那20个你需要的相关class和300个函数。(它们只有在被使用时才会实例化)</p>
<p>template虽然给我们提供了方便，但是注意如果使用不当，很容易导致代码膨胀(执行文件变大)。其结果有可能源码看起来合身而整齐，但目标码却不是那么回事。在template代码中，重复是隐藏的，所以你必须训练自己去感受当template被实例化多次时可能发生的重复。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;  <span class="comment">// 这里T称为模版的类型参数，n是非类型参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  	...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">5</span>&gt; sm1;</span><br><span class="line">sml.<span class="built_in">invert</span>();</span><br><span class="line"></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">10</span>&gt; sm2;</span><br><span class="line">sm<span class="number">2.</span><span class="built_in">invert</span>();</span><br></pre></td></tr></table></figure>

<p>上面这段模版封装，多次实例化，其中invert也会实例多份，虽然它们二进制实现一样。这就是隐晦的重复代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixbase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  	...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">(std::<span class="type">size_t</span> matrixSize)</span></span>;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqureMatrix</span> : <span class="keyword">public</span> SquareMatrixbase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;</span><br><span class="line">  	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  	...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">this</span>-&gt;<span class="built_in">invert</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把重复逻辑移到基类中，所有模版类共有，这样就减少了代码膨胀了。</p>
<p>本条款想表达的是使用template时要注意多次实例化后可能带来的代码重复，要尽量避免这种重复代码。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>template生成多个class和多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生相依关系。</li>
<li>因非类型模版参数而造成的代码膨胀，往往可消除，做法是以函数参数或class成员变量替换template参数。</li>
<li>因类型参数而造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制实现的代码共享，如放基类中。</li>
</ul>
</blockquote>
<h4 id="条款45-运用成员函数模版接受所有兼容类型"><a href="#条款45-运用成员函数模版接受所有兼容类型" class="headerlink" title="条款45. 运用成员函数模版接受所有兼容类型"></a>条款45. 运用成员函数模版接受所有兼容类型</h4><p><strong>在C++中，成员函数模板允许我们编写可以接受多种类型参数的成员函数，而不需要为每种类型都显式地重载函数。这就是“运用成员函数模板接受所有兼容类型”这句话的含义。</strong></p>
<p><strong>简单来说，当你有一个类或结构体，并且你希望它的某个成员函数能够接受不同类型的参数（只要这些类型是兼容的，即可以进行相应的操作），你就可以使用成员函数模板来实现这一点。这样做的好处是代码更加简洁、易于维护，并且提高了代码的复用性。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Print</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Print p;  </span><br><span class="line">    p.<span class="built_in">print</span>(<span class="number">42</span>);              <span class="comment">// 打印整数  </span></span><br><span class="line">    p.<span class="built_in">print</span>(<span class="number">3.14</span>);            <span class="comment">// 打印双精度浮点数  </span></span><br><span class="line">    p.<span class="built_in">print</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>)); <span class="comment">// 打印字符串  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还想要表达的是我们封装的模版所有操作行为要和普通类保持一致。即隐式行为要一致。如不同类型可隐式相互转换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPrt</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">SmartPrt</span>(<span class="type">const</span> SmartPrt&amp; other);  <span class="comment">//正常的copy构造函数，取消编译器自动生成</span></span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;   <span class="comment">// 泛化的copy构造函数(成员函数模版)，接受不同类型对象转换</span></span><br><span class="line">  	<span class="built_in">SmartPrt</span>(<span class="type">const</span> SmartPrt&lt;U&gt;&amp; other) : <span class="built_in">heldPtr</span>(other.<span class="built_in">get</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      	...</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> heldPtr;&#125;;</span><br><span class="line">  	...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  	T* heldPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过注意泛化的成员函数(即成员函数模版)并不会影响编译器自动生成类默认函数规则。所以如果你要完全自定义类行为，默认产生的函数除了泛化版本，对应的正常化版本也要声明。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>请使用成员函数模版生成可接受所有兼容类型的函数。</li>
<li>如果你声明成员函数模版用于泛化copy构造函数或赋值操作符，你还是需要声明对应正常的copy构造函数和赋值操作符函数。</li>
</ul>
</blockquote>
<h4 id="条款46-需要类型转换时请为模版定义非成员函数"><a href="#条款46-需要类型转换时请为模版定义非成员函数" class="headerlink" title="条款46. 需要类型转换时请为模版定义非成员函数"></a>条款46. 需要类型转换时请为模版定义非成员函数</h4><p>对应条款24，这里只是模版实现。规则一致，但它们写法上有所区别了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">Rational</span>(<span class="type">const</span> T&amp; numerator = <span class="number">0</span>,</span><br><span class="line">    				 <span class="type">const</span> T&amp; denominator = <span class="number">1</span>);</span><br><span class="line">  	<span class="function"><span class="type">const</span> T <span class="title">numerator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  	<span class="function"><span class="type">const</span> T <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要隐式转换的接口定义为非成员函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>* (<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                             <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational&lt;<span class="type">int</span>&gt; result = oneHalf * <span class="number">2</span>;  <span class="comment">// 这里会编译错误，2不能隐式转换</span></span><br></pre></td></tr></table></figure>

<p>上面只是把24条款示例改为模版实现，然而模版版本是编译不过的，因为编译器并不知道2要转换为什么。编译器推断不了模版的隐式转换。</p>
<p>对于模版我们只能通过friend和inline特性来实现非成员函数的定义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  	...</span><br><span class="line">    <span class="comment">// 这里Rational是Rational&lt;T&gt;的简写形式，在类模版内部可以简写。</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs,</span><br><span class="line">                                   	<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">      	<span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                       	lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以编译，连接通过了。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>当我们编写一个class template，而它所提供的函数要支持隐式转换时，请将这些函数定义为class template内部的friend函数。</li>
</ul>
</blockquote>
<h4 id="条款47-请使用traits-class表现类型信息"><a href="#条款47-请使用traits-class表现类型信息" class="headerlink" title="条款47. 请使用traits class表现类型信息"></a>条款47. 请使用traits class表现类型信息</h4><p>想要了解STL容器可以转到<a href="https://blog.csdn.net/m0_74795952/article/details/143096462?spm=1001.2014.3001.5502">C++ | STL | 侯捷 | 学习笔记_c++ stl-CSDN博客</a></p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>Traits class 使得类型相关信息在编译器可用。它们以template和template特化完成实现。</li>
<li>整合重载技术后，traits class有可能在编译期对类型执行if…else测试。(重载是编译期确定，if是运行期确定)</li>
</ul>
</blockquote>
<p><strong>例子：</strong><br>以 iterator_traits 为例介绍如何实现和使用 traits classes。STL 提供了很多的容器、迭代器和算法，其中的 advance 便是一个通用的算法，可以让一个迭代器移动给定距离：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span></span>; <span class="comment">// d &lt; 0 就向后移动</span></span><br><span class="line">STL 迭代器回顾：</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123;&#125;; <span class="comment">// 输入迭代器，只能向前移动</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123;&#125;; <span class="comment">// 输出迭代器，只能向前移动</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span>: <span class="keyword">public</span> input_iterator_tag &#123;&#125;; <span class="comment">// 稍强的是前向迭代器，可以多次读写它的当前位置</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span>: <span class="keyword">public</span> forward_iterator_tag &#123;&#125;; <span class="comment">// 双向迭代器，支持前后移动</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span>: <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;; <span class="comment">// 随机访问迭代器，可以支持 +=, -= 等移动操作</span></span><br></pre></td></tr></table></figure>

<p>回到 advance 上，它的实现取决于 Iter 类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 针对 random access 迭代器使用这种方式实现</span></span><br><span class="line">    <span class="keyword">if</span> (iter is a random access iterator) &#123;</span><br><span class="line">        iter += d;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其它迭代器使用 ++ 或 -- 实现</span></span><br><span class="line">        <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) &#123; <span class="keyword">while</span> (d--) ++iter; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">while</span> (d++) --iter; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是怎么判断 Iter 的类型是否是 random access 迭代器了，也就是需要知道它的类型。这真是需要使用到 Traits classes 的地方。</p>
<p><strong>实现 Traits classes：</strong><br>用户自定义类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123;</span><br><span class="line">    <span class="comment">// 类型 IterT 的 iterator_category 就是用来标识迭代器的类别</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> IterT::iterator_category iterator_category;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>指针类型：<br>指针本身就是可以支持随机访问（random access）的，所以我们对指针类型提供一个偏特化版本即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt; <span class="comment">// template偏特化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;IterT*&gt; &#123; <span class="comment">// 针对内置指针</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>advance 实现：</strong></p>
<p>不好的实现方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">typeid</span>(<span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::iterator_category) ==</span><br><span class="line">        <span class="built_in">typeid</span>(std::random_access_iterator_tag))</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>IterT</code> 和 <code>iterator_traits&lt;IterT &gt;::iterator_category</code> 都是可以在编译期间确定的，而 if 判断却要在运行期间核定，这样不仅浪费时间，也会导致代码膨胀。<br>建议做法是建立一组重载函数（doAdvance），接受不同的类型，原函数（advance）调用这些重载函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用不同版本的重载函数</span></span><br><span class="line">    <span class="built_in">doAdvance</span>(iter, d, <span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::<span class="built_in">iterator_category</span>());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 下面是一系列重载函数</span></span><br><span class="line"><span class="comment">// 随机访问迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DistT d, std::random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">    iter += d;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 双向迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DistT d, std::bidirectional_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) &#123; <span class="keyword">while</span> (d--) ++iter; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">while</span> (d++) --iter; &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 输入迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DistT d, std::input_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">       <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Negative distance&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (d--) ++iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="条款48-认识template元编程"><a href="#条款48-认识template元编程" class="headerlink" title="条款48. 认识template元编程"></a>条款48. 认识template元编程</h4><p>47条款的示例就是使用的模版元编程技术，<strong>它是一种把运行期的代码转移到编译期完成的技术</strong>。这种技术可能永远不会成为主流，但是如果你是一个程序库开发员，那这种技术就是家常便饭了。</p>
<p>通过模版或重载技术，把如if这种运行期的判断转换为编译期重载函数自动匹配。</p>
<p>它有两个特点：</p>
<ol>
<li>它让某些事情更容易。如果没有它，那些事情将是困难的，甚至不可能的。</li>
<li>由于它将工作从运行期转移到编译期。这可更早发现错误，而且更高效、较小的可执行文件、较短的运行期、较少的内存需求。不过它会使编译时间变长。</li>
</ol>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>模版元编程可将工作由运行期转移到编译期，因而得以实现早期错误发现和更高的执行效率。</li>
<li>模版元编程可被用来生成客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。</li>
</ul>
</blockquote>
<h3 id="8-定制-new-和-delete"><a href="#8-定制-new-和-delete" class="headerlink" title="8.定制 new 和 delete"></a>8.定制 new 和 delete</h3><p>了解new和delete相关知识可转入<a href="https://blog.csdn.net/m0_74795952/article/details/143168526?spm=1001.2014.3001.5502">侯捷 | C++ | 内存管理 | 学习笔记（一）: 第一章节 primitives-CSDN博客</a>，想要了解内存池相关内容可转入侯捷内存管理第二章节或手写SGI STL，nginx内存池项目博客。</p>
<h4 id="条款49-了解new-handler的行为"><a href="#条款49-了解new-handler的行为" class="headerlink" title="条款49. 了解new-handler的行为"></a>条款49. 了解new-handler的行为</h4><p>new-handler就是当new抛异常之前，它会先调用一个客户指定的错误处理函数。通过<code>set_new_handler</code>标准库函数指定。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当new无法分配足够内存时，被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outOfMem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	std::cerr &lt;&lt; <span class="string">&quot;Unable to satisfy request for memory\n&quot;</span>;</span><br><span class="line">  	std::<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	std::<span class="built_in">set_new_handler</span>(outOfMem);</span><br><span class="line">  	<span class="type">int</span>* pBigDataArray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100000000L</span>];</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面异常处理是全局的，但有时候你可能需要为不同类处理不同异常。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">outOfMem</span><span class="params">()</span></span>;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">outOfMem</span><span class="params">()</span></span>;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X* p1 = <span class="keyword">new</span> X;  <span class="comment">// 如果X错误，你希望调用X的错误函数</span></span><br><span class="line">Y* p2 = <span class="keyword">new</span> Y;	<span class="comment">// 如果Y错误，你希望调用Y的错误函数</span></span><br></pre></td></tr></table></figure>

<p>C++并不支持class的专属new-hander，但也可以通过其它形式自己实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RAII对象，保证new_handler还原</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerHolder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NewHandlerHolder</span><span class="params">(std::new_handler nh)</span> : handler(nh) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">NewHnadlerHolder</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">set_new_handler</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::new_handler handler;</span><br><span class="line">    <span class="comment">// 阻止copiying</span></span><br><span class="line">    <span class="built_in">NewHandlerHolder</span>(<span class="type">const</span> NewHandlerHolder&amp;);</span><br><span class="line">    NewHandlerHolder&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NewHandlerHolder&amp;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerSupport</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler</span><br><span class="line">NewHandlerSupport&lt;T&gt;::<span class="built_in">set_new_hnadler</span>(std::new_handler p) <span class="keyword">throw</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>* NewHandlerSupport&lt;T&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"><span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// new如果失败，则先会调用currentHandler，然后set_new_handler会返回上一次的handler。</span></span><br><span class="line">    <span class="comment">// NewHandlerHolder这个RAII对象则在析构时会把上面返回的上一次new_handler设置回去。</span></span><br><span class="line">    <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(std::set_new_handler(currentHandler))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用，只要继承封装的NewHandlerSupport&lt;T&gt;，就能够实现针对类自己的new_handler了。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> NewHandlerSupport&lt;Widget&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Widget::<span class="built_in">set_new_handler</span>(xxxx); <span class="comment">// xxxx是new失败执行的回调函数</span></span><br><span class="line">Widget* w = <span class="keyword">new</span> Widget; <span class="comment">// 如果失败，先会调用xxxx，然后会还原new_handler回调函数。</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用。</li>
<li>让new不抛异常是一个颇为局限的工具，因为它只是保证了内存分配时不抛异常，后续调用构造函数还是可能抛出异常。&#x3D;&gt; new做了两件事：1. 分配内存 2. 调用类的构造函数。</li>
</ul>
</blockquote>
<h4 id="条款50-了解new和delete的合理替换时机"><a href="#条款50-了解new和delete的合理替换时机" class="headerlink" title="条款50. 了解new和delete的合理替换时机"></a>条款50. 了解new和delete的合理替换时机</h4><p>什么时候我们需要替换编译器提供的new或delete呢？下面是三个最常见的理由：</p>
<ol>
<li>**用来检测运用上的错误。**如new的一段内存，delete时失败了导致内存泄漏。又或多次delete导致不确定行为。</li>
<li>**为了提升性能。**编译器默认提供的new&#x2F;delete是大众的，均衡的，不针对特定场景特定优化。如需要大量申请&#x2F;释放内存场景(碎片)，我们习知的有内存池技术。</li>
<li>**为了收集使用上的统计数据。**统计任何时刻内存分配情况等。</li>
</ol>
<p>但是要自定义一个合适的new&#x2F;delete并非易事，如<strong>内存对齐(对齐指令执行效率最高)，可移植性、线程安全</strong>…等等细节。所以我的建议是在你确定要自定义new&#x2F;delete之前，请先确定你程序瓶颈是否真的由默认new&#x2F;delete引起，而且现在也有商业产品可以替代编译器自带的内存管理器。或者也有一些开源的产品可以使用，如Boost的Pool就是对于常见的分配大量小型对象很有帮助。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>有许多理由需要写个自定义的new和delete，包括改善性能、对堆区运用错误进行调试、收集堆区使用信息。</li>
</ul>
</blockquote>
<h4 id="条款51-编写new和delete时需固守常规"><a href="#条款51-编写new和delete时需固守常规" class="headerlink" title="条款51. 编写new和delete时需固守常规"></a>条款51. 编写new和delete时需固守常规</h4><p>上面条款说了什么时候需要自定义new&#x2F;delete，本节则告诉你写自定义new&#x2F;delete需要遵守的一般规范。</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>operator new 1. 应该内含一个无限循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用new-handler。2. 它也应该有能力处理0字节申请。3. Class的专属版本则还应该处理“比正确大小更大的申请”(被继承后, new 派生对象，这时可以走编译器默认new操作)。</li>
<li>operator delete应该在收到null指针时不做任何事情。Class专属版本还应该处理“比正确大小更大的申请”(同上)。</li>
</ul>
</blockquote>
<h4 id="条款52-new与delete成对出现"><a href="#条款52-new与delete成对出现" class="headerlink" title="条款52. new与delete成对出现"></a>条款52. new与delete成对出现</h4><p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>当你写一个operator new, 请确定也写出了对应的operator delete。如果没有这样做，你的程序可能会发生隐晦而时断时续的内存泄漏。</li>
<li>当你声明new和delete，请确定不要无意识地(非故意)遮掩了它们的正常版本。</li>
</ul>
</blockquote>
<h3 id="9-杂项讨论"><a href="#9-杂项讨论" class="headerlink" title="9.杂项讨论"></a>9.杂项讨论</h3><h4 id="条款53-不要忽略编译器的警告"><a href="#条款53-不要忽略编译器的警告" class="headerlink" title="条款53. 不要忽略编译器的警告"></a>条款53. 不要忽略编译器的警告</h4><p>记住后期很多无休止调试就是由于你前期没有重视编译警告引起的。尽管一般认为，写出一个在最高警告级别下也无任何警告信息的程序是理想的，然而如果你对某些警告信息有深刻理解，你倒是可以选择忽略它。不管怎样说，在你打发某个警告信息之前，请确定你了解它意图说出的精确意义。这很重要！</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>严肃对待编译器发出的警告信息。努力在你的编译器的最高警告级别下争取无任何警告的荣誉。</li>
<li>不要过度依赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原本依赖的警告信息有可能消失。</li>
</ul>
</blockquote>
<h4 id="条款54-让自己熟悉包括-TR1-在内的标准程序库"><a href="#条款54-让自己熟悉包括-TR1-在内的标准程序库" class="headerlink" title="条款54. 让自己熟悉包括 TR1 在内的标准程序库"></a>条款54. 让自己熟悉包括 TR1 在内的标准程序库</h4><ul>
<li>C++ 标准程序库主要由 STL，iostream，locales 组成，并包含 C99 标准程序库。</li>
<li>TR1 组件都在 <code>std::tr1::</code> 命名空间下，以下是组件实例：</li>
</ul>
<ol>
<li>智能指针。</li>
<li><code>tr1::function</code>，常用于实现回调函数。</li>
<li><code>tr1::bind</code>，能够做 STL 绑定器 bind1st 和 bind2nd 所做的每一件事，而又更多。</li>
<li>Hash tables，用来实现 sets，multisets，maps 和 multi-maps。</li>
<li>正则表达式。</li>
<li>Tuples 变量组，这是标准程序库 pair 的升级，pair 只能持有两个对象，而 <code>tr1::tuple</code> 可持有任意个数对象。</li>
<li><code>tr1::array</code>，本质是个 STL 化的数组，即一个支持成员函数 begin 和 end 的数组。不过它大小固定，并不使用动态内存。</li>
<li><code>tr1::mem_fn</code>，这是一个语句上构造与成员函数指针（member function pointers）一致的东西。同样容纳并扩充了 C++98 的 <code>mem_fun</code> 和 <code>mem_fun_ref</code> 的能力。</li>
<li><code>tr1::reference_wrapper</code>，一个让引用的行为更像对象的设施。</li>
<li>随机数生成工具，它大大超越了 rand。</li>
<li>数学特殊函数，包括 Laguerre 多项式、Bessel 函数、完全椭圆积分，以及更多数学函数。</li>
<li>C99 兼容扩充，这是一大堆函数和模版用来将许多新的 C99 程序库特性带入 C++。</li>
<li>Type traits，一组 traits classes（条款 47），用以提供类型的编译期信息。</li>
<li><code>tr1::result_of</code>，这是一个用来推导函数调用的返回值类型的模版。</li>
</ol>
<p>这些实现一般很多实现在boost库中都有！</p>
<p><strong>请记住</strong></p>
<blockquote>
<ul>
<li>C++标准程序库的主要功能由STL、iostreams、locales组成。并包含C99标准程序库。</li>
<li>TR1添加了智能指针、一般化函数指针、hash-based容器、正则表达式以及另外10个组件的支持。</li>
<li>TR1自身只是一份规范。为获得TR1提供的好处，你需要一份实现。一个好的实现来源是Boost。</li>
</ul>
</blockquote>
<h4 id="条款55-让自己熟悉-Boost"><a href="#条款55-让自己熟悉-Boost" class="headerlink" title="条款55. 让自己熟悉 Boost"></a>条款55. 让自己熟悉 Boost</h4><ul>
<li>Boost 是一个社群，也是一个网站。致力于免费、源码开放、同僚复审的 C++ 程序库开发。</li>
<li>Boost 提供许多 TR1 组件的实现品，以及其它许多程序库。</li>
</ul>
]]></content>
      <categories>
        <category>从零开始的C++の学习之路</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>侯捷 C++ STL标准库和泛型编程 | 学习笔记</title>
    <url>/2024/10/20/C++/%E4%BE%AF%E6%8D%B7%20C++%20STL%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="侯捷-C-STL标准库和泛型编程-学习笔记"><a href="#侯捷-C-STL标准库和泛型编程-学习笔记" class="headerlink" title="侯捷 C++ STL标准库和泛型编程 | 学习笔记"></a>侯捷 C++ STL标准库和泛型编程 | 学习笔记</h1><h3 id="1-STL概述"><a href="#1-STL概述" class="headerlink" title="1 STL概述"></a>1 STL概述</h3><p>STL —— Standard Template Library，标准模板库</p>
<p>C++ Standard LIbrary，C++标准库中包含STL（即STL+一些小东西）</p>
<h4 id="1-1-头文件名称"><a href="#1-1-头文件名称" class="headerlink" title="1.1 头文件名称"></a>1.1 头文件名称</h4><ul>
<li>C++标准库的 header files 不带 <code>.h</code>，例如：<code>#include&lt;vector&gt;</code></li>
<li>新式 C header files 不带 <code>.h</code>，例如：<code>#include&lt;cstdio&gt;</code></li>
<li>老式 C header files 带 <code>.h</code> 仍然可用，例如：<code>#include&lt;stdio.h&gt;</code></li>
</ul>
<blockquote>
<p>新式 header 内的组件封装于 <em>namespace std</em></p>
<p>老式 header 内的组件<strong>不</strong>封装于 <em>namespace std</em></p>
</blockquote>
<h4 id="1-2-STL基础介绍"><a href="#1-2-STL基础介绍" class="headerlink" title="1.2 STL基础介绍"></a>1.2 STL基础介绍</h4><p>STL六大部件：容器(Containers)、分配器(Allocators)、算法(Algorithms)、迭代器(Iterators)、仿函数(Functors)、适配器(Adapters)</p>
<ul>
<li><em>容器</em>：放数据</li>
<li><em>分配器</em>：是来支持容器将数据放到内存里</li>
<li><em>算法</em>：是一个个函数来处理存放在容器里的数据</li>
<li><em>迭代器</em>：就是来支持算法操作容器的</li>
<li><em>仿函数</em>：作用类似函数，例如相加相减等等</li>
<li><em>适配器</em>：有三种，分别将容器，迭代器，仿函数来进行一个转换</li>
</ul>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/d09c45698779ce82cc027e9ea14f615d.png" alt="image-20230818085837524"></p>
<p>实例：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/04af82228aa28169dd7893570701b0d6.png" alt="image-20230818091503166"></p>
<ol>
<li>首先是创建一个 container（<em>vector</em>）</li>
<li>allocator 来帮助 container 来分配内存（一般会忽略不写）</li>
<li>用一个 Algorithm 来操作数据（<em>count_if</em> 是数出满足条件的个数）</li>
<li>iterator 就是一个泛化的指针，来告诉 Algorithm 要处理哪里的数据</li>
<li>用一个 functor 来判断数据（<em>less</em> 其有两个参数传入，第一个 &lt; 第二个就为真）</li>
<li>先用一个 function adapter（<em>bind2nd</em>）绑定了第二个参数为 40；再用一个 function adapter（<em>not1</em>）来对整个判断结果进行否定</li>
</ol>
<p>判断条件 predicate 为：<code>not1(bind2nd(less&lt;int&gt;(), 40))</code> —— 表示 &gt;&#x3D; 40 数为真</p>
<blockquote>
<p>前闭后开：[ )，基本所有容器都有 <code>begin()</code> <code>end()</code>，但 <em>begin</em> 是指向的容器的第一个元素，而 <em>end</em> 是指向的容器最后一个元素的<strong>下一个</strong></p>
<p>例子：遍历容器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Container&lt;T&gt; c;</span><br><span class="line">Container&lt;T&gt;::iterator i = c.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (; i != c.<span class="built_in">end</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//但在C++11中可以用新语法简写</span></span><br><span class="line">...</span><br><span class="line">Container&lt;T&gt; c;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> elem : c)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<h4 id="1-3-typename"><a href="#1-3-typename" class="headerlink" title="1.3 typename"></a>1.3 typename</h4><p>在模板参数的关键字使用中与 <code>class</code> 是一样的</p>
<p>在类型前面加上 <code>typename</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTemplateClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> T::NestedType NestedType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyTemplateFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> T::SomeType variable;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>typename</code> 用于告诉编译器 <code>T::NestedType</code> 和 <code>T::SomeType</code> 是类型名称而不是成员变量</p>
<p><code>typename</code> 是一个用于明确指定符号是一个类型的关键字，以帮助编译器正确解析代码并避免歧义，如果不使用 <code>typename</code>，编译器可能会认为符号是一个值而不是类型，导致编译错误。</p>
<h3 id="2-OOP-vs-GP"><a href="#2-OOP-vs-GP" class="headerlink" title="2 OOP vs. GP"></a>2 OOP vs. GP</h3><ul>
<li><p><strong>OOP</strong> —— Object-Oriented programming 面向对象编程</p>
<p>将数据和操作关联到一起</p>
<p>例如容器 List，其自带了一个 <code>sort()</code>，因为链表的存储空间不是连续的，Iterator 不能实现加减操作，所以不能使用全局的 <code>::sort()</code></p>
</li>
<li><p><strong>GP</strong> —— Generic Programming 泛式编程</p>
<p>将数据和操作分开</p>
<ul>
<li>容器和算法的团队就可以各自闭门造车，其间通过 Iterator 联通即可</li>
<li>算法通过 Iterator 确定操作范围，并通过 Iterator 取用容器的元素</li>
<li>所有的算法，其内的最终涉及元素的操作都是比大小</li>
</ul>
</li>
</ul>
<h3 id="3-容器"><a href="#3-容器" class="headerlink" title="3 容器"></a>3 容器</h3><h4 id="3-1-容器结构分类"><a href="#3-1-容器结构分类" class="headerlink" title="3.1 容器结构分类"></a>3.1 容器结构分类</h4><p>分类：序列式容器 <em>Sequence Container</em>，关联式容器 <em>Associative Container</em></p>
<ul>
<li><p>序列式容器：按照放入的次序进行排列</p>
<ul>
<li>Array 数组，固定大小</li>
<li>Vector 向量，会自动扩充大小</li>
<li>Deque 双向队列，双向都可以扩充</li>
<li>List 链表，双向链表</li>
<li>Forward-List 链表，单向链表</li>
</ul>
</li>
<li><p>关联式容器：有 <em>key</em> 和 <em>value</em>，适合快速的查找</p>
<p>STL中实现使用红黑树（高度平衡二叉树）和哈希表</p>
<ul>
<li><p>Set，<em>key</em> 就是 <em>value</em>，元素不可重复</p>
</li>
<li><p>Map，<em>key</em> 和 <em>value</em> 是分开的，元素不可重复</p>
</li>
<li><p>Multi~，元素是可以重复的</p>
</li>
<li><p>Unordered~，HashTable Separate Chaining</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>其中 <em>Array</em>，<em>Forward-List</em>，<em>Unordered~</em> 都是C++11的</p>
</blockquote>
<h4 id="3-2-序列式容器"><a href="#3-2-序列式容器" class="headerlink" title="3.2 序列式容器"></a>3.2 序列式容器</h4><h5 id="3-2-1-array"><a href="#3-2-1-array" class="headerlink" title="3.2.1 array"></a>3.2.1 array</h5><h6 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h6><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/aca4bf3e71f09fdee57770a2231e4cdd.png" alt="image-20230819103001457"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">//qsort, bsearch, NULL</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n test_array().......... \n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个包含long型元素的array容器，ASIZE为数组的大小</span></span><br><span class="line">    array&lt;<span class="type">long</span>, ASIZE&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充数组 c 中的元素，使用 rand() 生成随机数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; ASIZE; ++i) &#123;</span><br><span class="line">        c[i] = <span class="built_in">rand</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出填充数组所花费的毫秒数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出数组的大小、第一个元素、最后一个元素、起始地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;array.size()= &quot;</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;array.front()= &quot;</span> &lt;&lt; c.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;array.back()= &quot;</span> &lt;&lt; c.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;array.data()= &quot;</span> &lt;&lt; c.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目标值</span></span><br><span class="line">    <span class="type">long</span> target = <span class="built_in">get_a_target_long</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    timeStart = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="comment">// 使用标准库的 qsort 函数（快排）对数组 c 进行排序</span></span><br><span class="line">    ::<span class="built_in">qsort</span>(c.<span class="built_in">data</span>(), ASIZE, <span class="built_in">sizeof</span>(<span class="type">long</span>), compareLongs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用标准库的 bsearch 函数（二分查找）在排序后的数组中搜索目标值</span></span><br><span class="line">    <span class="type">long</span>* pItem = (<span class="type">long</span>*)::<span class="built_in">bsearch</span>(&amp;target, c.<span class="built_in">data</span>(), ASIZE, <span class="built_in">sizeof</span>(<span class="type">long</span>), compareLongs);</span><br><span class="line">    <span class="comment">// 输出排序和搜索所花费的毫秒数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;qsort()+bsearch(), milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>() - timeStart) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果找到目标值，输出该值；否则输出未找到消息</span></span><br><span class="line">    <span class="keyword">if</span> (pItem != <span class="literal">NULL</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;found, &quot;</span> &lt;&lt; *pItem &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;not found! &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/1215c8aa9afe3362a81c2b9945382cf3.png" alt="image-20230818113016596"></p>
<p>随机数据填充容器：47ms；排序和搜索：187ms</p>
<hr>
<h6 id="深度探索"><a href="#深度探索" class="headerlink" title="深度探索"></a>深度探索</h6><p><strong>C++TR1</strong>下（比较简单）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, std::<span class="type">size_t</span> _Nm&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">array</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator; <span class="comment">// 迭代器为_Tp*</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	value_type _M_instance[_Nm ? _Nm : <span class="number">1</span>]; <span class="comment">// 如果_Nm为0，就分配一个空间</span></span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(&amp;_M_instance[<span class="number">0</span>]); &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(&amp;_M_instance[_Nm]); &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>GCC4.9</strong>下（复杂且无益处）：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/5a01425f1dabb780277cae4fb907917b.png" alt="image-20230827201155808"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GCC4.9通过多个typedef以下面的逻辑创建的array里的data</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">100</span>]; <span class="comment">// T即类型int[100] </span></span><br><span class="line">T c; <span class="comment">// 与int c[100]一样</span></span><br></pre></td></tr></table></figure>

<h5 id="3-2-2-vector"><a href="#3-2-2-vector" class="headerlink" title="3.2.2 vector"></a>3.2.2 vector</h5><h6 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h6><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/a5590968ff2ba875bae642ee0320a531.png" alt="image-20230819102940829"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">//abort()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>  <span class="comment">//snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> 	<span class="comment">//sort()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试函数，接受一个引用类型的长整型参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_vector</span><span class="params">(<span class="type">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\ntest_vector().......... \n&quot;</span>;</span><br><span class="line">     </span><br><span class="line">    vector&lt;string&gt; c;  	<span class="comment">// 创建一个字符串类型的向量</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();	<span class="comment">// 记录开始时间							</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>; i&lt; value; ++i)	<span class="comment">// 循环插入随机生成的字符串</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">&quot;%d&quot;</span>, <span class="built_in">rand</span>());	<span class="comment">// 将随机整数转换为字符串</span></span><br><span class="line">            c.<span class="built_in">push_back</span>(<span class="built_in">string</span>(buf));     	<span class="comment">// 将字符串添加到向量中</span></span><br><span class="line">        &#125; <span class="comment">// 这里是处理异常，如内存不够</span></span><br><span class="line">        <span class="built_in">catch</span>(exception&amp; p) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;	</span><br><span class="line">            <span class="comment">// 输出出现异常的信息以及对应的索引值</span></span><br><span class="line">            <span class="comment">// 曾經最高 i=58389486 then std::bad_alloc</span></span><br><span class="line">            <span class="built_in">abort</span>();	<span class="comment">// 异常处理后中止程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;	<span class="comment">// 输出填充向量花费时间</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector.max_size()= &quot;</span> &lt;&lt; c.<span class="built_in">max_size</span>() &lt;&lt; endl;	<span class="comment">// 输出向量的最大容量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector.size()= &quot;</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;	<span class="comment">// 输出向量的实际大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector.front()= &quot;</span> &lt;&lt; c.<span class="built_in">front</span>() &lt;&lt; endl;	<span class="comment">// 输出向量的首元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector.back()= &quot;</span> &lt;&lt; c.<span class="built_in">back</span>() &lt;&lt; endl;	<span class="comment">// 输出向量的末尾元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector.data()= &quot;</span> &lt;&lt; c.<span class="built_in">data</span>() &lt;&lt; endl;	<span class="comment">// 输出向量地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector.capacity()= &quot;</span> &lt;&lt; c.<span class="built_in">capacity</span>() &lt;&lt; endl &lt;&lt; endl;	<span class="comment">// 输出向量的容量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接find来查找————次序查找</span></span><br><span class="line">    string target = <span class="built_in">get_a_target_string</span>();	<span class="comment">// 获取一个目标字符串</span></span><br><span class="line">    &#123;</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();	<span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);	<span class="comment">// 在向量中查找目标字符串</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;std::find(), milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;found, &quot;</span> &lt;&lt; *pItem &lt;&lt; endl &lt;&lt; endl;	<span class="comment">// 输出找到的目标字符串</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;not found! &quot;</span> &lt;&lt; endl &lt;&lt; endl;	<span class="comment">// 输出未找到目标字符串</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先排序再二分法查找</span></span><br><span class="line">    &#123;</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();	<span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="built_in">sort</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());	<span class="comment">// 对向量中的字符串进行排序</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sort(), milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl; </span><br><span class="line">        </span><br><span class="line">        timeStart = <span class="built_in">clock</span>();	    </span><br><span class="line">        string* pItem = (string*)::<span class="built_in">bsearch</span>(&amp;target, (c.<span class="built_in">data</span>()), </span><br><span class="line">                                           c.<span class="built_in">size</span>(), <span class="built_in">sizeof</span>(string), compareStrings); </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bsearch(), milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl; </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (pItem != <span class="literal">NULL</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;found, &quot;</span> &lt;&lt; *pItem &lt;&lt; endl &lt;&lt; endl;	<span class="comment">// 输出在排序后向量中找到的目标字符串</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;not found! &quot;</span> &lt;&lt; endl &lt;&lt; endl;	<span class="comment">// 输出在排序后向量中未找到目标字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    c.<span class="built_in">clear</span>();	<span class="comment">// 清空向量中的数据</span></span><br><span class="line">    <span class="built_in">test_moveable</span>(<span class="built_in">vector</span>&lt;MyString&gt;(),<span class="built_in">vector</span>&lt;MyStrNoMove&gt;(), value);	<span class="comment">// 调用另一个函数进行测试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是 array 在后面插入元素，其中若空间 <em>capacity</em> 不够，其会进行<strong>两倍扩充</strong>——即空间不够时会将原来的空间 <code>*2</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">push_back</span>(<span class="built_in">string</span>(buf));</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/305e5f8e58fd9e657e93a2d8aae9cbec.png" alt="img"></p>
<p>随机数据填充容器：3063ms；直接搜索：0ms（运气很好）；排序后二分查找：2765ms</p>
<hr>
<h6 id="深度探索-1"><a href="#深度探索-1" class="headerlink" title="深度探索"></a>深度探索</h6><p><strong>GCC2.9</strong>下：</p>
<p>一共3个指针：<code>start</code>，<code>finish</code>，<code>end_of_storage</code></p>
<p>所以 <code>sizeof(vector&lt;int&gt;)</code> 是<code>12</code></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/c5e34df7714022f72444ade564b78c06.png" alt="image-20230827163726770"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator; <span class="comment">// 迭代器就是T*</span></span><br><span class="line">	<span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	iterator start;</span><br><span class="line">	iterator finish;</span><br><span class="line">	iterator end_of_storage;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="built_in">end</span>() - <span class="built_in">begin</span>()); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(end_of_storage - <span class="built_in">begin</span>()); &#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>(); &#125;</span><br><span class="line">	reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span> *(<span class="built_in">begin</span>() + n); &#125;</span><br><span class="line">    <span class="comment">// 所有连续储存的容器都有[]的重载</span></span><br><span class="line">	<span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line">	<span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vector 每次成长会大量调用元素的拷贝构造函数和析构函数，是一个大成本</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage) <span class="comment">// 还有备用空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">construct</span>(finish, x); <span class="comment">// 全局函数</span></span><br><span class="line">        ++finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 无备用空间</span></span><br><span class="line">        <span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert_aux</span>(iterator position, <span class="type">const</span> T&amp; x)&#123;</span><br><span class="line"><span class="keyword">if</span> (finish != end_of_storage)&#123; <span class="comment">// insert_aux还会被其他函数调用所以还有检查</span></span><br><span class="line">    <span class="comment">// 在‘备用空间起始处’构建一个元素以vector最后一个元素为初值</span></span><br><span class="line">    <span class="comment">// insert_aux也可能被insert调用，元素插入位置不定</span></span><br><span class="line">    <span class="built_in">construct</span>(finish, *(finish - <span class="number">1</span>));</span><br><span class="line">    ++finish;</span><br><span class="line">    T x_copy = x;</span><br><span class="line">    <span class="built_in">copy_backward</span>(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>);</span><br><span class="line">    *position = x_copy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="type">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">    <span class="type">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 原大小为0，则分配1；否则，分配原大小的2倍</span></span><br><span class="line">    </span><br><span class="line">    iterator new_start = data_allocator::<span class="built_in">allocate</span>(len);</span><br><span class="line">    iterator new_finish = new_start;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 拷贝安插点前的原内容</span></span><br><span class="line">        new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);</span><br><span class="line">        <span class="built_in">construct</span>(new_finish, x);</span><br><span class="line">        ++new_finish;</span><br><span class="line">        <span class="comment">// 拷贝安插点后的原内容</span></span><br><span class="line">        new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)&#123;</span><br><span class="line">        <span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(new_start, len);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解构并释放原vector</span></span><br><span class="line">    <span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">deallocate</span>();</span><br><span class="line">    <span class="comment">// 调整迭代器，指向新vector</span></span><br><span class="line">    start = new_start;</span><br><span class="line">    finish = new_finish;</span><br><span class="line">    end_of_storage = new_start + len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GCC4.9</strong>下变得复杂：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/120e53f5542dd78a7fc49d5f44eb25ad.png" alt="image-20230827174519929"></p>
<blockquote>
<p>且迭代器也变得乱七八糟，舍近求远，何必如此！！</p>
</blockquote>
<h5 id="3-2-3-list"><a href="#3-2-3-list" class="headerlink" title="3.2.3 list"></a>3.2.3 list</h5><h6 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h6><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/ab34a433644691ad274dbf3450ee5d11.png" alt="image-20230819103100219"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_list</span><span class="params">(<span class="type">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    list&lt;string&gt; c;  <span class="comment">// 创建一个字符串列表  	</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];  <span class="comment">// 字符串缓冲区</span></span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">		</span><br><span class="line">    string target = <span class="built_in">get_a_target_string</span>();  <span class="comment">// 获取目标字符串		</span></span><br><span class="line">    timeStart = <span class="built_in">clock</span>();		</span><br><span class="line">    <span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);  <span class="comment">// 在列表中查找目标字符串						</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;std::find()，milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;  <span class="comment">// 输出查找时间		</span></span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    	</span><br><span class="line">    timeStart = <span class="built_in">clock</span>();		</span><br><span class="line">    c.<span class="built_in">sort</span>();  <span class="comment">// 对列表进行排序						</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c.sort(), milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;  <span class="comment">// 输出排序时间		    	</span></span><br><span class="line"></span><br><span class="line">    c.<span class="built_in">clear</span>();  <span class="comment">// 清空	 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code> c.sort();</code> 是容器自带的排序函数，如果容器自带肯定是要比全局的排序函数好的</p>
<p><em>list</em> 同样也是用 <code>c.push_back(string(buf));</code> 往里添加元素的</p>
</blockquote>
<p>运行结果：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/dc6e572dcf2870ccf150caaee39adc2a.png" alt="image-20230819105152408"></p>
<p>随机数据填充容器：3265ms；直接搜索：16ms；排序：2312ms</p>
<hr>
<h6 id="深度探索-2"><a href="#深度探索-2" class="headerlink" title="深度探索"></a>深度探索</h6><p><strong>GCC2.9</strong>中</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/3472edd6f4874126348f286c7c216f3f.png" alt="image-20230822105307837"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// list class</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> list</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt; iterator; <span class="comment">// 迭代器，每一个容器都会 typedef</span></span><br><span class="line">	<span class="comment">// 只传一个参数就行了 不理想</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	link_type node; <span class="comment">// 一个 __list_node&lt;T&gt; 的指针</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点 class</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">void</span>* void_pointer; <span class="comment">// 每次用还要转换类型 不理想</span></span><br><span class="line">	void_pointer prev;</span><br><span class="line">	void_pointer next;</span><br><span class="line">	T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>除了 array，vector 这样是连续存储的容器，其他容器的 iterator 都是智能指针，其有大量的操作符重载 —— 模拟指针</p>
</blockquote>
<p>基本上所有的 iterator 都有下面<em>5</em>个 <em>typedef</em> 和一大堆操作符重载</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// iterator class</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt; self;</span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category; <span class="comment">// (1)双向迭代器	</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">// (2)迭代器所指对象的类型</span></span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer; <span class="comment">// (3)迭代器所指对象的指针类型</span></span><br><span class="line">	<span class="keyword">typedef</span> Ref reference; <span class="comment">// (4)迭代器所指对象的引用类型</span></span><br><span class="line">	<span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; <span class="comment">// (5)两个迭代器之间的距离类型</span></span><br><span class="line"></span><br><span class="line">	link_type node; <span class="comment">// iterator本体，一个指向__list_node&lt;T&gt;的指针</span></span><br><span class="line"></span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">	self&amp; <span class="keyword">operator</span>++() <span class="comment">// ++i</span></span><br><span class="line">    &#123;</span><br><span class="line">        node = (link_type)((*node).next); <span class="comment">// 移到下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">    &#125;</span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="type">int</span>) <span class="comment">// i++ 为了区分加上了一个参数其实无用</span></span><br><span class="line">    &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>; </span><br><span class="line">        ++*<span class="keyword">this</span>; </span><br><span class="line">        <span class="keyword">return</span> tmp; </span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：<code>self operator++(int)&#123;...&#125;</code> 的 <code>self tmp = *this;</code> 中，由于先调用了 <code>=</code> 唤起了 <em>copy ctor</em> 用以创建 tmp 并以 <code>*this</code> 为初值，所以不会唤起 <code>operator*</code> —— <code>*this</code> 已经被解释为 ctor 的参数</p>
<p>下面的 <code>++*this;</code> 同理</p>
<blockquote>
<p>与 int 类似：iterator 可以连续前++，但不能连续后++</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/ef8375d526c91f0e218e2e003448b310.png" alt="image-20230822173147636"><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/a00deae379f70e7ae017d2f1fc32e185.png" alt="image-20230822173354379"></p>
<p>所以前++是返回引用，后++返回值</p>
</blockquote>
<p>因为要符合前闭后开原则，所以在 list 尾端加上了一个空白节点</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/e9c2a09a74edcd51c4babd40ac9f669e.png" alt="image-20230827092146933"></p>
<p><strong>GCC4.9</strong>中做出了改进：</p>
<ul>
<li>迭代器模板参数从三个 –&gt; 只有一个</li>
<li>节点 class 中的前后指针类型从 <code>void*</code> –&gt; <code>_LIst_node_base*</code></li>
</ul>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/9e8606c953607a40e72023f31bad81fd.png" alt="image-20230827091438719"></p>
<p>在GCC4.9中 <code>sizeof(list&lt;int&gt;)</code> 是 <strong>8</strong></p>
<p>在GCC2.9中 <code>sizeof(list&lt;int&gt;)</code> 是 <strong>4</strong></p>
<h5 id="3-2-4-forward-list"><a href="#3-2-4-forward-list" class="headerlink" title="3.2.4 forward_list"></a>3.2.4 forward_list</h5><h6 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h6><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/4dec1c1b47d7ff7f01aacdbed858c8de.png" alt="image-20230819103623779"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_forward_list</span><span class="params">(<span class="type">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">     </span><br><span class="line">    forward_list&lt;string&gt; c;  <span class="comment">// 创建一个前向列表  	</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];  <span class="comment">// 字符串缓冲区</span></span><br><span class="line">			</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    string target = <span class="built_in">get_a_target_string</span>();  <span class="comment">// 获取目标字符串	</span></span><br><span class="line">    timeStart = <span class="built_in">clock</span>();	</span><br><span class="line">    <span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);  <span class="comment">// 在前向列表中查找目标字符串	</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;std::find()，milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;  <span class="comment">// 输出查找时间		</span></span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    	</span><br><span class="line">    timeStart = <span class="built_in">clock</span>();		</span><br><span class="line">    c.<span class="built_in">sort</span>();  <span class="comment">// 进行排序					</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c.sort()， milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;  <span class="comment">// 输出排序时间		</span></span><br><span class="line">	</span><br><span class="line">    c.<span class="built_in">clear</span>();  <span class="comment">// 清空	 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<em>forward_list</em> 只有 <code>c.push_front();</code> 且没有 <code>forward_list.back()</code> <code>forward_list.size()</code></p>
</blockquote>
<p>运行结果：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/4e75b693896408979c4af81097a394ed.png" alt="image-20230819110505646"></p>
<p>随机数据填充容器：3204ms；直接搜索：15ms；排序：2656ms</p>
<h6 id="深度探索-3"><a href="#深度探索-3" class="headerlink" title="深度探索"></a>深度探索</h6><p>与 <em>list</em> 相似，略</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/9b70751a2edb8166845972444a2b6747.png" alt="image-20230827201331283"></p>
<h5 id="3-2-6-deque"><a href="#3-2-6-deque" class="headerlink" title="3.2.6 deque"></a>3.2.6 deque</h5><h6 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h6><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/8ba922f08b957fb8b1586a8873c340ff.png" alt="image-20230819103846501"></p>
<p>类似vector，两边都能扩充，实际上是分段连续的</p>
<p>其是通过 <em>map</em>（是一个vector，但在扩充时会 copy 到中间）里的指针指向各个 <em>buffer</em>，<em>buffer</em> 里再存数据，每个 <em>buffer</em> 的大小一致，每次扩充都是扩充一个指针指向一个新的 <em>buffer</em></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/2f6ad616b0641315dc4cf94745145e4b.png" alt="image-20230819111424969"></p>
<p>map其实是vector，它扩充的时候会增长为原来的2倍，移动原数据到新内存空间的时候，它会放到新内存空间的中间，方便扩充</p>
<p>比如：原来大小为8，扩充为16，那原来这8个放在 5-12这个位置，前面和留后面留着扩充</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_deque</span><span class="params">(<span class="type">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">     </span><br><span class="line">    deque&lt;string&gt; c;  <span class="comment">// 创建一个双端队列  	</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];  <span class="comment">// 字符串缓冲区</span></span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    string target = <span class="built_in">get_a_target_string</span>();  <span class="comment">// 获取目标字符串	</span></span><br><span class="line">    timeStart = <span class="built_in">clock</span>();	</span><br><span class="line">    <span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);  <span class="comment">// 在队列中查找目标字符串	</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;std::find()，milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;  <span class="comment">// 输出查找时间		</span></span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    	</span><br><span class="line">    timeStart = <span class="built_in">clock</span>();		</span><br><span class="line">    <span class="built_in">sort</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());  <span class="comment">// 对队列进行排序					</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sort()，milli-seconds : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;  <span class="comment">// 输出排序时间		</span></span><br><span class="line">	</span><br><span class="line">    c.<span class="built_in">clear</span>();  <span class="comment">// 清空队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/4b6d7996a0bbf2aa84149acf1b094145.png" alt="image-20230819112747434"></p>
<p>随机数据填充容器：2704ms；直接搜索：15ms；排序：3110ms</p>
<blockquote>
<p>下面的 <em>stack</em> 和 <em>queue</em> 内部都是一个 <em>deque</em>，所以技术上这两个可以看作容器适配器 <em>Container Adapter</em></p>
</blockquote>
<hr>
<h6 id="深度探索-4"><a href="#深度探索-4" class="headerlink" title="深度探索"></a>深度探索</h6><p><strong>GCC2.9</strong>下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc, <span class="type">size_t</span> BufSiz = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> deque</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> T* pointer;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> pointer* map_pointer; <span class="comment">// T** 指向指针的指针</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	iterator start;</span><br><span class="line">	iterator finish;</span><br><span class="line">	map_pointer map;</span><br><span class="line">	size_type map_size;</span><br><span class="line">    <span class="comment">// 两个迭代器:16*2，一个指针:4，一个size_t:4，一共40字节</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> finish - start; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：第三个模板参数 <code>size_t BufSiz = 0</code> 有一个函数：</p>
<p>如果不为0，则 buffer size 就是传入的数据</p>
<p>如果为0，表示预设值，那么</p>
<p>如果 <code>sz = sizeof(value_type)</code> &lt; 512，传回 <code>512/sz</code><br>如果 <code>sz = sizeof(value_type)</code> &gt;&#x3D; 512，传回 <code>1</code></p>
</blockquote>
<p>迭代器四个指针，<code>cur</code> 指向当前元素，<code>first</code> 指向当前 buffer 的第一个元素，<code>last</code> 指向当前 buffer 的最后一个元素的下一个，<code>node</code> 指向当前 buffer 在 map（控制中心）的指针</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/2ccb92a21a2729ae9b05d3de1c08ccae.png" alt="image-20230828084817056"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// deque迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">// (1)</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">// (2)</span></span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer; <span class="comment">// (3)</span></span><br><span class="line">	<span class="keyword">typedef</span> Ref reference; <span class="comment">// (4)</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; <span class="comment">// (5)</span></span><br><span class="line">	<span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line">	<span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line"></span><br><span class="line">	T* cur;</span><br><span class="line">	T* first;</span><br><span class="line">	T* last;</span><br><span class="line">	map_pointer node; <span class="comment">// 指向指针的指针</span></span><br><span class="line">    <span class="comment">// 四个指针，一共16字节</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>deque 中的 <em>insert</em> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position.cur == start.cur) <span class="comment">// 插入点在deque最前端      </span></span><br><span class="line">    &#123;							<span class="comment">// 交给push_front</span></span><br><span class="line">        <span class="built_in">push_front</span>(x);</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur) <span class="comment">// 插入点在deque最尾端</span></span><br><span class="line">    &#123;								  <span class="comment">// 交给push_front</span></span><br><span class="line">        <span class="built_in">push_back</span>(x);</span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        --tmp;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 在中间插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_aux</span>(position, x);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">insert_aux</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    difference_type index = pos - start; <span class="comment">// 安插点前元素个数</span></span><br><span class="line">    value_type x_copy = x;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="built_in">size</span>() / <span class="number">2</span>) <span class="comment">// 安插点前的元素少————搬前面的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">push_front</span>(<span class="built_in">front</span>());</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">copy</span>(front2, pos1, front1); <span class="comment">// 搬元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 安插点后的元素少————搬后面的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">push_back</span>(<span class="built_in">back</span>());</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">copy_backward</span>(pos, back2, back1);</span><br><span class="line">    &#125;</span><br><span class="line">    *pos = x_copy; <span class="comment">// 安插点设新值</span></span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>deque 模拟连续空间（deque iterator 的功能）：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/78469510fa69e1635333a6324580906e.png" alt="image-20230828093535797"></p>
<ul>
<li><p><code>-</code>：两个位置之间的距离——前闭后开的元素个数</p>
<p>两个位置之间的距离 &#x3D; buffer_size * 两个位置之间 buffer 的数量 + 末尾位置到 buffer 前端的长度 + 起始位置到 buffer 末尾的长度</p>
</li>
<li><p><code>++</code>&#x2F;<code>--</code>：注：下面带参数的是后++（i++）</p>
</li>
<li><p><code>+=</code>&#x2F;<code>+</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n)</span><br><span class="line">&#123;</span><br><span class="line">    difference_type offset = n + (cur - first);  </span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()))  </span><br><span class="line">        <span class="comment">// 若+了之后在缓冲区大小范围内</span></span><br><span class="line">        cur += n;  <span class="comment">// 直接移动迭代器 n 步</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        difference_type node_offset = offset &gt; <span class="number">0</span> ? offset / <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) </span><br><span class="line">            : -<span class="built_in">difference_type</span>((-offset - <span class="number">1</span>) / <span class="built_in">buffer_size</span>()) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算偏移的节点数，offset &gt; 0判断是为了之后的-=/-</span></span><br><span class="line">        <span class="comment">// 这里(-offset - 1)后除buffer_size()再-1是为了offset==buffer_size()的情况</span></span><br><span class="line">        <span class="built_in">set_node</span>(node + node_offset);  <span class="comment">// 调整节点，使迭代器指向正确的节点</span></span><br><span class="line">        cur = first + (offset - node_offset * <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()));  <span class="comment">// 调整迭代器位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>+(difference_type n) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;  <span class="comment">// 复制当前迭代器</span></span><br><span class="line">    <span class="keyword">return</span> tmp += n;   <span class="comment">// 返回向前移动 n 步后的迭代器副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>-=</code>&#x2F;<code>-</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -就等于+负的</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> += -n; &#125;</span><br><span class="line">self <span class="keyword">operator</span>-(difference_type n) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp -= n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>[]</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">reference <span class="keyword">operator</span>[](difference_type n) <span class="type">const</span> </span><br><span class="line">&#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>GCC4.9</strong>下：其实没必要这样</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/2b42428bbfd19b7cf5b4a4bc89b8f48b.png" alt="image-20230829210932604"></p>
<p>G2.91 允许指派 buffer_size</p>
<p>G4.53 不允许了</p>
<h5 id="3-2-7-stack，queque"><a href="#3-2-7-stack，queque" class="headerlink" title="3.2.7 stack，queque"></a>3.2.7 stack，queque</h5><h6 id="测试-5"><a href="#测试-5" class="headerlink" title="测试"></a>测试</h6><p>stack：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/bfc4167220c72a1cc7600a7e56b7ba32.png" alt="image-20230819104008973"></p>
<p>queue：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/ea729478e389f82e7ec219b984d28329.png" alt="image-20230819104029805"></p>
<blockquote>
<p><em>stack</em>，<em>queue</em> 是通过 <code>push()</code> 和 <code>pop()</code> 来放取元素的，且无<em>iterator</em> 的操作</p>
</blockquote>
<hr>
<h6 id="深度探索-5"><a href="#深度探索-5" class="headerlink" title="深度探索"></a>深度探索</h6><p><em>stack</em> 和 <em>queue</em> 内部默认用 <em>deque</em> 来实现，所以有时候不会将这两个认为容器而是<strong>一个适配器</strong></p>
<ul>
<li>底层函数可以使用 <em>list</em> 和 <em>deque</em>（deque默认更快）</li>
<li>queue 不能用 vector，stack 可以用 <em>vector</em></li>
<li>set，map 都不能用</li>
</ul>
<p>用时编译器可以通过的，但在具体使用函数时，若遇到底层容器没有这个函数时，就会报错</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// queue</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Sequence c; <span class="comment">// 底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 都是通过底层容器来实现</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">	<span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">	<span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">	<span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_front</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stack</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> stack</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Sequence c; <span class="comment">// 底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 都是通过底层容器来实现</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">	<span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_back</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>stack，queue 都不允许遍历，也不提供 iterator</p>
<h4 id="3-3-关联式容器"><a href="#3-3-关联式容器" class="headerlink" title="3.3 关联式容器"></a>3.3 关联式容器</h4><h5 id="3-3-0-RB-Tree"><a href="#3-3-0-RB-Tree" class="headerlink" title="3.3.0 RB-Tree"></a>3.3.0 RB-Tree</h5><p><strong>红黑树</strong>（Red-Black Tree）是一种自平衡的二叉搜索树 BST（AVL 是另一种），其设计目标是在最坏情况下也能保证基本的动态集合操作（如插入、删除和查找）的时间复杂度为O(log n)。红黑树通过一系列的颜色和性质约束来维持其平衡性，这些约束包括：</p>
<ol>
<li><strong>节点是红色或黑色</strong>：每个节点都有一个颜色属性，可以是红色或黑色。</li>
<li><strong>根节点是黑色</strong>：确保树的根始终为黑色，这有助于维持树的平衡。</li>
<li><strong>所有叶子节点都是黑色</strong>：这里的叶子节点指的是树中的空节点（NIL节点），它们被假定为黑色。</li>
<li><strong>红色节点的子节点必须是黑色</strong>（也称为“不能有两个连续的红色节点”）：这个性质确保了在任何路径上，红色节点不会紧密相连，从而限制了树的高度。</li>
<li><strong>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点</strong>：这个性质被称为“黑色平衡性质”，它确保了树在整体上保持平衡。</li>
</ol>
<blockquote>
<p>rb-tree 提供遍历操作和 iterators，按<em>中序遍历</em>遍历，便可以得到排序状态</p>
</blockquote>
<blockquote>
<p>不能用 iterator 去改变元素的 key（其有严谨的排列规则）</p>
</blockquote>
<blockquote>
<p>rb-tree 提供两种 insertion 操作：<code>insert_unique()</code> 和 <code>insert_equal()</code>，前者表示 key 独一无二，后者表示 key 可重复</p>
</blockquote>
<p><strong>GCC2.9</strong>下：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/dfd99e54d77a47ef4b3c97e7acb55666.png" alt="image-20230830083207175"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="comment">// key的类型</span></span><br><span class="line">		 <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="comment">// Value里包含key和date</span></span><br><span class="line">		 <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="comment">// 从Value中取出key的仿函数</span></span><br><span class="line">		 <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="comment">// 比较key大小的仿函数</span></span><br><span class="line">		 <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> rb_tree</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	size_type node_count; <span class="comment">// rb-tree节点数量，大小4</span></span><br><span class="line">	link_type header; <span class="comment">// 头指针，大小4</span></span><br><span class="line">	Compare Key_compare; <span class="comment">// key比大小的仿函数，大小1</span></span><br><span class="line">    <span class="comment">// sizeof: 9 ——&gt; 12(填充到4的倍数)</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>GCC4.9</strong>下：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/a6d74685d7bb2ce356159608a89c855c.png" alt="image-20230830093745761"></p>
<p><em>_M_color</em> 是 “枚举”（Enumeration）</p>
<h5 id="3-3-1-set-multiset"><a href="#3-3-1-set-multiset" class="headerlink" title="3.3.1 set &#x2F; multiset"></a>3.3.1 set &#x2F; multiset</h5><p>set&#x2F;multiset的value和key合一，value就是key</p>
<h6 id="测试-6"><a href="#测试-6" class="headerlink" title="测试"></a>测试</h6><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/6da4890fd665a5ea5514e45996b7040e.png" alt="image-20230819161037868"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_multiset</span><span class="params">(<span class="type">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\ntest_multiset().......... \n&quot;</span>;</span><br><span class="line">     </span><br><span class="line">    multiset&lt;string&gt; c;  <span class="comment">// 创建一个multiset  	</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];		</span><br><span class="line">    <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();  <span class="comment">// 记录起始时间							</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>; i&lt; value; ++i)  <span class="comment">// 添加元素到multiset中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">&quot;%d&quot;</span>, <span class="built_in">rand</span>());  <span class="comment">// 将随机数转换为字符串格式</span></span><br><span class="line">            c.<span class="built_in">insert</span>(<span class="built_in">string</span>(buf));  <span class="comment">// 将字符串插入multiset中     				</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span>(exception&amp; p) &#123;  <span class="comment">// 捕获可能的异常</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;  <span class="comment">// 输出异常信息</span></span><br><span class="line">            <span class="built_in">abort</span>();  <span class="comment">// 终止程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;毫秒数 : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;  <span class="comment">// 输出时间差，计算插入时间	</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;multiset.size()= &quot;</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// 输出multiset大小	</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;multiset.max_size()= &quot;</span> &lt;&lt; c.<span class="built_in">max_size</span>() &lt;&lt; endl;  <span class="comment">// 输出multiset的最大容量</span></span><br><span class="line">    </span><br><span class="line">    string target = <span class="built_in">get_a_target_string</span>();	</span><br><span class="line">    &#123;</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);  <span class="comment">// 在multiset中使用 std::find(...) 查找目标字符串</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;std::find()，毫秒数 : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;		</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"> 	</span><br><span class="line">    &#123;</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();		</span><br><span class="line">        <span class="keyword">auto</span> pItem = c.<span class="built_in">find</span>(target);  <span class="comment">// 在multiset中使用 c.find(...) 查找目标字符串</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c.find()，毫秒数 : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;		 </span><br><span class="line">        ...</span><br><span class="line">    &#125;	</span><br><span class="line">	 </span><br><span class="line">    c.<span class="built_in">clear</span>();  <span class="comment">// 清空multiset</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>安插元素是使用 <code>insert()</code>，其位置由红黑树决定</p>
</blockquote>
<blockquote>
<p>容器自己有 <code>c.find()</code>，其会比全局的 <code>::find()</code> 快</p>
</blockquote>
<p>运行结果：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/dd7af9538d510707b25bc72c89e7f146.png" alt="image-20230819162112550"></p>
<p>随机数据填充容器：6609ms（其在填充的时候就进行排序了）；直接搜索 <code>::find()</code>：203ms；<code>c.find()</code>：0ms</p>
<hr>
<h6 id="深度探索-6"><a href="#深度探索-6" class="headerlink" title="深度探索"></a>深度探索</h6><p>以 rb-tree 为底层结构，因此有——元素自动排序，key 与 value 和一</p>
<blockquote>
<p>set &#x2F; multiset 提供遍历操作和 iterators，按<em>中序遍历</em>遍历，便可以得到排序状态</p>
</blockquote>
<blockquote>
<p>禁止用 iterator 去改变元素的值（其有严谨的排列规则）</p>
</blockquote>
<blockquote>
<p>set的key 独一无二，其 <code>insert()</code> 操作用的 rb-tree 的：<code>insert_unique()</code></p>
<p>multiset 的 key 可以重复，其 <code>insert()</code> 操作用的 rb-tree 的：<code>insert_equal()</code></p>
</blockquote>
<p><strong>GCC2.9</strong>下：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241019171225154.png" alt="image-20241019171225154"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Compare</span> = less&lt;Key&gt;, <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> set</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> Key key_type;</span><br><span class="line">	<span class="keyword">typedef</span> Key value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">	<span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree&lt;key_type, value_type, identity&lt;value_type&gt;, </span><br><span class="line">    			    key_compare, Alloc&gt; rep_type;</span><br><span class="line">	rep_type t; <span class="comment">// 采用红黑树作为底层机制</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator iterator;</span><br><span class="line">	<span class="comment">// 注意：这里是const_iterator，所以不能用iterator改元素</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-2-map-multimap"><a href="#3-3-2-map-multimap" class="headerlink" title="3.3.2 map &#x2F; multimap"></a>3.3.2 map &#x2F; multimap</h5><p>key是key,val是val</p>
<h6 id="测试-7"><a href="#测试-7" class="headerlink" title="测试"></a>测试</h6><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/8d752c68b48392730e546ff9ad24c0f2.png" alt="image-20230819162351918"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_multimap</span><span class="params">(<span class="type">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    multimap&lt;<span class="type">long</span>, string&gt; c;  <span class="comment">// 创建一个multimap，key 为 long 类型，value 为 string 类型  	</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();  <span class="comment">// 记录起始时间							</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>; i&lt; value; ++i)  <span class="comment">// 添加元素到multimap中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">&quot;%d&quot;</span>, <span class="built_in">rand</span>());  <span class="comment">// 将随机数转换为字符串格式并复制到缓冲区</span></span><br><span class="line">            <span class="comment">// multimap 不可使用 [] 做 insertion </span></span><br><span class="line">            c.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">long</span>, string&gt;(i, buf));  <span class="comment">// 将元素插入multimap中   						</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span>(exception&amp; p) &#123;  <span class="comment">// 捕获可能的异常</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;  <span class="comment">// 输出异常信息</span></span><br><span class="line">            <span class="built_in">abort</span>();  <span class="comment">// 终止程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;毫秒数 : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;  <span class="comment">// 输出时间差，计算插入时间	</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;multimap.size()= &quot;</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// 输出multimap大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;multimap.max_size()= &quot;</span> &lt;&lt; c.<span class="built_in">max_size</span>() &lt;&lt; endl;  <span class="comment">// 输出multimap的最大容量</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> target = <span class="built_in">get_a_target_long</span>();		</span><br><span class="line">    timeStart = <span class="built_in">clock</span>();		</span><br><span class="line">    <span class="keyword">auto</span> pItem = c.<span class="built_in">find</span>(target);  <span class="comment">// 在multimap中查找目标 key								</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c.find()，毫秒数 : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;	 </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到，value=&quot;</span> &lt;&lt; (*pItem).second &lt;&lt; endl;  <span class="comment">// 如果找到，输出找到的值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到！&quot;</span> &lt;&lt; endl;  <span class="comment">// 如果未找到，输出未找到的信息	</span></span><br><span class="line">    </span><br><span class="line">    c.<span class="built_in">clear</span>();  <span class="comment">// 清空multimap		  					</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>c.insert(pair&lt;long, string&gt;(i, buf));</code> 中 <em>key</em> 是从1~1000000，<em>value</em> 是随机取的，将其组合为 <em>pair</em> 插入</p>
</blockquote>
<p>运行结果：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/9633ce7f96c68cd65d57aae788f943b6.png" alt="image-20230819163328911"></p>
<p>随机数据填充容器：4812ms（其在填充的时候就进行排序了）；<code>c.find()</code>：0ms</p>
<hr>
<h6 id="深度探索-7"><a href="#深度探索-7" class="headerlink" title="深度探索"></a>深度探索</h6><p>以 rb-tree 为底层结构，因此有——元素自动排序</p>
<blockquote>
<p>map&#x2F; multimap 提供遍历操作和 iterators，按<em>中序遍历</em>遍历，便可以得到排序状态</p>
</blockquote>
<blockquote>
<p>不能用 iterator 去改变元素的key（其有严谨的排列规则），但可以用 iterator 去改变元素的 data</p>
<p>因此 map &#x2F; multimap 将 user 指定的 <em>key_type</em> 设定成 <code>const</code></p>
</blockquote>
<blockquote>
<p>map的key 独一无二，其 <code>insert()</code> 操作用的 rb-tree 的：<code>insert_unique()</code></p>
<p>multimap 的 key 可以重复，其 <code>insert()</code> 操作用的 rb-tree 的：<code>insert_equal()</code></p>
</blockquote>
<p><strong>GCC2.9</strong>下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="comment">// key的类型</span></span><br><span class="line">		 <span class="keyword">class</span> <span class="title class_">T</span>, <span class="comment">// data的类型</span></span><br><span class="line">		 <span class="keyword">class</span> <span class="title class_">Compare</span> = less&lt;Key&gt;, </span><br><span class="line">		 <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> map</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> Key key_type;</span><br><span class="line">	<span class="keyword">typedef</span> T data_type;</span><br><span class="line">	<span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">	<span class="keyword">typedef</span> pair&lt;<span class="type">const</span> Key, T&gt; value_type;</span><br><span class="line">    <span class="comment">// 注意：这里是const Key ———— 防止改key</span></span><br><span class="line">	<span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree&lt;key_type, value_type, select1st&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">	rep_type t; <span class="comment">// 采用红黑树作为底层机制</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator iterator;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>map 的插入元素有特殊写法：<code>c[i] = string(buf)</code>，其中 <code>i</code> 就是 key；multimap没有</p>
<p>map 的 <code>[]</code> 功能：</p>
<p><strong>访问元素：</strong> 如果指定的键存在于映射中，<code>map[key]</code> 将返回与该键关联的 data；如果键不存在，<code>map[key]</code> 将自动创建一个新的键值对，key 为指定的 key，data 为默认 data，并返回这个默认 data</p>
</blockquote>
<h5 id="3-3-3-HashTable"><a href="#3-3-3-HashTable" class="headerlink" title="3.3.3 HashTable"></a>3.3.3 HashTable</h5><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/660d1a4207e93b879c1c87c748b6586c.png" alt="image-20230830144746686"></p>
<ul>
<li><p>元素的位置 &#x3D; key % bucket大小</p>
</li>
<li><p>bucket vector 的大小为质数</p>
</li>
<li><p>当元素个数大于 bucket 的总数时，bucket vector 扩充并重新打散放在新计算的 bucket 中（<em>rehashing</em> 很花时间）—— bucket 一定比元素多</p>
<blockquote>
<p>在扩充时，按 vector 扩充为2倍大小，但会选择靠进这个数的一个质数做新的大小</p>
</blockquote>
</li>
</ul>
<p><strong>GCC2.9</strong>下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="comment">// Value里包含key和date</span></span><br><span class="line">		  <span class="keyword">class</span> <span class="title class_">Key</span>, <span class="comment">// key的类型</span></span><br><span class="line">		  <span class="keyword">class</span> <span class="title class_">HashFcn</span>, <span class="comment">// hash函数</span></span><br><span class="line">		  <span class="keyword">class</span> <span class="title class_">ExtractKey</span>, <span class="comment">// 从Value中取出key的方法</span></span><br><span class="line">		  <span class="keyword">class</span> <span class="title class_">EqualKey</span>, <span class="comment">// 判断key相等的函数</span></span><br><span class="line">		  <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hashtable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> HashFcn hasher; </span><br><span class="line">	<span class="keyword">typedef</span> EqualKey key_equal; <span class="comment">// 判断key相等的函数</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 3个函数对象，大小一共3（应该是0，因为一些因素）</span></span><br><span class="line">	hasher hash;</span><br><span class="line">	key_equal equals;</span><br><span class="line">	ExtractKey get_key;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> __hashtable_node&lt;Value&gt; node;</span><br><span class="line"></span><br><span class="line">	vector&lt;node*, Alloc&gt; buckets; <span class="comment">// vector里3个指针，大小12</span></span><br><span class="line">	size_type num_elements; <span class="comment">// 大小4</span></span><br><span class="line">    <span class="comment">// 一共19 ——&gt; 20（调整为4的倍数）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buckets.<span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Hash函数：</p>
<p>给传进来的参数生成一个编号</p>
<p>偏特化写不同类型的 hash 函数，下图都是数值类型，直接返回就可以</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/8fd10d9734a5201ced1f3e32b00d00b6.png" alt="image-20230830153207439"></p>
<p>下图对 c 风格的字符串做了处理（也可以自己设计），来生成 hash code</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/e1f74e8077e6e02bd3b7d6cc586c2341.png" alt="image-20230830153109919"></p>
<blockquote>
<p>注意：老版本STL没有提供现成的 <em>string</em> 类型的 hash 函数</p>
</blockquote>
<h5 id="3-3-4-unordered容器"><a href="#3-3-4-unordered容器" class="headerlink" title="3.3.4 unordered容器"></a>3.3.4 unordered容器</h5><h6 id="测试-8"><a href="#测试-8" class="headerlink" title="测试"></a>测试</h6><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/0f4d39c7bf7aed976c5c91d093b3b7ea.png" alt="image-20230818103522538"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_unordered_multiset</span><span class="params">(<span class="type">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\ntest_unordered_multiset().......... \n&quot;</span>;</span><br><span class="line">     </span><br><span class="line">    unordered_multiset&lt;string&gt; c;  <span class="comment">// 创建一个 unordered_multiset  	</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();  <span class="comment">// 记录起始时间							</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>; i&lt; value; ++i)  <span class="comment">// 添加元素到 unordered_multiset 中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">&quot;%d&quot;</span>, <span class="built_in">rand</span>());  <span class="comment">// 将随机数转换为字符串格式</span></span><br><span class="line">            c.<span class="built_in">insert</span>(<span class="built_in">string</span>(buf));  <span class="comment">// 将字符串插入 unordered_multiset 中   			  		</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span>(exception&amp; p) &#123;  <span class="comment">// 捕获可能的异常</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.<span class="built_in">what</span>() &lt;&lt; endl;  <span class="comment">// 输出异常信息</span></span><br><span class="line">            <span class="built_in">abort</span>();  <span class="comment">// 终止程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;毫秒数 : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;  <span class="comment">// 输出时间差，计算插入时间	</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unordered_multiset.size()= &quot;</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// 输出 unordered_multiset 大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unordered_multiset.max_size()= &quot;</span> &lt;&lt; c.<span class="built_in">max_size</span>() &lt;&lt; endl;  <span class="comment">// 输出 unordered_multiset 的最大容量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unordered_multiset.bucket_count()= &quot;</span> &lt;&lt; c.<span class="built_in">bucket_count</span>() &lt;&lt; endl;  <span class="comment">// 输出 unordered_multiset 的桶数量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unordered_multiset.load_factor()= &quot;</span> &lt;&lt; c.<span class="built_in">load_factor</span>() &lt;&lt; endl;  <span class="comment">// 输出 unordered_multiset 的负载因子</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unordered_multiset.max_load_factor()= &quot;</span> &lt;&lt; c.<span class="built_in">max_load_factor</span>() &lt;&lt; endl;  <span class="comment">// 输出 unordered_multiset 的最大负载因子</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unordered_multiset.max_bucket_count()= &quot;</span> &lt;&lt; c.<span class="built_in">max_bucket_count</span>() &lt;&lt; endl;  <span class="comment">// 输出 unordered_multiset 的最大桶数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i=<span class="number">0</span>; i&lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bucket #&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; has &quot;</span> &lt;&lt; c.<span class="built_in">bucket_size</span>(i) &lt;&lt; <span class="string">&quot; elements.\n&quot;</span>;  <span class="comment">// 输出前20个桶中的元素数量</span></span><br><span class="line">    &#125;					</span><br><span class="line">				</span><br><span class="line">    string target = <span class="built_in">get_a_target_string</span>();	</span><br><span class="line">    &#123;</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);  <span class="comment">// 在 unordered_multiset 中使用 std::find(...) 查找目标字符串</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;std::find()，毫秒数 : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;	</span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;found, &quot;</span> &lt;&lt; *pItem &lt;&lt; endl;  <span class="comment">// 如果找到，输出找到的元素</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;not found! &quot;</span> &lt;&lt; endl;  <span class="comment">// 如果未找到，输出未找到的信息	</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">        timeStart = <span class="built_in">clock</span>();		</span><br><span class="line">        <span class="keyword">auto</span> pItem = c.<span class="built_in">find</span>(target);  <span class="comment">// 在 unordered_multiset 中使用 c.find(...) 查找目标字符串</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c.find()，毫秒数 : &quot;</span> &lt;&lt; (<span class="built_in">clock</span>()-timeStart) &lt;&lt; endl;	 </span><br><span class="line">        <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;found, &quot;</span> &lt;&lt; *pItem &lt;&lt; endl;  <span class="comment">// 如果找到，输出找到的元素</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;not found! &quot;</span> &lt;&lt; endl;  <span class="comment">// 如果未找到，输出未找到的信息	</span></span><br><span class="line">    &#125;		</span><br><span class="line">	 </span><br><span class="line">    c.<span class="built_in">clear</span>();  <span class="comment">// 清空unordered_multiset</span></span><br><span class="line">&#125;					</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/3c8d1b775533c415c6169a43a0f05bfc.png" alt="image-20230819164416021"></p>
<p>随机数据填充容器：4406ms；直接搜索 <code>::find()</code>：109ms；<code>c.find()</code>：0ms；前二十个 <em>bucket</em> 中只有一个有24个元素</p>
<h6 id="深度探索-8"><a href="#深度探索-8" class="headerlink" title="深度探索"></a>深度探索</h6><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/a372453cb394dbbeb1c3f8f9f63a6d65.png" alt="image-20230830155954989"></p>
<h3 id="4-分配器"><a href="#4-分配器" class="headerlink" title="4 分配器"></a>4 分配器</h3><h4 id="4-1-测试"><a href="#4-1-测试" class="headerlink" title="4.1 测试"></a>4.1 测试</h4><p>分配器都是与容器共同使用的，一般分配器参数用默认值即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;string, allocator&lt;string&gt;&gt; c1;</span><br></pre></td></tr></table></figure>

<p>不建议直接用分配器分配空间，因为其需要在释放内存时也要指明大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p; 	</span><br><span class="line">p = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">512</span>, (<span class="type">int</span>*)<span class="number">0</span>); <span class="comment">// 临时变量调用函数</span></span><br><span class="line"><span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p,<span class="number">512</span>); <span class="comment">// 释放时需要指明之前申请的大小</span></span><br></pre></td></tr></table></figure>

<h4 id="4-2-源码解析"><a href="#4-2-源码解析" class="headerlink" title="4.2 源码解析"></a>4.2 源码解析</h4><p><strong>VC6</strong>下：<em>allocator</em> 中有 <code>allocate</code>，<code>deallocate</code> 其分别用函数 <code>::operator new</code> 和 <code>::operator delete</code> 来调用 c 中的 <em>malloc</em> 和 <em>free</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">pointer <span class="title">allocate</span><span class="params">(size_type _N, <span class="type">const</span> <span class="type">void</span>*)</span></span>&#123;...&#125; <span class="comment">// 后面一个参数只是用来指明类型的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> _FARQ *_P, size_type)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>这里经过包装还是调用的 malloc 和 free，其执行效率变慢；且如果申请的空间比较小，会有较大比例的额外开销（cookie，调试模式所需空间等等）</p>
<p><strong>GCC2.9</strong> 下：其容器都是调用的名叫 <em>alloc</em> 的分配器</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/655058573413d1f6e2c7c3d9360eccea.png" alt="在这里插入图片描述"></p>
<p>其从0到15有一共16个链表，分别代表8字节到16<em>8字节，例如 #0 的位置用 malloc 要一大块内存，然后做切割，切成一块一块的8字节空间*<em>不带cookie</em></em>，用单向链表穿起来；当要申请6字节的大小的空间时，其就会到 #0 中占用一块 —— 节省空间</p>
<blockquote>
<p>在 GCC4.9 中各个容器又用回了 allocator，而上面的 alloc 变成了<code>__poll_alloc</code></p>
</blockquote>
<h3 id="5-迭代器"><a href="#5-迭代器" class="headerlink" title="5 迭代器"></a>5 迭代器</h3><p>迭代器必须能回答算法的所有提问，才能搭配该算法的所有操作</p>
<h4 id="5-1-迭代器的设计准则"><a href="#5-1-迭代器的设计准则" class="headerlink" title="5.1 迭代器的设计准则"></a>5.1 迭代器的设计准则</h4><p>Iterator 必须提供5种 associated type（说明自己的特性的）来供算法来识别，以便算法正确地使用 Iterator</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category; <span class="comment">// (1)迭代器类别：双向迭代器	</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">// (2)迭代器所指对象的类型</span></span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer; <span class="comment">// (3)迭代器所指对象的指针类型</span></span><br><span class="line">	<span class="keyword">typedef</span> Ref reference; <span class="comment">// (4)迭代器所指对象的引用类型</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; <span class="comment">// (5)两个迭代器之间的距离类型</span></span><br><span class="line">    <span class="comment">// iter1-iter2 时，要保证数据类型以存储任何两个迭代器对象间的距离</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代器回答</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// | Λ</span></span><br><span class="line"><span class="comment">// | |</span></span><br><span class="line"><span class="comment">// | | </span></span><br><span class="line"><span class="comment">// V |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法直接提问</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">algorithm</span><span class="params">(I first, I last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    I::iterator_category</span><br><span class="line">    I::pointer</span><br><span class="line">    I::reference</span><br><span class="line">    I::value_type</span><br><span class="line">    I::difference_type</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但当 Iterator 并不是 class 时，例如指针本身，就不能 <code>typedef</code> 了 —— 这时就要设计一个 <em>Iterator Traits</em></p>
<p><strong>Traits</strong>：用于定义类型特征的信息，从而在编译时根据类型的不同进行不同的操作或处理 —— 类似一个萃取机（针对不同类型做不同操作：偏特化）</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/30a23f652b69e072b3f5d6db9450ecdd.png" alt="image-20230827102754004"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// I是class iterator进</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</span><br><span class="line">    <span class="comment">// typename用于告诉编译器，接下来的标识符是一个类型名，而不是一个变量名或其他名称</span></span><br><span class="line">    <span class="comment">// I::iterator_category 是一个类型名</span></span><br><span class="line">    <span class="comment">// iterator_category是这个迭代器类型内部的一个嵌套类型（typedef ...）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// I是指向T的指针进</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Iterator_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> T* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// I是指向T的常量指针进</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">// 注意是T而不是const T</span></span><br><span class="line">    <span class="comment">// 按理说是const T，但声明一个不能被赋值的变量无用</span></span><br><span class="line">    <span class="comment">// 所以value_type不应加上const</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">const</span> T* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">const</span> T&amp; reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除了 Iterator Traits，还有很多其他 Traits</p>
</blockquote>
<h4 id="5-2-迭代器的分类"><a href="#5-2-迭代器的分类" class="headerlink" title="5.2 迭代器的分类"></a>5.2 迭代器的分类</h4><p>迭代器的分类对算法的效率有很大的影响</p>
<ol>
<li>输入迭代器 <em>input_iterator_tag</em>：istream迭代器</li>
<li>输出迭代器 <em>output_iterator_tag</em>：ostream迭代器</li>
<li>单向迭代器 <em>forward_iterator_tag</em>：forward_list，hash类容器</li>
<li>双向迭代器 <em>bidirectional_iterator_tag</em>： list、红黑树容器</li>
<li>随机存取迭代器 <em>random_access_iterator_tag</em>：array、vector、deque</li>
</ol>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/360bfcd664d8876228828a8a6f2698f4.png" alt="image-20230831085955167"></p>
<blockquote>
<p>用有继承关系的class实现：</p>
<ol>
<li>方便迭代器类型作为参数进行传递，如果是整数的是不方便的</li>
<li>有些算法的实现没有实现所有类型的迭代器类别，就要用继承关系去找父迭代器类别</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> : <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-3迭代器对算法的影响"><a href="#5-3迭代器对算法的影响" class="headerlink" title="5.3迭代器对算法的影响"></a>5.3迭代器对算法的影响</h4><p>1.算法 <em>distance</em> 将会按照迭代器的类别进行不同的操作以提升效率</p>
<ul>
<li>如果迭代器可以跳，直接 <code>last - first</code> 即可</li>
<li>如果迭代器不能跳，就只能一步一步走来计数</li>
</ul>
<p>两者的效率差别很大</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/e81c200aa2b907031a30025d7b089d47.png" alt="image-20230902091354849"></p>
<blockquote>
<p>但如果迭代器类别是 <code>farward_iterator_tag</code> 或者 <code>bidirectional_iterator_tag</code>，该算法没有针对这种类型迭代器实现，就可以用<strong>继承关系</strong>来使用父类的实现（继承关系——<em>“is a”</em> 子类是一种父类，当然可以用父类的实现）</p>
</blockquote>
<p>2.算法 <em>copy</em> 将经过很多判断筛选来找到最高效率的实现</p>
<p>其中用到了 <em>Iterator Traits</em> 和 <em>Type Traits</em> 来进行筛选</p>
<blockquote>
<p><em>has trivial op&#x3D;()</em> 是指的有不重要的拷贝赋值函数（例如复数用的自带的拷贝赋值函数）</p>
</blockquote>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/b573a5f546683feee74f170158c52665.png" alt="image-20230902093014515"></p>
<blockquote>
<p>注意：由于 <em>output_iterator_tag</em>（例如 <em>ostream_iterator</em>）是 <strong>write-only</strong>，无法用 <code>*</code> 来读取内容，所以在设计时就需要再写个专属版本</p>
</blockquote>
<p>在源码中，算法都是模板函数，接受所有的 iterator，但一些算法只能用特定的 iterator，所以其会在模板参数的名称上进行暗示：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/9608ffde3bf57b848da7d2d60f54b389.png" alt="img"></p>
<h3 id="6-算法"><a href="#6-算法" class="headerlink" title="6 算法"></a>6 算法</h3><p>算法的标准样式：需要传进去两个指针</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/b012391cc46975834045199300adc6d6.png" alt="image-20230903084435290"></p>
<h4 id="6-1-算法源码"><a href="#6-1-算法源码" class="headerlink" title="6.1 算法源码"></a>6.1 算法源码</h4><p>算法一般最后一个参数会允许我们传入一个函数对象，使得原来的函数对元素的操作有一定的规则</p>
<h5 id="6-1-1-accumulate"><a href="#6-1-1-accumulate" class="headerlink" title="6.1.1 accumulate"></a>6.1.1 accumulate</h5><p>两个版本：</p>
<ol>
<li><p>元素<strong>累加</strong>到 <em>init</em> 上</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first, InputIterator last, T init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">		init = init + *first; <span class="comment">// 累加到init</span></span><br><span class="line">	<span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>元素<strong>累运算</strong>到 <em>init</em> 上</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">BinaryOperation</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first, InputIterator last, T init, BinaryOperation binary_op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">		init = <span class="built_in">binary_op</span>(init, *first); <span class="comment">// 累运算到init上</span></span><br><span class="line">	<span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这里可以用任意的二元操作（可以是函数，也可以是仿函数）</p>
<p>测试：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>   <span class="comment">// std::minus</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span>      <span class="comment">// std::accumulate</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myfunc</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x<span class="number">+2</span>*y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x<span class="number">+3</span>*y;&#125;</span><br><span class="line">&#125; myobj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_accumulate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;\ntest_accumulate().......... \n&quot;</span>;	</span><br><span class="line">  <span class="type">int</span> init = <span class="number">100</span>;</span><br><span class="line">  <span class="type">int</span> nums[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;using default accumulate: &quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">accumulate</span>(nums,nums<span class="number">+3</span>,init);  <span class="comment">//160</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;using functional&#x27;s minus: &quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums<span class="number">+3</span>, init, <span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">//40</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;using custom function: &quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums<span class="number">+3</span>, init, myfunc);	<span class="comment">//220</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;using custom object: &quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums<span class="number">+3</span>, init, myobj);	<span class="comment">//280</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;															 </span><br></pre></td></tr></table></figure>

<h5 id="6-1-2-for-each"><a href="#6-1-2-for-each" class="headerlink" title="6.1.2 for_each"></a>6.1.2 for_each</h5><p>让范围里的所有元素都依次做同一件事情</p>
<p>Function 可以是函数也可以是仿函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Function</span>&gt;</span><br><span class="line"><span class="function">Function <span class="title">for_each</span><span class="params">(InputIterator first, InputIterator last, Function f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">		<span class="built_in">f</span>(*first);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>与C++11中的 <em>range-based for statement</em> 差不多</p>
</blockquote>
<h5 id="6-1-3-replace…"><a href="#6-1-3-replace…" class="headerlink" title="6.1.3 replace…"></a>6.1.3 replace…</h5><ul>
<li><p><code>replace</code>：范围内的所有等于 <em>old_value</em> 的，都被 <em>new_value</em> 取代</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">replace</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> T&amp; old_value, <span class="type">const</span> T&amp; new_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*first == old_value) *first = new_value;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>replace_if</code>：范围内所有满足 <code>pred()</code> 为 <em>true</em> 的元素都被 <em>new_value</em> 取代</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>,<span class="keyword">class</span> <span class="title class_">Predicate</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">replace_if</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">	Predicate pred, <span class="type">const</span> T&amp; new_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">pred</span>(*first)) *first = new_value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>replace_copy</code>：范围内的元素全部 copy 到新地方，其中所有等于 <em>old_value</em> 的，都被替代为 <em>new_value</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">replace_copy</span><span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">	OutputIterator result, <span class="type">const</span> T&amp; old_value, <span class="type">const</span> T&amp; new_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first, ++result)</span><br><span class="line">	&#123;</span><br><span class="line">		*result = (*first == old_value) ? new_value : *first;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="6-1-4-count…"><a href="#6-1-4-count…" class="headerlink" title="6.1.4 count…"></a>6.1.4 count…</h5><ul>
<li><p><code>count</code>：在范围中计数值等于 <em>value</em> 的个数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type <span class="comment">// 返回类型</span></span><br><span class="line"><span class="built_in">count</span> (InputIterator first, InputIterator last, <span class="type">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*first == value) ++n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>count_if</code>：在范围中计数满足条件 <code>pred()</code> 的个数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type <span class="comment">// 返回类型</span></span><br><span class="line"><span class="built_in">count_if</span> (InputIterator first, InputIterator last, Predicate pred)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">pred</span>(*first)) ++n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<ul>
<li>容器<strong>不带</strong>成员函数 <code>count()</code>：array，vector，forward_list，deque</li>
<li>容器<strong>自带</strong>成员函数 <code>count()</code>：set &#x2F; multiset，map &#x2F; multimap，unordered_set &#x2F; unordered_multiset，unordered_map &#x2F; unorderd_multimap —— 所有关联式容器</li>
</ul>
</blockquote>
<h5 id="6-1-5-find…"><a href="#6-1-5-find…" class="headerlink" title="6.1 5 find…"></a>6.1 5 find…</h5><ul>
<li><p><code>find</code>：在范围内找到值等于 value 的元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (first != last &amp;&amp; *first != value) ++first;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>find_if</code>：在范围内找到满足 <code>pred()</code> 的元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find_if</span><span class="params">(InputIterator first, InputIterator last, Predicate pred)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (first != last &amp;&amp; !<span class="built_in">pred</span>(*first)) ++first;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>都是循序查找，效率低</p>
</blockquote>
<blockquote>
<ul>
<li>容器<strong>不带</strong>成员函数 <code>find()</code>：array，vector，forward_list，deque</li>
<li>容器<strong>自带</strong>成员函数 <code>find()</code>：set &#x2F; multiset，map &#x2F; multimap，unordered_set &#x2F; unordered_multiset，unordered_map &#x2F; unorderd_multimap —— 所有关联式容器</li>
</ul>
</blockquote>
<h5 id="6-1-6-sort"><a href="#6-1-6-sort" class="headerlink" title="6.1.6 sort"></a>6.1.6 sort</h5><p>源码复杂</p>
<p>测试：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myfunc</span> <span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//仿函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j);&#125;</span><br><span class="line">&#125; myobj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义向量</span></span><br><span class="line"><span class="type">int</span> myints[] = &#123;<span class="number">32</span>,<span class="number">71</span>,<span class="number">12</span>,<span class="number">45</span>,<span class="number">26</span>,<span class="number">80</span>,<span class="number">53</span>,<span class="number">33</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">myvec</span><span class="params">(myints, myints<span class="number">+8</span>)</span></span>;          <span class="comment">// 32 71 12 45 26 80 53 33</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用默认的比较(operator &lt;)</span></span><br><span class="line"><span class="built_in">sort</span>(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">begin</span>()<span class="number">+4</span>);         <span class="comment">//(12 32 45 71)26 80 53 33</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用自己的函数作比较</span></span><br><span class="line"><span class="built_in">sort</span>(myvec.<span class="built_in">begin</span>()<span class="number">+4</span>, myvec.<span class="built_in">end</span>(), myfunc); 	<span class="comment">// 12 32 45 71(26 33 53 80)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用自己的仿函数作比较</span></span><br><span class="line"><span class="built_in">sort</span>(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">end</span>(), myobj);      <span class="comment">//(12 26 32 33 45 53 71 80)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用反向迭代器 reverse iterator 和默认的比较(operator &lt;)</span></span><br><span class="line"><span class="built_in">sort</span>(myvec.<span class="built_in">rbegin</span>(), myvec.<span class="built_in">rend</span>());           <span class="comment">// 80 71 53 45 33 32 26 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用显式默认比较(operator &lt;)</span></span><br><span class="line"><span class="built_in">sort</span>(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 12 26 32 33 45 53 71 80   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用另一个比较标准(operator &gt;)</span></span><br><span class="line"><span class="built_in">sort</span>(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 80 71 53 45 33 32 26 12 </span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>容器<strong>不带</strong>成员函数 <code>sort()</code>：array，vector，deque，所有关联式容器（本身就排好序了）</li>
<li>容器<strong>自带</strong>成员函数 <code>sort()</code>：list，forward_list（只能用自带）</li>
</ul>
</blockquote>
<blockquote>
<p><em>reverse iterator</em>：</p>
<p>其中用的是 <em>reverse_iterator</em> —— <strong>iterator adapter</strong></p>
</blockquote>
<h5 id="6-1-7-binary-search"><a href="#6-1-7-binary-search" class="headerlink" title="6.1.7 binary_search"></a>6.1.7 binary_search</h5><p>二分查找是否存在目标元素（并不给予位置），使用前必须先排序；其主要使用 <code>lower_bound()</code> 来找到能放入 <em>val</em> 的最低位置，再判断该元素是否存在</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">binary_search</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	first = <span class="built_in">lower_bound</span>(first, last, value);</span><br><span class="line">	<span class="keyword">return</span> (first != last &amp;&amp; !(value &lt; *first));</span><br><span class="line">    <span class="comment">// first == last 就是序列中所有元素都小于value</span></span><br><span class="line">    <span class="comment">// first == last 时，*first是没有值的，所以需要先检查</span></span><br><span class="line">    <span class="comment">// value &lt; *first 就是序列中没有等于value的</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>lower_bound()</code>：用于在有序序列中查找&#x3D;&#x3D;第一个大于等于&#x3D;&#x3D;该值的元素（包括目标值本身），并返回一个指向该位置的迭代器</p>
<ul>
<li>如果目标值在序列中多次出现，返回第一个出现的位置</li>
<li>如果目标值在序列中不存在，它将返回指向比目标值大的第一个元素位置，或者返回 <code>last</code></li>
</ul>
<p><code>upper_bound()</code>：用于在有序序列中查找&#x3D;&#x3D;第一个大于&#x3D;&#x3D;该值的元素（不包括目标值本身），并返回一个指向该位置的迭代器</p>
<ul>
<li>如果目标值在序列中多次出现，返回第一个大于目标值的位置</li>
<li>如果目标值在序列中不存在，它将返回与 <code>lower_bound()</code> 一样的位置</li>
</ul>
<p>一样是<strong>前闭后开</strong>的原则，且他们都用的是二分查找的方法</p>
</blockquote>
<h3 id="7-仿函数"><a href="#7-仿函数" class="headerlink" title="7 仿函数"></a>7 仿函数</h3><p>仿函数专门为算法服务，设计成一个函数&#x2F;仿函数是为了能传入算法</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/0d779136531fac0e3580ddc909c9ffe2.png" alt="image-20230904081042763"></p>
<p>STL中的每个仿函数都继承了 <code>binary_function</code> &#x2F; <code>unary_function</code>—— 融入到STL中</p>
<p>STL规定每个 Adaptable Function（之后可以改造的函数）都应该继承其中一个（因为之后 Function Adapter 将会提问）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个操作数的操作，例如“!”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">unary_function</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个操作数的操作，例如“+”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg1</span>, <span class="keyword">class</span> <span class="title class_">Arg2</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binary_function</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 理论大小都是0，实际上可能是1（如果有人继承，那就一定是0）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>仿函数是我们自己可能会写的，所以自己写的时候，如果想要融入STL，就要继承上面的两个之一</p>
</blockquote>
<h3 id="8-适配器"><a href="#8-适配器" class="headerlink" title="8 适配器"></a>8 适配器</h3><ul>
<li>适配器 Adapter 只是一个小变化，比如改个接口，函数名称等等</li>
<li>其出现在三个地方：仿函数适配器，迭代器适配器，容器适配器</li>
<li>可以使用继承 &#x2F; 复合的两种方式实现，STL中都用复合</li>
</ul>
<blockquote>
<p>其思想就是将该记的东西记起来，然后看要怎么样去改造它，以便日后使用</p>
</blockquote>
<h4 id="8-1-容器适配器"><a href="#8-1-容器适配器" class="headerlink" title="8.1 容器适配器"></a>8.1 容器适配器</h4><p><em>stack</em>，<em>queue</em> 都是属于 deque 的 Adapter</p>
<p>比如 stack 中将 deque 的 <code>push_back</code> 改名为 <code>push</code></p>
<h4 id="8-2-函数适配器"><a href="#8-2-函数适配器" class="headerlink" title="8.2 函数适配器"></a>8.2 函数适配器</h4><h5 id="8-2-1-binder2nd"><a href="#8-2-1-binder2nd" class="headerlink" title="8.2.1 binder2nd"></a>8.2.1 binder2nd</h5><p><em>binder2nd</em> —— 绑定第二参数</p>
<p>这个例子的OP就是less&lt;int&gt;</p>
<p>1.先是传给bind2nd函数</p>
<p>2.bind2nd生成binder2nd对象</p>
<p>3.对象里面记录op是less&lt;int&gt;，第二参数是40</p>
<p>4.然后都搞定以后返回一个函数对象op（其实返回的是op调用小括号重载运算符，这是一个函数对象）给到count_if作为第三参数，然后继续执行程序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数范围内所有小于40的元素个数</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">count_if</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), </span><br><span class="line">                 <span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数bind2nd，使用方便</span></span><br><span class="line"><span class="comment">// 编译器自动推动op的类型（函数模板）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> binder2nd&lt;Operation&gt; <span class="title">bind2nd</span><span class="params">(<span class="type">const</span> Operation&amp; op, <span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Operation::second_argument_type arg2_type;</span><br><span class="line">	<span class="comment">// 调用ctor生成一个binder2nd临时对象并返回</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">binder2nd</span>&lt;Operation&gt;(op, <span class="built_in">arg2_type</span>(x)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// binder2nd适配器：将二元函数对象转换为一元函数对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binder2nd</span> </span><br><span class="line">	: <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Operation::first_argument_type,</span><br><span class="line">	                        <span class="keyword">typename</span> Operation::result_type&gt;</span><br><span class="line"><span class="comment">// 可能binder2nd也要被改造，要回答问题</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Operation op; <span class="comment">// 内部成员，记录op和第二实参</span></span><br><span class="line">	<span class="keyword">typename</span> Operation::second_argument_type value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">binder2nd</span>(<span class="type">const</span> Operation&amp; x, </span><br><span class="line">			  <span class="type">const</span> <span class="keyword">typename</span> Operation::second_argument_type&amp; y)</span><br><span class="line">		: <span class="built_in">op</span>(x), <span class="built_in">value</span>(y) &#123;&#125; <span class="comment">// ctor，将op和第二实参记录下来</span></span><br><span class="line">	<span class="function"><span class="keyword">typename</span> Operation::result_type</span></span><br><span class="line"><span class="function">		<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Operation::first_argument_type&amp; x)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">op</span>(x, value); <span class="comment">// 实际调用op，第二实参为value</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然还有：<em>binder1st</em> —— 绑定第二参数</p>
<p>新型适配器：<code>bind</code>，代替了 <code>bind1st</code>，<code>bind2nd</code>，<code>binder1st</code>，<code>binder2nd</code></p>
<h5 id="8-2-2-not1"><a href="#8-2-2-not1" class="headerlink" title="8.2.2 not1"></a>8.2.2 not1</h5><p><em>not1</em> —— 否定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数范围内所有大于等于40的元素个数</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">count_if</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), </span><br><span class="line">    			<span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>)));</span><br></pre></td></tr></table></figure>

<h5 id="8-2-3-bind"><a href="#8-2-3-bind" class="headerlink" title="8.2.3 bind"></a>8.2.3 bind</h5><p>C++11提供的 <em>Adapter</em>，其可以绑定：</p>
<ol>
<li>functions</li>
<li>function objects</li>
<li>member functions</li>
<li>data members</li>
</ol>
<p>测试函数 &#x2F; 对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// functions</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">my_divide</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x/y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function objects 测试与functions同理</span></span><br><span class="line"><span class="comment">// divides&lt;double&gt; my_divide;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPair</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// data members</span></span><br><span class="line">	<span class="type">double</span> a, b;</span><br><span class="line">    <span class="comment">// member functions</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">multiply</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a*b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>占位符 <em>placeholders</em>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using namespace std::placeholders;</span><br></pre></td></tr></table></figure>

<p>提供了 <code>_1</code>，<code>_2</code>，<code>_3</code>，·······</p>
<p>下面的的 <code>_1</code> 指的是被绑函数中的第一个参数</p>
</blockquote>
<ul>
<li><p>binding <em>functions &#x2F; function objects</em> 测试</p>
<ul>
<li><p>单纯将两个整数 <code>10</code>，<code>2</code> 绑定到 <code>my_divide</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>(my_divide, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_five</span>() &lt;&lt; endl; <span class="comment">// 5.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用 <code>_1</code> 占据第一参数，第二参数绑定2，即 <code>x/2</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fn_half = <span class="built_in">bind</span>(my_divide, _1, <span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_half</span>(<span class="number">10</span>) &lt;&lt; endl; <span class="comment">// 5.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用 <code>_1</code> 占据第一参数，<code>_2</code> 占据第二参数，即 <code>y/x</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fn_invert = <span class="built_in">bind</span>(my_divide, _2, _1);</span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_invert</span>(<span class="number">10</span>, <span class="number">2</span>) &lt;&lt; endl; <span class="comment">// 0.2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>给 <code>bind</code> 指定了一个模板参数 <code>int</code>，将 <code>my_divide</code> 的返回类型变为 <code>int</code>，即 <code>int(x/y)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fn_rounding = <span class="built_in">bind</span>&lt;<span class="type">int</span>&gt;(my_divide, _1, _2);</span><br><span class="line">cout &lt;&lt; <span class="built_in">fn_rounding</span>(<span class="number">10</span>, <span class="number">3</span>) &lt;&lt; endl; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>binding <em>member functions &#x2F; data members</em> 测试</p>
<p><code>MyPair ten_two &#123;10, 2&#125;;</code> 用C++11的新语法定义一个实例</p>
<p>当函数是类的成员函数时，直接使用函数名并不能获取其地址（因为成员函数隐含地需要一个类的实例来调用），而是需要使用特定的语法来获取指向成员函数的指针。这时，<code>&amp;</code>的使用就显得尤为重要了。对于普通的全局函数或静态成员函数，直接使用函数名和加<code>&amp;</code>都可以获取其地址。</p>
<ul>
<li><p>绑定 <em>member functions</em>，由于成员函数有 <code>this</code>，所以 <code>_1</code> 就相当于 <code>this</code>，即 <code>x.multiply()</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> bound_memfn = <span class="built_in">bind</span>(&amp;MyPair::multiply, _1);</span><br><span class="line">cout &lt;&lt; <span class="built_in">bound_memfn</span>(ten_two) &lt;&lt; endl; <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定 <em>data members</em>，绑定是谁的数据</p>
<p>把实例 <code>ten_two</code> 绑定到 <code>a</code>，即 <code>ten_two.a</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> bound_memdata = <span class="built_in">bind</span>(&amp;MyPair::a, ten_two);</span><br><span class="line">cout &lt;&lt; <span class="built_in">bound_memdata</span>() &lt;&lt; endl; <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>用占位符绑定，即 <code>x.a</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> bound_member_data2 = <span class="built_in">bind</span>(&amp;MyPair::b, _1);</span><br><span class="line">cout &lt;&lt; <span class="built_in">bound_member_data2</span>(ten_two) &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="8-3-迭代器适配器"><a href="#8-3-迭代器适配器" class="headerlink" title="8.3 迭代器适配器"></a>8.3 迭代器适配器</h4><h5 id="8-3-1-reverse-iterator"><a href="#8-3-1-reverse-iterator" class="headerlink" title="8.3.1 reverse_iterator"></a>8.3.1 reverse_iterator</h5><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/b9de6363bddb95f526dab34dc5162fea.png" alt="image-20230922162253063"></p>
<blockquote>
<p>注意：对逆向迭代器取值，就是取其所指正向迭代器的前一个位置</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">reverse_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Iterator current;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 五个associated types与对应的正向迭代器相同</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> Iterator iterator_type; <span class="comment">// 代表正向迭代器</span></span><br><span class="line">	<span class="keyword">typedef</span> reverse_iterator&lt;Iterator&gt; self; <span class="comment">// 代表逆向迭代器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">reverse_iterator</span><span class="params">(iterator_type x)</span> : current(x) &#123;</span>&#125;</span><br><span class="line">	<span class="built_in">reverse_iterator</span>(<span class="type">const</span> self&amp; x) : <span class="built_in">current</span>(x.current) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator_type <span class="title">base</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> current; &#125; <span class="comment">// 取出正向迭代器</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 对逆向迭代器取值，就是取其所指正向迭代器的前一个位置</span></span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="type">const</span> </span><br><span class="line">	&#123; Iterator tmp = current; <span class="keyword">return</span> *--tmp; &#125;</span><br><span class="line"></span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125; <span class="comment">// 同上</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 前进变后退，后退变前进</span></span><br><span class="line">	self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">	&#123; --current; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">	self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">	&#123; ++current; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">	self <span class="keyword">operator</span>+(difference_type n)<span class="type">const</span></span><br><span class="line">	&#123; <span class="keyword">return</span> <span class="built_in">self</span>(current-n); &#125;</span><br><span class="line">	self <span class="keyword">operator</span>-(difference_type n)<span class="type">const</span></span><br><span class="line">	&#123; <span class="keyword">return</span> <span class="built_in">self</span>(current+n); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="8-3-2-inserter"><a href="#8-3-2-inserter" class="headerlink" title="8.3.2 inserter"></a>8.3.2 inserter</h5><p>对于 <code>copy(InputIterator first, InputIterator last, OutputIterator result)</code>，其会不管 <code>OutputIterator</code> 后是否有充裕空间，对 <code>result</code> 开始依次<strong>赋值</strong></p>
<p>但如果使用 <code>inserter</code>，就会有如下用 <code>copy</code> 实现的插入的效果</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/d0a54f540e37805fb74f551d91eaf5c6.png" alt="image-20230922165235291"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; foo, bar;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    foo.<span class="built_in">push_back</span>(i);</span><br><span class="line">    bar.<span class="built_in">push_back</span>(i*<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it = foo.<span class="built_in">begin</span>();</span><br><span class="line"><span class="built_in">advance</span>(it, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(bar.<span class="built_in">begin</span>(), bar.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(foo, it));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：其是 <em>output_iterator_tag</em></p>
</blockquote>
<p>其实现原理核心就是 —— 对 <code>=</code> 的<strong>操作符重载</strong></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241020160248042.png" alt="image-20241020160248042"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">insert_iterator&lt;Container&gt;&amp;</span><br><span class="line"><span class="keyword">operator</span>=(<span class="type">const</span> <span class="keyword">typename</span> Container::value_type&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 关键：转调用insert()</span></span><br><span class="line">	iter = container-&gt;<span class="built_in">insert</span>(iter, val);</span><br><span class="line">	++iter; <span class="comment">// 使其一直随target贴身移动</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-4-X适配器"><a href="#8-4-X适配器" class="headerlink" title="8.4 X适配器"></a>8.4 X适配器</h4><h5 id="8-4-1-ostream-iterator"><a href="#8-4-1-ostream-iterator" class="headerlink" title="8.4.1 ostream_iterator"></a>8.4.1 ostream_iterator</h5><p>其会将 <code>copy</code> 变为一个输出工具，分隔符是 <code>,</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_it</span><span class="params">(cout, <span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), out_it); <span class="comment">// 1,2,3,4,5,6,7,8,9,10,</span></span><br></pre></td></tr></table></figure>

<p>其核心依然是<strong>操作符重载</strong>，这样就相当于 <code>cout&lt;&lt;*first;</code> <code>cout&lt;&lt;&quot;,&quot;;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">basic_ostream&lt;charT,traits&gt;* out_stream;</span><br><span class="line"><span class="type">const</span> charT* delim;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">ostream_iterator&lt;T, charT, traits&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">	*out_stream &lt;&lt; value;</span><br><span class="line">	<span class="keyword">if</span>(delim!=<span class="number">0</span>) *out_stream &lt;&lt; delim; <span class="comment">// 分隔符delimiter</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream_iterator&lt;T,charT,traits&gt;&amp; <span class="keyword">operator</span>*()&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">ostream_iterator&lt;T,charT,traits&gt;&amp; <span class="keyword">operator</span>++()&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其中 <code>out_stream</code> 存的 <code>cout</code>，<code>delim</code> 存的 <code>,</code></p>
<h5 id="8-4-2-istream-iterator"><a href="#8-4-2-istream-iterator" class="headerlink" title="8.4.2 istream_iterator"></a>8.4.2 istream_iterator</h5><p>例一：</p>
<p>在创建 <code>iit</code> 的时候就已经把所有的键盘输入读进去了，之后就是一个一个取出来赋值给 value 的操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> value1, value2;</span><br><span class="line">istream_iterator&lt;<span class="type">double</span>&gt; eos; <span class="comment">// end of stream iterator</span></span><br><span class="line"><span class="function">istream_iterator&lt;<span class="type">double</span>&gt; <span class="title">iit</span><span class="params">(cin)</span></span>; <span class="comment">// 相当于cin&gt;&gt;value</span></span><br><span class="line"><span class="keyword">if</span>(iit != eos)</span><br><span class="line">    value1 = *iit; <span class="comment">// 相当于return value</span></span><br><span class="line">iit++; <span class="comment">// 迭代器不断++，就是不断地读内容</span></span><br><span class="line"><span class="keyword">if</span>(iit != eos)</span><br><span class="line">    value2 = *iit;</span><br></pre></td></tr></table></figure>

<p>例二：</p>
<p>从 <code>cin</code> 读 data，插入到目的容器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">istream_iterator&lt;<span class="type">double</span>&gt; eos; <span class="comment">// end of stream iterator</span></span><br><span class="line"><span class="function">istream_iterator&lt;<span class="type">double</span>&gt; <span class="title">iit</span><span class="params">(cin)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(iit, eos, <span class="built_in">inserter</span>(c,c.<span class="built_in">begin</span>()));</span><br></pre></td></tr></table></figure>

<p>原理依旧是大量的**操作符重载 **—— 就可以改变原函数的作用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">basic_istream&lt;charT, traits&gt;* in_stream;</span><br><span class="line">T value;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="built_in">istream_iterator</span>():<span class="built_in">in_stream</span>(<span class="number">0</span>)&#123;&#125; <span class="comment">// eos</span></span><br><span class="line"><span class="built_in">istream_iterator</span>(istream_type&amp; s):<span class="built_in">in_stream</span>(&amp;s)&#123;++*<span class="keyword">this</span>;&#125; <span class="comment">// 进++</span></span><br><span class="line"></span><br><span class="line">istream_iterator&lt;T,charT,traits,Distance&gt;&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(in_stream &amp;&amp; !(*in_stream &gt;&gt; value)) <span class="comment">// 开始读了</span></span><br><span class="line">        in_stream = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="9-STL周围"><a href="#9-STL周围" class="headerlink" title="9 STL周围"></a>9 STL周围</h3><h4 id="9-1-万用Hash-Function"><a href="#9-1-万用Hash-Function" class="headerlink" title="9.1 万用Hash Function"></a>9.1 万用Hash Function</h4><p>Hash Function的常规写法：其中 <code>hash_val</code> 就是万用Hash Function</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustumerHash</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Customer&amp; c)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> <span class="built_in">hash_val</span>(c.<span class="built_in">fname</span>(), c.<span class="built_in">lname</span>(), c.<span class="built_in">no</span>()); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>还可以直接用函数实现，或者写一个 <code>hash</code> 的特化版本</p>
</blockquote>
<p>原理：</p>
<p>通过三个函数重载实现从给入数据中逐一提取来不断改变 <code>seed</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个函数 首先进入该函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">hash_val</span><span class="params">(<span class="type">const</span> Type&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">size_t</span> seed = <span class="number">0</span>; <span class="comment">// 设置初始seed</span></span><br><span class="line">	<span class="built_in">hash_val</span>(seed, args...); <span class="comment">// 进入第二个函数</span></span><br><span class="line">	<span class="keyword">return</span> seed; <span class="comment">// seed就是最后的HashCode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个函数 该函数中逐一提取一个参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">hash_val</span><span class="params">(<span class="type">size_t</span>&amp; seed, <span class="type">const</span> T&amp; val, <span class="type">const</span> Types&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">hash_combine</span>(seed, val); <span class="comment">// 逐一取val，改变seed</span></span><br><span class="line">	<span class="built_in">hash_val</span>(seed, args...); <span class="comment">// 递归调用自己，直到取完进入第三个函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">hash_val</span><span class="params">(<span class="type">size_t</span>&amp; seed, <span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">hash_combine</span>(seed, val); <span class="comment">// 取最后一个val，改变seed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变seed的函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">hash_combine</span><span class="params">(<span class="type">size_t</span>&amp; seed, <span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 乱七八糟的运算，越乱越好</span></span><br><span class="line">	seed ^= <span class="built_in">hash</span>&lt;T&gt;()(val) + <span class="number">0x9e3779b9</span> + (seed&lt;&lt;<span class="number">6</span>) + (seed&gt;&gt;<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最后的seed就是hash code</p>
<p>C++11中 <em>variadic templates</em>：</p>
<p>从传入的内容（任意个数，任意元素类型）分为一个和其他，递归再分为一个和其他······</p>
</blockquote>
<blockquote>
<p><em>0x9e3779b9</em>：是黄金比例！</p>
</blockquote>
<p>C++11及其后续版本并没有为每个类型都自动提供哈希函数，但它确实为一些标准类型提供了<code>std::hash</code>的特化，并且允许开发者为用户定义的类型提供自己的<code>std::hash</code>特化。</p>
<h4 id="9-2-Tuple"><a href="#9-2-Tuple" class="headerlink" title="9.2 Tuple"></a>9.2 Tuple</h4><p>可以将一些东西组合在一起</p>
<h5 id="9-2-1-用例"><a href="#9-2-1-用例" class="headerlink" title="9.2.1 用例"></a>9.2.1 用例</h5><ul>
<li><p>创建 <code>tuple</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tuple&lt;string, <span class="type">int</span>, <span class="type">int</span>, complex&lt;<span class="type">double</span>&gt;&gt; t; </span><br><span class="line"></span><br><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">float</span>, string&gt; <span class="title">t1</span><span class="params">(<span class="number">41</span>, <span class="number">6.3</span>, <span class="string">&quot;nico&quot;</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> t2 = <span class="built_in">make_tuple</span>(<span class="number">22</span>, <span class="number">44</span>, <span class="string">&quot;stacy&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出 <code>tuple</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出t1中的第一个</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t1) &lt;&lt; endl; <span class="comment">// 41</span></span><br><span class="line">cout &lt;&lt; t &lt;&lt; endl; <span class="comment">// 在VS2022上并没有&lt;&lt;的重载 需要自己写一个重载</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t1 = t2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(t1 &lt; t2) <span class="comment">// 以特定的方式进行的比较 里面的东西拿出来一个一个比</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定解包</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">float</span>, string&gt; <span class="title">t3</span><span class="params">(<span class="number">77</span>, <span class="number">1.1</span>, <span class="string">&quot;more light&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">float</span> f;</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="built_in">tie</span>(i, f, s) = t3; <span class="comment">// i == 77, f == 1.1, s == &quot;more light&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><pre><code class="language-cpp">// tuple里有多少类型
tuple_size&lt; tuple&lt;int, float, string&gt; &gt;::value; // 3

// 取tuple里面的类型，前面一堆代表float
tuple_element&lt;1, TupleType&gt;::type fl = 1.0; // float fl = 1.0;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### 9.2.2 原理</span><br><span class="line"></span><br><span class="line">依然是使用 *variadic templates*，通过递归继承，不断从 `...` 中提取内容</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">// 空的tuple</span><br><span class="line">template &lt;&gt; class tuple&lt;&gt; &#123;&#125;; // 直到取完</span><br><span class="line"></span><br><span class="line">// tuple主体</span><br><span class="line">template &lt;typename Head, typename... Tail&gt;</span><br><span class="line">class tuple&lt;Head, Tail...&gt;</span><br><span class="line">	: private tuple&lt;Tail...&gt; // 递归继承</span><br><span class="line">&#123;</span><br><span class="line">    typedef tuple&lt;Tail...&gt; inherited;</span><br><span class="line">public:</span><br><span class="line">	tuple() &#123;&#125;</span><br><span class="line">	tuple(Head v, Tail... vtail) </span><br><span class="line">        : m_head(v), inherited(vtail...) &#123;&#125;</span><br><span class="line">	...</span><br><span class="line">protected:</span><br><span class="line">	Head m_head; // 每次取出的元素</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/79844991bf585c8b1cb306fd337febc8.png" alt="image-20230923111219018"> 👈🏻不断的继承就可以实现不同类型的组合了</p>
<p>其余函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">	<span class="function">Head <span class="title">head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_head; &#125;</span><br><span class="line">	<span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125; <span class="comment">// 通过转型获得Tail部分</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/e0e10eb9bc7c8768450cb051eebe8293.png" alt="image-20230923112317405"> 一般不这么用</p>
<p>出去head的41，剩下的都是tail部分，所以出来的是6.3</p>
<h4 id="9-3-type-traits"><a href="#9-3-type-traits" class="headerlink" title="9.3 type traits"></a>9.3 type traits</h4><h5 id="9-3-1-用例"><a href="#9-3-1-用例" class="headerlink" title="9.3.1 用例"></a>9.3.1 用例</h5><p><strong>GCC2.9</strong>中：</p>
<p>默认的 <code>__type_traits</code> 进行了一系列<strong>泛化</strong>的设定（<em>trivial</em> 是不重要的意思）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">struct</span> <span class="title class_">__true_type</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__false_type</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> __true_type this_dummy_member_must_be_first;</span><br><span class="line">	<span class="keyword">typedef</span> __false_type has_trivial_default_constructor;</span><br><span class="line">	<span class="keyword">typedef</span> __false_type has_trivial_copy_constructor;</span><br><span class="line">	<span class="keyword">typedef</span> __false_type has_trivial_assignment_operator;</span><br><span class="line">	<span class="keyword">typedef</span> __false_type has_trivial_destructor;</span><br><span class="line">	<span class="keyword">typedef</span> __false_type is_POD_type; <span class="comment">// Plain Old Data 类似C的struct</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还会通过<strong>特化</strong>来实现针对不同类型的设定，例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> __true_type has_trivial_default_constructor;</span><br><span class="line">	<span class="keyword">typedef</span> __true_type has_trivial_copy_constructor;</span><br><span class="line">	<span class="keyword">typedef</span> __true_type has_trivial_assignment_operator;</span><br><span class="line">	<span class="keyword">typedef</span> __true_type has_trivial_destructor;</span><br><span class="line">	<span class="keyword">typedef</span> __true_type is_POD_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>C++11</strong>中：<br>有了很多个 <em>type traits</em>，可以回答更多问题</p>
<p>测试：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; is_void&lt;T&gt;::value &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; is_integral&lt;T&gt;::value &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; is_floating_point&lt;T&gt;::value &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; is_array&lt;T&gt;::value &lt;&lt; endl;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/ea5226fb1e12611fdd9c9920b6aeb01c.png" alt="image-20230923192837871"></p>
<p>不论是什么类型都可以<strong>自动检测</strong>它的 <em>traits</em>，非常厉害！（里面有虚函数——就能自动检测出它有多态性）</p>
<h5 id="9-3-2-原理"><a href="#9-3-2-原理" class="headerlink" title="9.3.2 原理"></a>9.3.2 原理</h5><p>模板的作用</p>
<p>例 <code>is_integral</code></p>
<p>依然是采用的一种问答的方式实现的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_integral</span></span><br><span class="line">	:<span class="keyword">public</span> __is_intagral_helper&lt;<span class="keyword">typename</span> remove_cv&lt;_Tp&gt;::type&gt;::type</span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure>

<p>首先 <code>remove_cv</code>（<code>const</code> 和 <code>volatile</code>）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过偏特化实现remove const</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_const</span></span><br><span class="line">&#123; <span class="keyword">typedef</span> _Tp type &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_const</span>&lt;_Tp <span class="type">const</span>&gt;</span><br><span class="line">&#123; <span class="keyword">typedef</span> _Tp type &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove volatile 同理</span></span><br></pre></td></tr></table></figure>

<p>再通过 <code>__is_intagral_helper</code> 进行问答</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过偏特化实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__is_integral_helper</span></span><br><span class="line">	:<span class="keyword">public</span> false_type &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__is_integral_helper</span>&lt;<span class="type">bool</span>&gt;</span><br><span class="line">	:<span class="keyword">public</span> true_type &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__is_integral_helper</span>&lt;<span class="type">int</span>&gt;</span><br><span class="line">	:<span class="keyword">public</span> true_type &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__is_integral_helper</span>&lt;<span class="type">long</span>&gt;</span><br><span class="line">	:<span class="keyword">public</span> true_type &#123; &#125;;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其他深入 class 内部的一些 traits 比如是否有虚函数，是否是一个类，是否是POD等等，其实现可能都与编译器有关</p>
</blockquote>
<h4 id="9-4-move"><a href="#9-4-move" class="headerlink" title="9.4 move"></a>9.4 move</h4><p><em>moveable class</em> 中有：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// move ctor</span></span><br><span class="line"><span class="built_in">MyString</span>(MyString&amp;&amp; str) <span class="keyword">noexcept</span> <span class="comment">// 用&amp;&amp;与普通版本区别开</span></span><br><span class="line">    : _data(str._data), _len(str._len)</span><br><span class="line">&#123;</span><br><span class="line">    str._len = <span class="number">0</span>;</span><br><span class="line">    str._data = <span class="literal">NULL</span>; <span class="comment">// 避免析构函数释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// move assignment</span></span><br><span class="line">MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str)</span><br><span class="line">    &#123;</span><br><span class="line">        _len = str._len;</span><br><span class="line">        _data = str._data;</span><br><span class="line">        str._len = <span class="number">0</span>;</span><br><span class="line">        str._data = <span class="literal">NULL</span>; <span class="comment">// 避免析构函数释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dtor</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">MyString</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_data) <span class="keyword">delete</span> _data; <span class="comment">// 一定要检查</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">C11</span><span class="params">(C1)</span></span>; <span class="comment">// ctor</span></span><br><span class="line"><span class="function">MyString <span class="title">C12</span><span class="params">(move(C1))</span></span>; <span class="comment">// move ctor</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/fd400006aa48c698b6d7e0cd9de1dc13.png" alt="image-20230924094317369"> 是&#x3D;&#x3D;浅拷贝&#x3D;&#x3D;，并且把之前的指向去除了</p>
<p>对于 vector 这样的容器，其用 move 就只是 swap 了三根指针，非常快！</p>
<blockquote>
<p>move 之后原来的东西不能再使用</p>
<p>拿数据插入容器，用<strong>临时对象</strong>，编译器看到就会自动使用 move 版本的</p>
<p><code>MyString C11(C1);</code> 时，创建了一个实例 C11，编译器就不知道是否能用 move，就需要自己 <code>MyString C12(move(C1));</code> 使用 move，但注意之后&#x3D;&#x3D;一定不能用原来的 <code>C1</code>&#x3D;&#x3D;</p>
</blockquote>
<blockquote>
<p><code>&amp;&amp;</code>（右值引用）这是C++11引入的特性，右值引用用于处理临时对象或将资源所有权转移给其他对象，以提高性能和资源管理</p>
</blockquote>
]]></content>
      <categories>
        <category>从零开始的C++の学习之路</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>施磊C++ | 进阶学习笔记</title>
    <url>/2024/10/16/C++/%E6%96%BD%E7%A3%8AC++%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B%20%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%20%E5%8D%9A%E5%AE%A2%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="施磊C-高级进阶课程-学习笔记-博客汇总"><a href="#施磊C-高级进阶课程-学习笔记-博客汇总" class="headerlink" title="施磊C++高级进阶课程 | 学习笔记 | 博客汇总"></a>施磊C++高级进阶课程 | 学习笔记 | 博客汇总</h1><p>以下是CSDN链接</p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/142902671">施磊C++ | 进阶学习笔记 | 1.对象的应用优化、右值引用的优化-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/142902727">施磊C++ | 进阶学习笔记 | 2.智能指针-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/142902748">施磊C++ | 进阶学习笔记 | 3.绑定器和函数对象、lambda表达式-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/142904733">施磊C++ | 进阶学习笔记 | 4.c++11内容汇总、多线程应用实践-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/142959676">施磊C++ | 进阶学习笔记 | 5.设计模式-CSDN博客</a></p>
<p>剩余有关面试的等到明年投简历前学习</p>
]]></content>
      <categories>
        <category>从零开始的C++の学习之路</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>侯捷内存管理学习笔记 | C++</title>
    <url>/2024/10/24/C++/%E4%BE%AF%E6%8D%B7%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="侯捷内存管理学习笔记"><a href="#侯捷内存管理学习笔记" class="headerlink" title="侯捷内存管理学习笔记"></a>侯捷内存管理学习笔记</h1><h1 id="第一章节-primitives"><a href="#第一章节-primitives" class="headerlink" title="第一章节 primitives"></a>第一章节 primitives</h1><h2 id="零-new和delete概述"><a href="#零-new和delete概述" class="headerlink" title="零.new和delete概述"></a>零.new和delete概述</h2><p>C++中的<code>new</code>和<code>delete</code>是用于动态内存分配和释放的操作符，它们的底层机制和工作原理相对复杂，但也可以简单清晰地解释。</p>
<h3 id="new的底层机制和工作原理"><a href="#new的底层机制和工作原理" class="headerlink" title="new的底层机制和工作原理"></a><code>new</code>的底层机制和工作原理</h3><ol>
<li><strong>内存分配</strong>：<ul>
<li>当使用<code>new</code>操作符时，它首先会调用底层的内存分配函数（如<code>operator new</code>），这个函数通常是对<code>malloc</code>的封装。<code>malloc</code>会从堆中分配足够的内存空间。</li>
<li>如果内存分配失败，<code>operator new</code>会抛出一个<code>std::bad_alloc</code>异常，而不是像<code>malloc</code>那样返回<code>NULL</code>。</li>
</ul>
</li>
<li><strong>对象构造</strong>：<ul>
<li>内存分配成功后，<code>new</code>会调用对象的构造函数来初始化分配的内存区域。对于内置类型（如<code>int</code>、<code>char</code>等），这一步可能只是简单地设置值；而对于自定义类型，则会调用其构造函数。</li>
</ul>
</li>
<li><strong>返回指针</strong>：<ul>
<li>最后，<code>new</code>返回一个指向已分配并初始化对象的指针。</li>
</ul>
</li>
</ol>
<h3 id="delete的底层机制和工作原理"><a href="#delete的底层机制和工作原理" class="headerlink" title="delete的底层机制和工作原理"></a><code>delete</code>的底层机制和工作原理</h3><ol>
<li><strong>对象析构</strong>：<ul>
<li>当使用<code>delete</code>操作符时，它首先会调用对象的析构函数来清理对象中的资源。这一步对于自定义类型尤其重要，因为析构函数通常包含释放动态分配资源（如内存、文件句柄等）的代码。</li>
</ul>
</li>
<li><strong>内存释放</strong>：<ul>
<li>析构函数调用完成后，<code>delete</code>会调用底层的内存释放函数（如<code>operator delete</code>），这个函数通常是对<code>free</code>的封装。<code>free</code>会将之前分配的内存空间归还给堆管理器。</li>
</ul>
</li>
<li><strong>指针置空</strong>（可选）：<ul>
<li>虽然<code>delete</code>本身不会将指针置为空（<code>nullptr</code>），但这是一个良好的编程习惯。在释放内存后，将指针置为空可以避免悬空指针（dangling pointer）问题，即指针仍然指向已释放的内存区域。</li>
</ul>
</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>匹配使用</strong>：确保使用<code>new</code>分配的内存使用<code>delete</code>释放，使用<code>new[]</code>分配的内存使用<code>delete[]</code>释放。不匹配使用会导致未定义行为。</li>
<li><strong>不要重复释放</strong>：不要对同一个内存块调用<code>delete</code>（或<code>delete[]</code>）多次。</li>
<li><strong>避免使用已释放的内存</strong>：一旦内存被<code>delete</code>释放，就不要再尝试访问它。</li>
</ul>
<p>在C++<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D&spm=1001.2101.3001.7020">内存分配</a>当中分为四个阶层：</p>
<p>  1.调用容器<br>  2.使用new关键词<br>  3.直接调用malloc和free<br>  4.调用与系统绑定的内存分配函数</p>
<p>这四个阶层有层层包含的关系：<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/fb22e0d287c10cec142d938782488bd1.png" alt="在这里插入图片描述"><br>从::operateor new()开始，可以进行重载。同理，delete也可以进行重载。</p>
<p>new会调用operator new，然后operator new调用malloc进行内存分配</p>
<p>在第四个，你可以自己设计一个分配器搭配一个容器。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/e9b90ea7af531da14134181022627ffd.png" alt="在这里插入图片描述"></p>
<h2 id="一、new-和delete"><a href="#一、new-和delete" class="headerlink" title="一、new()和delete()"></a>一、new()和delete()</h2><h3 id="1-new"><a href="#1-new" class="headerlink" title="1. new()"></a>1. new()</h3><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/1fb2df6813e4159926c51d3c976ce583.png" alt="在这里插入图片描述"><br>new关键词相当于进行<strong>两个步骤</strong>：</p>
<p>  1.调用operator new，分配所创建对象需要的内存（其内部就是对malloc()的封装）<br>  2.调用对象的构造函数</p>
<p>如果某个步骤发生错误，则抛出异常。</p>
<p>注意：在一些版本中，只有编译器可以直接调用构造函数，如果在程序中自己调用则会出错。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A* pA = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">1</span>);<span class="comment">//正确</span></span><br><span class="line">	</span><br><span class="line">pA-&gt;A::<span class="built_in">A</span>(<span class="number">3</span>);<span class="comment">//错误</span></span><br><span class="line">	</span><br><span class="line">A::<span class="built_in">A</span>(<span class="number">5</span>);<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<h3 id="2-delete"><a href="#2-delete" class="headerlink" title="2.delete()"></a>2.delete()</h3><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/2346a3be131178d230c20810c7ad0401.png" alt="在这里插入图片描述"><br>相应的，delete关键词也相当于两个步骤：</p>
<p>  1.先对需要delete的对象进行析构，调用其析构函数<br>  2.再释放该对象所使用的内存空间（内部是封装了free()函数）</p>
<h3 id="3-new-和delete"><a href="#3-new-和delete" class="headerlink" title="3.new[ ]和delete[ ]"></a>3.new[ ]和delete[ ]</h3><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/6e11004bdebb4b94bb4a697d71b1c8f6.png" alt="在这里插入图片描述"><br>  使用new[ ]时，顺序分配对象所需空间，指针指向第一个内存空间，但不调用构造函数进行初始化（如果对象内不包含指针成员则无影响，包含则有影响）,后续可以通过指针对各个对象进行初始化。同时在空间开头会有一个cookie，记录了这个空间共有几个对象。<br>  使用delete[ ]时会读取cookie，倒序析构对象，并释放对应的空间；如果直接使用delete则不会读取cookie，会导致空间错位，程序报错，<strong>所以new[ ]必须要跟delet[]对应</strong>。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/c04ee6cf1cf361fb2e3bea6657eccc19.png" alt="在这里插入图片描述"></p>
<h3 id="4-placement-new（定位new）"><a href="#4-placement-new（定位new）" class="headerlink" title="4.placement new（定位new）"></a>4.placement new（定位new）</h3><p>定位new（Placement new）是C++中的一个高级特性，它允许在已分配的内存上构造对象，而不会进行新的内存分配。以下是对定位new的详细解释：</p>
<h4 id="一、定义与原理"><a href="#一、定义与原理" class="headerlink" title="一、定义与原理"></a>一、定义与原理</h4><ul>
<li><strong>定义</strong>：定位new就是在已分配好的内存空间中调用构造函数对象进行初始化。它不会申请新的内存空间，而是利用已经分配好的空间来构造对象。</li>
<li><strong>原理</strong>：使用定位new时，程序员需要指定一个已经分配好的内存区域，然后在这个区域中调用对象的构造函数来构造对象。由于对象的空间是预先分配好的，因此定位new不会进行额外的内存分配操作。</li>
</ul>
<h4 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a>二、使用方法</h4><p>定位new的使用语法通常如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cpp复制代码</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> (placement_address) <span class="built_in">type</span> (initializer_list);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>placement_address</code>：这是一个指向已分配内存的指针，表示对象将要被构造的位置。</li>
<li><code>type</code>：这是要构造的对象的类型。</li>
<li><code>initializer_list</code>：这是传递给对象构造函数的初始化列表（可选）。</li>
</ul>
<p>例如，假设有一个已经分配好的内存区域<code>mem</code>，并且想要在这个区域中构造一个类型为<code>A</code>的对象，可以使用以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cpp复制代码</span><br><span class="line"></span><br><span class="line">A* p = <span class="built_in">new</span> (mem) A;</span><br></pre></td></tr></table></figure>

<p>此时，指针<code>p</code>和数组名<code>mem</code>指向同一片存储区，对象<code>A</code>将在<code>mem</code>指向的内存区域中被构造。</p>
<h4 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a>三、注意事项</h4><ul>
<li><strong>内存管理</strong>：由于定位new不会进行内存分配，因此程序员需要手动管理内存。在对象不再需要时，需要显式地调用析构函数来释放对象占用的内存。</li>
<li><strong>对象生命周期</strong>：使用定位new构造的对象，其生命周期由程序员负责管理。程序员需要确保在对象不再需要时正确地调用析构函数，以避免内存泄漏和悬空指针等问题。</li>
<li><strong>使用场景</strong>：定位new通常用于内存池或自定义内存管理等场景，在这些场景中，程序员需要精确地控制内存的使用和对象的构造与析构。</li>
</ul>
<h4 id="四、示例"><a href="#四、示例" class="headerlink" title="四、示例"></a>四、示例</h4><p>以下是一个使用定位new的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span> <span class="comment">// 包含定位new所需的头文件  </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A&#x27;s constructor called&quot;</span> &lt;&lt; std::endl; &#125;  </span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A&#x27;s destructor called&quot;</span> &lt;&lt; std::endl; &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">char</span> mem[<span class="built_in">sizeof</span>(A)]; <span class="comment">// 分配一块足够大的内存区域来存储对象A  </span></span><br><span class="line">    A* p = <span class="built_in">new</span> (mem) A; <span class="comment">// 在指定的内存区域中构造对象A  </span></span><br><span class="line">    <span class="comment">// ... 使用对象p ...  </span></span><br><span class="line">    p-&gt;~<span class="built_in">A</span>(); <span class="comment">// 显式地调用析构函数来释放对象占用的内存  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先分配了一块足够大的内存区域<code>mem</code>来存储对象<code>A</code>，然后使用定位new在<code>mem</code>指向的内存区域中构造了一个对象<code>A</code>。最后，我们显式地调用了析构函数来释放对象占用的内存。</p>
<p>综上所述，定位new是C++中的一个高级特性，它允许在已分配的内存上构造对象而不会进行新的内存分配。在使用时需要谨慎处理内存管理和对象生命周期的问题以确保程序的正确性和稳定性。</p>
<p>课程中：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/806bc9dcf641fc9cad074fe303f5e661.png" alt="在这里插入图片描述"><br>  形式就相当于new ( p ) ,是将一块已经分配好了的内存用于构建对象，new则是当场分配一块内存用于构建对象，<strong>并没有特定的placement delete</strong>。</p>
<p>其中buf是已经分配好的内存</p>
<p>上面第二行这一行会被编译器解释为这三行</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241022174140625.png" alt="image-20241022174140625"></p>
<p>1.给一块已经分配好的内存，这一步其实什么都不会做，因为内存已经分配好了</p>
<p>2.转型</p>
<p>3.调用对象的构造函数</p>
<p>其实就相当于调用了一次构造函数  </p>
<h2 id="二、重载"><a href="#二、重载" class="headerlink" title="二、重载"></a>二、重载</h2><h3 id="1-new-和delete"><a href="#1-new-和delete" class="headerlink" title="1.new()和delete()"></a>1.new()和delete()</h3><p>  new()表达式本身不可重载，表示operator new()，但operator new()可以重载，分为全局和类内，通常重载类内的。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/13d713585ebd65109ad47be8f77214c5.png" alt="在这里插入图片描述"><br>  类内对operator new()和operator delete()进行重载，operator new()重载的第一参数必须是size_t，其大小足以保证存储内存中对象的大小，否则将抛出异常。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/6ad3aabcf4fc78e9b7d97c47e6ef4665.png" alt="在这里插入图片描述"><br>  如果在创建对象时，直接调用new()和delete()，则调用的是类内重载的new()和delete()，是编译器调用的，并且重载的new和delete这两个函数一定得是<strong>静态的</strong>，因为调用的时候还没有实例对象<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/24337688e22150f0f8c9ce019bae02d6.png" alt="在这里插入图片描述"><br>  如果调用::new()和::delete()，则调用的是全局的new()和delete()<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/3eaa396bb749d3a72b403e7246f4be70.png" alt="在这里插入图片描述"><br>  <strong>注意：</strong></p>
<p>这里说的是placement operator delete不是operator delete</p>
<p>前者是下图说的抛异常的时候用，后者是和operator new配对的</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/83568284eb7542fbc96d835b3ea4f009.png" alt="在这里插入图片描述"></p>
<p>很好的例子：</p>
<p>这是我们平常用的string，它的new会多出来一个extra，所以要重载</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241022201812108.png" alt="image-20241022201812108"></p>
<p><strong>重载全局的operator new和operator delete的接口的格式</strong></p>
<p>new一定要写参数size，delete写ptr指针，而size可写可不写是一个选项</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241023221714126.png" alt="image-20241023221714126"></p>
<h3 id="2-allocator-和deallocator"><a href="#2-allocator-和deallocator" class="headerlink" title="2.allocator()和deallocator()"></a>2.allocator()和deallocator()</h3><p>  进行类内operator new()和operator delete()的重载，主要是为了减少::operator new()和::operator delete()的调用。因为::operator new()是对malloc()适配，每调用一次malloc(),就会产生头尾两个cookie共8个字节，既造成了空间浪费，速度上也更慢。</p>
<p>  但对每一个不同的类进行重载，并且每次重载的内容都差不多，会造成大量重复劳动，会有很多的重复代码，所以设计一个概念把之前重载中共同的部分抽象出来，作为一个类来使用，即为allocator()和deallocator()。</p>
<p>  设计一个allocator的类，在类里面定义allocator()和deallocator()。allocator()使用<strong>内存池</strong>模式，每次申请一大块内存，然后将这块内存切割小块，大小等同于对象的大小，并串成一个链表。这样只有在申请一大块内存的时候会调用malloc()，生成两个cookie，创建对象时不使用malloc()，而是从链表中取出一块分给对象，调用deallocator()也不将释放的内存free()给系统，而且将这块内存重新插入链表顶端。</p>
<p><strong>重载operator new和delete的版本</strong></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241022202556920.png" alt="image-20241022202556920"></p>
<p>测试结果会有cookie的空间占用</p>
<p>现在这样就不需要上面又是struct又是union的</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/253eacc54f593972a8d0bdd9cc291a9f.png" alt="在这里插入图片描述"></p>
<p><strong>static allocator</strong>（用allocator的版本）</p>
<p>对象需要重载new和delete时，直接在类内创建一个allocator对象，调用allocator的类方法，即上面那张图。</p>
<p>使用static使得每个类有一个自己的内存池，进行内存管理，而不是一个对象一个内存池</p>
<p>测试结果没有cookie的空间占用</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/f47cdf391bf7b18f054c1cc356fb9d3f.png" alt="在这里插入图片描述"></p>
<p>application class的所有内存分配的细节都让allocator去操心，我们的工作是让application class正常工作</p>
<p><strong>使用宏把重复的代码定义一下来使用的版本</strong></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241022205628521.png" alt="image-20241022205628521"></p>
<p>测试结果没有cookie的空间占用，和static版本相同</p>
<p><code>技术的演进</code></p>
<p>new delete针对一个对象-&gt;static alloctor针对一个类-&gt;globa allocator针对一个标准库，里面有16个链表（static alloctor只有一个链表）</p>
<h3 id="3-new-handler"><a href="#3-new-handler" class="headerlink" title="3.new_handler"></a>3.new_handler</h3><p>  在调用内存失败，抛出异常之前，会调用一个由自己设计的一个补救函数，即new_handler()。若new_handler()中没有abort()或者exit()，或者没有让更多内存可用，则会一直调用new_handler()直至满足内存需求。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241022210612589.png" alt="image-20241022210612589"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用：</span></span><br><span class="line"><span class="comment">//在main中写</span></span><br><span class="line"><span class="built_in">set_new_handler</span>(自己写的补救函数名);</span><br></pre></td></tr></table></figure>

<p>注：</p>
<p>new delete的重载不可以是&#x3D;default的，但可以是&#x3D;delete的</p>
<h1 id="第二章节-std-allocator（为小区块服务）"><a href="#第二章节-std-allocator（为小区块服务）" class="headerlink" title="第二章节 std::allocator（为小区块服务）"></a>第二章节 std::allocator（为小区块服务）</h1><p>西北有高楼，上与浮云齐。</p>
<p>在工业级别，可能会用malloc上百万次，即使是有内存池的存在，cookie占用的额外内存还是不容小觑，同时malloc也挺慢的，所以这部分的目标就是去掉malloc，使得效率提高，空间率精简</p>
<p>去除cookie的先决条件是申请的块是一样的大小，如果块有大有小那就不能去掉，因为要标识块的大小，如果是一样的大小，那就可以去掉。而一个类的对象实例大小肯定是一样的。</p>
<h2 id="1-占用内存的计算方式"><a href="#1-占用内存的计算方式" class="headerlink" title="1.占用内存的计算方式"></a>1.占用内存的计算方式</h2><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241022215936337.png" alt="image-20241022215936337"></p>
<p>0xC是block size,是咱们申请分配的内存大小，实际给咱的是计算后的结果即0x40</p>
<h2 id="2-不同版本的allocator设计"><a href="#2-不同版本的allocator设计" class="headerlink" title="2.不同版本的allocator设计"></a>2.不同版本的allocator设计</h2><h3 id="1-VC6、BC5、G2-9和G4-9的allocator"><a href="#1-VC6、BC5、G2-9和G4-9的allocator" class="headerlink" title="1. VC6、BC5、G2.9和G4.9的allocator"></a>1. VC6、BC5、G2.9和G4.9的allocator</h3><h4 id="VC6的标准分配器"><a href="#VC6的标准分配器" class="headerlink" title="VC6的标准分配器"></a>VC6的标准分配器</h4><p>这个编译器的allocator没有任何特殊设计，单纯是调用malloc和free，分配是以对象元素为单位。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/f239c045988301e668255bd886d3dc1d.png" alt="在这里插入图片描述"></p>
<h4 id="BC5的标准分配器"><a href="#BC5的标准分配器" class="headerlink" title="BC5的标准分配器"></a>BC5的标准分配器</h4><p>和VC6相同，没有任何特殊设计。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/81f8c769d550ded1f23281713fa63c6e.png" alt="在这里插入图片描述"></p>
<h4 id="GNU4-9的标准分配器"><a href="#GNU4-9的标准分配器" class="headerlink" title="GNU4.9的标准分配器"></a>GNU4.9的标准分配器</h4><p>同样，没有任何特殊设计，和VC6，BC5一样。这个文件中已经说明，这个分配器没有用，容器的分配器不使用它！</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/ddffcf4f6459babdebfcdc21eb7cc40f.png" alt="在这里插入图片描述"></p>
<h4 id="GUN-2-9d的标准分配器"><a href="#GUN-2-9d的标准分配器" class="headerlink" title="GUN 2.9d的标准分配器"></a>GUN 2.9d的标准分配器</h4><p>同样，没有任何特殊设计</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241023093804151.png" alt="image-20241023093804151"></p>
<p>这些版本下的allocator()本质上都是malloc()<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/ff1e96270a3c5ea652b9ac8d63d351f0.png" alt="在这里插入图片描述"><br>在这些版本下，所有的容器都是直接调用allocator(),即第二个模板参数都是allocator。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/55db2ce6813a8240aeffffa3185b9ed2.png" alt="在这里插入图片描述"></p>
<h3 id="2-G2-9的alloc流程解析"><a href="#2-G2-9的alloc流程解析" class="headerlink" title="2. G2.9的alloc流程解析"></a>2. G2.9的alloc流程解析</h3><p>这个和G4.9 pool allocator就消除了大部分cookie的额外空间，因为只要用malloc就会有cookie，所以不可能完全没有，只是尽可能去回收已经分配过得内存来减少malloc从而减少cookie。两者实现方式差不多所以看2.9版的</p>
<h4 id="1-内存池配置器概述："><a href="#1-内存池配置器概述：" class="headerlink" title="1.内存池配置器概述："></a>1.内存池配置器概述：</h4><ol>
<li><strong>一级配置器</strong>：直接对<code>malloc</code>和<code>free</code>（或<code>new</code>和<code>delete</code>）进行封装，提供预申请内存接口，减少内存分配的上下文切换。当申请的内存区块大于一定阈值（如128bytes）时，一级配置器会处理这些大块内存的分配和释放。</li>
<li><strong>二级配置器</strong>：是真正的内存池实现，主要针对小块内存的频繁申请和释放。它采用内存块分级管理策略，将内存划分为多个不同大小的区块（如8, 16, 24, …, 120, 128 bytes等），并使用自由链表（free-lists）来管理这些区块。当需要小块内存时，二级配置器会尝试从自由链表中找到合适大小的区块进行分配；当释放小块内存时，也会将其回收到对应的自由链表中。</li>
</ol>
<h4 id="2-具体流程"><a href="#2-具体流程" class="headerlink" title="2.具体流程"></a>2.具体流程</h4><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/6fc79a47b691e0cac43f25b796e2269d.png" alt="在这里插入图片描述"><br>  原始的allocator()只维护一个内存链表，链表中每个节点的内存块大小根据创建allocator的对象来决定。现在的alloc通过free-list维护16条链表,节点的内存块大小从8byte到128byte共16种。</p>
<p>  <strong>内存申请过程：程序申请一块32bytes大小的空间，alloc会先通过malloc申请一块32*40bytes的空间，分一块给程序，32*19挂到free-list上维护为一条大小为32bytes，个数为19的链表.剩下32*20交给备用空间，暂时不进行处理。若程序继续要申请一块64bytes大小的空间，则直接将刚刚剩余的32*20的空间挂到free-list变为64*10的链表，并把第一个节点内的内存分配给程序。</strong></p>
<p>下一次申请就没有备用空间了，就得重新和malloc申请</p>
<p>PS：加入追加量概念和每次除以16都是经验所得，不用太纠结</p>
<p>注意点：<br>  1.每一个区块采用union结构，前四个字节表示为指向下一个区块的指针，好处是减少了额外的指针开销。有元素的时候就放元素了，用完了归还的时候又变成了指针。<br>  2.每条链表的长度为1-20，即使空间足够，长度也不会超过20。<br>  3.申请的空间如果很大，那还是会到一级配置器调用malloc。若当前需要申请一块104bytes的空间，而备用空间只剩下80bytes，则先将备用空间的80bytes挂到#9号链表下，再进行内存申请，若空间剩余不为8的倍数，则向上补齐为8的倍数再放入链表。<br>  4.若当前要申请一块72bytes的空间，备用空间不够，系统内存也不够无法通过malloc()额外申请。则将80bytes的链表（即最靠近72bytes，且比72bytes大的链表）中切下一块放入备用空间，再从备用空间中切下72bytes，交给程序。若80bytes的链表也没有空间，则依次向后继续找，若找到128bytes仍然没有足够的空间，则报错内存分配失败。<br>  <strong>5.备用空间是通过一头一尾两个指针来界定。</strong><br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/a7ba181ea982bd664f621469e695dc9f.png" alt="在这里插入图片描述"><br>  6.当程序将空间返回时，若大于128bytes，直接通过一级配置器返还给系统，还是会调用free来回收，若小于128bytes，则直接安插到free-list对应链表的<strong>头部</strong>。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/916b689f74e1f053e437abf04948d815.png" alt="在这里插入图片描述"><br>  7.若程序申请80bytes的内存空间，链表上为空，则先调用备用空间。若备用空间能分配一块以上但不足20块的内存大小，比如备用空间还有248，那就分成3块，给程序一块，然后两块空余，这三块都挂在9号，备用空间只剩8这样子。若备用空间内存足够，则将一块内存分配给程序，剩余19块内存挂载到链表上，并通过指针相连。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/0669b1cff25dc0bd6f64aab389034fea.png" alt="在这里插入图片描述"><br>  8.若程序申请80bytes的内存空间，链表上为空且备用空间不足，则<strong>free-list</strong>会调用<strong>refill()函数来填充链表</strong>，进行malloc()操作。若系统空间只能分配一块80bytes，则直接将内存分配给程序，不挂到链表上；若系统空间内存足够，则将一块内存分配给程序，剩余19块内存挂载到链表上，并通过指针相连。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/a91e99cc07fc396af8972c4acc343a1b.png" alt="在这里插入图片描述"><br>  9.<strong>为什么当备用空间不足，且系统空间不足以申请20块内存时，要从更大的内存块链表切下一块放入备用空间，而不是向系统申请一块内存？</strong><br>  因为链表上挂着的内存，本质上都是由alloc维护，只要是申请过并且分配过的（很大的一块空间但是内存池不知道这个到底有多大，因为链表很长，所以就都拿在手中)就不还给操作系统，如果这样做就相当于不使用alloc现有的内存而去向系统继续申请额外内存，后果是当前程序占有的内存越来越大，对于多任务系统是一种灾难。<strong>尽可能使用已经拥有的内存！！！</strong></p>
<h4 id="3-缺陷以及消除cookie后的测试结果"><a href="#3-缺陷以及消除cookie后的测试结果" class="headerlink" title="3.缺陷以及消除cookie后的测试结果"></a>3.缺陷以及消除cookie后的测试结果</h4><p><code>缺陷：</code></p>
<p>比如3号一开始的指针，这个是一开始用malloc分配的有cookie，在后面分配的时候，没有变量去保存这个指针，所以也导致归还不了内存，在第四讲中会有更好的东西来弥补它</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241023110511895.png" alt="image-20241023110511895"></p>
<p><code>测试结果：</code></p>
<p>都是一百万个对象</p>
<p>左边用了内存池，分配内存的行为malloc只调用了122次，而右边没有用的调用了一百万次malloc，一个cookie是8字节，相当于多用了8百万字节的额外空间，前面只是122*8个字节而已。</p>
<p>而上面的1675283是new的调用的次数，其实这个没有影响，因为内存池多了一层管理，而右边没人管理，所以左边会比右边多一些new和delete的操作，而这里面的delete其实没办法计数的。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241023111736164.png" alt="image-20241023111736164"></p>
<h1 id="第三章节-malloc-free"><a href="#第三章节-malloc-free" class="headerlink" title="第三章节 malloc&#x2F;free"></a>第三章节 malloc&#x2F;free</h1><p>先通过概述了解一下大致的工作流程再去看源代码会清晰很多</p>
<h2 id="1-malloc概述"><a href="#1-malloc概述" class="headerlink" title="1.malloc概述"></a>1.malloc概述</h2><p>C++中的<code>malloc</code>函数是一个用于动态内存分配的函数，其底层机制和工作原理相对复杂但可以通过以下简单清晰的解释来理解。</p>
<h3 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h3><p><code>malloc</code>函数在C++（以及C语言）中用于从堆（heap）中分配一块指定大小的内存空间，并返回该内存空间的起始地址。堆是操作系统管理的一块内存区域，用于动态分配内存。</p>
<p><code>malloc</code>函数的底层实现依赖于操作系统的内存管理机制。在Linux系统中，<code>malloc</code>通常通过维护一个空闲链表来管理可用的内存块。这个链表将可用的内存块连接起来，当<code>malloc</code>被调用时，它会遍历这个链表以找到第一个足够大的空闲块来满足请求。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol>
<li><strong>内存分配</strong>：<ul>
<li>当<code>malloc</code>被调用时，它首先计算所需内存的大小（包括一些额外的空间用于管理，如链表指针等）。</li>
<li>然后，它遍历空闲链表以找到第一个足够大的空闲块。</li>
<li>如果找到这样的块，<code>malloc</code>会将其拆分成两部分：一部分是用户请求的大小，另一部分是剩余的大小（如果有的话），并将剩余部分重新链接到空闲链表中。</li>
<li>最后，<code>malloc</code>返回用户请求大小的内存块的起始地址。</li>
</ul>
</li>
<li><strong>内存释放</strong>：<ul>
<li>当使用完<code>malloc</code>分配的内存后，应使用<code>free</code>函数来释放它。</li>
<li><code>free</code>函数会接收一个指向要释放内存的指针，并将这块内存重新链接到空闲链表中。</li>
</ul>
</li>
<li><strong>内存碎片整理</strong>：<ul>
<li>随着多次的<code>malloc</code>和<code>free</code>调用，空闲链表可能会被切成很多小的内存片段（内存碎片）。</li>
<li>当用户请求一块较大的内存空间时，可能会出现空闲链表中没有满足要求的片段的情况。</li>
<li>在这种情况下，<code>malloc</code>可能会请求延时，并开始检查空闲链表上的各个内存片段，尝试将它们合并成较大的内存块以满足请求。</li>
</ul>
</li>
<li><strong>系统调用</strong>：<ul>
<li>对于小块内存分配（通常小于128KB），<code>malloc</code>可能会使用<code>brk()</code>系统调用来调整堆的顶部指针，从而分配新的内存空间。</li>
<li>对于大块内存分配（通常大于128KB），<code>malloc</code>可能会使用<code>mmap()</code>系统调用来在文件映射区域分配内存。</li>
</ul>
</li>
</ol>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>malloc</code>分配的内存空间是未初始化的，可能包含任意值，因此在使用前需要对其进行初始化。</li>
<li>使用完毕后，应通过调用<code>free</code>函数来释放<code>malloc</code>分配的内存空间，以避免内存泄漏。</li>
<li>在多线程环境下，使用<code>malloc</code>分配内存时需要注意线程安全性。</li>
</ul>
<p><code>free</code> 函数在 C++（以及 C 语言）中用于释放之前通过 <code>malloc</code>、<code>calloc</code> 或 <code>realloc</code> 等函数动态分配的内存空间。其底层机制和工作原理可以简单而清晰地解释如下：</p>
<h2 id="2-free概述"><a href="#2-free概述" class="headerlink" title="2.free概述"></a>2.free概述</h2><h3 id="底层机制-1"><a href="#底层机制-1" class="headerlink" title="底层机制"></a>底层机制</h3><p><code>free</code> 函数的底层实现依赖于操作系统的内存管理机制，特别是与堆（heap）管理相关的部分。在大多数操作系统中，堆是一块由操作系统管理的内存区域，用于满足程序的动态内存分配需求。</p>
<p>当 <code>free</code> 被调用时，它接收一个指向要释放内存的指针。这个指针必须是指向之前通过 <code>malloc</code>、<code>calloc</code> 或 <code>realloc</code> 分配的内存块的起始地址。</p>
<h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><ol>
<li>验证指针<ul>
<li><code>free</code> 首先会检查传入的指针是否为 <code>NULL</code>。如果是，<code>free</code> 会立即返回而不执行任何操作，因为释放一个空指针是安全的。</li>
<li>如果指针不是 <code>NULL</code>，<code>free</code> 会继续验证该指针是否指向一个有效的、之前分配的内存块。这通常通过检查指针是否在堆的范围内以及是否指向一个已知的内存块头（包含管理信息，如大小、状态等）来完成。</li>
</ul>
</li>
<li>更新内存块头<ul>
<li>一旦验证了指针的有效性，<code>free</code> 会更新该内存块头的信息，将其标记为“空闲”或“已释放”。</li>
</ul>
</li>
<li>合并内存块<ul>
<li>为了减少内存碎片，<code>free</code> 会尝试将刚刚释放的内存块与其相邻的空闲内存块合并。这通常涉及更新内存块头中的大小和链表指针信息。</li>
<li>如果合并成功，新的空闲内存块将包含合并前两块内存的总大小。</li>
</ul>
</li>
<li>维护空闲链表<ul>
<li>在许多实现中，空闲的内存块会被组织成一个链表（或类似的数据结构），以便快速查找和分配。</li>
<li><code>free</code> 会将刚刚释放（或合并后）的内存块插入到这个链表中，或者更新链表中现有节点的信息。</li>
</ul>
</li>
<li>系统调用（可选）<ul>
<li>在某些情况下，如果释放的内存块非常大或者达到了某个阈值，<code>free</code> 可能会通过系统调用（如 <code>munmap</code>）将内存归还给操作系统。</li>
<li>然而，这通常是可选的，并且取决于具体的内存分配器实现和操作系统的行为。</li>
</ul>
</li>
<li>返回<ul>
<li>最后，<code>free</code> 函数返回，不再对该内存块有任何引用或控制。</li>
</ul>
</li>
</ol>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>不要重复释放</strong>：不要对同一个内存块调用 <code>free</code> 多次，这会导致未定义行为，可能包括程序崩溃或数据损坏。</li>
<li><strong>避免使用已释放的内存</strong>：一旦内存被 <code>free</code> 释放，就不要再尝试访问它。这可能会导致程序崩溃或安全漏洞。</li>
<li><strong>匹配分配和释放</strong>：确保使用与分配内存时相同的函数（或函数族）来释放内存。例如，如果内存是通过 <code>malloc</code> 分配的，那么应该使用 <code>free</code> 来释放它；如果内存是通过 <code>new</code> 分配的，那么应该使用 <code>delete</code>（或 <code>delete[]</code> 对于数组）来释放它。</li>
</ul>
<h2 id="3-VC6的malloc设计"><a href="#3-VC6的malloc设计" class="headerlink" title="3.VC6的malloc设计"></a>3.VC6的malloc设计</h2><p>实际上malloc也是内存池的思想，malloc本质上的速度也并不慢</p>
<p>  这是VC6版本下的malloc程序设计，从下往上一次执行。在该版本中有SBH（small block heap）的设计,即对于小块内存会采用特殊的分配方式。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/20dfb9844b4ed402a0566cdb0abc3525.png" alt="在这里插入图片描述"></p>
<h3 id="SBH首次分配内存详细步骤"><a href="#SBH首次分配内存详细步骤" class="headerlink" title="SBH首次分配内存详细步骤"></a>SBH首次分配内存详细步骤</h3><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/b8e546c08a1ae472ea1dd3305f5b1c3c.png" alt="在这里插入图片描述"></p>
<p>总体的malloc如上图。总的来说，就是为了添加debug信息，申请具体的内存，方面内存管理。</p>
<ol>
<li>_heap_init()做的事是分配16个头，16个头的数据结构如下，使用这个数据结构使得每个header能够管理1M的内存，1M内存能够快速分配，快速回收。一个header包括两个指针，一个指针指向自己管理的内存，一个指针指向管理内存中心。详细见步骤6。这些bit用于存放链表的状态，是否挂载上page。</li>
</ol>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/a4846e5acca3d91b950f17abe47d7087.png" alt="在这里插入图片描述"></p>
<p>2._ioinit()负责第一次分配内存：根据是不是debug的模式，调用不同的内存分配策略。debug直接调用malloc，非debug则给程序分配256字节的内存</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/506a763f0087f8577dce80449658f0cd.png" alt="img"></p>
<p>3._heap_alloc_dbg()负责在debug模式下，加上一些调试信息（debug header），这些调试信息就是下面的数据结构_CrtMemBlockHeader。这些调试信息包括：调试文件名，行号，数据大小，间隔符。绿色的地方就是填充我们最后要申请分配的内存。被分配的内存会被指针串起来形成一条链表。</p>
<p>gap就是把绿色部分包住，不让用户写的超过这个范围(间隔符)</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/a9cb3fc6a20767089bdebdfe023e0f5f.png" alt="在这里插入图片描述"></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241023152711137.png" alt="image-20241023152711137"></p>
<p>4._heap-alloc_base()根据申请的大小来判断（是否大于1016，为什么是1016？因为要留给cookie八字节的内存）是要自己提供服务还是交由<strong>操作系统</strong>来服务。</p>
<p>5.__sbh_alloc_block()用于字节对齐，加首尾cookie。处理完之后的内存块如下图右上角的图。cookie利用最后的一个bit来代表这个内存块是否被分配出去，1表示已分配，0表示未分配。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/694bcb8258cf333da1e3f37288e99c3d.png" alt="在这里插入图片描述"></p>
<p>6.__sbh_alloc_new_region()：内存管理中心数据结构就是tagRegion，管理区块是不是被分配，在不在内存分配链表上。为了管理好1M的内存空间，花了16K的内存（tagRegion数据结构）。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/ff4bd789df1546304aceb8a09ff6235a.png" alt="在这里插入图片描述"></p>
<p>7.__sbh_alloc_new_group()：4K一个page。一个header管理1M内存，这个1M内存会被分成32块（组，每个组由32对指针组成，即双向链表），32块分别由内存管理中心的数据结构来管理，每一个块又会被分成8个page，一个page占4K，使用链表将这些page连起来，连起来之后首尾接到绿箭头指向的双向链表中。完成这些工作之后，申请一块内存，得到内存，初始化，内存申请就成功了。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/b8e546c08a1ae472ea1dd3305f5b1c3c.png" alt="在这里插入图片描述"></p>
<p>8.最后将__sbh_alloc_new_region组好的内存填充到组中去。层层return会让用户拿到指向绿色开头的指针。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/675d307a10da58fe4cc7fa19d91daa1e.png" alt="在这里插入图片描述"></p>
<h3 id="SBH第二（n）次分配内存"><a href="#SBH第二（n）次分配内存" class="headerlink" title="SBH第二（n）次分配内存"></a>SBH第二（n）次分配内存</h3><p>在一个page上继续进行切分，当前page不够用，去其他page找。header负责维护的状态应该发生变化。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/0f20eb6e0363549036914a804365c37c.png" alt="在这里插入图片描述"></p>
<h3 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h3><p>将一个内存块的cookie中的状态置为未分配，将内存变为两个指针，指向负责管理内存的链表，header中的bit也发生变化，表示未分配。</p>
<p>回收相邻的内存。应该有个合并策略（这就是为什么要有下cookie的原因），要不然会出现内存碎片的问题。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/94f6f25c60c4355315496750fb97c1f7.png" alt="在这里插入图片描述"></p>
<h3 id="free-p"><a href="#free-p" class="headerlink" title="free( p )"></a>free( p )</h3><p>p属于哪个header？<br>p属于哪个group？<br>p属于哪个free-list？</p>
<h3 id="内存分配总结"><a href="#内存分配总结" class="headerlink" title="内存分配总结"></a>内存分配总结</h3><p>上述的分配策略，总的思想是一个分段管理。至于为什么有16个头，32个组，1个头管理1M内存，这些都是经验值，有利于操作系统。</p>
<p>全回收的动作会被延缓，并不会只要归还所有内存之后就把这么多段的内存整合还给操作体统（defer）。当第二个全回收出现的时候才会把内存归还操作系统。</p>
<h1 id="第四章节-loki-allocator"><a href="#第四章节-loki-allocator" class="headerlink" title="第四章节 loki::allocator"></a>第四章节 loki::allocator</h1><h2 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h2><p><code>loki::allocator</code> 是 Loki 库中的一个内存分配器组件，但需要注意的是，Loki 库并非 C++ 标准库的一部分，而是一个提供设计模式、编程惯用法等实现的第三方库。由于 Loki 库的具体实现和版本可能有所不同，以下对 <code>loki::allocator</code> 的底层原理和工作机制的描述将基于一般性的理解和假设。</p>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><code>loki::allocator</code> 的底层原理主要涉及到内存的分配和释放策略，旨在优化性能和减少内存碎片。它可能采用了以下一些技术：</p>
<ol>
<li>内存池（Memory Pool）<ul>
<li>内存池是一种预先分配大块内存并在需要时从中分配小块内存的技术。<code>loki::allocator</code> 可能实现了一个或多个内存池，用于存储不同类型的对象。</li>
<li>内存池的好处是减少了向操作系统请求内存的次数，从而提高了性能。此外，它还允许分配器更好地控制内存碎片。</li>
</ul>
</li>
<li>对象对齐（Object Alignment）<ul>
<li>为了满足特定硬件或编译器的要求，<code>loki::allocator</code> 可能支持对象对齐。这意味着对象在内存中的位置将满足特定的对齐条件。</li>
<li>对齐通常是为了提高内存访问速度或满足特定数据结构的布局要求。</li>
</ul>
</li>
<li>自定义分配策略<ul>
<li><code>loki::allocator</code> 可能允许用户定义自己的分配策略，如分配大小、对齐要求、是否使用内存池等。</li>
<li>这提供了灵活性，使得分配器可以根据特定的应用场景进行优化。</li>
</ul>
</li>
<li>缓存友好性（Cache Friendliness）<ul>
<li>为了提高内存访问效率，<code>loki::allocator</code> 可能会尝试将对象分配在缓存友好的位置。</li>
<li>这可能涉及到对象的布局、内存池的组织方式以及分配策略的选择。</li>
</ul>
</li>
</ol>
<h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p><code>loki::allocator</code> 的工作机制通常包括以下几个步骤：</p>
<ol>
<li>内存分配<ul>
<li>当需要分配内存时，<code>loki::allocator</code> 首先会检查内存池中是否有足够的空闲空间。</li>
<li>如果有，它会从内存池中分配一块适当大小的内存给对象。</li>
<li>如果没有足够的空闲空间，它可能会向操作系统请求更多的内存，并扩展内存池。</li>
</ul>
</li>
<li>对象构造<ul>
<li>在分配内存之后，<code>loki::allocator</code> 可能会调用对象的构造函数来初始化对象（对于类类型对象而言）。</li>
<li>这一步是可选的，取决于分配器的设计和使用场景。</li>
</ul>
</li>
<li>内存释放<ul>
<li>当对象不再需要时，<code>loki::allocator</code> 会负责释放对象所占用的内存。</li>
<li>它可能会将这块内存归还给内存池，以便将来重新分配。</li>
<li>如果内存池已满或不再需要，它可能会将部分或全部内存归还给操作系统。</li>
</ul>
</li>
<li>对象析构<ul>
<li>在释放内存之前，<code>loki::allocator</code> 可能会调用对象的析构函数来清理对象（对于类类型对象而言）。</li>
<li>这一步同样是可选的，取决于分配器的设计和使用场景。</li>
</ul>
</li>
</ol>
<h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>由于 <code>loki::allocator</code> 不是标准库的一部分，你需要确保你的项目中包含了 Loki 库，并且正确地配置了编译环境。</li>
<li>在使用 <code>loki::allocator</code> 之前，你应该仔细阅读相关的文档和源代码，以了解它的具体实现和用法。</li>
<li>考虑到 Loki 库的使用可能不太广泛，如果你在维护一个长期的项目或与其他开发者合作，使用标准库中的 <code>std::allocator</code> 或其他广泛使用的第三方库可能是更安全、更可维护的选择。</li>
</ul>
<h2 id="1、loki的allocator设计"><a href="#1、loki的allocator设计" class="headerlink" title="1、loki的allocator设计"></a>1、loki的allocator设计</h2><h3 id="0-总体上"><a href="#0-总体上" class="headerlink" title="0.总体上"></a>0.总体上</h3><p>loki::allocator由三个类构成，用户直接操纵SmallObjAllocator。</p>
<p>上面两个类都带有两个指针指向vector对象的类型</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/e67c43847e184da045c1d4e15868ca02.png" alt="在这里插入图片描述"></p>
<h3 id="1-Chunk"><a href="#1-Chunk" class="headerlink" title="1. Chunk"></a>1. Chunk</h3><h4 id="（1）Chunk的结构和初始化"><a href="#（1）Chunk的结构和初始化" class="headerlink" title="（1）Chunk的结构和初始化"></a>（1）Chunk的结构和初始化</h4><p>Chunk包含三个部分：一个指针和2个unsigned char。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/98db57121c4e5873dc6e3bd2cc0f1820.png" alt="在这里插入图片描述"><br>  在chunk初始化时会申请一块内存，然后根据Blocksize将内存切成若干块，由一个指针指向该内存。然后遍历这些内存块，把每个内存块的第一个字节按顺序编号，用这种方式（类似索引）实现嵌入式指针的效果。firstAvailableBlock用于记录下一个可以分配的内存块编号，blocksAvailable_用于记录总共还剩多少个内存块可以分配。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/1b11b107feb048e3b3a48d3a72b57c18.png" alt="在这里插入图片描述"></p>
<h4 id="（2）Chunk的内存分配过程"><a href="#（2）Chunk的内存分配过程" class="headerlink" title="（2）Chunk的内存分配过程"></a>（2）Chunk的内存分配过程</h4><p>  找到firstAvailableBlock记录的可分配内存块，该编号为相对于内存开头的偏移量，这块内存的第一位记录的是下一块优先分配的内存编号，在给出这块内存之前，将firstAvailableBlock指针指向次优先级的内存块，同时blocksAvailable_的值-1。</p>
<p>就是图中的4-&gt;3（这个是索引，表示从开头到这块是第几块，3是第四块）就是数字3的块给出去了，如果程序还要继续申请内存那给出去的就会是索引号3，数字块2，再下一个就是索引号2，数字块1。每给出去一块可用的块数就会减一。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/5255e1b5b8421e10cf08c13ef16cb25a.png" alt="在这里插入图片描述"></p>
<h4 id="（3）Chunk的内存释放过程"><a href="#（3）Chunk的内存释放过程" class="headerlink" title="（3）Chunk的内存释放过程"></a>（3）Chunk的内存释放过程</h4><p>回收的块号是回收指针减去头指针再除以块数得到的</p>
<p>  先将firstAvailableBlock写入返回内存块的第一位，即最高优先权的位置（在链表里面其实就是个头插法，只不过这里没有虚拟头结点罢了），再根据返回指针的位置，计算出当前内存块的具体位置编号，赋给firstAvailableBlock，最后将blocksAvailable_的值+1。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241023195252839.png" alt="image-20241023195252839"></p>
<p>所以就明白为什么顺序是乱的，因为分配出去的块的顺序和重新回收插入到头部的顺序大多数情况下都不会相同</p>
<h3 id="2-FixedAllocator"><a href="#2-FixedAllocator" class="headerlink" title="2. FixedAllocator"></a>2. FixedAllocator</h3><h4 id="（1）FixedAllocator的结构"><a href="#（1）FixedAllocator的结构" class="headerlink" title="（1）FixedAllocator的结构"></a>（1）FixedAllocator的结构</h4><p>  FixedAllocator包含一个vector&lt; Chunk &gt;，allocChunk指针指向的是上一个进行内存分配的chunk，deallocChunk指针指向的是上一个进行内存归还的chunk（根据经验设计的，局部性原理）。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/7467223998d53720a5b1375b333f64c1.png" alt="在这里插入图片描述"></p>
<h4 id="（2）Allocator"><a href="#（2）Allocator" class="headerlink" title="（2）Allocator"></a>（2）Allocator</h4><p>  首先对allocChunk进行判断，若指针为空或者所指的chunk已经满了，则开始从头遍历chunk。<br>  若遍历结束没找到可用的chunk，则再尾部新增加一个chunk，将allocChunk指向新增的chunk，deallocChunk指向第一个chunk（因为vector可能会搬运move，move之后，原来的指针可能就失效了，所以要重新搞一个值，那索性就第一个好了）。<br>  若遍历过程中找到了可用的chunk，然后直接从该chunk进行内存分配，将allocChunk指向该chunk。还要标记一个哨兵，下次直接从这里开始找Chunk<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/76dfa6bd9b5dd0bd284a61c4de72d617.png" alt="在这里插入图片描述"></p>
<h4 id="（2）Deallocator"><a href="#（2）Deallocator" class="headerlink" title="（2）Deallocator"></a>（2）Deallocator</h4><p>Deallocator函数进行两个操作，先找到可以归还内存的chunk，再进行chunk全回收判断。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/3a5444c75dcb737c8b482fa6ac15f67a.png" alt="在这里插入图片描述"></p>
<h5 id="①-VicinityFind"><a href="#①-VicinityFind" class="headerlink" title="① VicinityFind"></a>① VicinityFind</h5><p>  定义两个指针分别指向deallocChunk和deallocChunk + 1的chunk，然后从deallocChunk往front找，deallocChunk + 1往back找，交叉寻找（往上找一个chunk，往下找一个chunk），如果找到内存块所属chunk则进入chunk内存返还，<strong>若找不到则一直循环！</strong>（新版已经改了）<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/c784f5622b02d1a3c5066a010eb468b7.png" alt="在这里插入图片描述"></p>
<h5 id="②-DoDeallocator"><a href="#②-DoDeallocator" class="headerlink" title="② DoDeallocator"></a>② DoDeallocator</h5><p>  先调用Deallocator进行内存回收，回收完了进行判断，若当前chunk可用空间与初始状态不同，则说明还未全回收，直接跳出程序。若相同，则确认全回收，进行返还判断，分为三种情况：<br>  1.若全回收的chunk为vector的最后一块，并且前一块也是全回收的，则将最后一块chunk释放给系统。<br>  2.若全回收的chunk不为vector的最后一块，但最后一块chunk是全回收的，则将最后一块chunk释放给系统，当前chunk不释放。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/5381916b020d5a1effbd5536a09c0bac.png" alt="在这里插入图片描述"><br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/d581e0c2bb3282f814d1c0d653ee409d.png" alt="在这里插入图片描述"></p>
<h3 id="3-SmallObjAllocator"><a href="#3-SmallObjAllocator" class="headerlink" title="3. SmallObjAllocator"></a>3. SmallObjAllocator</h3><p>  SmallObjAllocator是由一系列内存块大小不同的vector&lt; Chunk &gt;组成，主要功能是将程序的内存申请分配到合适大小的vector&lt; Chunk &gt;进行处理。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/b7f5a2a32edd9a001f056ce62ce053ac.png" alt="在这里插入图片描述"><br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/56c9ced5717ec8da911b55e84ac0c603.png" alt="在这里插入图片描述"></p>
<h2 id="2、loki-allocator的特点"><a href="#2、loki-allocator的特点" class="headerlink" title="2、loki::allocator的特点"></a>2、loki::allocator的特点</h2><p><strong>1.结构简单精简，多使用暴力遍历。<br>2.使用数组取代链表，索引取代指针的特殊实现。<br>3.有较为简单的chunk全回收判断，进而归还给系统。<br>4.有deferring(暂缓归还)功能。<br>5.本身是个allocator，用于分配不带有cookies的内存块，最适用于容器，但底层却通过vector实现，不太合理，它内部的vector用的分配器还是标准库的那一套而不是他自己这个，要用它自己这个得我们自己写容器的时候指明第二个参数是他这个分配器才行。</strong></p>
<h1 id="第五章节-other-issues"><a href="#第五章节-other-issues" class="headerlink" title="第五章节 other issues"></a>第五章节 other issues</h1><p>就是介绍一下GUN的其他分配器，方便在各种情形下去使用</p>
<h2 id="GNU4-9分配器"><a href="#GNU4-9分配器" class="headerlink" title="GNU4.9分配器"></a>GNU4.9分配器</h2><p>分配器各有各的优势。</p>
<h3 id="1-new-allocator和malloc-allocator（最简单的）"><a href="#1-new-allocator和malloc-allocator（最简单的）" class="headerlink" title="1.new_allocator和malloc_allocator（最简单的）"></a>1.new_allocator和malloc_allocator（最简单的）</h3><p><strong>new_allocator</strong></p>
<p>实现出简单的operator new和operator delete，这个好处就是能够重载。</p>
<p><strong>malloc_allocator</strong></p>
<p>直接调用malloc和free，没有经过operator new &#x2F; delete，所以没有重载的机会。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241023203411232.png" alt="image-20241023203411232"></p>
<hr>
<h3 id="2-智能型的分配器"><a href="#2-智能型的分配器" class="headerlink" title="2.智能型的分配器"></a>2.智能型的分配器</h3><p>array_allocator、debug_allocator、__mt_allocator、__pool_allocator、bitmap_allocator都是智能型</p>
<h4 id="1-array-allocator"><a href="#1-array-allocator" class="headerlink" title="1.array_allocator"></a>1.array_allocator</h4><p>允许分配一个<strong>已知且固定大小</strong>（known and fixed size）的内存块，这些内存来自<code>std::array</code>对象。使用这个分配器，大小固定的容器（包括<code>std::string</code>）就不再需要调用<code>operator new</code>和<code>operator delete</code>。这就使我们能够使用STL abstractions，而无需在运行时造成混乱或增加开销。甚至在程序启动时也可以使用这种分配器。</p>
<p>其实就是用C++底部的静态的数组来供应内存，然后如果一开始就知道大小的话，这个就比较好用，速度也快。既不是new也不是malloc。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/8e66394b39f2a16cf0cba9bcfd6ecbcc.png" alt="在这里插入图片描述"></p>
<p><code>array_allocator的使用</code></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241023205844066.png" alt="image-20241023205844066"></p>
<p>arrat_allocator并不会回收已经给出的内存空间。（不能回收其实没有啥用）</p>
<p>静态分配，不需要free。没啥用，因为不free，用过的空间不能再次使用了。</p>
<p>也可以将底部C++的数组换成标准库的array容器。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241023210221463.png" alt="image-20241023210221463"></p>
<h4 id="2-debug-allocator"><a href="#2-debug-allocator" class="headerlink" title="2.debug_allocator"></a>2.debug_allocator</h4><p>这是一个包装器（wrapper），可以包装在任何分配器（allocator）之上。它会将用户的请求量增加一些，然后由分配器进行响应，并使用那一小块额外的内存来存储大小信息。一旦<code>deallocate()</code>函数接收到一个指针，它就会检查大小信息，并使用<code>assert()</code>函数来确保匹配。</p>
<p>就是自己是加了点东西，然后分配的活一点不干都外包给它里面那个allocator。</p>
<p>多出来的_M_extra就是记录区块大小，就只是加了个大小，没什么用（不是我说的，是侯捷老师说的，但我也觉得没啥用）</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/467e0f17f6325b38b4ee529d11ed7f14.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="3-三种使用内存池的分配器"><a href="#3-三种使用内存池的分配器" class="headerlink" title="3.三种使用内存池的分配器"></a>3.三种使用内存池的分配器</h3><p>下面的三种分配器实现都是内存池的思想，追求的是不要分配过多的cookie。</p>
<h4 id="1-pool-allocator"><a href="#1-pool-allocator" class="headerlink" title="1.__pool_allocator"></a>1.__pool_allocator</h4><p>就是GNU2.9中的alloc，这里不再赘述。</p>
<h4 id="2-mt-allocator"><a href="#2-mt-allocator" class="headerlink" title="2.__mt_allocator"></a>2.__mt_allocator</h4><p>多线程的内存分配器。</p>
<h4 id="3-bitmap-allocator"><a href="#3-bitmap-allocator" class="headerlink" title="3.bitmap_allocator"></a>3.bitmap_allocator</h4><p>是个bitmap index，用以索引至一个以2的指数倍成长的篮子</p>
<p>一个高效能的分配器，使用bit-map追踪被使用和未被使用的内存块。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241023211037280.png" alt="image-20241023211037280"></p>
<h5 id="1-内存分配"><a href="#1-内存分配" class="headerlink" title="1.内存分配"></a>1.内存分配</h5><p><strong>关于blocks，supper-blocks，bitmap，mini-vector</strong></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/95d2debb53e4364ba16d92dd0825850a.png" alt="在这里插入图片描述"><br>1.上图是一个super block</p>
<p>bitmap用于存放后面的block是否被分配出去</p>
<p>use-count表示已经分配了多少个</p>
<p>2.<strong>__mini_vector</strong>是控制中心，用来管理后面的block，指向block的头尾</p>
<p>bitmap的变化方向和_M_start变化方向相反</p>
<p>start和finish是super block的空闲块的头和尾，end_of_storage指的是容量的尾巴(就那个会扩容两倍那个实际上的容量的尾巴，模仿标准库vector容器写的)</p>
<p>3.如果一个super block用光了，就会新起一个super block，控制中心mini_vector也会增长，而且能够分配的内存会翻倍，如下图：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/6a8c9bc96533570cd4e2002d61b7f27e.png" alt="在这里插入图片描述"></p>
<p>用1表示还没分配的block，用0表示已经分配的block，前面的数字会标识还有几块空闲没有被分配的</p>
<p>4.这个vector的entries无限制，每个entry代表一种value type，不用的value type即使大小相同也不混用</p>
<p>就和一个类有一个分配器一样的，这里的entry代表的super block也是每个类型一个，不会混用</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241023212639506.png" alt="image-20241023212639506"></p>
<h5 id="2-内存回收"><a href="#2-内存回收" class="headerlink" title="2.内存回收"></a>2.内存回收</h5><p>如果发生全回收，便会造成下一次分配的内存规模减半（它自己设计就是这样的，不用纠结）。图中64,128,256全部都回收，那下一次malloc分配的话就是给分配128个blocks。</p>
<p><code>下面是第一个64blocks的全回收</code></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241023213355765.png" alt="image-20241023213355765"></p>
<p>全回收，使用另外一个__min_vector来登记（free list）全回收的super block。对于原来的两个指针，是用vector的erase来删除的，就相当于删掉了vector的0,1号元素。</p>
<p>问题1的答案其实是0号和2号都可以的。但是测出来是2号，这个是无所谓的。</p>
<p>问题2的答案是唯一的。因为要先用已经分配过得内存，这一点是好的。</p>
<p>发生全回收，则分配内存减半，如下图是<code>三次全回收</code>的情况：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/314136d70ceb5b4f3c0e8d70584bf149.png" alt="在这里插入图片描述"></p>
<p>右上角的_s_free_list就是登记全回收的super block的链表,释放的时候就看这里面哪个super block最长最大，就释放掉谁。</p>
<p>如果free list中已经有64个super block，下一次再free的的super block，直接delete。</p>
<p><strong>如果要这时候要申请一个block，那就从_s_free_list里面恢复一个进行使用</strong></p>
<h3 id="4-这些分配器的使用"><a href="#4-这些分配器的使用" class="headerlink" title="4.这些分配器的使用"></a>4.这些分配器的使用</h3><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241023214741499.png" alt="image-20241023214741499"></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241023214815272.png" alt="image-20241023214815272"></p>
]]></content>
      <categories>
        <category>从零开始的C++の学习之路</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>施磊C++ | 进阶学习笔记</title>
    <url>/2024/10/16/C++/%E6%96%BD%E7%A3%8AC++%20%20%E8%BF%9B%E9%98%B6%20%20%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="施磊C-进阶学习笔记"><a href="#施磊C-进阶学习笔记" class="headerlink" title="施磊C++ | 进阶学习笔记"></a>施磊C++ | 进阶学习笔记</h1><h2 id="一、对象的应用优化、右值引用的优化"><a href="#一、对象的应用优化、右值引用的优化" class="headerlink" title="一、对象的应用优化、右值引用的优化"></a>一、对象的应用优化、右值引用的优化</h2><h3 id="1-1-构造，拷贝，赋值，析构中的优化"><a href="#1-1-构造，拷贝，赋值，析构中的优化" class="headerlink" title="1.1 构造，拷贝，赋值，析构中的优化"></a>1.1 构造，拷贝，赋值，析构中的优化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">test</span>(<span class="type">int</span> a = <span class="number">10</span>) :<span class="built_in">ma</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;test(int)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~test&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="built_in">test</span>(<span class="type">const</span> test&amp; t) :<span class="built_in">ma</span>(t.ma) &#123; cout &lt;&lt; <span class="string">&quot;test(const &amp;)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> test&amp; t)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">		ma = t.ma;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	test t1;<span class="comment">//构造</span></span><br><span class="line">	<span class="function">test <span class="title">t2</span><span class="params">(t1)</span></span>;<span class="comment">//拷贝</span></span><br><span class="line">	test t3 = t1;<span class="comment">//拷贝</span></span><br><span class="line">	<span class="comment">//临时对象生存周期就是这个语句</span></span><br><span class="line">	<span class="comment">/*1.C++编译器对于对象构造的优化：用临时对象生成新对象的时候，临时对象就不产生了，直接构造新对象就可以了*/</span></span><br><span class="line">	test t4 = <span class="built_in">test</span>(<span class="number">20</span>);<span class="comment">//相当于 test t4(20); 而不是先用临时对象构造，临时对象拷贝，然后临时对象析构，这样效率太低了就给优化了</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	t4 = t2;<span class="comment">//赋值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.显式生成临时对象</span></span><br><span class="line">	<span class="comment">//t4.operator=(const Test &amp;t)这个临时对象会产生，因为要给参数t赋值，传参</span></span><br><span class="line">	t4 = <span class="built_in">test</span>(<span class="number">30</span>);<span class="comment">// 依次调用 构造 赋值 析构</span></span><br><span class="line">	t4 = (test)<span class="number">30</span>;<span class="comment">//有合适的构造函数可以隐式的生成一个临时对象然后给t4，没有合适的就报错</span></span><br><span class="line">	<span class="comment">//隐式生成临时对象</span></span><br><span class="line">	t4 = <span class="number">30</span>;<span class="comment">//这3句等价</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3. 临时对象，指针和引用</span></span><br><span class="line">	<span class="comment">// 指针指向临时对象不安全，但是引用是安全的</span></span><br><span class="line">	<span class="comment">//p指向的是一个已经析构的临时对象，变成了野指针</span></span><br><span class="line">	test* p = &amp;<span class="built_in">test</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="comment">//但是引用是可以的，因为是起了一个别名，给一块内存重新按了一个名字，就可以继续用，所以是安全的</span></span><br><span class="line">	<span class="type">const</span> test&amp; ref = <span class="built_in">test</span>(<span class="number">50</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4.全局变量是在main函数之前就完成了初始化的</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//5.test *p1=new test(70) 调用一次构造函数 只有在delete的时候才调用析构</span></span><br><span class="line">	<span class="comment">//6.test *p2=new test[2] 调用两次构造</span></span><br><span class="line">	<span class="comment">//7.delete p1 调用析构然后才释放内存</span></span><br><span class="line">	<span class="comment">//8.delete []p2 两次析构然后调用free释放整个内存 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="课后练习："><a href="#课后练习：" class="headerlink" title="课后练习："></a>课后练习：</h4><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241009213117219.png" alt="image-20241009213117219"></p>
<h3 id="1-2-函数调用过程中对象背后调用的方法"><a href="#1-2-函数调用过程中对象背后调用的方法" class="headerlink" title="1.2 函数调用过程中对象背后调用的方法"></a>1.2 函数调用过程中对象背后调用的方法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">test</span>(<span class="type">int</span> a = <span class="number">10</span>) :<span class="built_in">ma</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;test(int)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~test&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="built_in">test</span>(<span class="type">const</span> test&amp; t) :<span class="built_in">ma</span>(t.ma) &#123; cout &lt;&lt; <span class="string">&quot;test(const &amp;)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> test&amp; t)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">		ma = t.ma;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ma; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">test <span class="title">GetObject</span><span class="params">(test t)</span><span class="comment">//不能返回局部的或者临时对象的指针或引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> val = t.<span class="built_in">getData</span>();</span><br><span class="line">	<span class="function">test <span class="title">tmp</span><span class="params">(val)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//背后调用了哪些函数呢？</span></span><br><span class="line">	test t1;<span class="comment">//1.test(int)</span></span><br><span class="line">	test t2;<span class="comment">//2.test(int)</span></span><br><span class="line">	t2 = <span class="built_in">GetObject</span>(t1);<span class="comment">//3.test(const test&amp;) t1-&gt;t 实参到形参是一个初始化的过程不是第一个赋值的过程，这里用t1初始化形参t</span></span><br><span class="line">	<span class="comment">//4.test(int) 初始化tmp</span></span><br><span class="line">	<span class="comment">// 5.test(const test&amp;) tmp拷贝给一个临时对象</span></span><br><span class="line">	<span class="comment">//5.tmp 析构</span></span><br><span class="line">	<span class="comment">//6.t析构</span></span><br><span class="line">	<span class="comment">//7.operator 赋值 给t2</span></span><br><span class="line">	<span class="comment">//8.临时对象析构</span></span><br><span class="line">	<span class="comment">//9.t2析构</span></span><br><span class="line">	<span class="comment">//10.t1析构</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-对象优化三原则"><a href="#1-3-对象优化三原则" class="headerlink" title="1.3 对象优化三原则"></a>1.3 对象优化三原则</h3><p>1.函数参数传递过程中，对象优先按引用传递，不要按照值传递（实参到形参不需要构造和析构函数调用）</p>
<p>2.函数返回对象的时候，优先考虑返回一个临时对象，而不是一个定义过的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意加了引用</span></span><br><span class="line"><span class="function">test <span class="title">GetObject</span><span class="params">(test &amp;t)</span><span class="comment">//改成这样以后，调用会少了tmp的构造和析构，又少了两个调用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> val = t.<span class="built_in">getData</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">test</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.接收函数返回值是对象的函数调用的时候，优先按初始化的方式接收，不要按复制的方式接收</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">test</span>(<span class="type">int</span> a = <span class="number">10</span>) :<span class="built_in">ma</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;test(int)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~test&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="built_in">test</span>(<span class="type">const</span> test&amp; t) :<span class="built_in">ma</span>(t.ma) &#123; cout &lt;&lt; <span class="string">&quot;test(const &amp;)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> test&amp; t)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">		ma = t.ma;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ma; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//注意，加了引用</span></span><br><span class="line"><span class="function">test <span class="title">GetObject</span><span class="params">(test &amp;t)</span><span class="comment">//不能返回局部的或者临时对象的指针或引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> val = t.<span class="built_in">getData</span>();</span><br><span class="line">	<span class="function">test <span class="title">tmp</span><span class="params">(val)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//背后调用了哪些函数呢？</span></span><br><span class="line">	test t1;<span class="comment">//1.test(int) 构造t1 </span></span><br><span class="line">	test t2 = <span class="built_in">GetObject</span>(t1);<span class="comment">//2.test(int) 直接构造t2</span></span><br><span class="line">    <span class="comment">//3.t2析构</span></span><br><span class="line">    <span class="comment">//4.t1析构</span></span><br><span class="line">    <span class="comment">//test t2;</span></span><br><span class="line">    <span class="comment">//t2 = GetObject(t1);</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-右值引用、move移动语意、完美转发"><a href="#1-4-右值引用、move移动语意、完美转发" class="headerlink" title="1.4 右值引用、move移动语意、完美转发"></a>1.4 右值引用、move移动语意、完美转发</h3><p>请转至<a href="https://blog.csdn.net/m0_74795952/article/details/142858121?spm=1001.2014.3001.5501">C++11 新特性 学习笔记-CSDN博客</a>进行学习</p>
<h2 id="二、智能指针"><a href="#二、智能指针" class="headerlink" title="二、智能指针"></a>二、智能指针</h2><h3 id="2-1智能指针介绍"><a href="#2-1智能指针介绍" class="headerlink" title="2.1智能指针介绍"></a>2.1智能指针介绍</h3><p>学习C++的人，一直在接触裸指针，一边感受着它的强大，一边感受着它的坑爹。当然，坑不坑爹在于开发者，指针本身近乎完美，但奈何用的人比较猥琐，给自己埋下无数的坑，还哭喊着指针不好用，那么今天要介绍的智能指针可以释放大家在使用裸指针时的一些压力，当然智能指针无法替代裸指针的全部功能。</p>
<p>裸指针到底有什么不好，写过一些C++代码的人应该都能知道，比如下面的原因：</p>
<ol>
<li>忘记释放资源，导致资源泄露（常发生内存泄漏问题）</li>
<li>同一资源释放多次，导致释放野指针，程序崩溃</li>
<li>明明代码的后面写了释放资源的代码，但是由于程序逻辑满足条件，从中间return掉了，导致释放资源的代码未被执行到，懵</li>
<li>代码运行过程中发生异常，随着异常栈展开，导致释放资源的代码未被执行到，懵</li>
</ol>
<p>总之，智能指针的<strong>智能</strong>二字，主要体现在用户可以不关注资源的释放，因为智能指针会帮你完全管理资源的释放，它会保证无论程序逻辑怎么跑，正常执行或者产生异常，资源在到期的情况下，一定会进行释放。</p>
<p>C++11库里面，提供了<strong>带引用计数的智能指针和不带引用计数的智能指针</strong>，这篇文章主要介绍它们的原理和应用场景，包括<strong>auto_ptr，scoped_ptr，unique_ptr，shared_ptr，weak_ptr</strong>。</p>
<h3 id="2-2自己实现智能指针（基础知识）"><a href="#2-2自己实现智能指针（基础知识）" class="headerlink" title="2.2自己实现智能指针（基础知识）"></a>2.2自己实现智能指针（基础知识）</h3><p>为了更好的理解C++库中智能指针的原理，我们首先需要自己实现一个简单的智能指针，窥探一下智能指针的基本原理，就是利用<strong>栈上的对象出作用域会自动析构</strong>这么一个特点，把资源释放的代码全部放在这个析构函数中执行，就达到了所谓的<strong>智能</strong>指针。对比下面的两块代码：</p>
<ol>
<li>使用裸指针</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">	<span class="comment">/*其它的代码...*/</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	如果这里忘记写delete，或者上面的代码段中程序return掉了，</span></span><br><span class="line"><span class="comment">	没有执行到这里，都会导致这里没有释放内存，内存泄漏</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.使用智能指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CSmartPtr</span>(T *ptr = <span class="literal">nullptr</span>) :<span class="built_in">mptr</span>(ptr) &#123;&#125;</span><br><span class="line">	~<span class="built_in">CSmartPtr</span>() &#123; <span class="keyword">delete</span> mptr; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T *mptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CSmartPtr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">	<span class="comment">/*其它的代码...*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*由于ptr是栈上的智能指针对象，不管是函数正常执行完，还是运行过程中出现</span></span><br><span class="line"><span class="comment">	异常，栈上的对象都会自动调用析构函数，在析构函数中进行了delete</span></span><br><span class="line"><span class="comment">	操作，保证释放资源*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码就是一个非常简单的智能指针，主要用到了这两点：<br>1）<strong>智能指针体现在把裸指针进行了一次面向对象的封装，在构造函数中初始化资源地址，在析构函数中负责释放资源</strong><br>2）<strong>利用栈上的对象出作用域自动析构这个特点，在智能指针的析构函数中保证释放资源</strong></p>
<p>所以，智能指针一般都是定义在栈上的，曾经有一个面试问题，问“<strong>能不能在堆上定义智能指针？</strong>”，如这段代码<strong>CSmartPtr *p &#x3D; new CSmartPtr(new int)</strong>;大家应该能看出来，这里定义的p虽然是智能指针类型，但它实质上还是一个裸指针，因此p还是需要进行手动delete，又回到了最开始裸指针我们面临的问题，那还不如一开始就用裸指针算了。</p>
<p>当然，智能指针要做到和裸指针相似，还得提供裸指针常见的*<strong>和-&gt;两种运算符的重载函数</strong>，使用起来才真正的和裸指针一样，代码扩充如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CSmartPtr</span>(T *ptr = <span class="literal">nullptr</span>) :<span class="built_in">mptr</span>(ptr) &#123;&#125;</span><br><span class="line">	~<span class="built_in">CSmartPtr</span>() &#123; <span class="keyword">delete</span> mptr; &#125;</span><br><span class="line"></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *mptr; &#125;</span><br><span class="line">	<span class="type">const</span> T&amp; <span class="keyword">operator</span>*()<span class="type">const</span> &#123; <span class="keyword">return</span> *mptr; &#125;</span><br><span class="line"></span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> mptr; &#125;</span><br><span class="line">	<span class="type">const</span> T* <span class="keyword">operator</span>-&gt;()<span class="type">const</span> &#123; <span class="keyword">return</span> mptr; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T *mptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CSmartPtr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">	*ptr = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ptr-&gt;mptr;<span class="comment">//解析过程是 (ptr.operator-&gt;())-&gt;mptr 其实是-&gt;运算符重载函数的返回值去调用箭头运算符</span></span><br></pre></td></tr></table></figure>

<p>上面的这个智能指针，使用起来就和普通的裸指针非常相似了，但是它还存在很大的问题，看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CSmartPtr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">	<span class="function">CSmartPtr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个main函数运行，代码直接崩溃，<strong>问题出在默认的拷贝构造函数做的是浅拷贝，两个智能指针都持有一个new int资源，ptr2先析构释放了资源，到ptr1析构的时候，就成了delete野指针了，造成程序崩溃</strong>。所以这里引出来智能指针需要解决的两件事情：</p>
<ol>
<li>怎么解决智能指针的浅拷贝问题</li>
<li>多个智能指针指向同一个资源的时候，怎么保证资源只释放一次，而不是每个智能指针都释放一次，造成代码运行不可预期的严重后果</li>
</ol>
<p>我们一起看看C++库中提供的智能指针是怎么解决上面提到的问题的。</p>
<h3 id="2-3不带引用计数的智能指针"><a href="#2-3不带引用计数的智能指针" class="headerlink" title="2.3不带引用计数的智能指针"></a>2.3不带引用计数的智能指针</h3><p>C++库中提供的不带引用计数的智能指针主要包括：<strong>auto_ptr（C++库），scoped_ptr（C++11），unique_ptr(C++11)</strong>，下面一一进行介绍。</p>
<h4 id="1-auto-ptr"><a href="#1-auto-ptr" class="headerlink" title="1.auto_ptr"></a>1.auto_ptr</h4><p>先浏览一下auto_ptr的主要源码，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">auto_ptr</span></span><br><span class="line">	&#123;	<span class="comment">// wrap an object pointer to ensure destruction</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> _Ty element_type;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(_Ty * _Ptr = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">		: _Myptr(_Ptr)</span></span><br><span class="line"><span class="function">		&#123;</span>	<span class="comment">// construct from object pointer</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*这里是auto_ptr的拷贝构造函数，</span></span><br><span class="line"><span class="comment">	_Right.release()函数中，把_Right的_Myptr</span></span><br><span class="line"><span class="comment">	赋为nullptr，也就是换成当前auto_ptr持有资源地址</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">auto_ptr</span>(auto_ptr&amp; _Right) <span class="keyword">noexcept</span></span><br><span class="line">		: _Myptr(_Right.<span class="built_in">release</span>())</span><br><span class="line">		&#123;	<span class="comment">// construct by assuming pointer from _Right auto_ptr</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="function">_Ty * <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">		</span>&#123;	<span class="comment">// return wrapped pointer and give up ownership</span></span><br><span class="line">		_Ty * _Tmp = _Myptr;</span><br><span class="line">		_Myptr = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">return</span> (_Tmp);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	_Ty * _Myptr;	<span class="comment">// the wrapped object pointer</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从auto_ptr的源码可以看到，指向同一块内存的智能指针只有最新构造的一个auto_ptr智能指针持有资源，原来具有相同资源的的auto_ptr在新的aotu_ptr构造的时候都被赋nullptr了，不再管理资源，考虑如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	经过拷贝构造，p2指向了new int资源，</span></span><br><span class="line"><span class="comment">	p1现在为nullptr了，如果使用p1，相当于</span></span><br><span class="line"><span class="comment">	访问空指针了，很危险</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	auto_ptr&lt;<span class="type">int</span>&gt; p2 = p1;</span><br><span class="line">	*p1 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序，如果用户不了解auto_ptr的实现，代码就会出现严重的问题。记得曾经一个面试题问过“<strong>auto_ptr能不能使用在容器当中？</strong>”，看下面的代码描述：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;auto_ptr&lt;<span class="type">int</span>&gt;&gt; vec;</span><br><span class="line">	vec.<span class="built_in">push_back</span>(<span class="built_in">auto_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>)));</span><br><span class="line">	vec.<span class="built_in">push_back</span>(<span class="built_in">auto_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>)));</span><br><span class="line">	vec.<span class="built_in">push_back</span>(<span class="built_in">auto_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">30</span>)));</span><br><span class="line">	<span class="comment">// 这里可以打印出10</span></span><br><span class="line">	cout &lt;&lt; *vec[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	vector&lt;auto_ptr&lt;<span class="type">int</span>&gt;&gt; vec2 = vec;</span><br><span class="line">	<span class="comment">/* 这里由于上面做了vector容器的拷贝，相当于容器中</span></span><br><span class="line"><span class="comment">	的每一个元素都进行了拷贝构造，原来vec中的智能指针</span></span><br><span class="line"><span class="comment">	全部为nullptr了，再次访问就成访问空指针了，程序崩溃</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	cout &lt;&lt; *vec[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以不要在容器中使用auto_ptr，<strong>C++建议最好不要使用auto_ptr</strong>，除非应用场景非常简单。</p>
<p>【总结】：<strong>auto_ptr智能指针不带引用计数，那么它处理浅拷贝的问题，是直接把前面的auto_ptr都置为nullptr，只让最后一个auto_ptr持有资源。</strong>（也可以理解为这个指针会转交资源的管理权）</p>
<h4 id="2-scoped-ptr"><a href="#2-scoped-ptr" class="headerlink" title="2.scoped_ptr"></a>2.scoped_ptr</h4><p>先浏览一下scoped_ptr的源码，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">scoped_ptr</span> <span class="comment">// noncopyable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T * px;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	私有化拷贝构造函数和赋值函数，这样scoped_ptr的智能指针</span></span><br><span class="line"><span class="comment">	对象就不支持这两种操作，从根本上杜绝浅拷贝的发生</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="built_in">scoped_ptr</span>(scoped_ptr <span class="type">const</span> &amp;);</span><br><span class="line">    scoped_ptr &amp; <span class="keyword">operator</span>=(scoped_ptr <span class="type">const</span> &amp;);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">typedef</span> scoped_ptr&lt;T&gt; this_type;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	私有化逻辑比较运算符重载函数，不支持scoped_ptr的智能指针</span></span><br><span class="line"><span class="comment">	对象的比较操作</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>==( scoped_ptr <span class="type">const</span>&amp; ) <span class="type">const</span>;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>!=( scoped_ptr <span class="type">const</span>&amp; ) <span class="type">const</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T element_type;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_ptr</span><span class="params">( T * p = <span class="number">0</span> )</span>: px( p ) // never throws</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(BOOST_SP_ENABLE_DEBUG_HOOKS)</span></span><br><span class="line">        boost::<span class="built_in">sp_scalar_constructor_hook</span>( px );</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BOOST_NO_AUTO_PTR</span></span><br><span class="line">	<span class="comment">/*支持从auto_ptr构造一个scoped_ptr智能指针对象，</span></span><br><span class="line"><span class="comment">	但是auto_ptr因为调用release()函数，导致其内部指</span></span><br><span class="line"><span class="comment">	针为nullptr*/</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_ptr</span><span class="params">( std::auto_ptr&lt;T&gt; p )</span> BOOST_NOEXCEPT : px( p.release() )</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(BOOST_SP_ENABLE_DEBUG_HOOKS)</span></span><br><span class="line">        boost::<span class="built_in">sp_scalar_constructor_hook</span>( px );</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*析构函数，释放智能指针持有的资源*/</span></span><br><span class="line">    ~<span class="built_in">scoped_ptr</span>() <span class="comment">// never throws</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(BOOST_SP_ENABLE_DEBUG_HOOKS)</span></span><br><span class="line">        boost::<span class="built_in">sp_scalar_destructor_hook</span>( px );</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        boost::<span class="built_in">checked_delete</span>( px );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从scoped_ptr的源码可以看到，该智能指针由于私有化了拷贝构造函数和operator&#x3D;赋值函数，因此<strong>从根本上杜绝了智能指针浅拷贝的发生，所以scoped_ptr也是不能用在容器当中的，如果容器互相进行拷贝或者赋值，就会引起scoped_ptr对象的拷贝构造和赋值，这是不允许的，代码会提示编译错误</strong>。</p>
<p>也可以理解为他把拷贝构造和赋值重载设置为delete了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scoped_ptr</span>(<span class="type">const</span> scoped_ptr&lt;T&gt;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">scoped_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> scoped_ptr&lt;T&gt;&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<p>auto_ptr和scoped_ptr这一点上的区别，有些资料上用<strong>所有权</strong>的概念来描述，道理是相同的，<strong>auto_ptr可以任意转移资源的所有权，而scoped_ptr不会转移所有权</strong>（因为拷贝构造和赋值被禁止了）。</p>
<h4 id="3-unique-ptr"><a href="#3-unique-ptr" class="headerlink" title="3.unique_ptr"></a>3.unique_ptr</h4><p>先看看unique_ptr的部分源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>,</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">_Dx</span>&gt;	<span class="comment">// = default_delete&lt;_Ty&gt;</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">unique_ptr</span></span><br><span class="line">		: <span class="keyword">public</span> _Unique_ptr_base&lt;_Ty, _Dx&gt;</span><br><span class="line">	&#123;	<span class="comment">// non-copyable pointer to an object</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> _Unique_ptr_base&lt;_Ty, _Dx&gt; _Mybase;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> _Mybase::pointer pointer;</span><br><span class="line">	<span class="keyword">typedef</span> _Ty element_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Dx deleter_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*提供了右值引用的拷贝构造函数*/</span></span><br><span class="line">	<span class="built_in">unique_ptr</span>(unique_ptr&amp;&amp; _Right) <span class="keyword">noexcept</span></span><br><span class="line">		: _Mybase(_Right.<span class="built_in">release</span>(),</span><br><span class="line">			_STD forward&lt;_Dx&gt;(_Right.<span class="built_in">get_deleter</span>()))</span><br><span class="line">		&#123;	<span class="comment">// construct by moving _Right</span></span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*提供了右值引用的operator=赋值重载函数*/</span></span><br><span class="line">	unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&amp;&amp; _Right) <span class="keyword">noexcept</span></span><br><span class="line">		&#123;	<span class="comment">// assign by moving _Right</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != _STD <span class="built_in">addressof</span>(_Right))</span><br><span class="line">			&#123;	<span class="comment">// different, do the move</span></span><br><span class="line">			<span class="built_in">reset</span>(_Right.<span class="built_in">release</span>());</span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">get_deleter</span>() = _STD forward&lt;_Dx&gt;(_Right.<span class="built_in">get_deleter</span>());</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	交换两个unique_ptr智能指针对象的底层指针</span></span><br><span class="line"><span class="comment">	和删除器</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unique_ptr&amp; _Right)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">		</span>&#123;	<span class="comment">// swap elements</span></span><br><span class="line">		_Swap_adl(<span class="keyword">this</span>-&gt;_Myptr(), _Right._Myptr());</span><br><span class="line">		_Swap_adl(<span class="keyword">this</span>-&gt;<span class="built_in">get_deleter</span>(), _Right.<span class="built_in">get_deleter</span>());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*通过自定义删除器释放资源*/</span></span><br><span class="line">	~<span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span></span><br><span class="line">		&#123;	<span class="comment">// destroy the object</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">get</span>() != <span class="built_in">pointer</span>())</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">get_deleter</span>()(<span class="built_in">get</span>());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*unique_ptr提供-&gt;运算符的重载函数*/</span></span><br><span class="line">	_NODISCARD pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">		&#123;	<span class="comment">// return pointer to class object</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span>-&gt;_Myptr());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*返回智能指针对象底层管理的指针*/</span></span><br><span class="line">	<span class="function">_NODISCARD pointer <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">		</span>&#123;	<span class="comment">// return pointer to object</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span>-&gt;_Myptr());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*提供bool类型的重载，使unique_ptr对象可以</span></span><br><span class="line"><span class="comment">	直接使用在逻辑语句当中，比如if,for,while等*/</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">		</span>&#123;	<span class="comment">// test for non-null pointer</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="built_in">get</span>() != <span class="built_in">pointer</span>());</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*功能和auto_ptr的release函数功能相同，最终也是只有一个unique_ptr指针指向资源*/</span></span><br><span class="line">	<span class="function">pointer <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">		</span>&#123;	<span class="comment">// yield ownership of pointer</span></span><br><span class="line">		pointer _Ans = <span class="built_in">get</span>();</span><br><span class="line">		<span class="keyword">this</span>-&gt;_Myptr() = <span class="built_in">pointer</span>();</span><br><span class="line">		<span class="keyword">return</span> (_Ans);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*把unique_ptr原来的旧资源释放，重置新的资源_Ptr*/</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(pointer _Ptr = pointer())</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">		</span>&#123;	<span class="comment">// establish new pointer</span></span><br><span class="line">		pointer _Old = <span class="built_in">get</span>();</span><br><span class="line">		<span class="keyword">this</span>-&gt;_Myptr() = _Ptr;</span><br><span class="line">		<span class="keyword">if</span> (_Old != <span class="built_in">pointer</span>())</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">get_deleter</span>()(_Old);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	删除了unique_ptr的拷贝构造和operator=赋值函数，</span></span><br><span class="line"><span class="comment">	因此不能做unique_ptr智能指针对象的拷贝构造和</span></span><br><span class="line"><span class="comment">	赋值，防止浅拷贝的发生</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p>从上面看到，unique_ptr有一点和scoped_ptr做的一样，就是<strong>去掉了拷贝构造函数和operator&#x3D;赋值重载函数，禁止用户对unique_ptr进行显示的拷贝构造和赋值，防止智能指针浅拷贝问题的发生</strong>。</p>
<p><strong>但是unique_ptr提供了带右值引用参数的拷贝构造和赋值</strong>，也就是说，unique_ptr智能指针可以通过右值引用进行拷贝构造和赋值操作，或者在产生unique_ptr临时对象的地方，如把unique_ptr作为函数的返回值时，示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例1</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = std::<span class="built_in">move</span>(ptr); <span class="comment">// 使用了右值引用的拷贝构造</span></span><br><span class="line">ptr2 = std::<span class="built_in">move</span>(ptr); <span class="comment">// 使用了右值引用的operator=赋值重载函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">test_uniqueptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> ptr1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	此处调用test_uniqueptr函数，在return ptr1代码</span></span><br><span class="line"><span class="comment">	处，调用右值引用的拷贝构造函数，由ptr1拷贝构造ptr</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	unique_ptr&lt;<span class="type">int</span>&gt; ptr = <span class="built_in">test_uniqueptr</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unique_ptr也是auto_ptr一样，只有最后一个指针有资源管理权，但这个是通过move实现的，不是将原来的指针置为空，原来的unique_ptr也不能管理资源，只有最新的一个可以。</p>
<p>unique_ptr还提供了reset重置资源，swap交换资源等函数，也经常会使用到。<strong>可以看到，unique_ptr从名字就可以看出来，最终也是只能有一个该智能指针引用资源，因此建议在使用不带引用计数的智能指针时，可以优先选择unique_ptr智能指针</strong>。</p>
<h4 id="4-三个指针对比"><a href="#4-三个指针对比" class="headerlink" title="4.三个指针对比"></a>4.三个指针对比</h4><table>
<thead>
<tr>
<th></th>
<th>有没有拷贝和赋值重载</th>
<th>哪个指针管理内存资源</th>
<th>可以赋值吗</th>
</tr>
</thead>
<tbody><tr>
<td>auto</td>
<td>有，并且可用</td>
<td>指向同一块内存的指针只有最新的指针才能管理内存</td>
<td>可以，但是原来的指针被赋值为nullptr</td>
</tr>
<tr>
<td>scoped</td>
<td>有，但是被设为私有，不能用</td>
<td>指向同一块内存的指针只有最新的指针才能管理内存</td>
<td>不可以，直接是不允许的行为</td>
</tr>
<tr>
<td>unique</td>
<td>有，但是被设置为delete了，不能用</td>
<td>指向同一块内存的指针只有最新的指针才能管理内存</td>
<td>不可以用左值赋值，但可以通过move转为右值赋值</td>
</tr>
</tbody></table>
<h3 id="2-4带引用计数的智能指针shared-ptr、weak-ptr"><a href="#2-4带引用计数的智能指针shared-ptr、weak-ptr" class="headerlink" title="2.4带引用计数的智能指针shared_ptr、weak_ptr"></a>2.4带引用计数的智能指针shared_ptr、weak_ptr</h3><p>这里主要介绍shared_ptr和weak_ptr两个智能指针，<strong>什么是带引用计数的智能指针</strong>？当允许多个智能指针指向同一个资源的时候，<strong>每一个智能指针都会给资源的引用计数加1，当一个智能指针析构时，同样会使资源的引用计数减1，这样最后一个智能指针把资源的引用计数从1减到0时，就说明该资源可以释放了</strong>，由最后一个智能指针的析构函数来处理资源的释放问题，这就是引用计数的概念。</p>
<p>要对资源的引用个数进行计数，那么大家知道，<strong>对于整数的++或者- -操作，它并不是线程安全的操作，因此shared_ptr和weak_ptr底层的引用计数已经通过CAS操作，保证了引用计数加减的原子特性，因此shared_ptr和weak_ptr本身就是线程安全的带引用计数的智能指针</strong>。</p>
<p>曾经有一道面试的问题这样问“<strong>shared_ptr智能指针的引用计数在哪里存放？</strong>”，当然，这个问题需要看shared_ptr的源码了，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	下面这两个是shared_ptr的成员变量，_Ptr是指向内存资源的指针，_Rep是</span></span><br><span class="line"><span class="comment">	指向new出来的计数器对象的指针，该计数器对象包含了资源的一个引用计数器count</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	element_type * _Ptr&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">	_Ref_count_base * _Rep&#123;<span class="literal">nullptr</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>因此，<strong>shared_ptr智能指针的资源引用计数器在内存的heap堆上</strong>。shared_ptr一般被称作<strong>强智能指针</strong>，weak_ptr被称作<strong>弱智能指针</strong>，它们有下边两个非常重要的应用场景需要注意。</p>
<p>强：可以改变资源的引用计数</p>
<p>弱：不能改变资源的引用计数</p>
<h3 id="2-5智能指针的交叉引用（循环引用）问题"><a href="#2-5智能指针的交叉引用（循环引用）问题" class="headerlink" title="2.5智能指针的交叉引用（循环引用）问题"></a>2.5智能指针的交叉引用（循环引用）问题</h3><p>请看下面的这个代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前置声明类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	shared_ptr&lt;B&gt; _ptrb; <span class="comment">// 指向B对象的智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	shared_ptr&lt;A&gt; _ptra; <span class="comment">// 指向A对象的智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">shared_ptr&lt;A&gt; <span class="title">ptra</span><span class="params">(<span class="keyword">new</span> A())</span></span>;<span class="comment">// ptra指向A对象，A的引用计数为1</span></span><br><span class="line">	<span class="function">shared_ptr&lt;B&gt; <span class="title">ptrb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;<span class="comment">// ptrb指向B对象，B的引用计数为1</span></span><br><span class="line">	ptra-&gt;_ptrb = ptrb;<span class="comment">// A对象的成员变量_ptrb也指向B对象，B的引用计数为2</span></span><br><span class="line">	ptrb-&gt;_ptra = ptra;<span class="comment">// B对象的成员变量_ptra也指向A对象，A的引用计数为2</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; ptra.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 打印A的引用计数结果:2</span></span><br><span class="line">	cout &lt;&lt; ptrb.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 打印B的引用计数结果:2</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	出main函数作用域，ptra和ptrb两个局部对象析构，分别给A对象和</span></span><br><span class="line"><span class="comment">	B对象的引用计数从2减到1，达不到释放A和B的条件（释放的条件是</span></span><br><span class="line"><span class="comment">	A和B的引用计数为0），因此造成两个new出来的A和B对象无法释放，</span></span><br><span class="line"><span class="comment">	导致内存泄露，这个问题就是“强智能指针的交叉引用(循环引用)问题”</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241012100647629.png" alt="image-20241012100647629"></p>
<p>代码打印结果：<br>A()<br>B()<br>2<br>2<br>可以看到，A和B对象并没有进行析构，通过上面的代码示例，能够看出来“交叉引用”的问题所在，就是对象无法析构，<strong>资源无法释放</strong>，那怎么解决这个问题呢？请注意强弱智能指针的一个重要应用规则：<strong>定义对象时，用强智能指针shared_ptr，在其它地方引用对象时，使用弱智能指针weak_ptr</strong>。</p>
<p><code>注解：</code>这句话的意思是，在创建或分配一个对象时，应该使用<code>std::shared_ptr</code>来管理这个对象的生命周期。而在需要引用这个对象，但又不想拥有它（即不想影响它的生命周期）的地方，应该使用<code>std::weak_ptr</code>。</p>
<p>在这里，“引用对象”指的是在代码中创建或获取一个指向某个对象的引用或指针，以便能够访问该对象的成员（属性或方法）。</p>
<p><strong>弱智能指针weak_ptr区别于shared_ptr之处在于</strong>：</p>
<ol>
<li>weak_ptr不会改变资源的引用计数，只是一个观察者的角色，通过观察shared_ptr来判定资源是否存在</li>
<li>weak_ptr持有的引用计数，不是资源的引用计数，而是同一个资源的观察者的计数</li>
<li>weak_ptr没有提供常用的指针操作，无法直接访问资源，需要先通过lock方法提升为shared_ptr强智能指针，才能访问资源</li>
</ol>
<p>那么上面的代码怎么修改，<strong>也就是如何解决带引用计数的智能指针的交叉引用问题</strong>，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前置声明类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	weak_ptr&lt;B&gt; _ptrb; <span class="comment">// 指向B对象的弱智能指针。引用对象时，用弱智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	weak_ptr&lt;A&gt; _ptra; <span class="comment">// 指向A对象的弱智能指针。引用对象时，用弱智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义对象时，用强智能指针</span></span><br><span class="line">	<span class="function">shared_ptr&lt;A&gt; <span class="title">ptra</span><span class="params">(<span class="keyword">new</span> A())</span></span>;<span class="comment">// ptra指向A对象，A的引用计数为1</span></span><br><span class="line">	<span class="function">shared_ptr&lt;B&gt; <span class="title">ptrb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;<span class="comment">// ptrb指向B对象，B的引用计数为1</span></span><br><span class="line">	<span class="comment">// A对象的成员变量_ptrb也指向B对象，B的引用计数为1，因为是弱智能指针，引用计数没有改变</span></span><br><span class="line">	ptra-&gt;_ptrb = ptrb;</span><br><span class="line">	<span class="comment">// B对象的成员变量_ptra也指向A对象，A的引用计数为1，因为是弱智能指针，引用计数没有改变</span></span><br><span class="line">	ptrb-&gt;_ptra = ptra;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; ptra.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 打印结果:1</span></span><br><span class="line">	cout &lt;&lt; ptrb.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 打印结果:1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	出main函数作用域，ptra和ptrb两个局部对象析构，分别给A对象和</span></span><br><span class="line"><span class="comment">	B对象的引用计数从1减到0，达到释放A和B的条件，因此new出来的A和B对象</span></span><br><span class="line"><span class="comment">	被析构掉，解决了“强智能指针的交叉引用(循环引用)问题”</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码打印如下：<br>A()<br>B()<br>1<br>1<br>~B()<br>~A()<br>可以看到，A和B对象正常析构，问题解决！</p>
<p><strong>weak没有重载*和-&gt;运算符，不能完全替代裸指针的功能</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前置声明类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	weak_ptr&lt;B&gt; _ptrb; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//假设是一个非常好的方法</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	weak_ptr&lt;A&gt; _ptra; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//_ptra-&gt;testA(); weak没有重载*和-&gt;运算符，不能完全替代裸指针的功能</span></span><br><span class="line">        <span class="comment">//如果想要调用A中那个非常好的方法/函数</span></span><br><span class="line">        <span class="comment">//得用lock先把弱指针提升为强指针,资源没了就提升失败返回nullptr，成功了能用了</span></span><br><span class="line">        <span class="comment">//之后就可以用强指针的功能了，但是引用计数也会+1</span></span><br><span class="line">        <span class="comment">//这个强指针由弱指针创建，提升完以后弱指针依然存在</span></span><br><span class="line">        shared_ptr&lt;A&gt; ps=_ptra.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(ps!=<span class="literal">nullptr</span>)</span><br><span class="line">            ps-&gt;<span class="built_in">testA</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">shared_ptr&lt;A&gt; <span class="title">ptra</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">	<span class="function">shared_ptr&lt;B&gt; <span class="title">ptrb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">	ptra-&gt;_ptrb = ptrb;</span><br><span class="line">	ptrb-&gt;_ptra = ptra;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; ptra.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 打印结果:1</span></span><br><span class="line">	cout &lt;&lt; ptrb.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 打印结果:1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6多线程访问共享对象问题"><a href="#2-6多线程访问共享对象问题" class="headerlink" title="2.6多线程访问共享对象问题"></a>2.6多线程访问共享对象问题</h3><p>有一个用C++写的开源网络库，muduo库，作者陈硕，大家可以在网上下载到muduo的源代码，该源码中对于智能指针的应用非常优秀，其中<strong>借助shared_ptr和weak_ptr解决了这样一个问题，多线程访问共享对象的线程安全问题</strong>，解释如下：线程A和线程B访问一个共享的对象，如果线程A正在析构这个对象的时候，线程B又要调用该共享对象的成员方法，此时可能线程A已经把对象析构完了，线程B再去访问该对象，就会发生不可预期的错误。</p>
<p>先看如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造Test对象，_ptr指向一块int堆内存，初始值是20</span></span><br><span class="line">	<span class="built_in">Test</span>() :_ptr(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>)) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 析构Test对象，释放_ptr指向的堆内存</span></span><br><span class="line">	~<span class="built_in">Test</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> _ptr;</span><br><span class="line">		_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 该show会在另外一个线程中被执行</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; *_ptr &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> *<span class="keyword">volatile</span> _ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadProc</span><span class="params">(Test *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 睡眠两秒，此时main主线程已经把Test对象给delete析构掉了</span></span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	此时当前线程访问了main线程已经析构的共享对象，结果未知，隐含bug。</span></span><br><span class="line"><span class="comment">	此时通过p指针想访问Test对象，需要判断Test对象是否存活，如果Test对象</span></span><br><span class="line"><span class="comment">	存活，调用show方法没有问题；如果Test对象已经析构，调用show有问题！</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	p-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 在堆上定义共享对象</span></span><br><span class="line">	Test *p = <span class="keyword">new</span> <span class="built_in">Test</span>();</span><br><span class="line">	<span class="comment">// 使用C++11的线程类，开启一个新线程，并传入共享对象的地址p</span></span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(threadProc, p)</span></span>;</span><br><span class="line">	<span class="comment">// 在main线程中析构Test共享对象</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="comment">// 等待子线程运行结束</span></span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的代码，发现在main主线程已经delete析构Test对象以后，子线程threadProc再去访问Test对象的show方法，<em><em>无法打印出</em>_ptr的值20</em>*。可以用shared_ptr和weak_ptr来解决多线程访问共享对象的线程安全问题，上面代码修改如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造Test对象，_ptr指向一块int堆内存，初始值是20</span></span><br><span class="line">	<span class="built_in">Test</span>() :_ptr(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>)) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 析构Test对象，释放_ptr指向的堆内存</span></span><br><span class="line">	~<span class="built_in">Test</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> _ptr;</span><br><span class="line">		_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 该show会在另外一个线程中被执行</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; *_ptr &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> *<span class="keyword">volatile</span> _ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadProc</span><span class="params">(weak_ptr&lt;Test&gt; pw)</span> <span class="comment">// 通过弱智能指针观察强智能指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 睡眠两秒</span></span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	如果想访问对象的方法，先通过pw的lock方法进行提升操作，把weak_ptr提升</span></span><br><span class="line"><span class="comment">	为shared_ptr强智能指针，提升过程中，是通过检测它所观察的强智能指针保存</span></span><br><span class="line"><span class="comment">	的Test对象的引用计数，来判定Test对象是否存活，ps如果为nullptr，说明Test对象</span></span><br><span class="line"><span class="comment">	已经析构，不能再访问；如果ps!=nullptr，则可以正常访问Test对象的方法。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	shared_ptr&lt;Test&gt; ps = pw.<span class="built_in">lock</span>();</span><br><span class="line">	<span class="keyword">if</span> (ps != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ps-&gt;<span class="built_in">show</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 在堆上定义共享对象</span></span><br><span class="line">	<span class="function">shared_ptr&lt;Test&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Test)</span></span>;</span><br><span class="line">	<span class="comment">// 使用C++11的线程，开启一个新线程，并传入共享对象的弱智能指针</span></span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(threadProc, weak_ptr&lt;Test&gt;(p))</span></span>;</span><br><span class="line">	<span class="comment">// 在main线程中析构Test共享对象</span></span><br><span class="line">	<span class="comment">// 等待子线程运行结束</span></span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的代码，show方法可以打印出20，<strong>因为main线程调用了t1.join()方法等待子线程结束，此时pw通过lock提升为ps成功</strong>，见上面代码示例。</p>
<p>如果设置t1为分离线程，让main主线程结束，p智能指针析构，进而把Test对象析构，此时show方法已经不会被调用，<strong>因为在threadProc方法中，pw提升到ps时，lock方法判定Test对象已经析构，提升失败</strong>！main函数代码可以如下修改测试：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 在堆上定义共享对象</span></span><br><span class="line">	<span class="function">shared_ptr&lt;Test&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Test)</span></span>;</span><br><span class="line">	<span class="comment">// 使用C++11的线程，开启一个新线程，并传入共享对象的弱智能指针</span></span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(threadProc, weak_ptr&lt;Test&gt;(p))</span></span>;</span><br><span class="line">	<span class="comment">// 在main线程中析构Test共享对象</span></span><br><span class="line">	<span class="comment">// 设置子线程分离</span></span><br><span class="line">	t<span class="number">1.</span><span class="built_in">detach</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该main函数运行后，最终的threadProc中，show方法不会被执行到。<strong>以上是在多线程中访问共享对象时，对shared_ptr和weak_ptr的一个典型应用</strong>。</p>
<h3 id="2-7自定义删除器"><a href="#2-7自定义删除器" class="headerlink" title="2.7自定义删除器"></a>2.7自定义删除器</h3><p>我们经常用智能指针管理的资源是堆内存，当智能指针出作用域的时候，在其析构函数中会delete释放堆内存资源，但是除了堆内存资源，智能指针还可以管理其它资源，比如打开的文件，此时对于文件指针的关闭，就不能用delete了，这时我们需要自定义智能指针释放资源的方式，先看看unique_ptr智能指针的析构函数代码，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">~<span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span></span><br><span class="line">&#123;	<span class="comment">// destroy the object</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">get</span>() != <span class="built_in">pointer</span>())</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">get_deleter</span>()(<span class="built_in">get</span>()); <span class="comment">// 这里获取底层的删除器，进行函数对象的调用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从unique_ptr的析构函数可以看到，如果要实现一个自定义的删除器，实际上就是定义一个函数对象（重载的调用运算符（））而已，示例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDeletor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(T *ptr)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;  </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;call MyDeletor.operator()&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">delete</span>[]ptr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFileDeletor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(T *ptr)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;call MyFileDeletor.operator()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    	<span class="built_in">fclose</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>, MyDeletor&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>]); <span class="comment">// delete []ptr;</span></span><br><span class="line">    unique_ptr&lt;FILE, MyFileDeletor&lt;FILE&gt;&gt; <span class="built_in">ptr2</span> (<span class="built_in">fopen</span>(<span class="string">&quot;data,txt&quot;</span>, <span class="string">&quot;w&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然这种方式需要定义额外的函数对象类型，不推荐，可以用C++11提供的函数对象function和lambda表达式更好的处理自定义删除器，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>, function&lt;<span class="type">void</span>(<span class="type">int</span>*)&gt;&gt; <span class="built_in">ptrl</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>],</span><br><span class="line">    	[] (<span class="type">int</span> *p) -&gt;<span class="type">void</span> &#123;</span><br><span class="line">    		cout &lt;&lt; <span class="string">&quot;call lambda release new int[100]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    		<span class="keyword">delete</span> []p;</span><br><span class="line">    	&#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    unique_ptr&lt;FILE, function&lt;<span class="type">void</span>(FILE*)&gt;&gt; <span class="built_in">ptr2</span>(<span class="built_in">fopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;w&quot;</span>),</span><br><span class="line">    	[] (FILE *p) -&gt;<span class="type">void</span> &#123;</span><br><span class="line">    		cout &lt;&lt; <span class="string">&quot;call lambda release new fopen&quot;</span> &lt;&lt; endl;</span><br><span class="line">    		<span class="built_in">fclose</span>(p);</span><br><span class="line">    	&#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、绑定器和函数对象、lambda表达式"><a href="#三、绑定器和函数对象、lambda表达式" class="headerlink" title="三、绑定器和函数对象、lambda表达式"></a>三、绑定器和函数对象、lambda表达式</h2><h3 id="3-1模板的完全特例化和非完全（部分）特例化"><a href="#3-1模板的完全特例化和非完全（部分）特例化" class="headerlink" title="3.1模板的完全特例化和非完全（部分）特例化"></a>3.1模板的完全特例化和非完全（部分）特例化</h3><h4 id="1-完全特例化和非完全（部分）特例化"><a href="#1-完全特例化和非完全（部分）特例化" class="headerlink" title="1.完全特例化和非完全（部分）特例化"></a>1.完全特例化和非完全（部分）特例化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Vector</span> () &#123; cout &lt;&lt; <span class="string">&quot;call Vector template init&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 下面这个是对char*类型提供的完全特例化版本 </span></span><br><span class="line">    <span class="comment">//1.必须得有上面那个才能提供下面这个，光下面这个也不行</span></span><br><span class="line">    <span class="comment">//2. &quot;&lt;&gt;&quot;这是语法不能省略</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&lt;<span class="type">char</span>*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Vector</span> () &#123; cout &lt;&lt; <span class="string">&quot;call Vector&lt;char*&gt; init&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//针对指针类型提供的部分特例化版本 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//我们并不知道是哪个类型的指针，所以还是要写typename T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Vector</span> () &#123; cout &lt;&lt; <span class="string">&quot;call Vector&lt;T*&gt; init&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//针对函数指针类型（有返回值，有两个形参变量的函数）提供的部分特例化版本 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> A1,<span class="keyword">typename</span> A2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&lt;<span class="built_in">R</span>(*)(A1,A2)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Vector</span> () &#123; cout &lt;&lt; <span class="string">&quot;call Vector&lt;R(*)(A1,A2)&gt; init&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//完全特例化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&lt;<span class="built_in">int</span>(*)(<span class="type">int</span>,<span class="type">int</span>)&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//部分特例化更灵活一点</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//函数类型部分特例化    </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> A1,<span class="keyword">typename</span> A2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&lt;<span class="built_in">R</span>(A1,A2)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Vector</span> () &#123; cout &lt;&lt; <span class="string">&quot;call Vector&lt;R(A1,A2)&gt; init&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a+b;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector&lt;<span class="type">int</span>&gt; vec1;<span class="comment">//从原模板进行实例化</span></span><br><span class="line">    Vector&lt;<span class="type">char</span> *&gt; vec2;<span class="comment">//使用完全特例化版本</span></span><br><span class="line">    Vector&lt;<span class="type">int</span> *&gt; vec3;<span class="comment">//使用针对指针的部分特例化版本</span></span><br><span class="line">    Vector&lt;<span class="built_in">int</span>(*)(<span class="type">int</span>,<span class="type">int</span>)&gt;vec4;<span class="comment">//使用针对指针的特例化版本 这个类型相当于上面sum函数类型（函数指针），只是同一个类型，不是指sum函数</span></span><br><span class="line">    Vector&lt;<span class="built_in">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;vec4;<span class="comment">//这是函数类型，不是函数指针类型，匹配的是函数类型的模板进行实例化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数类型</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PFUNC1)</span> <span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">    PFUNC1 pfunc1 = sum;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">pfunc1</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//函数指针类型</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="type">int</span> <span class="title">PFUNC2</span> <span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">    PFUNC2 *pfunc2 = sum;</span><br><span class="line">    cout &lt;&lt; (*pfunc2)(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意区分两者</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看有没有完全特例化，没有看部分特例化，最后看原模板</p>
<h4 id="2-模板的实参推演"><a href="#2-模板的实参推演" class="headerlink" title="2.模板的实参推演"></a>2.模板的实参推演</h4><p>typeid().name用来得到传入参数的类型</p>
<p>向上面一样，我们如果得到的T是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> (*)(<span class="type">int</span>,<span class="type">int</span>)或者<span class="built_in">int</span>(<span class="type">int</span>,<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>那完全没什么作用，就只是知道了，而现在可以通过实参推演，获得各个部分是什么类型，以下面代码为例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得普通类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> A1,<span class="keyword">typename</span> A2&gt;<span class="comment">//指针对函数指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(R (*a)(A1,A2))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">typeid</span>(R).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">typeid</span>(A1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">typeid</span>(A2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//int,int,int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T,<span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt;<span class="comment">//针对类成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(R(T::*a)(A1, A2))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">typeid</span>(R).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">typeid</span>(A1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">typeid</span>(A2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//int,class test,int,int</span></span><br><span class="line"><span class="comment">//可以用这些进行变量定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">	<span class="built_in">func</span>(sum);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">func2</span>(sum);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">func3</span>(&amp;test::sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241012182940976.png" alt="image-20241012182940976"></p>
<p>从结果可以看出，我们可以获得各个类型</p>
<h3 id="3-2-C-STL中的绑定器"><a href="#3-2-C-STL中的绑定器" class="headerlink" title="3.2 C++ STL中的绑定器"></a>3.2 C++ STL中的绑定器</h3><p><strong>bind1st</strong>和<strong>bind2nd</strong>是C++标准库中的两个函数适配器，它们的主要作用是将一个<strong>二元函数对象</strong>（即接受两个参数的函数对象）转换为一元函数对象（即接受一个参数的函数对象）。这两个函数适配器的区别主要在于它们绑定的是二元函数对象的哪一个参数。</p>
<p><code>只能用于二元</code></p>
<h4 id="bind1st"><a href="#bind1st" class="headerlink" title="bind1st"></a>bind1st</h4><ul>
<li><strong>功能</strong>：bind1st函数接受一个二元函数和一个值，返回一个新的函数对象。这个新的函数对象将二元函数的第一个参数绑定为给定的值，因此调用时只需要提供第二个参数。</li>
<li><strong>使用场景</strong>：当你希望将一个二元函数的第一个参数固定为某个值时，可以使用bind1st。这样，你就可以得到一个一元函数，其行为类似于原二元函数但第一个参数已被绑定。</li>
</ul>
<h4 id="bind2nd"><a href="#bind2nd" class="headerlink" title="bind2nd"></a>bind2nd</h4><ul>
<li><strong>功能</strong>：与bind1st类似，bind2nd函数也接受一个二元函数和一个值，但返回的新函数对象将二元函数的第二个参数绑定为给定的值。因此，调用时只需要提供第一个参数。</li>
<li><strong>使用场景</strong>：当你希望将一个二元函数的第二个参数固定为某个值时，可以使用bind2nd。这样，你也可以得到一个一元函数，但其行为是原二元函数且第二个参数已被绑定。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printvec</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> c : v)</span><br><span class="line">		cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printvec</span>(vec);</span><br><span class="line">	<span class="comment">//从小到大</span></span><br><span class="line">	<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printvec</span>(vec);</span><br><span class="line">	<span class="comment">//从大到小</span></span><br><span class="line">	<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">	<span class="built_in">printvec</span>(vec);</span><br><span class="line">	<span class="comment">//greater a&gt;b 从大到小</span></span><br><span class="line">	<span class="comment">//less a&lt;b 从小到大</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*bind绑定器</span></span><br><span class="line"><span class="comment">	把70按顺序插入到vec容器中 找第一个小于70的数字，那只传入一个参数，就没办法用gerater或者less了</span></span><br><span class="line"><span class="comment">	所以可以用绑定器 绑定器 + 二元函数对象 =&gt; 一元函数对象</span></span><br><span class="line"><span class="comment">	bind1st：+ greater bool operator()(70,const _Ty&amp; _Right)</span></span><br><span class="line"><span class="comment">	bind2nd：+ less bool operator()(const _Ty&amp; _Left,70)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">auto</span> it1 = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">bind1st</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">70</span>));</span><br><span class="line">	<span class="keyword">if</span> (it1 != vec.<span class="built_in">end</span>())</span><br><span class="line">		vec.<span class="built_in">insert</span>(it1, <span class="number">70</span>);</span><br><span class="line">	<span class="built_in">printvec</span>(vec);</span><br><span class="line">	<span class="keyword">auto</span> it2 = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">60</span>));</span><br><span class="line">	<span class="keyword">if</span> (it2 != vec.<span class="built_in">end</span>())</span><br><span class="line">		vec.<span class="built_in">insert</span>(it2, <span class="number">60</span>);</span><br><span class="line">	<span class="built_in">printvec</span>(vec);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自己实现一个bind1st"><a href="#自己实现一个bind1st" class="headerlink" title="自己实现一个bind1st"></a>自己实现一个bind1st</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> Compare&gt;</span></span><br><span class="line"><span class="function">Iterator <span class="title">my_find_if</span><span class="params">(Iterator first, Iterator last, Compare comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; first++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">comp</span>(*first))<span class="comment">//comp.operator()(*fist) comp的()重载函数传入参数为*first</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> first;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_mybind1st</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	_mybind1st(Compare comp,T val):_comp(comp),_val(val)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; second)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _comp(_val, second);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Compare _comp;</span><br><span class="line">	T _val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare,<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">_mybind1st&lt;Compare,T&gt; <span class="title">mybind1st</span><span class="params">(Compare comp, <span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _mybind1st&lt;Compare, T&gt;(comp, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printvec</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> c : v)</span><br><span class="line">		cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">		vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printvec</span>(vec);</span><br><span class="line">	<span class="comment">//从小到大</span></span><br><span class="line">	<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printvec</span>(vec);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> it1 = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">mybind1st</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">70</span>));</span><br><span class="line">	<span class="keyword">if</span> (it1 != vec.<span class="built_in">end</span>())</span><br><span class="line">		vec.<span class="built_in">insert</span>(it1, <span class="number">70</span>);</span><br><span class="line">	<span class="built_in">printvec</span>(vec);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过程说明：</p>
<ol>
<li><strong>创建 <code>_mybind1st</code> 对象</strong>：<br>当调用 <code>mybind1st(greater&lt;int&gt;(), 70)</code> 时，会创建一个 <code>_mybind1st&lt;greater&lt;int&gt;, int&gt;</code> 类型的临时对象。这个对象内部存储了 <code>greater&lt;int&gt;</code> 的一个实例（作为 <code>_comp</code> 成员变量）和整数 <code>70</code>（作为 <code>_val</code> 成员变量）。</li>
<li><strong>将 <code>_mybind1st</code> 对象传递给 <code>my_find_if</code></strong>：<br>然后，这个 <code>_mybind1st</code> 对象被传递给 <code>my_find_if</code> 函数作为 <code>comp</code> 参数。</li>
<li><strong>在 <code>my_find_if</code> 中调用 <code>comp(*first)</code></strong>：<br>在 <code>my_find_if</code> 的循环中，当调用 <code>comp(*first)</code> 时，实际上是在调用 <code>_mybind1st</code> 对象的 <code>operator()</code> 成员函数。这是因为 <code>_mybind1st</code> 对象是一个函数对象，它重载了 <code>operator()</code> 以使其表现得像一个函数。</li>
<li><strong><code>_mybind1st</code> 的 <code>operator()</code> 实现</strong>：<br>在 <code>_mybind1st</code> 的 <code>operator()</code> 中，代码是 <code>return _comp(_val, second);</code>。这里，<code>_comp</code> 是存储的 <code>greater&lt;int&gt;</code> 对象，<code>_val</code> 是 <code>70</code>，而 <code>second</code> 是 <code>*first</code>（即当前正在检查的元素）。因此，这个调用实际上是在检查当前元素 <code>*first</code> 是否小于 <code>70</code>（因为 <code>greater&lt;int&gt;</code> 的 <code>operator()</code> 检查第一个参数是否大于第二个参数，而这里我们是在用 <code>_val</code>（即 <code>70</code>）作为第一个参数，<code>*first</code> 作为第二个参数）。</li>
</ol>
<p>补充内容：</p>
<p><code>greater&lt;int&gt;</code>是C++标准库中的一个模板类，用于表示两个整数之间的“大于”关系。当实例化<code>greater&lt;int&gt;</code>时，会得到一个函数对象，该函数对象重载了<code>operator()</code>，接受两个<code>int</code>类型的参数，并返回第一个参数是否大于第二个参数的布尔值。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">greater&lt;<span class="type">int</span>&gt; comp;  </span><br><span class="line"><span class="type">bool</span> result = <span class="built_in">comp</span>(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// result 为 true，因为 5 &gt; 3</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-C-11从Boost库中引入了bind和function函数对象机制"><a href="#3-3-C-11从Boost库中引入了bind和function函数对象机制" class="headerlink" title="3.3 C++11从Boost库中引入了bind和function函数对象机制"></a>3.3 C++11从Boost库中引入了bind和function函数对象机制</h3><h4 id="1-function函数对象类型的应用示例（function基础）"><a href="#1-function函数对象类型的应用示例（function基础）" class="headerlink" title="1.function函数对象类型的应用示例（function基础）"></a>1.function函数对象类型的应用示例（function基础）</h4><p>绑定器，函数对象，lambda表达式 他们只能在一条语句中使用</p>
<p><code>function作用：</code>把上面这三个的类型留下来，说得更清楚点就是再给他们一个名字然后方便之后<strong>通过调用给的名字来使用函数对象或者lambda的功能</strong>。</p>
<p><code>function基础：</code></p>
<p>1.用函数类型实例化function<br>2.通过function调用operator（）函数的时候，需要根据函数类型传入相应的参数</p>
<p>具体实例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello2</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">hello2</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//从function的类模板定义处，看到希望用一个函数类型实例化function</span></span><br><span class="line"></span><br><span class="line">	function&lt;<span class="type">void</span>()&gt; func1 = hello1;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.func1.operator() =&gt; hello1 先调用func1的()重载函数，然后调用包装的hello1</span></span><br><span class="line">	<span class="built_in">func1</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.人原来有参数，你写的时候就要加上参数，传入的时候也要传入</span></span><br><span class="line">	function&lt;<span class="type">void</span>(string)&gt; func2 = hello2;</span><br><span class="line">	<span class="built_in">func2</span>(<span class="string">&quot;hello hello2&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//有返回值的</span></span><br><span class="line">	function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func3 = sum;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">func3</span>(<span class="number">20</span>, <span class="number">30</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.lambda的类型保留 注意结尾不要忘了加分号</span></span><br><span class="line">	function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func4 = [](<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">func4</span>(<span class="number">100</span>, <span class="number">200</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.成员函数的类型保留</span></span><br><span class="line">	<span class="comment">//注意点1:在原来的参数列表要多加一个test*</span></span><br><span class="line">	<span class="comment">// 注意点2：调用func5的时候要借助该类对象的指针，这里就构建一个临时对象取地址当做指针来用</span></span><br><span class="line">	function&lt;<span class="type">void</span>(test*, string)&gt; func5 = &amp;test::hello2;</span><br><span class="line">	<span class="built_in">func5</span>(&amp;<span class="built_in">test</span>(), <span class="string">&quot;call test::hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数指针和普通函数指针不同</span></span><br><span class="line">	<span class="comment">//普通指针随便调用就行，但成员函数前面必须要有一个作用域，所以必须依赖一个对象，这也是调用func5要加一个test*的原因</span></span><br><span class="line">	<span class="comment">//成员函数一经编译参数都会多一个指向当前类型的this指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//void (*print)(string str)</span></span><br><span class="line">	<span class="comment">//void (test::*print)(striing str)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合例子来看：</p>
<p>1.func1.operator() &#x3D;&gt; hello1 先调用func1的()重载函数，然后调用包装的hello1</p>
<p>2.人原来有参数，你写的时候就要加上参数，传入的时候也要传入</p>
<p>3.lambda的类型保留 注意结尾不要忘了加分号</p>
<p>4.成员函数的类型保留<br>注意点1:在原来的参数列表要多加一个test*<br>注意点2：调用func5的时候要借助该类对象的指针，这里就构建一个临时对象取地址当做指针来用</p>
<ol start="5">
<li><p>   成员函数指针和普通函数指针不同<br>  普通指针随便调用就行，但成员函数前面必须要有一个作用域，所以必须依赖一个对象，这也是调用func5要加一个test*的原因<br>  成员函数一经编译参数都会多一个指向当前类型的this指针</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> (*print)(string str)</span><br><span class="line"><span class="built_in">void</span> (test::*print)(striing str)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-fucntion函数对象类型的实现原理"><a href="#2-fucntion函数对象类型的实现原理" class="headerlink" title="2.fucntion函数对象类型的实现原理"></a>2.fucntion函数对象类型的实现原理</h4><p>实例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>&#123; cout &lt;&lt; str &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fty&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myfunction</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板的特例版本 针对hello</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> A1&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myfunction</span>&lt;<span class="built_in">R</span>(A1)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*)(A1);</span><br><span class="line">	<span class="built_in">myfunction</span>(PFUNC pfunc):_pfunc(pfunc)&#123;&#125;</span><br><span class="line">	<span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(A1 arg)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _pfunc(arg);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	PFUNC _pfunc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板的特例版本 针对sum</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myfunction</span>&lt;<span class="built_in">R</span>(A1,A2)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*)(A1,A2);</span><br><span class="line">	<span class="built_in">myfunction</span>(PFUNC pfunc) :_pfunc(pfunc) &#123;&#125;</span><br><span class="line">	<span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(A1 arg1,A2 arg2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _pfunc(arg1,arg2);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	PFUNC _pfunc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	myfunction&lt;<span class="built_in">void</span>(string)&gt; func1 = hello;</span><br><span class="line">	<span class="built_in">func1</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	myfunction&lt;<span class="built_in">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; func2 = sum;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">func2</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那肯定会觉得，那这得写多少代码才可以写完，但其实不需要。C+11中提供了可变参的类型参数：包（arg…）</p>
<p>可以理解为把你传进入的所有参数，依次一个一个的传入</p>
<p>感兴趣的读者可以去这里看看相关知识点，这里不再赘述。</p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/142858121?spm=1001.2014.3001.5502">C++11 新特性 学习笔记-CSDN博客</a></p>
<p><strong>通过可变参数实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>&#123; cout &lt;&lt; str &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fty&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myfunction</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... A&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myfunction</span>&lt;<span class="built_in">R</span>(A...)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*)(A...);</span><br><span class="line">	<span class="built_in">myfunction</span>(PFUNC pfunc) :_pfunc(pfunc) &#123;&#125;</span><br><span class="line">	<span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(A... arg)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _pfunc(arg...);<span class="comment">//相当于return sum(10,20);</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	PFUNC _pfunc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	myfunction&lt;<span class="built_in">void</span>(string)&gt; func1 = hello;</span><br><span class="line">	<span class="built_in">func1</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	myfunction&lt;<span class="built_in">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; func2 = sum;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">func2</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以当做是一个可变参数模板的一个实例进行记忆。</p>
<h4 id="3-bind"><a href="#3-bind" class="headerlink" title="3.bind"></a>3.bind</h4><p>bind绑定器返回的也是函数对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> placeholders;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>&#123; cout &lt;&lt; str &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1.bind是函数模板 可以自动推演模板类型参数</span></span><br><span class="line">	<span class="built_in">bind</span>(hello, <span class="string">&quot;hello bind&quot;</span>)();</span><br><span class="line">	cout &lt;&lt; <span class="built_in">bind</span>(sum, <span class="number">10</span>, <span class="number">20</span>)() &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">bind</span>(&amp;test::sum, <span class="built_in">test</span>(), <span class="number">20</span>, <span class="number">30</span>)()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.参数占位符 最多绑定20个参数</span></span><br><span class="line">	<span class="built_in">bind</span>(hello, placeholders::_1)(<span class="string">&quot;hello bind2&quot;</span>);</span><br><span class="line">	<span class="comment">//using namespace placeholders; 有了这句话就可以不写前面的作用域，直接写_1,_2最多20个</span></span><br><span class="line">	cout&lt;&lt;<span class="built_in">bind</span>(sum, _1, _2)(<span class="number">100</span>, <span class="number">200</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.绑定器除了当前语句无法继续使用 解决方法：function</span></span><br><span class="line">	<span class="comment">//此处把bind返回的绑定器就复用起来了</span></span><br><span class="line">	function&lt;<span class="type">void</span>(string)&gt; func1 = <span class="built_in">bind</span>(hello,_1);</span><br><span class="line">	<span class="built_in">func1</span>(<span class="string">&quot;hello china&quot;</span>);</span><br><span class="line">	<span class="built_in">func1</span>(<span class="string">&quot;hello a&quot;</span>);</span><br><span class="line">	<span class="built_in">func1</span>(<span class="string">&quot;hello b&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="bind给成员函数绑定具体的对象（重点）"><a href="#bind给成员函数绑定具体的对象（重点）" class="headerlink" title="bind给成员函数绑定具体的对象（重点）"></a>bind给成员函数绑定具体的对象（重点）</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">memberFunction</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Member function called with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    MyClass obj; <span class="comment">// 创建一个 MyClass 的实例  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用 std::bind 将 memberFunction 与 obj 绑定，并绑定第二个参数为 42  </span></span><br><span class="line">    <span class="keyword">auto</span> boundFunction = std::<span class="built_in">bind</span>(&amp;MyClass::memberFunction, &amp;obj, <span class="number">42</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 调用 boundFunction，它现在会调用 obj 的 memberFunction，并传递 42 作为参数  </span></span><br><span class="line">    <span class="built_in">boundFunction</span>(); <span class="comment">// 输出: Member function called with value: 42  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 注意：在这个例子中，我们没有传递第一个参数（即 this 指针的等价物），  </span></span><br><span class="line">    <span class="comment">// 因为我们已经通过 &amp;obj 提供了具体的对象实例。std::bind 会自动处理这个“隐式”的 this 指针。  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 另外，由于我们已经绑定了第二个参数，所以调用 boundFunction 时不需要再传递它。  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 如果你想要一个更通用的可调用对象，可以只绑定对象实例，而不绑定其他参数：  </span></span><br><span class="line">    <span class="keyword">auto</span> boundFunctionGeneric = std::<span class="built_in">bind</span>(&amp;MyClass::memberFunction, &amp;obj, std::placeholders::_1);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 现在你可以传递一个参数来调用 memberFunction：  </span></span><br><span class="line">    <span class="built_in">boundFunctionGeneric</span>(<span class="number">100</span>); <span class="comment">// 输出: Member function called with value: 100  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-bind-和-function实现线程池"><a href="#4-bind-和-function实现线程池" class="headerlink" title="4.bind 和 function实现线程池"></a>4.bind 和 function实现线程池</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Thread</span>(function&lt;<span class="built_in">void</span>()&gt; func) : _func(func) &#123;&#125;</span><br><span class="line">    <span class="function">thread <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(_func)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    function&lt;<span class="type">void</span>()&gt; _func;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        <span class="comment">//释放Thread对象占用的堆资源</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _pool.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">delete</span> _pool[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开启线程池</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startPool</span><span class="params">(<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">//本身不可以是成员方法，但是可以用bind做到，i作为线程编号</span></span><br><span class="line">            _pool.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="built_in">bind</span>(&amp;ThreadPool::runInThread, <span class="keyword">this</span>, i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            _handler.<span class="built_in">push_back</span>(_pool[i]-&gt;<span class="built_in">start</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (thread&amp; t : _handler) &#123;</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Thread*&gt; _pool;</span><br><span class="line">    vector&lt;thread&gt; _handler;</span><br><span class="line">    <span class="comment">//把runInThread这个成员方法充当线程函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">runInThread</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;call runInThread id: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">startPool</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-类的成员函数不能直接作为线程函数，需要bind进行绑定"><a href="#5-类的成员函数不能直接作为线程函数，需要bind进行绑定" class="headerlink" title="5.类的成员函数不能直接作为线程函数，需要bind进行绑定"></a>5.类的成员函数不能直接作为线程函数，需要bind进行绑定</h4><p>在C++中，类的成员函数不能直接作为线程函数（即不能直接传递给<code>std::thread</code>的构造函数）。这是因为成员函数需要一个隐式的<code>this</code>指针来访问类的成员变量和成员函数，而普通的函数指针或可调用对象并不包含这个<code>this</code>指针的信息。</p>
<p><strong>其实呢也好理解，就是一个成员函数你得有个实例对象才能用.或者-&gt;进行调用成员函数，光传一个名字谁知道你要调用哪个对象的这个函数，因为不同的对象内部成员变量什么的都不同，函数内部使用的也不同，所以得有一个this指向它。</strong></p>
<p>当你尝试将成员函数直接作为线程函数时，编译器会报错，因为它无法确定<code>this</code>指针的值（在创建线程时，目标对象可能还没有被正确构造，或者<code>this</code>指针的值在多线程环境下可能变得不确定）。</p>
<p>为了在线程中调用类的成员函数，你有几个选项：</p>
<ol>
<li><strong>使用<code>std::bind</code></strong>：<br><code>std::bind</code>可以绑定成员函数和<code>this</code>指针，生成一个新的可调用对象，这个对象可以被<code>std::thread</code>接受。这是你在问题中提到的方法。</li>
<li><strong>使用lambda表达式</strong>：<br>Lambda表达式是C++11引入的一个特性，它允许你定义一个匿名的函数对象。你可以在lambda表达式中捕获<code>this</code>指针（通常使用<code>[&amp;]</code>或<code>[=]</code>捕获方式），然后在lambda体内调用成员函数。</li>
<li><strong>使用静态成员函数或友元函数</strong>：<br>如果成员函数不依赖于特定的对象实例（即它不需要访问非静态成员变量），你可以将其声明为静态成员函数。静态成员函数不属于任何对象实例，因此可以直接作为线程函数。但是，请注意，静态成员函数不能访问非静态成员变量或成员函数。</li>
<li><strong>使用类外部的普通函数</strong>：<br>如果可能的话，你可以将需要在线程中执行的功能移动到类外部的一个普通函数中。然后，你可以将这个函数作为线程函数，并通过参数传递任何需要的数据。</li>
</ol>
<h5 id="使用-std-bind"><a href="#使用-std-bind" class="headerlink" title="使用 std::bind"></a>使用 <code>std::bind</code></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnectionTask</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producing connection task in thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startProducing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 使用 std::bind 绑定成员函数和 this 指针  </span></span><br><span class="line">        <span class="function">std::thread <span class="title">producerThread</span><span class="params">(std::bind(&amp;ConnectionPool::produceConnectionTask, <span class="keyword">this</span>))</span></span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 等待线程完成（在实际应用中，可能需要更复杂的线程管理）  </span></span><br><span class="line">        producerThread.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ConnectionPool pool;  </span><br><span class="line">    pool.<span class="built_in">startProducing</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用-Lambda-表达式"><a href="#使用-Lambda-表达式" class="headerlink" title="使用 Lambda 表达式"></a>使用 Lambda 表达式</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnectionTask</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producing connection task in thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startProducing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 使用 lambda 表达式捕获 this 指针  </span></span><br><span class="line">        <span class="function">std::thread <span class="title">producerThread</span><span class="params">([<span class="keyword">this</span>]() &#123;  </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">this</span>-&gt;produceConnectionTask();  </span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 等待线程完成  </span></span><br><span class="line">        producerThread.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ConnectionPool pool;  </span><br><span class="line">    pool.<span class="built_in">startProducing</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用静态成员函数或友元函数"><a href="#使用静态成员函数或友元函数" class="headerlink" title="使用静态成员函数或友元函数"></a>使用静态成员函数或友元函数</h5><p>注意，静态成员函数不能访问非静态成员变量，因此这个方法通常用于不需要访问类实例状态的函数。这里我改为使用友元函数来演示，因为它可以访问类的私有和保护成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">produceConnectionTaskWrapper</span><span class="params">(ConnectionPool&amp; pool)</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnectionTask</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producing connection task in thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startProducing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 使用友元函数作为线程函数  </span></span><br><span class="line">        <span class="function">std::thread <span class="title">producerThread</span><span class="params">(produceConnectionTaskWrapper, std::ref(*<span class="keyword">this</span>))</span></span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 等待线程完成  </span></span><br><span class="line">        producerThread.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 友元函数实现  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">produceConnectionTaskWrapper</span><span class="params">(ConnectionPool&amp; pool)</span> </span>&#123;  </span><br><span class="line">    pool.<span class="built_in">produceConnectionTask</span>();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ConnectionPool pool;  </span><br><span class="line">    pool.<span class="built_in">startProducing</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用类外部的普通函数"><a href="#使用类外部的普通函数" class="headerlink" title="使用类外部的普通函数"></a>使用类外部的普通函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnectionTask</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producing connection task in thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startProducing</span><span class="params">(ConnectionPool* pool)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 使用类外部的普通函数作为线程函数  </span></span><br><span class="line">        <span class="function">std::thread <span class="title">producerThread</span><span class="params">(produceConnectionTaskExternal, pool)</span></span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 等待线程完成  </span></span><br><span class="line">        producerThread.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 类外部的普通函数  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">produceConnectionTaskExternal</span><span class="params">(ConnectionPool* pool)</span> </span>&#123;  </span><br><span class="line">    pool-&gt;<span class="built_in">produceConnectionTask</span>();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ConnectionPool pool;  </span><br><span class="line">    pool.<span class="built_in">startProducing</span>(&amp;pool);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-lambda表达式-底层依赖函数对象机制实现的"><a href="#3-4-lambda表达式-底层依赖函数对象机制实现的" class="headerlink" title="3.4 lambda表达式 底层依赖函数对象机制实现的"></a>3.4 lambda表达式 底层依赖函数对象机制实现的</h3><h4 id="1-lambda概述"><a href="#1-lambda概述" class="headerlink" title="1.lambda概述"></a>1.lambda概述</h4><p>函数对象的的升级版—-lambda</p>
<p>函数对象的缺点：</p>
<p>灵活性太差了，需要定一个类出来，但其实实际上我可能只需要在泛型算法里面用一次就不用了</p>
<h4 id="2-lambda表达式的语法"><a href="#2-lambda表达式的语法" class="headerlink" title="2.lambda表达式的语法"></a>2.lambda表达式的语法</h4><p><code>语法：</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[捕获外部变量](形参列表)-&gt;返回值&#123;操作代码&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意操作代码后面也有分号，句子结束也有分号，不要忘了，不要少写</strong></p>
<p>如果没有返回值”-&gt;返回值”这部分可以省略</p>
<p>关于形参列表部分，如果参数，关键字，返回值一个都没有，那小括号可写可不写，如果有一个那就得写小括号</p>
<p><strong>形参列表对应的是函数对象中operator()()的形参列表</strong></p>
<h6 id="lambda匿名函数中的-外部变量"><a href="#lambda匿名函数中的-外部变量" class="headerlink" title="lambda匿名函数中的[外部变量]"></a>lambda匿名函数中的[外部变量]</h6><p>外部变量指的是和lambda在一个作用域的变量，写[&#x3D;]把同一作用域和更外层的变量拷贝一个副本</p>
<p>这个应该对应函数对象的类里面的成员变量</p>
<table>
<thead>
<tr>
<th>外部变量格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>空方括号表示当前 lambda 匿名函数中不导入任何外部变量。</td>
</tr>
<tr>
<td>[&#x3D;]</td>
<td>只有一个 &#x3D; 等号，表示以值传递的方式导入所有外部变量；</td>
</tr>
<tr>
<td>[&amp;]</td>
<td>只有一个 &amp; 符号，表示以引用传递的方式导入所有外部变量；</td>
</tr>
<tr>
<td>[val1,val2,…]</td>
<td>表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序；</td>
</tr>
<tr>
<td>[&amp;val1,&amp;val2,…]</td>
<td>表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序；</td>
</tr>
<tr>
<td>[val,&amp;val2,…]</td>
<td>以上 2 种方式还可以混合使用，变量之间没有前后次序。</td>
</tr>
<tr>
<td>[&#x3D;,&amp;val1,…]</td>
<td>表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。</td>
</tr>
<tr>
<td>[this]</td>
<td>表示以值传递的方式导入当前的 this 指针。</td>
</tr>
</tbody></table>
<blockquote>
<p>注意，单个外部变量不允许以相同的传递方式导入多次。例如 [&#x3D;，val1] 中，val1 先后被以值传递的方式导入了 2 次，这是非法的。</p>
</blockquote>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241012215219186.png" alt="image-20241012215219186"></p>
<p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> placeholders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">class</span> testLambda01</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">testLambda01</span>()&#123;&#125;</span><br><span class="line">	<span class="type">void</span> <span class="built_in">operator</span>()()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> testLambda02</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">testLambda02</span>() &#123;&#125;</span><br><span class="line">	<span class="type">int</span> <span class="built_in">operator</span>()(<span class="type">int</span> a,<span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> testLambda03</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">testLambda03</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">ma</span>(a),<span class="built_in">mb</span>(b) &#123;&#125;</span><br><span class="line">	<span class="comment">//常方法里面不能修改成员变量</span></span><br><span class="line">	<span class="comment">//1.成员变量加mutable</span></span><br><span class="line">	<span class="comment">//2.lambda加关键字mutable</span></span><br><span class="line">	<span class="type">void</span> <span class="built_in">operator</span>()() <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tmp = ma;</span><br><span class="line">		ma = mb;</span><br><span class="line">		mb = tmp;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> ma;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> mb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">auto</span> func3 = [a, b]()<span class="keyword">mutable</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tmp = a;</span><br><span class="line">			a = b;</span><br><span class="line">			b = tmp;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func3</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;b &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	testLambda03&lt;&gt; <span class="built_in">t3</span>(a, b);</span><br><span class="line">	<span class="built_in">t3</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;b &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> testLambda04</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">testLambda04</span>(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b):<span class="built_in">ma</span>(a),<span class="built_in">mb</span>(b) &#123;&#125;</span><br><span class="line">	<span class="comment">//常方法里面不能修改成员变量</span></span><br><span class="line">	<span class="comment">//1.成员变量加mutable</span></span><br><span class="line">	<span class="comment">//2.lambda加关键字mutable</span></span><br><span class="line">	<span class="type">void</span> <span class="built_in">operator</span>()() <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tmp = ma;</span><br><span class="line">		ma = mb;</span><br><span class="line">		mb = tmp;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> &amp;ma;</span><br><span class="line">	<span class="type">int</span> &amp;mb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> func1 = []()-&gt;<span class="type">void</span> &#123;cout &lt;&lt; <span class="string">&quot;hello world&quot;</span>&lt;&lt;endl; &#125;;</span><br><span class="line">	<span class="built_in">func1</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> func2 = [](<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">func2</span>(<span class="number">20</span>, <span class="number">30</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//func1的函数对象版本</span></span><br><span class="line">	testLambda01&lt;&gt; t1;</span><br><span class="line">	<span class="built_in">t1</span>();</span><br><span class="line">	<span class="comment">//func2的函数对象版本</span></span><br><span class="line">	testLambda02&lt;&gt; t2;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">t2</span>(<span class="number">20</span>,<span class="number">30</span>)&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//虽然实现了func3lambda对应的函数对象，但是a，b根本上还是没变（因为是值传递，不是引用），没有实现交换这个功能</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">auto</span> func3 = [a, b]()<span class="keyword">mutable</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tmp = a;</span><br><span class="line">			a = b;</span><br><span class="line">			b = tmp;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func3</span>();</span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;a &quot;</span>&lt;&lt; a &lt;&lt;<span class="string">&quot;b &quot;</span>&lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	testLambda03&lt;&gt; <span class="built_in">t3</span>(a,b);</span><br><span class="line">	<span class="built_in">t3</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;b &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//实现交换功能，按照引用来传递参数，lambda后面的mutable也不用加了</span></span><br><span class="line">	<span class="comment">//函数对象里面的mutable也不用加了 因为交换改变的是ma，mb的内存里面的东西</span></span><br><span class="line">	<span class="comment">/*int a = 10;</span></span><br><span class="line"><span class="comment">	int b = 20;</span></span><br><span class="line"><span class="comment">	auto func4 = [&amp;a, &amp;b]()</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			int tmp = a;</span></span><br><span class="line"><span class="comment">			a = b;</span></span><br><span class="line"><span class="comment">			b = tmp;</span></span><br><span class="line"><span class="comment">		&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	func4();</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; &quot;a &quot; &lt;&lt; a &lt;&lt; &quot; b &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	testLambda04&lt;&gt; t4(a, b);</span></span><br><span class="line"><span class="comment">	t4();</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; &quot;a &quot; &lt;&lt; a &lt;&lt; &quot; b &quot; &lt;&lt; b &lt;&lt; endl;*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Q：为什么在类中换成引用类型就不需要mtable来修饰成员变量了？</p>
<p>在C++中，当成员变量是引用类型时，即使在<code>const</code>成员函数内部，我们也可以通过这些引用来修改它们所引用的外部对象的状态。这是因为<code>const</code>成员函数中的<code>const</code>关键字限制了成员变量本身的“可修改性”（如果成员变量不是引用或指针的话），但它并不限制通过成员变量（如果它们是引用或指针）所间接访问的对象的可修改性。</p>
<p>具体来说，当一个成员函数被声明为<code>const</code>时，这意味着该成员函数不能修改其所属对象的任何非静态成员变量（除非这些变量被声明为<code>mutable</code>）。然而，这一规则并不适用于引用类型的成员变量，因为引用本身并不是对象，它只是对象的一个别名。当我们说“不能修改成员变量”时，实际上是指不能改变成员变量所引用的对象（如果成员变量是对象的话）或成员变量所指向的地址（如果成员变量是指针的话）。但是，如果成员变量是引用，并且它引用了一个外部对象，那么我们完全可以通过这个引用来修改那个外部对象的状态。</p>
<p>换句话说，<code>const</code>成员函数中的<code>const</code>性仅仅保证了成员函数不会改变其所属对象的“身份”（即不会改变成员变量的值，如果成员变量是值类型的话），但并不保证不会改变成员变量所引用的外部对象的“状态”。</p>
<h4 id="3-lambda的应用实践"><a href="#3-lambda的应用实践" class="headerlink" title="3.lambda的应用实践"></a>3.lambda的应用实践</h4><h5 id="1-泛型算法之中"><a href="#1-泛型算法之中" class="headerlink" title="1.泛型算法之中"></a>1.泛型算法之中</h5><p>就使用这一下，不用麻烦的写函数对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.vector从大到小排序的lambda排序</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),[](<span class="type">int</span> a,<span class="type">int</span> b)-&gt;<span class="type">bool</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> a&gt;b;</span><br><span class="line">		&#125;)</span><br><span class="line"><span class="comment">//2.找到第一个比65小的数字的位置插入65到这里</span></span><br><span class="line"><span class="keyword">auto</span> it=<span class="built_in">find_id</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),[](<span class="type">int</span> a)-&gt;<span class="type">bool</span>&#123;<span class="keyword">return</span> a&lt;<span class="number">65</span>;&#125;);</span><br><span class="line"><span class="keyword">if</span>(it!=v.<span class="built_in">end</span>())</span><br><span class="line">    	v.<span class="built_in">insert</span>(it,<span class="number">65</span>);</span><br></pre></td></tr></table></figure>

<p>为什么a，b在()而不是[]里面？</p>
<p>在C++中，当你使用lambda表达式作为<code>sort</code>函数的比较函数时，lambda表达式的参数（在这个例子中是<code>a</code>和<code>b</code>）是通过<code>operator()</code>函数传入的，而不是通过捕获列表<code>[]</code>传入的。这是因为捕获列表<code>[]</code>用于指定哪些外部变量应该被捕获到lambda表达式的内部作用域中，而不是用于接收函数参数。</p>
<h5 id="2-既然lambda只能用在语句中，如果想跨语句使用之前定义好的lambda表达式怎么办？有什么类型表达lambda？"><a href="#2-既然lambda只能用在语句中，如果想跨语句使用之前定义好的lambda表达式怎么办？有什么类型表达lambda？" class="headerlink" title="2.既然lambda只能用在语句中，如果想跨语句使用之前定义好的lambda表达式怎么办？有什么类型表达lambda？"></a>2.既然lambda只能用在语句中，如果想跨语句使用之前定义好的lambda表达式怎么办？有什么类型表达lambda？</h5><p>解决方法：用函数对象function表示lambda的类型，lambda-&gt;函数对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Data</span>(<span class="type">int</span> val1=<span class="number">10</span>,<span class="type">int</span> val2=<span class="number">10</span>):<span class="built_in">ma</span>(val1),<span class="built_in">mb</span>(val2)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Data &amp;data) <span class="type">const</span> &#123; <span class="keyword">return</span> ma &gt; data.ma; &#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Data &amp;data) <span class="type">const</span> &#123; <span class="keyword">return</span> ma &lt; data.ma; &#125;</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line">    <span class="type">int</span> mb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.function存储类型</span></span><br><span class="line">    map&lt;<span class="type">int</span>, function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; caculateMap;</span><br><span class="line">    caculateMap [<span class="number">1</span>] = [] (<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">    caculateMap [<span class="number">2</span>] = [] (<span class="type">int</span> a, inth)&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a - b; &#125;;</span><br><span class="line">    caculateMap [<span class="number">3</span>] = [] (<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a * b; &#125;;</span><br><span class="line">    caculateMap [<span class="number">4</span>] = [] (<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a / b; &#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;选择:&quot;</span>;</span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    cin &gt;&gt; choice;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;10 + 15:&quot;</span> &lt;&lt; caculateMap[choice] (<span class="number">10</span>, <span class="number">15</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	<span class="comment">// 2.智能指针自定义删除器</span></span></span><br><span class="line"><span class="function">    unique_ptr&lt;FILE,function&lt;<span class="title">void</span> <span class="params">(FILE *)</span>&gt;&gt;</span></span><br><span class="line"><span class="function">    <span class="title">pti1</span> <span class="params">(fopen (<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;w&quot;</span>), [] (FILE *pf) &#123;fclose(pf); &#125;)</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//3.优先级队列 默认要进行比较，因为底层是大根堆 但是&gt;和&lt;运算符重载有点麻烦且灵活性很差，每次都要改动</span></span><br><span class="line">    priority_queue&lt;Data&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line">    queue.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">15</span>,<span class="number">15</span>));</span><br><span class="line">    queue.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    <span class="comment">//修改后，加入了比较函数，比较灵活</span></span><br><span class="line">    <span class="keyword">using</span> PFUNC=function&lt;<span class="built_in">bool</span>(Data&amp;,Data&amp;)&gt;;</span><br><span class="line">    priority_queue&lt;Data,vector&lt;Data&gt;,PFUNC&gt; </span><br><span class="line">        <span class="built_in">q</span>([](Data &amp;d1,Data &amp;d2)-&gt;<span class="type">bool</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> d<span class="number">1.</span>ma&gt;d<span class="number">2.</span>ma;</span><br><span class="line">		&#125;</span><br><span class="line">    );</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">15</span>,<span class="number">15</span>));</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、c-11内容汇总、多线程应用实践"><a href="#四、c-11内容汇总、多线程应用实践" class="headerlink" title="四、c++11内容汇总、多线程应用实践"></a>四、c++11内容汇总、多线程应用实践</h2><h3 id="4-1-c-11内容汇总"><a href="#4-1-c-11内容汇总" class="headerlink" title="4.1 c++11内容汇总"></a>4.1 c++11内容汇总</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">一:关键字和语法</span><br><span class="line"><span class="keyword">auto</span>:可以根据右值,推导出右值的类型,然后左边变量的类型也就已知了</span><br><span class="line"><span class="literal">nullptr</span>:给指针专用(能够和整数进行区别)</span><br><span class="line">foreach:可以遍历数组,容器等</span><br><span class="line"><span class="keyword">for</span>(Type val:container)=&gt;底层就是通过指针或者迭代器来实现的</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">右值引用:move移动语义函数和forward类型完美转发函数</span><br><span class="line">模板的一个新特性:<span class="keyword">typename</span> ... A 表示可变参(类型参数)</span><br><span class="line"></span><br><span class="line">二:绑定器和函数对象</span><br><span class="line">function:函数对象</span><br><span class="line">bind:绑定器</span><br><span class="line">lambda表达式</span><br><span class="line"></span><br><span class="line">三:智能指针</span><br><span class="line">shared ptr和weak_ptr</span><br><span class="line"></span><br><span class="line">四:容器</span><br><span class="line">set和map:红黑树 <span class="built_in">O</span>(<span class="number">1</span>gn)</span><br><span class="line">unordered set和unordered map:哈希表 <span class="built_in">O</span>(<span class="number">1</span>)</span><br><span class="line">array: 数组</span><br><span class="line">forward list:前向链表</span><br><span class="line"></span><br><span class="line">五:C++语言级别支持的多线程编程</span><br><span class="line">createThread</span><br><span class="line">pthread create</span><br><span class="line">clone</span><br></pre></td></tr></table></figure>

<p>读者可参考此文章进行学习</p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/142858121?spm=1001.2014.3001.5502">C++11 新特性 学习笔记-CSDN博客</a></p>
<h3 id="4-2-C-语言级别的多线程编程"><a href="#4-2-C-语言级别的多线程编程" class="headerlink" title="4.2 C++语言级别的多线程编程"></a>4.2 C++语言级别的多线程编程</h3><p>可以看这些复习。</p>
<p><a href="https://blog.csdn.net/weixin_45754224/article/details/141139153?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-141139153-blog-118861539.235%5Ev43%5Epc_blog_bottom_relevance_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-141139153-blog-118861539.235%5Ev43%5Epc_blog_bottom_relevance_base1&utm_relevant_index=5">C++多线程详解 | 线程创建 | 互斥锁 | 条件变量 | 线程池_c++ 线程-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/sjc_0910/article/details/118861539">C++11 多线程（std::thread）详解_c++11线程使用-CSDN博客</a></p>
<p>语言级别多线程最大的优点：可跨平台</p>
<p>就是在语言层面加了一层封装，c++里面加了一些宏可以识别当前的操作系统，然后还是去调用相应的系统调用</p>
<p>比如linux就还是底层调用pthread_creat之类的函数</p>
<p>多线程编程两个问题：</p>
<p><strong>1.线程间的互斥</strong></p>
<p>竞态条件–&gt;临界区代码段–&gt;原子操作–&gt;互斥锁或者CAS</p>
<p><code>竞态条件：</code></p>
<p>竞态条件指的是设备或系统出现不恰当的执行时序，导致得到不正确的结果。从多进程间通信的角度来看，竞态条件发生在两个或多个进程对共享的数据进行读或写的操作时，最终的结果取决于这些进程的执行顺序。在并发编程中，竞态条件通常指的是程序的执行结果依赖于线程执行的顺序。</p>
<p><code>临界区代码段：</code></p>
<p>导致竞态条件发生的代码段被称为临界区代码段。在临界区内，代码的执行顺序对结果有重要影响，因此必须确保同一时间只有一个线程能够执行临界区内的代码。</p>
<p>保证临界区代码段的原子操作通过互斥锁或者CAS实现</p>
<p><strong>2.线程间的同步通信</strong></p>
<p>生产者，消费者线程模型</p>
<p>注：C++的STL容器在默认状态下都是线程不安全的</p>
<h4 id="1-通过thread类编写C-多线程程序"><a href="#1-通过thread类编写C-多线程程序" class="headerlink" title="1.通过thread类编写C++多线程程序"></a>1.通过thread类编写C++多线程程序</h4><h5 id="1-头文件以及命名空间"><a href="#1-头文件以及命名空间" class="headerlink" title="1.头文件以及命名空间"></a>1.头文件以及命名空间</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">头文件：#include&lt;thread&gt;</span><br><span class="line">写using namespace std; 或者 std::thread 都可以使用thread类</span><br></pre></td></tr></table></figure>

<h5 id="2-线程创建"><a href="#2-线程创建" class="headerlink" title="2.线程创建"></a>2.线程创建</h5><p>std :: thread定义一个线程对象,传入线程所需要的线程函数和参数，线程自动开启</p>
<p>定义一个线程对象 参数传入一个线程函数threadHandle1</p>
<p> 一个线程对应一个线程栈 这个名字就是线程的入口函数</p>
<p><strong>传入后，新线程就开始运行了，其实就是入口函数开始运行了</strong></p>
<p>第一个参数是线程函数，第二个参数开始就是线程函数的参数了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadHandle1</span><span class="params">(<span class="type">int</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//让子线程睡眠两秒 一堆命名空间不用管</span></span><br><span class="line">	this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(time));</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello thread&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(threadHandle1,<span class="number">2</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="注意：类的成员函数不能直接作为线程函数，需要bind进行绑定"><a href="#注意：类的成员函数不能直接作为线程函数，需要bind进行绑定" class="headerlink" title="注意：类的成员函数不能直接作为线程函数，需要bind进行绑定"></a>注意：类的成员函数不能直接作为线程函数，需要bind进行绑定</h5><p>在C++中，类的成员函数不能直接作为线程函数（即不能直接传递给<code>std::thread</code>的构造函数）。这是因为成员函数需要一个隐式的<code>this</code>指针来访问类的成员变量和成员函数，而普通的函数指针或可调用对象并不包含这个<code>this</code>指针的信息。</p>
<p><strong>其实呢也好理解，就是一个成员函数你得有个实例对象才能用.或者-&gt;进行调用成员函数，光传一个名字谁知道你要调用哪个对象的这个函数，因为不同的对象内部成员变量什么的都不同，函数内部使用的也不同，所以得有一个this指向它。</strong></p>
<p>当你尝试将成员函数直接作为线程函数时，编译器会报错，因为它无法确定<code>this</code>指针的值（在创建线程时，目标对象可能还没有被正确构造，或者<code>this</code>指针的值在多线程环境下可能变得不确定）。</p>
<p>为了在线程中调用类的成员函数，你有几个选项：</p>
<ol>
<li><strong>使用<code>std::bind</code></strong>：<br><code>std::bind</code>可以绑定成员函数和<code>this</code>指针，生成一个新的可调用对象，这个对象可以被<code>std::thread</code>接受。这是你在问题中提到的方法。</li>
<li><strong>使用lambda表达式</strong>：<br>Lambda表达式是C++11引入的一个特性，它允许你定义一个匿名的函数对象。你可以在lambda表达式中捕获<code>this</code>指针（通常使用<code>[&amp;]</code>或<code>[=]</code>捕获方式），然后在lambda体内调用成员函数。</li>
<li><strong>使用静态成员函数或友元函数</strong>：<br>如果成员函数不依赖于特定的对象实例（即它不需要访问非静态成员变量），你可以将其声明为静态成员函数。静态成员函数不属于任何对象实例，因此可以直接作为线程函数。但是，请注意，静态成员函数不能访问非静态成员变量或成员函数。</li>
<li><strong>使用类外部的普通函数</strong>：<br>如果可能的话，你可以将需要在线程中执行的功能移动到类外部的一个普通函数中。然后，你可以将这个函数作为线程函数，并通过参数传递任何需要的数据。</li>
</ol>
<h5 id="使用-std-bind-1"><a href="#使用-std-bind-1" class="headerlink" title="使用 std::bind"></a>使用 <code>std::bind</code></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnectionTask</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producing connection task in thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startProducing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 使用 std::bind 绑定成员函数和 this 指针  </span></span><br><span class="line">        <span class="function">std::thread <span class="title">producerThread</span><span class="params">(std::bind(&amp;ConnectionPool::produceConnectionTask, <span class="keyword">this</span>))</span></span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 等待线程完成（在实际应用中，可能需要更复杂的线程管理）  </span></span><br><span class="line">        producerThread.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ConnectionPool pool;  </span><br><span class="line">    pool.<span class="built_in">startProducing</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用-Lambda-表达式-1"><a href="#使用-Lambda-表达式-1" class="headerlink" title="使用 Lambda 表达式"></a>使用 Lambda 表达式</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnectionTask</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producing connection task in thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startProducing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 使用 lambda 表达式捕获 this 指针  </span></span><br><span class="line">        <span class="function">std::thread <span class="title">producerThread</span><span class="params">([<span class="keyword">this</span>]() &#123;  </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">this</span>-&gt;produceConnectionTask();  </span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 等待线程完成  </span></span><br><span class="line">        producerThread.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ConnectionPool pool;  </span><br><span class="line">    pool.<span class="built_in">startProducing</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用静态成员函数或友元函数-1"><a href="#使用静态成员函数或友元函数-1" class="headerlink" title="使用静态成员函数或友元函数"></a>使用静态成员函数或友元函数</h5><p>注意，静态成员函数不能访问非静态成员变量，因此这个方法通常用于不需要访问类实例状态的函数。这里我改为使用友元函数来演示，因为它可以访问类的私有和保护成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">produceConnectionTaskWrapper</span><span class="params">(ConnectionPool&amp; pool)</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnectionTask</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producing connection task in thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startProducing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 使用友元函数作为线程函数  </span></span><br><span class="line">        <span class="function">std::thread <span class="title">producerThread</span><span class="params">(produceConnectionTaskWrapper, std::ref(*<span class="keyword">this</span>))</span></span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 等待线程完成  </span></span><br><span class="line">        producerThread.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 友元函数实现  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">produceConnectionTaskWrapper</span><span class="params">(ConnectionPool&amp; pool)</span> </span>&#123;  </span><br><span class="line">    pool.<span class="built_in">produceConnectionTask</span>();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ConnectionPool pool;  </span><br><span class="line">    pool.<span class="built_in">startProducing</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用类外部的普通函数-1"><a href="#使用类外部的普通函数-1" class="headerlink" title="使用类外部的普通函数"></a>使用类外部的普通函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnectionTask</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producing connection task in thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startProducing</span><span class="params">(ConnectionPool* pool)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 使用类外部的普通函数作为线程函数  </span></span><br><span class="line">        <span class="function">std::thread <span class="title">producerThread</span><span class="params">(produceConnectionTaskExternal, pool)</span></span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 等待线程完成  </span></span><br><span class="line">        producerThread.<span class="built_in">join</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 类外部的普通函数  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">produceConnectionTaskExternal</span><span class="params">(ConnectionPool* pool)</span> </span>&#123;  </span><br><span class="line">    pool-&gt;<span class="built_in">produceConnectionTask</span>();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ConnectionPool pool;  </span><br><span class="line">    pool.<span class="built_in">startProducing</span>(&amp;pool);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h5 id="3-子线程如何结束"><a href="#3-子线程如何结束" class="headerlink" title="3.子线程如何结束"></a>3.子线程如何结束</h5><p>子线程函数运行完成，线程就结束了</p>
<h5 id="4-主线程如何处理子线程"><a href="#4-主线程如何处理子线程" class="headerlink" title="4.主线程如何处理子线程"></a>4.主线程如何处理子线程</h5><p>主线程和子线程没有先后顺序，自己运行自己的</p>
<p>子线程可以比主线程早结束，但通常不推荐这么做，最好就是确保子线程都结束了主线程再结束</p>
<p><code>1.join函数</code></p>
<p>主线程阻塞等待子线程t1结束，主线程继续往下进行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>

<p><code>2.detach函数</code></p>
<p>使用<code>detach()</code>会将子线程t1与主线程main分离，主线程结束，整个进程结束，所有子线程都自动结束了</p>
<p>不是很安全，不推荐使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">t<span class="number">1.</span><span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure>

<p>实例代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadHandle1</span><span class="params">(<span class="type">int</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//让子线程睡眠两秒</span></span><br><span class="line">	this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(time));</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello thread&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(threadHandle1,<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//t1.join();</span></span><br><span class="line">	t<span class="number">1.</span><span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;main thread&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-线程互斥"><a href="#2-线程互斥" class="headerlink" title="2.线程互斥"></a>2.线程互斥</h4><h5 id="1-为什么需要线程互斥"><a href="#1-为什么需要线程互斥" class="headerlink" title="1.为什么需要线程互斥"></a>1.为什么需要线程互斥</h5><p>竞态条件：多线程程序执行的结果是一直的，不会随着CPU对线程不同的调用顺序而产生不同的运行结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//车站有100张车票，由三个窗口一起卖票</span></span><br><span class="line"><span class="type">int</span> countSum = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对车票--不是一个线程安全的操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sellTicket</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果是if的话 就卖三张票就结束了</span></span><br><span class="line">	<span class="keyword">while</span> (countSum &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;窗口：&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;卖出第：&quot;</span> &lt;&lt; countSum &lt;&lt; <span class="string">&quot;张票&quot;</span> &lt;&lt; endl;</span><br><span class="line">		countSum--;</span><br><span class="line">		<span class="comment">//模拟卖票花的时间 100毫秒</span></span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;thread&gt; tlist;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">		tlist.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(sellTicket, i));</span><br><span class="line">	<span class="keyword">for</span> (thread &amp; c : tlist)</span><br><span class="line">		c.<span class="built_in">join</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;所有窗口卖票结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在本个例子中存在竞态条件，因为每次执行结果都不一样的</p>
<p>原因是，对车票–操作不是一个线程安全的操作，每个线程减到一半可能时间片到了就去执行另外一个线程，导致一张票卖出去多次（出现了相同的数字的票）</p>
<h5 id="2-mutex-互斥锁"><a href="#2-mutex-互斥锁" class="headerlink" title="2.mutex 互斥锁"></a>2.mutex 互斥锁</h5><p>在linux中mutex底层也调用的是系统调用，用的是pthread_mutex_t互斥锁</p>
<p>锁的概念参考这篇文章，这里不再赘述</p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/142872020?spm=1001.2014.3001.5502">黑马程序员 | linux系统编程 | 学习笔记_linux网络操作系统项目教程黑马程序员电子版-CSDN博客</a></p>
<p><code>头文件：</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><code>互斥锁创建及使用</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> 对应线程函数(形参列表)</span><br><span class="line">&#123;</span><br><span class="line">	mtx.<span class="built_in">lock</span>();</span><br><span class="line">	核心代码，需要原子操作的（即必须要一次执行完的，不能执行到一半去别的线程）</span><br><span class="line">	mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mutex mtx;<span class="comment">//全局的一把互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sellTicket</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mtx.<span class="built_in">lock</span>();</span><br><span class="line">	<span class="keyword">while</span>(countSum &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;窗口：&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;卖出第：&quot;</span> &lt;&lt; countSum &lt;&lt; <span class="string">&quot;张票&quot;</span> &lt;&lt; endl;</span><br><span class="line">		countSum--;</span><br><span class="line">		<span class="comment">//模拟卖票花的时间 100毫秒</span></span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样改是不行的，我们把整个函数代码都上锁，那么只会有一个窗口卖票剩下的都不会卖的，因为它占有的mutex资源一直没有释放</p>
<p>所以只保证核心的代码的原子性就行，锁的内容尽量的少</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sellTicket</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(countSum &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		mtx.<span class="built_in">lock</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;窗口：&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;卖出第：&quot;</span> &lt;&lt; countSum &lt;&lt; <span class="string">&quot;张票&quot;</span> &lt;&lt; endl;</span><br><span class="line">		countSum--;</span><br><span class="line">		mtx.<span class="built_in">unlock</span>();</span><br><span class="line">		<span class="comment">//模拟卖票花的时间 100毫秒</span></span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样还是不完全安全，如果线程1在卖最后一张票，拿上锁，但还没有–的时候线程2进来了，他一看还有一张票，就等着锁资源，1卖完了最后一张，释放锁，2进来了卖的就是第0张票</p>
<p>所以要采用   <code>锁+双重判断</code>   的模式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sellTicket</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(countSum &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		mtx.<span class="built_in">lock</span>();</span><br><span class="line">		<span class="keyword">if</span> (countSum &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;窗口：&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;卖出第：&quot;</span> &lt;&lt; countSum &lt;&lt; <span class="string">&quot;张票&quot;</span> &lt;&lt; endl;</span><br><span class="line">			countSum--;</span><br><span class="line">		&#125;</span><br><span class="line">		mtx.<span class="built_in">unlock</span>();</span><br><span class="line">		<span class="comment">//模拟卖票花的时间 100毫秒</span></span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果说，mutex中间满足条件子线程函数结束了，那么后面的线程会一直拿不到锁</p>
<p>在C++中，互斥锁（<code>std::mutex</code>）不会自动因为线程的结束而被释放；锁的释放必须显式地通过调用<code>unlock</code>成员函数来完成，或者使用RAII（Resource Acquisition Is Initialization）机制来自动管理。</p>
<p>如果子线程在没有显式释放锁的情况下结束，那么锁将保持锁定状态，这通常会导致几个问题：</p>
<ol>
<li><strong>死锁</strong>：其他尝试获取该锁的线程将被永久阻塞，因为它们无法获取到已经被持有且未释放的锁。</li>
<li><strong>资源泄露</strong>：锁是一种有限资源，如果它们被永久占用而不释放，那么系统将无法有效地管理这些资源，可能导致性能下降或资源耗尽。</li>
<li><strong>数据不一致</strong>：如果锁保护的共享数据在锁未释放的情况下被其他线程访问或修改，那么可能会导致数据不一致或损坏。</li>
</ol>
<p>所以要用<code>lock_guard</code>（RALL）来对锁进行管理，类似于裸指针和智能指针那样的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mutex mtx;</span><br><span class="line"><span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">需要上锁的核心代码</span><br><span class="line">lock生命周期结束调用析构，自动释放锁资源</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sellTicket</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(countSum &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//lock_guard对象的作用域是这个while循环，出去以后就调用析构，析构里面实现了释放锁的逻辑</span></span><br><span class="line">		<span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (countSum &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;窗口：&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;卖出第：&quot;</span> &lt;&lt; countSum &lt;&lt; <span class="string">&quot;张票&quot;</span> &lt;&lt; endl;</span><br><span class="line">			countSum--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//模拟卖票花的时间 100毫秒</span></span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过加<strong>大括号</strong>来限制lock_guard的作用域，除了大括号就析构释放资源了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sellTicket</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(countSum &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//lock_guard对象的作用域是这个while循环，出去以后就调用析构，析构里面实现了释放锁的逻辑</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (countSum &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;窗口：&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;卖出第：&quot;</span> &lt;&lt; countSum &lt;&lt; <span class="string">&quot;张票&quot;</span> &lt;&lt; endl;</span><br><span class="line">                countSum--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//模拟卖票花的时间 100毫秒</span></span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但函数参数传递或者返回的时候就不能用lock_guard了，因为它不支持赋值和重载</strong></p>
<p>可以用unique_lock（升级版），和unique_ptr一样，拷贝和赋值重载被delete，但是给了右值引用赋值，调用析构也会释放锁资源</p>
<p><code>使用方法：</code></p>
<p>构造和析构时，占有锁和释放锁</p>
<p>也可以显示调用</p>
<p>l.lock()和l.unlock()但是没什么必要</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sellTicket</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (countSum &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">unique_lock&lt;mutex&gt; <span class="title">l</span><span class="params">(mtx)</span></span>;</span><br><span class="line">			<span class="keyword">if</span> (countSum &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;窗口：&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;卖出第：&quot;</span> &lt;&lt; countSum &lt;&lt; <span class="string">&quot;张票&quot;</span> &lt;&lt; endl;</span><br><span class="line">				countSum--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-基于CAS操作的atomic原子类型"><a href="#3-基于CAS操作的atomic原子类型" class="headerlink" title="3.基于CAS操作的atomic原子类型"></a>3.基于CAS操作的atomic原子类型</h5><p>如果只有一两个语句需要原子特性，那没必要加锁，太麻烦了</p>
<p>系统理论：CAS来保证上面的++ –操作的原子特性就足够了，也被称为<code>无锁操作</code></p>
<p>这个无锁指的，不是从软件层面加锁，而是硬件层面。</p>
<p><code>硬件实现具体过程：</code><strong>CPU从内存取出数据，计算，再写回内存的过程</strong>中对总线加锁，这个时候不允许线程去使用总线，通过这种方式来完成的”加锁”</p>
<p>面经当中的无锁操作比如无锁队列都指的是通过CAS来实现的</p>
<p><code>头文件</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><code>volatile</code>关键字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加上volatile关键字那么各个线程不再缓存这两个变量，读的都是内存里面原来的那一份</span></span><br><span class="line"><span class="comment">//好处是主线程一旦更改这两个，子线程里面都能读取到</span></span><br><span class="line"><span class="comment">//防止多线程对共享变量进行缓存</span></span><br><span class="line"><span class="keyword">volatile</span> atomic_bool isReady = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">volatile</span> std::atomic_int num = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>实例代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> atomic_bool isReady = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">volatile</span> std::atomic_int num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!isReady)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//线程让出当前CPU时间片，等待下一次调度</span></span><br><span class="line">		this_thread::<span class="built_in">yield</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">		num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//10线程都对num++100次</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;thread&gt; tlist;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">		tlist.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(task, i));</span><br><span class="line">	<span class="comment">//主线程睡两秒</span></span><br><span class="line">	this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">	isReady = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (thread &amp; c : tlist)</span><br><span class="line">		c.<span class="built_in">join</span>();</span><br><span class="line">	cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//0 1000</span></span><br></pre></td></tr></table></figure>

<h4 id="3-线程同步通信"><a href="#3-线程同步通信" class="headerlink" title="3.线程同步通信"></a>3.线程同步通信</h4><p>读者可参考这篇文章的线程同步通信一起学习，是在linux环境下的线程同步通信</p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/142872020?spm=1001.2014.3001.5502">黑马程序员 | linux系统编程 | 学习笔记_linux网络操作系统项目教程黑马程序员电子版-CSDN博客</a></p>
<p>以及下面这篇</p>
<p><a href="https://blog.csdn.net/weixin_45031801/article/details/142705048">【C++】多线程编程图文详解（多角度详解，小白一看就懂！！）-CSDN博客</a></p>
<h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><p><code>头文件</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;condition_variable&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>std::condition_variable </code><strong>是C++标准库中的一个类，用于在多线程编程中实现线程间的条件变量和线程同步。它提供了</strong>等待</strong>和<strong>通知</strong>的机制，使得线程可以等待某个条件成立时被唤醒，或者在满足某个条件时通知其他等待的线程。其提供了以下几个函数用于等待和通知线程： </p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>wait</strong></td>
<td>使当前线程进入等待状态，直到被其他线程通过**<code>notify_one()</code><strong>或</strong><code>notify_all()</code>**函数唤醒。该函数需要一个互斥锁作为参数，调用时会自动释放互斥锁，并在被唤醒后重新获取互斥锁。</td>
</tr>
<tr>
<td><strong>wait_for</strong></td>
<td>使当前线程进入等待状态，最多等待一定的时间，直到被其他线程通过<strong>notify_one()<strong>或</strong>notify_all()<strong>函数唤醒，或者等待超时。该函数需要一个互斥锁和一个时间段作为参数，返回时有两种情况：等待超时返回</strong>std::cv_status::timeout</strong>，被唤醒返回<strong>std::cv_status::no_timeout</strong>。</td>
</tr>
<tr>
<td><strong>wait_until</strong></td>
<td>使当前线程进入等待状态，直到被其他线程通过<strong>notify_one()<strong>或notify_all()函数唤醒，或者等待时间达到指定的绝对时间点。该函数需要一个互斥锁和一个绝对时间点作为参数，返回时有两种情况：时间到达返回</strong>std::cv_status::timeout</strong>，被唤醒返回<strong>std::cv_status::no_timeout</strong></td>
</tr>
<tr>
<td><strong>notify_one</strong></td>
<td>唤醒一个等待中的线程，如果有多个线程在等待，则选择其中一个线程唤醒</td>
</tr>
<tr>
<td><strong>notify_all</strong></td>
<td>唤醒所有等待中的线程，使它们从等待状态返回</td>
</tr>
</tbody></table>
<blockquote>
<p><code>std::condition_variable</code>的主要特点如下：</p>
</blockquote>
<ul>
<li>等待和通知机制：<strong>std::condition_variable</strong> 允许线程进入等待状态，直到某个条件满足时才被唤醒。线程可以调用wait函数进入等待状态，并指定一个互斥量作为参数，以确保线程在等待期间互斥量被锁定。当其他线程满足条件并调用 <em>notify_one</em> 或 <em>notify_all</em> 函数时，等待的线程将被唤醒并继续执行。</li>
<li>与互斥量配合使用：<strong>std::condition_variable</strong> 需要与互斥量（std::mutex或std::unique_lockstd::mutex）配合使用，以确保线程之间的互斥性。在等待之前，线程必须先锁定互斥量，以避免竞争条件。当条件满足时，通知其他等待的线程之前，必须再次锁定互斥量。</li>
<li>支持超时等待：<strong>std::condition_variable</strong>提供了带有超时参数的等待函数 <strong>wait_for</strong> 和<strong>wait_until</strong>，允许线程在等待一段时间后自动被唤醒。这对于处理超时情况或限时等待非常有用。</li>
</ul>
<blockquote>
<p>使用std::condition_variable的一般步骤如下：</p>
</blockquote>
<ol>
<li>创建一个std::condition_variable对象。</li>
<li>创建一个互斥量对象（std::mutex或std::unique_lock<a href="std::mutex">std::mutex</a>）。</li>
<li>在等待线程中，使用std::unique_lock锁定互斥量，并调用wait函数进入等待状态。</li>
<li>在唤醒线程中，使用std::unique_lock锁定互斥量，并调用notify_one或notify_all函数通知等待的线程。</li>
<li>等待线程被唤醒后，继续执行相应的操作。</li>
</ol>
<p><strong>示例：</strong> </p>
<blockquote>
<p>模拟一个简单的计数器。一个线程负责增加计数，另一个线程等待并打印计数的值。 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;condition_variable&gt;</span><br><span class="line">// 定义共享变量和相关的同步工具</span><br><span class="line">int count = 0; // 计数器</span><br><span class="line">std::mutex mtx; // 互斥锁</span><br><span class="line">std::condition_variable cv; // 条件变量</span><br><span class="line">// 增加计数的线程函数</span><br><span class="line">void increment() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 5; ++i) &#123;</span><br><span class="line">   std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模拟工作</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; lock(mtx); // 使用 unique_lock</span><br><span class="line">        count++; // 增加计数</span><br><span class="line">        std::cout &lt;&lt; &quot;计数增加到: &quot; &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">        cv.notify_one(); // 通知其他线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 打印计数的线程函数</span><br><span class="line">void print() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 5; ++i) &#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; lock(mtx); // 加锁</span><br><span class="line">        cv.wait(lock); // 等待通知</span><br><span class="line">        std::cout &lt;&lt; &quot;当前计数是: &quot; &lt;&lt; count &lt;&lt; std::endl; // 打印计数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::thread t1(increment); // 创建增加计数的线程</span><br><span class="line">    std::thread t2(print); // 创建打印计数的线程</span><br><span class="line">    t1.join(); // 等待线程完成</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>共享变量</strong>：</p>
<ul>
<li><strong><code>int count = 0;</code></strong>：定义一个共享的计数器。</li>
<li><strong><code>std::mutex mtx;</code></strong>：定义一个互斥锁，用于保护共享变量 <strong><code>count</code></strong>。</li>
<li><code>std::condition_variable cv;</code>：定义一个条件变量，用于线程同步。</li>
</ul>
<p><strong>增加计数的线程</strong> (<code>increment</code> 函数)：</p>
<ul>
<li>使用 <strong><code>std::this_thread::sleep_for</code></strong> 模拟工作，增加计数器的值。</li>
<li>使用 <strong><code>std::lock_guard</code></strong> 加锁，以确保在修改 <code>count</code> 时没有其他线程干扰。</li>
<li>增加计数并打印当前值，然后使用 <code>cv.notify_one()</code> 通知等待的线程。</li>
</ul>
<p><strong>打印计数的线程</strong> (<code>print</code> 函数)：</p>
<ul>
<li>使用 <strong><code>cv.wait(lock)</code></strong> 等待通知，只有当 <strong><code>increment</code></strong> 函数通知时才会继续执行。</li>
<li>打印当前的计数值。</li>
</ul>
<h5 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h5><p>通过信号量实现线程间的通信（即互相通知）</p>
<p><code>生产者消费者模型</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;<span class="comment">//定义互斥锁</span></span><br><span class="line">condition_variable cv;<span class="comment">//定义条件变量，做线程间的同步通信操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//生产物品</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//这个一定要加上，因为put和get是在不同的线程里面调用的，一个生产者调用一个消费者调用</span></span><br><span class="line">		<span class="function">unique_lock&lt;mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//que不为空，生产者应该通知消费者去消费，消费完了，再继续生产</span></span><br><span class="line">			<span class="comment">//生产者线程应该进入等待状态，并且把mtx互斥锁释放掉</span></span><br><span class="line">			<span class="comment">//阻塞等待的时候应该先把mtx释放掉，不然消费者也没法消费</span></span><br><span class="line">			cv.<span class="built_in">wait</span>(lck);<span class="comment">//一进入等待状态就把锁释放掉了</span></span><br><span class="line">		&#125;</span><br><span class="line">		que.<span class="built_in">push</span>(val);</span><br><span class="line">		<span class="comment">//通知其他所有线程，已经生产好了物品，去消费吧</span></span><br><span class="line">		cv.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		cv.notify_all：通知其他所有线程</span></span><br><span class="line"><span class="comment">		cv.notify_one：通知另外的一个线程</span></span><br><span class="line"><span class="comment">		其他线程得到该通知，就会从等待状态变为阻塞态，还得拿到锁以后才可以继续执行</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;生产者 生产:&quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;号物品&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//消费物品</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">unique_lock&lt;mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (que.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//消费者发现没有东西可以消费，通知生产者生产</span></span><br><span class="line">			cv.<span class="built_in">wait</span>(lck);<span class="comment">//一进入等待状态就把锁释放掉了</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> val = que.<span class="built_in">front</span>();</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">		cv.<span class="built_in">notify_all</span>();<span class="comment">//通知其他线程（生产者），我消费完了，赶紧生产</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;消费者 消费&quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;号物品&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(Queue* que)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		que-&gt;<span class="built_in">put</span>(i);</span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(Queue* que)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> val = que-&gt;<span class="built_in">get</span>();</span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Queue que;</span><br><span class="line">	<span class="comment">//传入两者共享的队列</span></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(producer, &amp;que)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(consumer, &amp;que)</span></span>;</span><br><span class="line"></span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="五、设计模式"><a href="#五、设计模式" class="headerlink" title="五、设计模式"></a>五、设计模式</h2><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241014203719890.png" alt="image-20241014203719890"></p>
<p>这里贴出常用的23中设计模式。视频课程仅包含部分，剩余部分需要找其他课程或者资料进行自学。</p>
<h3 id="1-设计模式三大类型概述"><a href="#1-设计模式三大类型概述" class="headerlink" title="1.设计模式三大类型概述"></a>1.设计模式三大类型概述</h3><p>C++设计模式是一套被广泛认可的用于解决常见软件设计问题的最佳实践，它们可以帮助开发者编写更加清晰、可维护和可扩展的代码。根据解决的问题类型，设计模式通常被分为三大类：创建型、结构型和行为型。以下是对每一大类的概述及其特点：</p>
<h4 id="一、创建型设计模式"><a href="#一、创建型设计模式" class="headerlink" title="一、创建型设计模式"></a>一、创建型设计模式</h4><p>创建型设计模式主要关注于对象的创建机制，帮助使系统独立于如何创建、组合和表示对象。</p>
<ul>
<li><strong>特点</strong>：<ul>
<li>将对象的创建和使用分离，增加代码的灵活性和可维护性。</li>
<li>通过定义创建对象的接口或方法，使得子类或具体实现类可以决定实例化哪个类。</li>
</ul>
</li>
<li><strong>常见模式</strong>：<ul>
<li><strong>单例模式（Singleton）</strong>：确保一个类只有一个实例，并提供一个全局访问点。</li>
<li><strong>工厂方法模式（Factory Method）</strong>：定义一个用于创建对象的接口，让子类决定实例化哪一个类。</li>
<li><strong>抽象工厂模式（Abstract Factory）</strong>：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</li>
<li><strong>建造者模式（Builder）</strong>：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</li>
<li><strong>原型模式（Prototype）</strong>：通过复制现有的实例来创建新的实例，而不是通过新建类。</li>
</ul>
</li>
</ul>
<h4 id="二、结构型设计模式"><a href="#二、结构型设计模式" class="headerlink" title="二、结构型设计模式"></a>二、结构型设计模式</h4><p>结构型设计模式关注于类和对象的组合，用于形成更大的结构，以解决如何将对象和类组合成较大的结构，同时保持结构的灵活和高效。</p>
<ul>
<li><strong>特点</strong>：<ul>
<li>通过组合和继承等方式，将对象或类组合成更大的结构。</li>
<li>强调对象之间的静态关系，以及如何通过不同的组合方式获得更加灵活的程序结构。</li>
</ul>
</li>
<li><strong>常见模式</strong>：<ul>
<li><strong>适配器模式（Adapter）</strong>：将一个类的接口转换成客户期望的另一个接口。</li>
<li><strong>桥接模式（Bridge）</strong>：将抽象部分与实现部分分离，使它们可以独立变化。</li>
<li><strong>组合模式（Composite）</strong>：将对象组合成树形结构以表示“部分-整体”的层次结构。</li>
<li><strong>装饰器模式（Decorator）</strong>：动态地给一个对象添加一些额外的职责。</li>
<li><strong>外观模式（Facade）</strong>：提供一个统一的接口，用来访问子系统中的一群接口。</li>
<li><strong>享元模式（Flyweight）</strong>：运用共享技术有效地支持大量细粒度的对象。</li>
<li><strong>代理模式（Proxy）</strong>：为其他对象提供一种代理以控制对这个对象的访问。</li>
</ul>
</li>
</ul>
<h4 id="三、行为型设计模式"><a href="#三、行为型设计模式" class="headerlink" title="三、行为型设计模式"></a>三、行为型设计模式</h4><p>行为型设计模式特别关注对象之间的通信，以及如何通过对象之间的协作来实现特定的功能。</p>
<ul>
<li><strong>特点</strong>：<ul>
<li>强调对象之间的动态关系，以及如何通过对象之间的交互来实现特定的行为。</li>
<li>通过定义对象之间的交互规则和通信方式，使得系统更加灵活和可扩展。</li>
</ul>
</li>
<li><strong>常见模式</strong>：<ul>
<li><strong>责任链模式（Chain of Responsibility）</strong>：为请求创建一个接收者对象的链。</li>
<li><strong>命令模式（Command）</strong>：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化。</li>
<li><strong>解释器模式（Interpreter）</strong>：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</li>
<li><strong>迭代器模式（Iterator）</strong>：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露其内部的表示。</li>
<li><strong>中介者模式（Mediator）</strong>：用一个中介对象来封装一系列的对象交互。</li>
<li><strong>备忘录模式（Memento）</strong>：在不破坏封装的前提下，捕获并保存一个对象的内部状态，以便在将来的时间点上恢复对象到这个状态。</li>
<li><strong>观察者模式（Observer）</strong>：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</li>
<li><strong>状态模式（State）</strong>：允许一个对象在其内部状态改变时改变它的行为。</li>
<li><strong>策略模式（Strategy）</strong>：定义一系列的算法，把它们一个个封装起来，并使它们可相互替换。</li>
<li><strong>模板方法模式（Template Method）</strong>：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。</li>
<li><strong>访问者模式（Visitor）</strong>：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</li>
</ul>
</li>
</ul>
<p>综上所述，C++中的创建型、结构型和行为型设计模式各具特点，分别关注于对象的创建、组合以及对象之间的通信和协作。这些设计模式在软件开发中具有重要的应用价值，可以帮助开发者编写更加清晰、可维护和可扩展的代码。</p>
<h3 id="2-设计模式三大原则"><a href="#2-设计模式三大原则" class="headerlink" title="2.设计模式三大原则"></a>2.设计模式三大原则</h3><p>设计模式的三大原则通常指的是<strong>开闭原则</strong>（Open&#x2F;Closed Principle）、<strong>里氏替换原则</strong>（Liskov Substitution Principle）和<strong>依赖倒置原则</strong>（Dependency Inversion Principle），它们是面向对象设计的基本原则，旨在提高代码的灵活性、可维护性和可扩展性。以下是这三个原则的清晰简洁解释：</p>
<ol>
<li><p>开闭原则（Open&#x2F;Closed Principle）</p>
<p>：</p>
<ul>
<li><strong>解释</strong>：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着当需要添加新功能时，应该通过扩展现有代码（例如添加新类、新接口等）来实现，而不是修改已有代码。</li>
<li><strong>目的</strong>：提高代码的灵活性和可维护性，减少因修改已有代码而引入的潜在错误。</li>
</ul>
</li>
<li><p>里氏替换原则（Liskov Substitution Principle）</p>
<p>：</p>
<ul>
<li><strong>解释</strong>：子类必须能够替换它们的基类而不会导致程序出错。这要求子类必须完全遵守基类所定义的接口契约，即子类在替换基类时，其行为应该与基类保持一致。</li>
<li><strong>目的</strong>：确保系统的稳定性和可靠性，避免子类破坏基类的行为预期。</li>
</ul>
</li>
<li><p>依赖倒置原则（Dependency Inversion Principle）</p>
<p>：</p>
<ul>
<li><strong>解释</strong>：高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。这意味着在设计中，应该通过接口或抽象类来定义高层模块和低层模块之间的交互，而不是直接依赖于具体的实现类。</li>
<li><strong>目的</strong>：降低模块之间的耦合度，提高系统的可扩展性和可维护性。通过依赖抽象而不是具体实现，可以更容易地在不改变高层模块的情况下替换低层模块的实现。</li>
</ul>
</li>
</ol>
<p>这三大原则共同构成了面向对象设计的基础，它们指导我们如何设计更加灵活、可维护和可扩展的软件系统。遵循这些原则，可以帮助我们避免常见的设计问题，提高代码的质量和可维护性。</p>
<h3 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3.单例模式"></a>3.单例模式</h3><p><code>单例模式：</code>一个类不管创建多少次对象，永远只能得到该类型的一个对象的实例</p>
<p>常用到的，比如日志模块，数据库模块</p>
<p><strong>需要注意的五个点</strong>：</p>
<p>1、需要将构造函数私有化，这样保证使用者无法通过构造函数创建新的单例对象<br>2、需要定义一个唯一的static实例对象<br>3、需要提供对外的接口返回这个唯一的实例对象<br>4、需要删除拷贝构造函数和赋值运算符重载函数，保证使用者不能通过者二者构造新的对象<br>5、在类内声明了static对象，还需要在类外进行定义</p>
<p>分为两类：</p>
<p><code>饿汉式单例模式：</code>还没有获取实例对象，实例对象就已经产生了<br><code>懒汉式单例模式：</code>唯一的实例对象，直到第一次获取它的时候，才产生（初始化)</p>
<h4 id="1-饿汉单例模式"><a href="#1-饿汉单例模式" class="headerlink" title="1.饿汉单例模式"></a>1.饿汉单例模式</h4><p><strong>饿汉单例模式 一定是线程安全的</strong></p>
<p>**饿汉式单例模式在类加载时就创建实例。**这种方式的特点是线程安全，因为实例在类加载时就已经被初始化，而类加载是线程安全的（由类加载器保证）。此外，饿汉式单例模式的实现相对简单。然而，它的缺点是即使实例没有被使用，它也会在类加载时被创建，这可能会导致内存浪费。</p>
<p><code>创建步骤：</code></p>
<p>1.构造函数私有化 使得用户不能随意调用构造函数，没有那么轻易的创建对象的实例</p>
<p>2.定义一个唯一的类的实例对象（既然已经让用户难以调用构造函数，那么类应该提供这个唯一的实例化对象）</p>
<p>3.定义接口让用户有办法获取类的唯一实例化对象的方法，通常返回的都是指针类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span><span class="comment">//3.定义接口让用户有办法获取类的唯一实例化对象的方法</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;instance;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> Singleton instance;<span class="comment">//2.定义一个唯一的类的实例对象（既然已经让用户难以调用构造函数，那么类应该提供这个唯一的实例化对象）</span></span><br><span class="line">	<span class="built_in">Singleton</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;<span class="comment">// 1.构造函数私有化 使得用户不能随意调用构造函数，没有那么轻易的创建对象的实例</span></span><br><span class="line">	<span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton Singleton::instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//打印出来的p1 p2 p3 都是同一块地址</span></span><br><span class="line">	Singleton* p1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	Singleton* p2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	Singleton* p3 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-懒汉单例模式"><a href="#2-懒汉单例模式" class="headerlink" title="2.懒汉单例模式"></a>2.懒汉单例模式</h4><p>**懒汉式单例模式在首次使用时才创建实例。**这种方式的特点是实现了延迟加载，即只有在需要实例时才创建它，从而节省了内存。</p>
<p>把静态变量设置为指针，通过初始化为空的方式不去分配内存，直到使用时（调用get）才去分配内存。</p>
<p><code>创建步骤：</code></p>
<p>1.构造函数私有化 使得用户不能随意调用构造函数，没有那么轻易的创建对象的实例</p>
<p>2.定义一个唯一的类的实例对象（既然已经让用户难以调用构造函数，那么类应该提供这个唯一的实例化对象）</p>
<p>3.定义接口让用户有办法获取类的唯一实例化对象的方法，通常返回的都是指针类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span><span class="comment">//3.定义接口让用户有办法获取类的唯一实例化对象的方法</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> Singleton *instance;<span class="comment">//2.定义一个唯一的类的实例对象（既然已经让用户难以调用构造函数，那么类应该提供这个唯一的实例化对象）</span></span><br><span class="line">	<span class="built_in">Singleton</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;<span class="comment">// 1.构造函数私有化 使得用户不能随意调用构造函数，没有那么轻易的创建对象的实例</span></span><br><span class="line">	<span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Singleton* p1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	Singleton* p2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	Singleton* p3 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然而，懒汉式单例模式在多线程环境下可能会出现线程安全问题，即多个线程可能会同时创建实例，导致违反单例原则。为了解决这个问题，可以在创建实例的方法上加上同步关键字（synchronized），但这会降低性能。</p>
<p>为了解决懒汉式单例模式在多线程环境下的线程安全问题和性能问题，可以采用双重检查锁定（Double-Checked Locking）和volatile关键字。双重检查锁定可以确保在创建实例时只进行一次同步操作，而volatile关键字可以确保<strong>变量的可见性和禁止指令重排序</strong>，从而避免在创建实例时出现线程安全问题。</p>
<h3 id="4-线程安全的懒汉单例模式"><a href="#4-线程安全的懒汉单例模式" class="headerlink" title="4.线程安全的懒汉单例模式"></a>4.线程安全的懒汉单例模式</h3><p>**可重入函数：**这个函数还没执行完，可不可以再被调用一次</p>
<p>在单线程中不可能发生（除了递归），在多线程中可能，线程1还没运行完，线程2就来运行了</p>
<p>如果这个函数可以在多线程环境下直接运行而且不发生竞态条件，那就是<code>可重入函数</code></p>
<p>而懒汉单例模式中，getIntance并不是线程安全的</p>
<p>线程1进去了，还没给instance赋值，时间片到了给了线程2，那线程2就给instance赋值了，所以不是可重入函数，<strong>所以懒汉单例模式并不是线程安全的</strong></p>
<h4 id="1-锁-双重判断"><a href="#1-锁-双重判断" class="headerlink" title="1.锁+双重判断"></a>1.锁+双重判断</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line"><span class="comment">//锁+双重判断</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//锁的粒度太大了 在单线程环境中也要不停地加锁解锁</span></span><br><span class="line">		<span class="comment">//lock_guard&lt;mutex&gt; guard(mtx);</span></span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//放到if里面，只要创建过，后面就不会进来if</span></span><br><span class="line">			<span class="function">lock_guard&lt;mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line">			<span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">					1.开辟内存</span></span><br><span class="line"><span class="comment">					2.构造对象</span></span><br><span class="line"><span class="comment">					3.给instance赋值</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//不加volatile的默认情况下，线程会对代码数据段拷贝一份副本，自己看自己的副本，加上以后不拷贝副本，只要instance发生改变，所有线程都能立马看到它改变了</span></span><br><span class="line">	<span class="comment">//注意在下面初始化的时候也要加上volatile关键字</span></span><br><span class="line">	<span class="type">static</span> Singleton * <span class="keyword">volatile</span> instance;</span><br><span class="line">	<span class="built_in">Singleton</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* <span class="keyword">volatile</span> Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Singleton* p1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	Singleton* p2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	Singleton* p3 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：1.不加volatile的默认情况下，线程会对代码数据段拷贝一份副本，自己看自己的副本，加上以后不拷贝副本，只要instance发生改变，所有线程都能立马看到它改变了</p>
<p>2.在下面初始化的时候也要加上volatile关键字</p>
<p>3.new具体步骤补充</p>
<ol>
<li><strong>开辟内存</strong>：<code>new</code> 操作符首先为对象分配足够的内存空间。这是通过调用底层的内存分配函数（如 <code>malloc</code>，尽管在 C++ 中更常见的是使用 <code>operator new</code>）来完成的。这个步骤确保了对象有足够的空间来存储其数据成员。</li>
<li><strong>构造对象</strong>：一旦内存被分配，<code>new</code> 操作符就会在该内存位置上调用类的构造函数来初始化对象。这是对象实际被“创建”或“构造”的时刻，它的数据成员被赋予初始值（如果有的话）。</li>
<li><strong>给 <code>instance</code> 赋值</strong>：最后，<code>new</code> 操作符返回指向新构造对象的指针，这个指针随后被赋值给静态成员变量 <code>instance</code>。这一步是将新创建的对象与类的静态成员变量关联起来的关键。</li>
</ol>
<h4 id="2-简洁的线程安全懒汉单例模式"><a href="#2-简洁的线程安全懒汉单例模式" class="headerlink" title="2.简洁的线程安全懒汉单例模式"></a>2.简洁的线程安全懒汉单例模式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">static</span> Singleton instance;</span><br><span class="line">		<span class="keyword">return</span> &amp;instance;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在C++中，类的静态局部变量的内存确实在程序启动时就已经为其预留，但是变量的初始化会延迟到第一次执行到它所在的代码块，所以这也是一种懒汉单例模式</p>
<p><strong>而函数静态局部变量的初始化，在汇编指令上已经自动添加线程互斥指令了，因此不用担心线程安全的问题</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">static</span> Singleton instance;</span><br><span class="line">		<span class="keyword">return</span> &amp;instance;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Singleton* p1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	Singleton* p2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	Singleton* p3 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-简单工厂-Simple-Factor-、工厂方法-Factory-Method"><a href="#5-简单工厂-Simple-Factor-、工厂方法-Factory-Method" class="headerlink" title="5.简单工厂(Simple Factor)、工厂方法(Factory Method)"></a>5.简单工厂(Simple Factor)、工厂方法(Factory Method)</h3><p><code>工厂模式：</code>主要是封装了对象的创建操作</p>
<h4 id="1-简单工厂"><a href="#1-简单工厂" class="headerlink" title="1.简单工厂"></a>1.简单工厂</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Car</span>(string name):_name(name)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BMW</span>(string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获得了一辆宝马汽车&quot;</span> &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Audi</span>(string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获得了一辆奥迪汽车&quot;</span> &lt;&lt; _name &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CarType</span></span><br><span class="line">&#123;</span><br><span class="line">	Bmw, AUDI</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Car* <span class="title">createCar</span><span class="params">(CarType ct)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (ct)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> Bmw:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BMW</span>(<span class="string">&quot;X1&quot;</span>);</span><br><span class="line">		<span class="keyword">case</span> AUDI:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(<span class="string">&quot;A6&quot;</span>);</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			cerr &lt;&lt; <span class="string">&quot;传入工厂的参数不正确:&quot;</span> &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*1.原来是这样的，但是对于用户来说根本不需要知道什么X1，X6什么的</span></span><br><span class="line"><span class="comment">	Car* p1 = new BMW(&quot;X1&quot;);</span></span><br><span class="line"><span class="comment">	Car* p2 = new Audi(&quot;A6&quot;);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*2.</span></span><br><span class="line"><span class="comment">	SimpleFactory* factory = new SimpleFactory();</span></span><br><span class="line"><span class="comment">	Car* p1 = factory-&gt;createCar(Bmw);</span></span><br><span class="line"><span class="comment">	Car* p2 = factory-&gt;createCar(AUDI);</span></span><br><span class="line"><span class="comment">	p1-&gt;show();</span></span><br><span class="line"><span class="comment">	p2-&gt;show();</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.使用智能指针管理资源</span></span><br><span class="line">	<span class="function">unique_ptr&lt;SimpleFactory&gt; <span class="title">factory</span><span class="params">(<span class="keyword">new</span> SimpleFactory())</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Car&gt; <span class="title">p1</span><span class="params">(factory-&gt;createCar(Bmw))</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Car&gt; <span class="title">p2</span><span class="params">(factory-&gt;createCar(AUDI))</span></span>;</span><br><span class="line"></span><br><span class="line">	p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">	p2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该例子中使用SimpleFactory类封装两个汽车类的创建操作</p>
<p>一共2种使用方法，即代码中的2种，直接用或者通过智能指针间接用</p>
<p>简单工厂模式（Simple Factory）的缺点主要包括以下几个方面：</p>
<ol>
<li>违反开闭原则<ul>
<li>开闭原则要求软件实体（类、模块、函数等）应该是可扩展的，但不可修改的。然而，在简单工厂模式中，每当需要增加新的产品时，都需要修改工厂类中的判断逻辑，从而违反了开闭原则。</li>
</ul>
</li>
<li>高内聚问题<ul>
<li>简单工厂模式中的工厂类通常负责所有产品的创建，这导致工厂类的职责过重，不符合高内聚的原则。高内聚要求一个模块或类应该只负责一个功能或一个紧密相关的功能集合。</li>
</ul>
</li>
<li>不利于扩展和维护<ul>
<li>由于简单工厂模式中的工厂类集中了所有产品的创建逻辑，随着产品种类的增加，工厂类的逻辑将变得越来越复杂，不利于系统的扩展和维护。</li>
<li>当需要添加新产品时，需要修改工厂类的代码，这增加了代码的维护成本。</li>
</ul>
</li>
<li>测试困难<ul>
<li>在简单工厂模式中，由于工厂类与具体产品类之间存在紧密的耦合关系，这增加了单元测试的难度。为了测试某个具体产品类，可能需要先实例化工厂类，并调用其创建方法，这可能会引入不必要的依赖和复杂性。</li>
</ul>
</li>
<li>缺乏灵活性<ul>
<li>简单工厂模式通常使用静态方法或全局方法来创建对象，这限制了对象的创建方式和灵活性。例如，在某些情况下，可能需要使用不同的创建策略或根据不同的上下文创建不同的对象实例，但简单工厂模式无法提供这种灵活性。</li>
</ul>
</li>
</ol>
<p>所以有了工厂方法和抽象工厂</p>
<h4 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2.工厂方法"></a>2.工厂方法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Car</span>(string name):_name(name)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BMW</span>(string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获得了一辆宝马汽车&quot;</span> &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Audi</span>(string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获得了一辆奥迪汽车&quot;</span> &lt;&lt; _name &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Car* <span class="title">createCar</span><span class="params">(string name)</span> </span>= <span class="number">0</span>;<span class="comment">//这个就是所谓的工厂方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMWFactory</span> :<span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Car* <span class="title">createCar</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BMW</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudiFactory</span> :<span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Car* <span class="title">createCar</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">unique_ptr&lt;Factory&gt; <span class="title">bmwfty</span><span class="params">(<span class="keyword">new</span> BMWFactory())</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Factory&gt; <span class="title">audifty</span><span class="params">(<span class="keyword">new</span> AudiFactory())</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Car&gt; <span class="title">p1</span><span class="params">(bmwfty-&gt;createCar(<span class="string">&quot;X6&quot;</span>))</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Car&gt; <span class="title">p2</span><span class="params">(audifty-&gt;createCar(<span class="string">&quot;A8&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">	p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">	p2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Factory的纯虚函数就是工厂方法</p>
<p><strong>其实就是对每个类有又单独创建了一个创建它的对象的类，就相当于封装了</strong></p>
<p>1.完成了对对象的封装操作</p>
<p>2.贴合了软件的开闭原则（对原来已有的功能封闭，对扩展新功能开放）</p>
<p>一个工厂对应了一个类的创建，如果类很多的话会导致工厂也很多</p>
<p><code>缺点：</code>灵活性受限</p>
<ul>
<li>工厂方法模式通常用于创建单个产品对象，如果需要创建多个相关或依赖的产品对象，可能需要使用其他模式（如抽象工厂模式）来替代。</li>
</ul>
<h3 id="6-抽象工厂-Abstract-Factory"><a href="#6-抽象工厂-Abstract-Factory" class="headerlink" title="6.抽象工厂(Abstract Factory)"></a>6.抽象工厂(Abstract Factory)</h3><p>对有一组关联关系的产品簇提供产品对象的统一创建</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Car</span>(string name):_name(name)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BMW</span>(string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获得了一辆宝马汽车&quot;</span> &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Audi</span>(string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获得了一辆奥迪汽车&quot;</span> &lt;&lt; _name &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//车的相关系列产品 车灯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Light</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BmwLight</span> :<span class="keyword">public</span> Light</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot; BMW Light&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudiLight</span> :<span class="keyword">public</span> Light</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot; Audi Light&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂 对有一组关联关系的产品簇提供产品对象的统一创建</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//这个就是所谓的工厂方法</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Car* <span class="title">createCar</span><span class="params">(string name)</span> </span>= <span class="number">0</span>;<span class="comment">//工厂方法 创建车</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Light* <span class="title">createCarLight</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//工厂方法 创建汽车关联的产品车灯</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMWFactory</span> :<span class="keyword">public</span> AbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Car* <span class="title">createCar</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BMW</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Light* <span class="title">createCarLight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BmwLight</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudiFactory</span> :<span class="keyword">public</span> AbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Car* <span class="title">createCar</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Light* <span class="title">createCarLight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AudiLight</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">unique_ptr&lt;AbstractFactory&gt; <span class="title">bmwfty</span><span class="params">(<span class="keyword">new</span> BMWFactory())</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;AbstractFactory&gt; <span class="title">audifty</span><span class="params">(<span class="keyword">new</span> AudiFactory())</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Car&gt; <span class="title">p1</span><span class="params">(bmwfty-&gt;createCar(<span class="string">&quot;X6&quot;</span>))</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Car&gt; <span class="title">p2</span><span class="params">(audifty-&gt;createCar(<span class="string">&quot;A8&quot;</span>))</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Light&gt; <span class="title">l1</span><span class="params">(bmwfty-&gt;createCarLight())</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Light&gt; <span class="title">l2</span><span class="params">(audifty-&gt;createCarLight())</span></span>;</span><br><span class="line"></span><br><span class="line">	p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">	p2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">	l1-&gt;<span class="built_in">show</span>();</span><br><span class="line">	l2-&gt;<span class="built_in">show</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>缺点：不支持单一产品的变化</p>
<ul>
<li>抽象工厂模式适用于一组相关产品的创建，但如果只有一个产品发生变化，那么整个工厂都需要进行修改，可能不够灵活。</li>
</ul>
<p>其他的类甚至也要重写AbstractFactory里面新加的这个产品，不然自己的类会变成虚函数，但是实际上其他类本身也不提供这个产品（比如宝马课程生产一个螺丝奥迪可能就没有，这个时候就挺尴尬）</p>
<p><strong>小结：</strong></p>
<p><strong>简单工厂 Simple Factory :</strong></p>
<p>**优点：**把对象的创建封装在一个接口函数里面,通过传入不同的标识,返回创建的对象</p>
<p>客户不用自己负责new对象,不用了解对象创建的详细过程</p>
<p>**缺点：**提供创建对象实例的接口函数不闭合,不能对修改关闭</p>
<p><strong>工厂方法 Factory Method</strong></p>
<p>**优点：**Factory基类,提供了一个纯虚函数(创建产品)，定义派生类(具体产品的工厂)负责创建对应的</p>
<p>产品,可以做到不同的产品,在不同的工厂里面创建,能够对现有工厂,以及产品的修改关闭</p>
<p>**缺点：**实际上,很多产品是有关联关系的,属于一个产品簇,不应该放在不同的工厂里面去创建,这样</p>
<p>一是不符合实际的产品对象创建逻辑,二是工厂类太多了,不好维护</p>
<p><strong>抽象工厂 Abstract Factory</strong></p>
<p>**优点：**把有关联关系的,属于一个产品簇的所有产品创建的接口函数,放在一个抽象工厂里面AbstractFactroy，派生类(具体产品的工厂)应该负责创建该产品簇里面所有的产品</p>
<p>**缺点：**抽象工厂模式适用于一组相关产品的创建，但如果只有一个产品发生变化，那么整个工厂都需要进行修改，可能不够灵活。</p>
<h3 id="7-代理模式（Proxy）"><a href="#7-代理模式（Proxy）" class="headerlink" title="7.代理模式（Proxy）"></a>7.代理模式（Proxy）</h3><p>通过代理类，来控制实际对象的访问权限</p>
<p><strong>代理模式（Proxy Pattern）</strong> 是一种结构型设计模式，它提供一个对象的代理，以控制对这个对象的访问。代理对象作为客户端和目标对象之间的中介，客户端通过代理对象间接地访问目标对象。代理模式常用于延迟加载、访问控制、缓存等功能。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li><strong>隐藏实现细节</strong>：客户端通过代理对象访问目标对象，不需要知道目标对象的具体实现。</li>
<li><strong>增强目标对象</strong>：可以在不修改目标对象代码的情况下，为目标对象添加额外的功能。</li>
<li><strong>控制访问</strong>：可以对目标对象的访问进行权限控制。</li>
<li><strong>减少系统开销</strong>：例如，通过代理实现延迟加载，减少系统资源的消耗。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><strong>性能损耗</strong>：代理对象会增加一层调用开销，虽然这个开销通常很小，但在高性能要求的场景下可能会成为瓶颈。</li>
<li><strong>代码复杂度增加</strong>：引入代理模式后，系统的代码复杂度会增加。</li>
</ol>
<p><strong>步骤：</strong></p>
<p>1.抽象公共类</p>
<p>2.委托类（继承自公共类）</p>
<p>3.代理类（继承自公共类）</p>
<p>4.以组合的方式使用代理对象</p>
<p>5.客户直接访问代理对象 相当于客户只能访问助理，不能直接访问老板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户   助理proxy   老板 委托类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoSite</span><span class="comment">//1.抽象类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//免费看电影</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//vip看</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMovie</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//用券才能看</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FixBugVideoSite</span>:<span class="keyword">public</span> VideoSite<span class="comment">//2.委托类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;观看免费电影&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;观看vip电影&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMovie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;用券观看电影&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FreeVideoSiteProxy</span> :<span class="keyword">public</span> VideoSite</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">FreeVideoSiteProxy</span>() &#123; pVideo = <span class="keyword">new</span> <span class="built_in">FixBugVideoSite</span>(); &#125;</span><br><span class="line">	~<span class="built_in">FreeVideoSiteProxy</span>() &#123; <span class="keyword">delete</span> pVideo; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pVideo-&gt;<span class="built_in">freeMovie</span>();<span class="comment">//通过代理对象的freemovie访问委托类真正的freemovie</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您目前只是普通用户，需要升级VIP才能观看VIP电影&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMovie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您目前没有券，需要购买电影券才能观看该电影&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	VideoSite* pVideo;<span class="comment">//4.以组合的方式使用代理对象</span></span><br><span class="line">	<span class="comment">//或者去掉构造和析构，直接调用委托类也行 </span></span><br><span class="line">	<span class="comment">//FixBugVideoSite Video</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VipVideoSiteProxy</span> :<span class="keyword">public</span> VideoSite</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">VipVideoSiteProxy</span>() &#123; pVideo = <span class="keyword">new</span> <span class="built_in">FixBugVideoSite</span>(); &#125;</span><br><span class="line">	~<span class="built_in">VipVideoSiteProxy</span>() &#123; <span class="keyword">delete</span> pVideo; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pVideo-&gt;<span class="built_in">freeMovie</span>();<span class="comment">//通过代理对象的freemovie访问委托类真正的freemovie</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pVideo-&gt;<span class="built_in">vipMovie</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMovie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您目前没有券，需要购买电影券才能观看该电影&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	VideoSite* pVideo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这些都是通用的API接口，使用的都是基类的指针或者引用 通过多态访问虚函数就是了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">watchMovice</span><span class="params">(unique_ptr&lt;VideoSite&gt; &amp;ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ptr-&gt;<span class="built_in">freeMovie</span>();</span><br><span class="line">	ptr-&gt;<span class="built_in">vipMovie</span>();</span><br><span class="line">	ptr-&gt;<span class="built_in">ticketMovie</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*1.只有委托类，没有代理类</span></span><br><span class="line"><span class="comment">	同一个用户p1看的时候可能就还得对这些调用加if else判断</span></span><br><span class="line"><span class="comment">	来判断身份从而控制访问权限，什么电影能看，什么不能看，很麻烦，不灵活*/</span></span><br><span class="line">	VideoSite* p1 = <span class="keyword">new</span> <span class="built_in">FixBugVideoSite</span>();</span><br><span class="line">	p1-&gt;<span class="built_in">freeMovie</span>();</span><br><span class="line">	p1-&gt;<span class="built_in">vipMovie</span>();</span><br><span class="line">	p1-&gt;<span class="built_in">ticketMovie</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*2.</span></span><br><span class="line"><span class="comment">	通过代理，不同身份的用户可以对不同类型的电影具有不同的访问权限</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第五步，客户直接访问代理对象 相当于客户只能访问助理，不能直接访问老板</span></span><br><span class="line">	<span class="comment">//游客</span></span><br><span class="line">	<span class="function">unique_ptr&lt;VideoSite&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> FreeVideoSiteProxy())</span></span>;</span><br><span class="line">	<span class="built_in">watchMovice</span>(p2);</span><br><span class="line">	<span class="comment">//VIP</span></span><br><span class="line">	<span class="function">unique_ptr&lt;VideoSite&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> VipVideoSiteProxy())</span></span>;</span><br><span class="line">	<span class="built_in">watchMovice</span>(p3);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>类和接口的说明：</code></p>
<ol>
<li><strong>VideoSite</strong>：这是一个抽象基类，定义了三个纯虚函数<code>freeMovie</code>、<code>vipMovie</code>和<code>ticketMovie</code>，分别代表观看免费电影、VIP电影和用券观看电影的功能。这个类作为所有视频站点（包括代理和委托）的接口。</li>
<li><strong>FixBugVideoSite</strong>：这是<code>VideoSite</code>的一个具体实现，即委托类。它实现了所有三个虚函数，分别输出相应的观看信息。这个类代表了一个实际的视频站点，提供了观看电影的具体功能。</li>
<li><strong>FreeVideoSiteProxy</strong>和<strong>VipVideoSiteProxy</strong>：这两个类都是<code>VideoSite</code>的代理类。它们各自持有一个指向<code>VideoSite</code>（实际上是<code>FixBugVideoSite</code>）的指针，用于在需要时调用委托类的功能。代理类通过重写虚函数来控制对委托类功能的访问，例如，普通用户（<code>FreeVideoSiteProxy</code>）不能观看VIP电影或用券观看电影，而VIP用户（<code>VipVideoSiteProxy</code>）则可以观看VIP电影，但仍然不能用券观看（在这个例子中，VIP用户是否能用券观看取决于代理类的实现，这里简单地限制了）。</li>
</ol>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-15%20141753.png" alt="屏幕截图 2024-10-15 141753"></p>
<p>委托类和代理类的虚函数都是一样的，都是抽象类里面的函数</p>
<p>代理类经过检查发现不合法，没有权限，就不会调用委托类对象</p>
<h3 id="8-装饰器模式"><a href="#8-装饰器模式" class="headerlink" title="8.装饰器模式"></a>8.装饰器模式</h3><p><code>装饰器模式：</code>主要是增加现有类的功能</p>
<p>为了增强现有类的功能，通过实现子类的方式，重写接口，是可以完成功能扩展的，但是代码中有太多的子类添加进来了</p>
<p>**装饰器模式（Decorator Pattern）**是一种结构型设计模式，它允许你向一个现有的对象添加新的功能，同时又不改变其结构。装饰器模式通过创建一个包装对象（即装饰器）来包裹原始对象，从而可以在运行时动态地给对象添加职责。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol>
<li><strong>灵活性</strong>：可以在不修改原有类的情况下增加新的功能。</li>
<li><strong>扩展性</strong>：通过组合而非继承来扩展功能，避免了继承带来的高耦合和代码膨胀问题。</li>
<li><strong>复用性</strong>：装饰器和具体组件可以独立变化，互不干扰。</li>
</ol>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><strong>装饰链复杂</strong>：如果装饰链太长，调试和维护会变得复杂。</li>
<li><strong>性能</strong>：因为每次调用都会通过多个装饰器，可能会有一定的性能开销。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bmw</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是一辆宝马汽车，配置有：基类配置&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是一辆奥迪汽车，配置有：基类配置&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Benz</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是一辆奔驰汽车，配置有：基类配置&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//装饰器的基类 装饰器可以让增加的功能互相组合</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarDecorator</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CarDecorator</span>(Car* p) :<span class="built_in">pCar</span>(p) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Car* pCar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//装饰器1 定速巡航</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator01</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ConcreteDecorator01</span>(Car *p):<span class="built_in">pCar</span>(p)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pCar-&gt;<span class="built_in">show</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;,定速巡航&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Car* pCar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//装饰器2 定速巡航</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator02</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ConcreteDecorator02</span>(Car* p) :<span class="built_in">pCar</span>(p) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pCar-&gt;<span class="built_in">show</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;,自动刹车&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Car* pCar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//装饰器3 车道偏离</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator03</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ConcreteDecorator03</span>(Car* p) :<span class="built_in">pCar</span>(p) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pCar-&gt;<span class="built_in">show</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;,车道偏离&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Car* pCar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Car* p1 = <span class="keyword">new</span> <span class="built_in">ConcreteDecorator01</span>(<span class="keyword">new</span> <span class="built_in">Bmw</span>());</span><br><span class="line">	<span class="comment">//功能组合</span></span><br><span class="line">	p1 = <span class="keyword">new</span> <span class="built_in">ConcreteDecorator02</span>(p1);</span><br><span class="line">	p1 = <span class="keyword">new</span> <span class="built_in">ConcreteDecorator03</span>(p1);</span><br><span class="line">	p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Car* p2 = <span class="keyword">new</span> <span class="built_in">ConcreteDecorator02</span>(<span class="keyword">new</span> <span class="built_in">Audi</span>());</span><br><span class="line">	p2-&gt;<span class="built_in">show</span>();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Car* p3 = <span class="keyword">new</span> <span class="built_in">ConcreteDecorator03</span>(<span class="keyword">new</span> <span class="built_in">Benz</span>());</span><br><span class="line">	p3-&gt;<span class="built_in">show</span>();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-代理和装饰的区别"><a href="#9-代理和装饰的区别" class="headerlink" title="9.代理和装饰的区别"></a>9.代理和装饰的区别</h3><p>C++中的装饰器模式（Decorator Pattern）和代理模式（Proxy Pattern）都是结构型设计模式，但它们在目的、功能扩展方式、结构修改以及关注点等方面存在显著的区别。</p>
<h4 id="一、目的"><a href="#一、目的" class="headerlink" title="一、目的"></a>一、目的</h4><ul>
<li><strong>装饰器模式</strong>：主要用于动态地为对象添加额外的职责，而不改变其结构。它允许在不改变现有对象代码的情况下，通过创建一系列的装饰器类来增加、扩展或修改对象的功能。</li>
<li><strong>代理模式</strong>：主要用于控制对其他对象的访问。它在客户端和实际对象之间引入了一个代理对象，客户端通过代理对象访问实际对象。代理对象可以用于控制访问权限、延迟加载、远程访问等。</li>
</ul>
<h4 id="二、功能扩展方式"><a href="#二、功能扩展方式" class="headerlink" title="二、功能扩展方式"></a>二、功能扩展方式</h4><ul>
<li><strong>装饰器模式</strong>：通过组合多个装饰器类来实现功能扩展。每个装饰器类都实现了与被装饰对象相同的接口，并可以在调用接口方法之前或之后添加额外的行为。</li>
<li><strong>代理模式</strong>：主要通过代理对象来控制访问，实际功能一般是由被代理对象提供的。代理对象可以在访问实际对象之前或之后添加额外的逻辑，如权限检查、日志记录等。</li>
</ul>
<h4 id="三、结构修改"><a href="#三、结构修改" class="headerlink" title="三、结构修改"></a>三、结构修改</h4><ul>
<li><strong>装饰器模式</strong>：通常不改变对象的结构，只是在其上添加装饰器。装饰器与被装饰对象具有相同的接口，因此可以替换或组合使用。</li>
<li><strong>代理模式</strong>：虽然也引入了新的代理对象，但代理对象通常包含了额外的逻辑，这些逻辑在访问实际对象之前或之后执行。此外，代理模式可能会改变客户端与实际对象之间的交互方式。</li>
</ul>
<h4 id="四、关注点"><a href="#四、关注点" class="headerlink" title="四、关注点"></a>四、关注点</h4><ul>
<li><strong>装饰器模式</strong>：关注于对象的功能增强。它允许在不修改现有代码的情况下，动态地为对象添加新的行为或功能。</li>
<li><strong>代理模式</strong>：关注于对象的访问控制和管理。它提供了对实际对象访问的间接层，以便在访问过程中添加额外的逻辑或控制。</li>
</ul>
<h4 id="五、应用场景"><a href="#五、应用场景" class="headerlink" title="五、应用场景"></a>五、应用场景</h4><ul>
<li><strong>装饰器模式</strong>：<ul>
<li>组件扩展：在大型项目中，随着业务的增加，需要添加新的功能时，装饰器可以避免修改原有的基础组件。</li>
<li>API增强：当提供API给第三方调用时，装饰器可以用于添加额外的功能，如日志记录、安全校验等。</li>
<li>权限管理：装饰器可以用来控制对原有特定接口的访问权限。</li>
<li>缓存机制：在网络请求或数据库查询等操作中，装饰器可以用来添加额外的缓存、重试、超时处理等功能。</li>
</ul>
</li>
<li><strong>代理模式</strong>：<ul>
<li>延迟加载：可以在需要时才创建实际对象，节省资源。</li>
<li>远程代理：用于控制对远程对象的访问，通常用于网络编程中。</li>
<li>保护代理：用于控制对对象的访问权限，增强安全性。</li>
<li>缓存&#x2F;缓冲代理：用于缓存频繁访问的数据，以减少计算或网络请求的开销。</li>
<li>智能引用代理：用于管理对象的生命周期，确保对象在不再需要时被正确释放。</li>
</ul>
</li>
</ul>
<h3 id="10-适配器模式"><a href="#10-适配器模式" class="headerlink" title="10.适配器模式"></a>10.适配器模式</h3><p><code>适配器模式：</code>让不兼容的接口可以在一起工作</p>
<p>**适配器模式（Adapter Pattern）**是一种结构型设计模式，它允许接口不兼容的类一起工作。适配器模式将类的接口转换成客户端所期望的另一种接口形式，使得原本不兼容的类可以合作无间。</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol>
<li><strong>提高灵活性</strong>：通过适配器，客户端可以透明地访问不兼容的接口，提高了系统的灵活性。</li>
<li><strong>复用性</strong>：适配器使得已有的类可以被复用，而无需修改它们的源代码。</li>
<li><strong>解耦</strong>：适配器模式有助于将接口和实现解耦，使得系统更加模块化。</li>
</ol>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><strong>代码复杂度增加</strong>：引入适配器会增加系统的代码量和复杂度。</li>
<li><strong>性能损耗</strong>：在某些情况下，适配器可能会导致性能上的损耗，因为它需要在客户端和适配对象之间进行额外的转换。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VGA接口的电脑 TV投影仪也是VGA接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VGA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">play</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TV01表示支持VGA接口的投影仪</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TV01</span> :<span class="keyword">public</span> VGA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;通过VGA接口连接投影仪，进行视频播放&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现一个电脑类，只支持VGA接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//由于电脑只支持VGA接口，所以该方法的参数也只能支持VGA接口的指针和引用</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">playVideo</span><span class="params">(VGA* pVGA)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pVGA-&gt;<span class="built_in">play</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进了一批新的投影仪，都只支持HDMT接口，根本都插不到电脑上</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HDMI</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">play</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TV02</span> :<span class="keyword">public</span> HDMI</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;通过HDMI接口连接投影仪，进行视频播放&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于电脑(VGA接口)和投影仪(HDMI接口)无法直接相连，所以需要添加适配器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VGAToHDMTAdapter</span> :<span class="keyword">public</span> VGA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">VGAToHDMTAdapter</span>(HDMI *p):<span class="built_in">pHdmi</span>(p)&#123;&#125;</span><br><span class="line">	<span class="comment">//该方法相当于就是转换头，做不同接口的信号转换的</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pHdmi-&gt;<span class="built_in">play</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	HDMI* pHdmi;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Computer computer;</span><br><span class="line">	<span class="comment">//电脑本身就支持VGA，通过VGA投影到投影仪上</span></span><br><span class="line">	computer.<span class="built_in">playVideo</span>(<span class="keyword">new</span> <span class="built_in">TV01</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*TV02只支持HDMI，不支持AGV</span></span><br><span class="line"><span class="comment">	computer.playVideo(new TV02());</span></span><br><span class="line"><span class="comment">	表现为VGA*不接受一个TV02指针类型的参数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	方法1：换一个支持HDMI接口的电脑，这个就叫代码重构</span></span><br><span class="line"><span class="comment">	方法2：买一个转换头（适配器），能够把VGA信号转成HDMI信号，这是添加适配器类*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过转换头，可以通过HDMI接口投影仪播放视频</span></span><br><span class="line">	computer.<span class="built_in">playVideo</span>(<span class="keyword">new</span> <span class="built_in">VGAToHDMTAdapter</span>(<span class="keyword">new</span> <span class="built_in">TV02</span>()));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是对代码中各个部分的详细讲解：</p>
<ol>
<li><strong>抽象接口定义</strong></li>
</ol>
<ul>
<li><strong>VGA</strong> 和 <strong>HDMI</strong> 是两个抽象基类，分别定义了具有 <code>play()</code> 方法的接口。这两个接口代表两种不同的视频输出标准。</li>
</ul>
<ol start="2">
<li><strong>具体实现类</strong></li>
</ol>
<ul>
<li><strong>TV01</strong> 继承自 <strong>VGA</strong>，表示一个支持VGA接口的投影仪，其 <code>play()</code> 方法实现了通过VGA接口播放视频的功能。</li>
<li><strong>TV02</strong> 继承自 <strong>HDMI</strong>，表示一个支持HDMI接口的投影仪，其 <code>play()</code> 方法实现了通过HDMI接口播放视频的功能。</li>
</ul>
<ol start="3">
<li><strong>电脑类</strong></li>
</ol>
<ul>
<li><strong>Computer</strong> 类有一个方法 <code>playVideo(VGA* pVGA)</code>，这个方法接受一个 <strong>VGA</strong> 接口的指针作为参数，并调用该指针的 <code>play()</code> 方法。这表示电脑只能通过VGA接口播放视频。</li>
</ul>
<ol start="4">
<li><strong>适配器类</strong></li>
</ol>
<ul>
<li><strong>VGAToHDMTAdapter</strong> 类继承自 <strong>VGA</strong>，但它内部持有一个 <strong>HDMI</strong> 接口的指针。这个适配器类实现了 <strong>VGA</strong> 接口的 <code>play()</code> 方法，但在这个方法内部，它调用的是内部 <strong>HDMI</strong> 接口指针的 <code>play()</code> 方法。这样，<strong>VGAToHDMTAdapter</strong> 就起到了将HDMI接口转换为VGA接口的作用。</li>
</ul>
<h3 id="11-观察者模式"><a href="#11-观察者模式" class="headerlink" title="11.观察者模式"></a>11.观察者模式</h3><p>也称为<strong>监听者模式</strong>或<strong>发布-订阅模式</strong></p>
<p>它属于<strong>行为型模式</strong>，而行为型主要关注的是<strong>对象之间的通信</strong></p>
<p><strong>观察者模式</strong>主要关注的是对象的一对多的关系，也就是多个对象都依赖一个对象，当该对象的状态发生改变时，其他对象都能接收到相应的通知</p>
<p>观察者模式（Observer Pattern）是一种行为设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ol>
<li><strong>松耦合</strong>：观察者和被观察者之间通过抽象接口进行交互，降低了它们之间的耦合度。</li>
<li><strong>灵活性</strong>：观察者可以在任何时候增加或删除，而不会影响被观察者的行为。</li>
<li><strong>扩展性强</strong>：可以在不修改被观察者代码的情况下增加新的观察者。</li>
</ol>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><strong>性能开销</strong>：如果被观察者状态频繁变化，并且有很多观察者，那么通知所有观察者可能会带来较大的性能开销。</li>
<li><strong>内存泄漏风险</strong>：如果没有正确管理观察者的生命周期，可能会导致内存泄漏。</li>
<li><strong>循环依赖</strong>：观察者之间可能相互依赖，导致复杂的依赖关系网。</li>
</ol>
<p><code>例如：</code></p>
<p>一组数据（数据对象），通过这一组数据生成 曲线图（对象1）&#x2F; 柱状图（对象2）&#x2F; 圆饼图（对象3）</p>
<p>当数据对象改变时，对象1,2,3应该及时收到相应的通知</p>
<p><strong>Subject主题有更改的时候，应该及时通知相应的观察者，去处理相应的事件</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//观察者抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> msgid)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个观察者实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer1</span> :<span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> msgid)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (msgid)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Observer1 recv 1 msg&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Observer1 recv 2 msg&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Observer1 recv unkown msg&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个观察者实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer2</span> :<span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> msgid)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (msgid)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Observer2 recv 2 msg&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Observer2 recv unkown msg&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三个观察者实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer3</span> :<span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> msgid)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (msgid)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Observer3 recv 1 msg&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Observer3 recv 3 msg&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Observer3 recv unkown msg&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主题类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//给主题增加观察者对象</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">adObserver</span><span class="params">(Observer* obser, <span class="type">int</span> msgid)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_subMap[msgid].<span class="built_in">push_back</span>(obser);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//主题检测发生改变，通知相应的观察者对象处理事件</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dispatch</span><span class="params">(<span class="type">int</span> msgid)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> it = _subMap.<span class="built_in">find</span>(msgid);</span><br><span class="line">		<span class="comment">//没找着说明没人对这件事情感兴趣</span></span><br><span class="line">		<span class="keyword">if</span> (it != _subMap.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (Observer* pObser : it-&gt;second)</span><br><span class="line">			&#123;</span><br><span class="line">				pObser-&gt;<span class="built_in">handle</span>(msgid);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	unordered_map&lt;<span class="type">int</span>, list&lt;Observer*&gt;&gt; _subMap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Subject subject;</span><br><span class="line">	Observer* p1 = <span class="keyword">new</span> <span class="built_in">Observer1</span>();</span><br><span class="line">	Observer* p2 = <span class="keyword">new</span> <span class="built_in">Observer2</span>();</span><br><span class="line">	Observer* p3 = <span class="keyword">new</span> <span class="built_in">Observer3</span>();</span><br><span class="line"></span><br><span class="line">	subject.<span class="built_in">adObserver</span>(p1, <span class="number">1</span>);</span><br><span class="line">	subject.<span class="built_in">adObserver</span>(p1, <span class="number">2</span>);</span><br><span class="line">	subject.<span class="built_in">adObserver</span>(p2, <span class="number">2</span>);</span><br><span class="line">	subject.<span class="built_in">adObserver</span>(p3, <span class="number">1</span>);</span><br><span class="line">	subject.<span class="built_in">adObserver</span>(p3, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> msgid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入消息id:&quot;</span> ;</span><br><span class="line">		cin &gt;&gt; msgid;</span><br><span class="line">		<span class="keyword">if</span> (msgid == <span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		subject.<span class="built_in">dispatch</span>(msgid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当主题改变的时候，对消息关注的对象会收到通知</p>
]]></content>
      <categories>
        <category>从零开始的C++の学习之路</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>侯捷 C++11 新特性 学习笔记</title>
    <url>/2024/10/10/C++/%E4%BE%AF%E6%8D%B7%20%20C++11%20%E6%96%B0%E7%89%B9%E6%80%A7%20%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="C-11-新特性-学习笔记"><a href="#C-11-新特性-学习笔记" class="headerlink" title="C++11 新特性 学习笔记"></a>C++11 新特性 学习笔记</h1><h2 id="1-Variadic-Templates"><a href="#1-Variadic-Templates" class="headerlink" title="1.Variadic Templates"></a>1.Variadic Templates</h2><h4 id="C-11支持函数模板的默认模板参数"><a href="#C-11支持函数模板的默认模板参数" class="headerlink" title="C++11支持函数模板的默认模板参数"></a>C++11支持函数模板的默认模板参数</h4><p>在 C++98&#x2F;03 标准中，类模板可以有默认的模板参数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="type">int</span>, U N = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> Foo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是却不支持函数的默认模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt;  <span class="comment">// error in C++98/03: default template arguments</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">func</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在这一限制在 C++11 中被解除了。上面的 func 函数在 C++11 中可以直接使用，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();   <span class="comment">//T = int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时模板参数 T 的类型就为默认值 int。从上面的例子中可以看出，当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随<code>&lt;&gt;</code>来实例化。</p>
<p>除了上面提到的部分之外，函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在参数表最后的限制。甚至于，根据实际场景中函数模板被调用的情形，编译器还可以自行推导出部分模板参数的类型。</p>
<p>这意味着，当默认模板参数和编译器自行推导出模板参数类型的能力一起结合使用时，代码的书写将变得异常灵活。我们可以指定函数中的一部分模板参数采用默认参数，而另一部分使用自动推导，比如下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R = <span class="type">int</span>, <span class="keyword">typename</span> U&gt;</span><br><span class="line">R <span class="built_in">func</span>(U val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">97</span>);               <span class="comment">// R=int, U=int</span></span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">char</span>&gt;(<span class="number">97</span>);         <span class="comment">// R=char, U=int</span></span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">double</span>, <span class="type">int</span>&gt;(<span class="number">97</span>);  <span class="comment">// R=double, U=int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++11 标准中，我们可以像 func(97) 这样调用模板函数，因为编译器可以根据实参 97 自行推导出模板参数 U 的类型为 int，并且根据返回值 val&#x3D;97 推导出 R 的类型也为 int；而 func(97) 手动指定了模板参数 R 的类型为 char（默认模板参数将无效），并通过实参 97 推导出了 U &#x3D; int；最后 func&lt;double,int&gt;(97) 手动指定的 R 和 U 的类型值，因此无需编译器自行推导。</p>
<p>再次强调，当默认模板参数和自行推导的模板参数同时使用时，若无法推导出函数模板参数的类型，<strong>编译器会选择使用默认模板参数</strong>；如果模板参数即无法推导出来，又未设置其默认值，则编译器直接报错。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="type">double</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">func</span>(T val1 = <span class="number">0</span>, U val2 = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="string">&#x27;c&#x27;</span>); <span class="comment">//T=char, U=double</span></span><br><span class="line">    <span class="built_in">func</span>();    <span class="comment">//编译报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，func(‘c’) 的这种调用方式，编译器通过实参 ‘c’ 可以推导出 T&#x3D;char，但由于未传递第 2 个实参，因此模板参数 U 使用的是默认参数 double；但 func() 的调用方式是不行的，虽然 val1 设置有默认值，但编译器无法通过该默认值推导出模板参数 T 的类型。由此不难看出，编译器的自动推导能力并没有想象的那么强大。</p>
<p>总的来说，C++11 支持为函数模板中的参数设置默认值，在实际使用过程中，我们可以选择使用默认值，也可以尝试由编译器自行推导得到，还可以亲自指定各个模板参数的类型。</p>
<h4 id="C-11在函数模板和类模板中使用可变参数"><a href="#C-11在函数模板和类模板中使用可变参数" class="headerlink" title="C++11在函数模板和类模板中使用可变参数"></a>C++11在函数模板和类模板中使用可变参数</h4><p>所谓可变参数，指的是参数的个数和类型都可以是任意的。提到参数，大家会第一时间想到函数参数，除此之外 C++ 的模板（包括函数模板和类模板）也会用到参数。</p>
<p>对于函数参数而言，C++ 一直都支持为函数设置可变参数，最典型的代表就是 printf() 函数，它的语法格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int printf ( const char * format, ... );</span><br></pre></td></tr></table></figure>

<p><code>...</code>就表示的是可变参数，即 printf() 函数可以接收任意个参数，且各个参数的类型可以不同，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;%d&quot;, 10);printf(&quot;%d %c&quot;,10, &#x27;A&#x27;);printf(&quot;%d %c %f&quot;,10, &#x27;A&#x27;, 1.23);</span><br></pre></td></tr></table></figure>

<p>我们通常将容纳多个参数的可变参数称为<strong>参数包</strong>。借助 format 字符串，printf() 函数可以轻松判断出参数包中的参数个数和类型。</p>
<p>下面的程序中，自定义了一个简单的可变参数函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span><span class="comment">//可变参数的函数</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vair_fun</span><span class="params">(<span class="type">int</span> count, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    va_list args;    </span><br><span class="line">    <span class="built_in">va_start</span>(args, count);    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)    </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="type">int</span> arg = <span class="built_in">va_arg</span>(args, <span class="type">int</span>);        </span><br><span class="line">        std::cout &lt;&lt; arg &lt;&lt; <span class="string">&quot; &quot;</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">va_end</span>(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="comment">//可变参数有 4 个，分别为 10、20、30、40    </span></span><br><span class="line">    <span class="built_in">vair_fun</span>(<span class="number">4</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>,<span class="number">40</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序中的 vair_fun() 函数有 2 个参数，一个是 count，另一个就是 … 可变参数。我们可以很容易在函数内部使用 count 参数，但要想使用参数包中的参数，需要借助<code>&lt;cstdarg&gt;</code>头文件中的 va_start、va_arg 以及 va_end 这 3 个带参数的宏：</p>
<ul>
<li>va_start(args, count)：args 是 va_list 类型的变量，我们可以简单的将其视为 char * 类型。借助 count 参数，找到可变参数的起始位置并赋值给 args；</li>
<li>va_arg(args, int)：调用 va_start 找到可变参数起始位置的前提下，通过指明参数类型为 int，va_arg 就可以将可变参数中的第一个参数返回；</li>
<li>va_end(args)：不再使用 args 变量后，应及时调用 va_end 宏清理 args 变量。</li>
</ul>
<blockquote>
<p>注意，借助 va_arg 获取参数包中的参数时，va_arg 不具备自行终止的能力，所以程序中借助 count 参数控制 va_arg 的执行次数，继而将所有的参数读取出来。控制 va_arg 执行次数还有其他方法，比如读取到指定数据时终止。</p>
</blockquote>
<p>使用 … 可变参数的过程中，需注意以下几点：</p>
<ol>
<li>… 可变参数必须作为函数的最后一个参数，且一个函数最多只能拥有 1 个可变参数。</li>
<li>可变参数的前面至少要有 1 个有名参数（例如上面例子中的 count 参数）；</li>
<li>当可变参数中包含 char 类型的参数时，va_arg 宏要以 int 类型的方式读取；当可变参数中包含 short 类型的参数时，va_arg 宏要以 double 类型的方式读取。</li>
</ol>
<p>**需要注意的是，… 可变参数的方法仅适用于函数参数，并不适用于模板参数。**C++11 标准中，提供了一种实现可变模板参数的方法。</p>
<h3 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h3><p>C++ 11 标准发布之前，函数模板和类模板只能设定固定数量的模板参数。C++11 标准对模板的功能进行了扩展，允许模板中包含任意数量的模板参数，这样的模板又称可变参数模板。</p>
<h5 id="1-可变参数函数模板"><a href="#1-可变参数函数模板" class="headerlink" title="1) 可变参数函数模板"></a>1) 可变参数函数模板</h5><p>先讲解函数模板，如下定义了一个可变参数的函数模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vair_fun</span><span class="params">(T...args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板参数中， typename（或者 class）后跟 … 就表明 T 是一个可变模板参数，它可以接收多种数据类型，又称模板参数包。vair_fun() 函数中，args 参数的类型用 T… 表示，表示 args 参数可以接收任意个参数，又称函数参数包。</p>
<p>这也就意味着，此函数模板最终实例化出的 vair_fun() 函数可以指定任意类型、任意数量的参数。例如，我们可以这样使用这个函数模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vair_fun</span>();</span><br><span class="line"><span class="built_in">vair_fun</span>(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="built_in">vair_fun</span>(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>, <span class="number">1.23</span>);</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>使用可变参数模板的难点在于，如何在模板函数内部“解开”参数包（使用包内的数据），这里给大家介绍两种简单的方法。</p>
<p>【递归方式解包】<br>先看一个实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//模板函数递归的出口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vir_fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vir_fun</span><span class="params">(T argc, args... argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; argc &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//开始递归，将第一个参数外的 argv 参数包重新传递给 vir_fun</span></span><br><span class="line">    <span class="built_in">vir_fun</span>(argv...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vir_fun</span>(<span class="number">1</span>, <span class="string">&quot;http://www.biancheng.net&quot;</span>, <span class="number">2.34</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果为：</p>
<p>1<br><a href="http://www.biancheng.net/">http://www.biancheng.net</a><br>2.34</p>
<p>分析一个程序的执行流程：</p>
<ul>
<li>首先，main() 函数调用 vir_fun() 模板函数时，根据所传实参的值，可以很轻易地判断出模板参数 T 的类型为 int，函数参数 argc 的值为 1，剩余的模板参数和函数参数都分别位于 args 和 argv 中；</li>
<li>vir_fun() 函数中，首先输出了 argc 的值（为 1），然后重复调用自身，同时将函数参数包 argv 中的数据作为实参传递给形参 argc 和 argv；</li>
<li>再次执行 vir_fun() 函数，此时模板参数 T 的类型为 char*，输出 argc 的值为 “http:<a href="http://www.biancheng.net”.再次调用自身,继续将/">www.biancheng.net”。再次调用自身，继续将</a> argv 包中的数据作为实参；</li>
<li>再次执行 vir_fun() 函数，此时模板参数 T 的类型为 double，输出 argc 的值为 2.34。再次调用自身，将空的 argv 包作为实参；</li>
<li>由于 argv 包没有数据，此时会调用无任何形参、函数体为空的 vir_fun() 函数，最终执行结束。</li>
</ul>
<blockquote>
<p>以递归方式解包，一定要设置递归结束的出口。例如本例中，无形参、函数体为空的 vir_fun() 函数就是递归结束的出口。</p>
</blockquote>
<p>【非递归方法解包】<br>借助逗号表达式和初始化列表，也可以解开参数包。</p>
<p>以 vir_fun() 函数为例，下面程序演示了非递归方法解包的过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dispaly</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vir_fun</span><span class="params">(args... argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//逗号表达式+初始化列表</span></span><br><span class="line">    <span class="type">int</span> arr[] = &#123; (<span class="built_in">dispaly</span>(argv),<span class="number">0</span>)... &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vir_fun</span>(<span class="number">1</span>, <span class="string">&quot;http://www.biancheng.net&quot;</span>, <span class="number">2.34</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里重点分析一下第 13 行代码，我们以<code>&#123; &#125;</code>初始化列表的方式对数组 arr 进行了初始化， (display(argv),0)… 会依次展开为 (display(1),0)、(display(“<a href="http://www.biancheng.net”),0/">http://www.biancheng.net”),0</a>) 和 (display(2.34),0)。也就是说，第 13 行代码和如下代码是等价的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; (<span class="built_in">dispaly</span>(<span class="number">1</span>),<span class="number">0</span>), (<span class="built_in">dispaly</span>(<span class="string">&quot;http://www.biancheng.net&quot;</span>),<span class="number">0</span>), (<span class="built_in">dispaly</span>(<span class="number">2.34</span>),<span class="number">0</span>) &#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，每个元素都是一个逗号表达式，以 (display(1), 0) 为例，它会先计算 display(1)，然后将 0 作为整个表达式的值返回给数组，因此 arr 数组最终存储的都是 0。arr 数组纯粹是为了将参数包展开，没有发挥其它作用。</p>
<h5 id="2-可变参数类模板"><a href="#2-可变参数类模板" class="headerlink" title="2) 可变参数类模板"></a>2) 可变参数类模板</h5><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241010102752119.png" alt="image-20241010102752119"></p>
<p>printf递归调用，解包，和上面一样。要注意函数1，算是一个终止条件吧。</p>
<p>Types可以理解为一个包类型，表示参数可以有很多类型</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241010204756484.png" alt="image-20241010204756484"></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241010103142620.png" alt="image-20241010103142620"></p>
<p>答：2比较特化（特别），3比较泛化</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241010103807043.png" alt="image-20241010103807043"></p>
<p>tuple继承，（看右上角）一开始是int，float，string，继承为float，string，一层一层继承下去，下面的例子也是说的这个</p>
<p>C++11 标准中，类模板中的模板参数也可以是一个可变参数。C++ 11 标准提供的 typle 元组类就是一个典型的可变参数模板类，它的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>;</span><br></pre></td></tr></table></figure>

<p>和固定模板参数的类不同，tuple 模板类实例化时，可以接收任意数量、任意类型的模板参数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std:tuple&lt;&gt; tp0;</span><br><span class="line">std::tuple&lt;<span class="type">int</span>&gt; tp1 = std::<span class="built_in">make_tuple</span>(<span class="number">1</span>);</span><br><span class="line">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>&gt; tp2 = std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2.34</span>);</span><br><span class="line">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>, string&gt; tp3 = std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2.34</span>, <span class="string">&quot;http://www.biancheng.net&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如下代码展示了一个支持可变参数的类模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//声明模板类demo</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt; <span class="keyword">class</span> <span class="title class_">demo</span>;</span><br><span class="line"><span class="comment">//继承式递归的出口</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class</span> <span class="title class_">demo</span>&lt;&gt; &#123;&#125;;</span><br><span class="line"><span class="comment">//以继承的方式解包</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&lt;Head, Tail...&gt;</span><br><span class="line">    : <span class="keyword">private</span> demo&lt;Tail...&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(Head v, Tail... vtail) : <span class="built_in">m_head</span>(v), <span class="built_in">demo</span>&lt;Tail...&gt;(vtail...) &#123;</span><br><span class="line">        <span class="built_in">dis_head</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dis_head</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; m_head &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Head m_head;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt; <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">2.34</span>, <span class="string">&quot;http://www.biancheng.net&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序中，demo 模板参数中的 Tail 就是一个参数包，解包的方式是以“递归+继承”的方式实现的。具体来讲，demo&lt;Head, Tail…&gt; 类实例化时，由于其继承自 demo&lt;Tail…&gt; 类，因此父类也会实例化，一直递归至 Tail 参数包为空，此时会调用模板参数列表为空的 demo 模板类。</p>
<p>程序的输出结果为：</p>
<p><a href="http://www.biancheng.net/">http://www.biancheng.net</a><br>2.34<br>1</p>
<h3 id="参数包扩展"><a href="#参数包扩展" class="headerlink" title="参数包扩展"></a>参数包扩展</h3><p>参数包扩展是C++模板编程中的一个重要特性，它允许在模板中接受任意数量和类型的参数。参数包的扩展是在编译时由编译器自动处理的，其过程可以视为将参数包中的每个参数都作为独立的参数进行展开。</p>
<p>具体来说，参数包扩展的语法是在参数名后面加上省略号（<code>...</code>）。这个省略号表示该参数是一个参数包，可以包含零个或多个参数。在函数调用或模板实例化时，编译器会根据上下文自动将参数包中的每个参数展开为独立的参数。</p>
<p>以下是一些关于参数包扩展的详细解释和示例：</p>
<ol>
<li><strong>函数模板中的参数包扩展</strong>：</li>
</ol>
<p>在函数模板中，参数包可以用于定义可变数量的函数参数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Args... args)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// ... 这里可以使用参数包展开来逐个打印参数  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Args...</code> 是一个类型参数包，它表示函数可以接受任意数量和类型的参数。在函数体内，可以使用参数包展开来逐个处理这些参数。</p>
<ol>
<li><strong>参数包展开的方式</strong>：</li>
</ol>
<p>参数包展开有多种方式，包括递归函数、逗号表达式、折叠表达式等。以下是几种常见的展开方式：</p>
<ul>
<li><strong>递归函数</strong>：通过定义一个递归函数来逐个处理参数包中的参数。这种方式需要定义一个递归终止条件，以避免无限递归。</li>
<li><strong>逗号表达式</strong>：利用C++中的逗号表达式（<code>,</code>），它保证从左到右的顺序求值，可以在逗号表达式中逐个展开参数包。</li>
<li><strong>折叠表达式</strong>（C++17引入）：折叠表达式提供了一种简洁的方式来展开参数包，并可以对参数包中的元素进行折叠操作（如求和、求积等）。</li>
</ul>
<ol>
<li><strong>示例</strong>：</li>
</ol>
<p>以下是一个使用折叠表达式来展开参数包并打印每个参数的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Args... args)</span> </span>&#123;  </span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl; <span class="comment">// 使用折叠表达式展开参数包  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;hello&quot;</span>); <span class="comment">// 输出：123hello  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，折叠表达式 <code>(std::cout &lt;&lt; ... &lt;&lt; args)</code> 将参数包 <code>args</code> 中的每个参数都展开为 <code>std::cout &lt;&lt;</code> 操作的一部分，并依次打印出来。</p>
<p>需要注意的是，虽然参数包扩展提供了很大的灵活性，但也需要谨慎使用以避免编译错误或运行时错误。在使用参数包时，应确保传入的参数类型与函数模板或类模板中定义的参数包类型相匹配。</p>
<h2 id="2-Spaces-in-Template-Expressions-nullptr-auto"><a href="#2-Spaces-in-Template-Expressions-nullptr-auto" class="headerlink" title="2.Spaces in Template Expressions &amp;&amp; nullptr &amp;&amp; auto"></a>2.Spaces in Template Expressions &amp;&amp; nullptr &amp;&amp; auto</h2><h3 id="2-1-Spaces-in-Template-Expressions（-的改进）"><a href="#2-1-Spaces-in-Template-Expressions（-的改进）" class="headerlink" title="2.1 Spaces in Template Expressions（&gt;&gt;的改进）"></a>2.1 Spaces in Template Expressions（&gt;&gt;的改进）</h3><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241010104301186.png" alt="image-20241010104301186"></p>
<p>就是容器嵌套的时候不需要加空格了（之前害怕两个&gt;&gt;解析为输入）</p>
<h3 id="2-2-nullptr-and-std-nullptr-t"><a href="#2-2-nullptr-and-std-nullptr-t" class="headerlink" title="2.2 nullptr and std:nullptr_t"></a>2.2 nullptr and std:nullptr_t</h3><ul>
<li><code>nullptr</code>的类型是<code>std::nullptr_t</code>。</li>
</ul>
<h4 id="C-11-nullptr：初始化空指针"><a href="#C-11-nullptr：初始化空指针" class="headerlink" title="C++11 nullptr：初始化空指针"></a>C++11 nullptr：初始化空指针</h4><p>实际开发中，避免产生“野指针”最有效的方法，就是在定义指针的同时完成初始化操作，即便该指针的指向尚未明确，也要将其初始化为空指针。</p>
<blockquote>
<p>所谓“野指针”，又称“悬挂指针”，指的是没有明确指向的指针。野指针往往指向的是那些不可用的内存区域，这就意味着像操作普通指针那样使用野指针（例如 &amp;p），极可能导致程序发生异常。</p>
</blockquote>
<p>C++98&#x2F;03 标准中，将一个指针初始化为空指针的方式有 2 种：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>; <span class="comment">//推荐使用</span></span><br></pre></td></tr></table></figure>

<p>可以看到，我们可以将指针明确指向 0（0x0000 0000）这个内存空间。一方面，明确指针的指向可以避免其成为野指针；另一方面，大多数操作系统都不允许用户对地址为 0 的内存空间执行写操作，若用户在程序中尝试修改其内容，则程序运行会直接报错。</p>
<p>相比第一种方式，我们更习惯将指针初始化为 NULL。值得一提的是，NULL 并不是 C++ 的关键字，它是 C++ 为我们事先定义好的一个宏，并且它的值往往就是字面量 0（#define NULL 0）。</p>
<p>C++ 中将 NULL 定义为字面常量 0，虽然能满足大部分场景的需要，但个别情况下，它会导致程序的运行和我们的预期不符。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isnull</span><span class="params">(<span class="type">void</span> *c)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void*c&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isnull</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">isnull</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">isnull</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>int n<br>int n</p>
<p>对于 isnull(0) 来说，显然它真正调用的是参数为整形的 isnull() 函数；而对于 isnull(NULL)，我们期望它实际调用的是参数为 void*c 的 isnull() 函数，但观察程序的执行结果不难看出，并不符合我们的预期。</p>
<p>C++ 98&#x2F;03 标准中，如果我们想令 isnull(NULL) 实际调用的是 isnull(void* c)，就需要对 NULL（或者 0）进行强制类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isnull</span>( (<span class="type">void</span>*)<span class="literal">NULL</span> );</span><br><span class="line"><span class="built_in">isnull</span>( (<span class="type">void</span>*)<span class="number">0</span> );</span><br></pre></td></tr></table></figure>

<p>如此，才会成功调用我们预期的函数（读者可自行执行此代码，观察输出结果）。</p>
<p>由于 C++ 98 标准使用期间，NULL 已经得到了广泛的应用，出于兼容性的考虑，C++11 标准并没有对 NULL 的宏定义做任何修改。为了修正 C++ 存在的这一 BUG，C++ 标准委员会最终决定另其炉灶，在 C++11 标准中引入一个新关键字，即 nullptr。</p>
<blockquote>
<p>在使用 nullptr 之前，读者需保证自己使用的编译器支持该关键字。以 Visual Studio 和 codeblocks 为例，前者早在 2010 版本就对 C++ 11 标准中的部分特性提供了支持，其中就包括 nullptr；如果使用后者，读者需将其 G++ 编译器版本至少升级至 4.6.1（同时开启 -std&#x3D;c++0x 编译选项）。</p>
</blockquote>
<p>nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。</p>
<p>值得一提的是，nullptr 可以被隐式转换成任意的指针类型。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * a1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">char</span> * a2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">double</span> * a3 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>显然，不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int*、char* 以及 double* 指针类型。</p>
<p>另外，通过将指针初始化为 nullptr，可以很好地解决 NULL 遗留的问题，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isnull</span><span class="params">(<span class="type">void</span> *c)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void*c&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isnull</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">isnull</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">isnull</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>int n<br>void*c</p>
<p>借助执行结果不难看出，由于 nullptr 无法隐式转换为整形，而可以隐式匹配指针类型，因此执行结果和我们的预期相符。</p>
<blockquote>
<p>总之在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮。</p>
</blockquote>
<h3 id="2-3-auto"><a href="#2-3-auto" class="headerlink" title="2.3 auto"></a>2.3 auto</h3><h4 id="C-auto类型推导完全攻略"><a href="#C-auto类型推导完全攻略" class="headerlink" title="C++ auto类型推导完全攻略"></a>C++ auto类型推导完全攻略</h4><p>在 <a href="http://c.biancheng.net/cplus/">C++</a>11 之前的版本（C++98 和 C++ 03）中，定义变量或者声明变量之前都必须指明它的类型，比如 int、char 等；但是在一些比较灵活的语言中，比如 <a href="http://c.biancheng.net/csharp/">C#</a>、<a href="http://c.biancheng.net/js/">JavaScript</a>、<a href="http://c.biancheng.net/php/">PHP</a>、<a href="http://c.biancheng.net/python/">Python</a> 等，程序员在定义变量时可以不指明具体的类型，而是让编译器（或者解释器）自己去推导，这就让代码的编写更加方便。</p>
<p>C++11 为了顺应这种趋势也开始支持自动类型推导了！C++11 使用 <strong>auto</strong> 关键字来支持自动类型推导。</p>
<h4 id="auto-类型推导的语法和规则"><a href="#auto-类型推导的语法和规则" class="headerlink" title="auto 类型推导的语法和规则"></a>auto 类型推导的语法和规则</h4><p>在之前的 C++ 版本中，auto 关键字用来指明变量的存储类型，它和 static 关键字是相对的。auto 表示变量是自动存储的，这也是编译器的默认规则，所以写不写都一样，一般我们也不写，这使得 auto 关键字的存在变得非常鸡肋。</p>
<p>C++11 赋予 auto 关键字新的含义，使用它来做自动类型推导。也就是说，使用了 auto 关键字以后，编译器会在编译期间自动推导出变量的类型，这样我们就不用手动指明变量的数据类型了。</p>
<p>auto 关键字基本的使用语法如下：</p>
<p>auto name &#x3D; value;</p>
<p>name 是变量的名字，value 是变量的初始值。</p>
<p>注意：auto 仅仅是一个占位符，在编译器期间它会被真正的类型所替代。或者说，C++ 中的变量必须是有明确类型的，只是这个类型是由编译器自己推导出来的。</p>
<p>auto 类型推导的简单例子：</p>
<p>auto n &#x3D; 10;<br>auto f &#x3D; 12.8;<br>auto p &#x3D; &n;<br>auto url &#x3D; “<a href="http://c.biancheng.net/cplus/%E2%80%9D">http://c.biancheng.net/cplus/”</a>;</p>
<p>下面我们来解释一下：</p>
<ul>
<li>第 1 行中，10 是一个整数，默认是 int 类型，所以推导出变量 n 的类型是 int。</li>
<li>第 2 行中，12.8 是一个小数，默认是 double 类型，所以推导出变量 f 的类型是 double。</li>
<li>第 3 行中，&amp;n 的结果是一个 int* 类型的指针，所以推导出变量 p 的类型是 int*。</li>
<li>第 4 行中，由双引号<code>&quot;&quot;</code>包围起来的字符串是 const char* 类型，所以推导出变量 url 的类型是 const char*，也即一个常量指针。</li>
</ul>
<p>我们也可以连续定义多个变量：</p>
<p>int n &#x3D; 20;<br>auto *p &#x3D; &amp;n, m &#x3D; 99;</p>
<p>先看前面的第一个子表达式，&amp;n 的类型是 int*，编译器会根据 auto *p 推导出 auto 为 int。后面的 m 变量自然也为 int 类型，所以把 99 赋值给它也是正确的。</p>
<p>这里我们要注意，推导的时候不能有二义性。在本例中，编译器根据第一个子表达式已经推导出 auto 为 int 类型，那么后面的 m 也只能是 int 类型，如果写作<code>m=12.5</code>就是错误的，因为 12.5 是double 类型，这和 int 是冲突的。</p>
<p>还有一个值得注意的地方是：使用 auto 类型推导的变量必须马上初始化，这个很容易理解，因为 auto 在 C++11 中只是“占位符”，并非如 int 一样的真正的类型声明。</p>
<h4 id="auto-的高级用法"><a href="#auto-的高级用法" class="headerlink" title="auto 的高级用法"></a>auto 的高级用法</h4><p>auto 除了可以独立使用，还可以和某些具体类型混合使用，这样 auto 表示的就是“半个”类型，而不是完整的类型。请看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> *p1 = &amp;x;   <span class="comment">//p1 为 int *，auto 推导为 int</span></span><br><span class="line"><span class="keyword">auto</span>  p2 = &amp;x;   <span class="comment">//p2 为 int*，auto 推导为 int*</span></span><br><span class="line"><span class="keyword">auto</span> &amp;r1  = x;   <span class="comment">//r1 为 int&amp;，auto 推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> r2 = r1;    <span class="comment">//r2 为  int，auto 推导为 int</span></span><br></pre></td></tr></table></figure>

<p>下面我们来解释一下：</p>
<ul>
<li>第 2 行代码中，p1 为 int* 类型，也即 auto * 为 int *，所以 auto 被推导成了 int 类型。</li>
<li>第 3 行代码中，auto 被推导为 int* 类型，前边的例子也已经演示过了。</li>
<li>第 4 行代码中，r1 为 int &amp; 类型，auto 被推导为 int 类型。</li>
<li>第 5 行代码是需要重点说明的，r1 本来是 int&amp; 类型，但是 auto 却被推导为 int 类型，这表明当<code>=</code>右边的表达式是一个引用类型时，auto 会把引用抛弃，直接推导出它的原始类型。</li>
</ul>
<p>接下来，我们再来看一下 auto 和 const 的结合：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  x = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span>  <span class="keyword">auto</span> n = x;  <span class="comment">//n 为 const int ，auto 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> f = n;      <span class="comment">//f 为 const int，auto 被推导为 int（const 属性被抛弃）</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;r1 = x;  <span class="comment">//r1 为 const int&amp; 类型，auto 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;r2 = r1;  <span class="comment">//r1 为 const int&amp; 类型，auto 被推导为 const int 类型`在这里插入代码片`</span></span><br></pre></td></tr></table></figure>

<p>下面我们来解释一下：</p>
<ul>
<li>第 2 行代码中，n 为 const int，auto 被推导为 int。</li>
<li>第 3 行代码中，n 为 const int 类型，但是 auto 却被推导为 int 类型，这说明当<code>=</code>右边的表达式带有 const 属性时， auto 不会使用 const 属性，而是直接推导出 non-const 类型。</li>
<li>第 4 行代码中，auto 被推导为 int 类型，这个很容易理解，不再赘述。</li>
<li>第 5 行代码中，r1 是 const int &amp; 类型，auto 也被推导为 const int 类型，这说明当 const 和引用结合时，auto 的推导将保留表达式的 const 类型。</li>
</ul>
<p>最后我们来简单总结一下 auto 与 const 结合的用法：</p>
<ul>
<li>当类型不为引用时，auto 的推导结果将不保留表达式的 const 属性；</li>
<li>当类型为引用时，auto 的推导结果将保留表达式的 const 属性。</li>
</ul>
<h4 id="auto-的限制"><a href="#auto-的限制" class="headerlink" title="auto 的限制"></a>auto 的限制</h4><p>前面介绍推导规则的时候我们说过，使用 auto 的时候必须对变量进行初始化，这是 auto 的限制之一。那么，除此以外，auto 还有哪些其它的限制呢？</p>
<ol>
<li>auto 不能在函数的参数中使用。</li>
</ol>
<p>这个应该很容易理解，我们在定义函数的时候只是对参数进行了声明，指明了参数的类型，但并没有给它赋值，只有在实际调用函数的时候才会给参数赋值；而 auto 要求必须对变量进行初始化，所以这是矛盾的。</p>
<ol>
<li>auto 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中。</li>
<li>auto 关键字不能定义数组，比如下面的例子就是错误的：</li>
</ol>
<p>char url[] &#x3D; “<a href="http://c.biancheng.net/%E2%80%9D">http://c.biancheng.net/”</a>;<br>auto str[] &#x3D; url; &#x2F;&#x2F;arr 为数组，所以不能使用 auto</p>
<ol>
<li>auto 不能作用于模板参数，请看下面的例子：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A&lt;<span class="type">int</span>&gt; C1;</span><br><span class="line">    A&lt;<span class="keyword">auto</span>&gt; C2 = C1;  <span class="comment">//错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="auto-的应用（重点）"><a href="#auto-的应用（重点）" class="headerlink" title="auto 的应用（重点）"></a>auto 的应用（重点）</h4><p>说了那么多 auto 的推导规则和一些注意事项，那么 auto 在实际开发中到底有什么应用呢？下面我们列举两个典型的应用场景。</p>
<h5 id="使用-auto-定义迭代器"><a href="#使用-auto-定义迭代器" class="headerlink" title="使用 auto 定义迭代器"></a>使用 auto 定义迭代器</h5><p>auto 的一个典型应用场景是用来定义 stl 的迭代器。</p>
<p>我们在使用 stl 容器的时候，需要使用迭代器来遍历容器里面的元素；不同容器的迭代器有不同的类型，在定义迭代器时必须指明。而迭代器的类型有时候比较复杂，书写起来很麻烦，请看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; v;</span><br><span class="line">    vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;::iterator i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出来，定义迭代器 i 的时候，类型书写比较冗长，容易出错。然而有了 auto 类型推导，我们大可不必这样，只写一个 auto 即可。</p>
<p>修改上面的代码，使之变得更加简洁：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; v;</span><br><span class="line">    <span class="keyword">auto</span> i = v.<span class="built_in">begin</span>();  <span class="comment">//使用 auto 代替具体的类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>auto 可以根据表达式 v.begin() 的类型（begin() 函数的返回值类型）来推导出变量 i 的类型。</p>
<h5 id="auto-用于泛型编程"><a href="#auto-用于泛型编程" class="headerlink" title="auto 用于泛型编程"></a>auto 用于<a href="https://so.csdn.net/so/search?q=%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B&spm=1001.2101.3001.7020">泛型编程</a></h5><p>auto 的另一个应用就是当我们不知道变量是什么类型，或者不希望指明具体类型的时候，比如泛型编程中。我们接着看例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">get</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://c.biancheng.net/cplus/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> val = T::<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>&lt;A&gt;();</span><br><span class="line">    <span class="built_in">func</span>&lt;B&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>100<br><a href="http://c.biancheng.net/cplus/">http://c.biancheng.net/cplus/</a></p>
<p>本例中的模板函数 func() 会调用所有类的静态函数 get()，并对它的返回值做统一处理，但是 get() 的返回值类型并不一样，而且不能自动转换。这种要求在以前的 C++ 版本中实现起来非常的麻烦，需要额外增加一个模板参数，并在调用时手动给该模板参数赋值，用以指明变量 val 的类型。</p>
<p>但是有了 auto 类型自动推导，编译器就根据 get() 的返回值自己推导出 val 变量的类型，就不用再增加一个模板参数了。</p>
<p>下面的代码演示了不使用 auto 的解决办法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">get</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://c.biancheng.net/cplus/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;  <span class="comment">//额外增加一个模板参数 T2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    T2 val = T1::<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用时也要手动给模板参数赋值</span></span><br><span class="line">    <span class="built_in">func</span>&lt;A, <span class="type">int</span>&gt;();</span><br><span class="line">    <span class="built_in">func</span>&lt;B, <span class="type">const</span> <span class="type">char</span>*&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Unifrom-Lnitialization（统一初始化）"><a href="#3-Unifrom-Lnitialization（统一初始化）" class="headerlink" title="3.Unifrom Lnitialization（统一初始化）"></a>3.Unifrom Lnitialization（统一初始化）</h2><h3 id="C-11列表初始化（统一了初始化方式）"><a href="#C-11列表初始化（统一了初始化方式）" class="headerlink" title="C++11列表初始化（统一了初始化方式）"></a>C++11列表初始化（统一了初始化方式）</h3><p>我们知道，在 <a href="http://c.biancheng.net/cplus/">C++</a>98&#x2F;03 中的对象初始化方法有很多种，请看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化列表</span></span><br><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br><span class="line"><span class="comment">//拷贝初始化（copy-initialization）</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125;</span><br><span class="line">&#125; foo = <span class="number">123</span>;  <span class="comment">//需要拷贝构造函数</span></span><br><span class="line"><span class="comment">//直接初始化（direct-initialization）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">j</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Foo <span class="title">bar</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这些不同的初始化方法，都有各自的适用范围和作用。最关键的是，这些种类繁多的初始化方法，没有一种可以通用所有情况。</p>
<p>为了统一初始化方式，并且让初始化行为具有确定的效果，C++11 中提出了列表初始化（List-initialization）的概念。</p>
<p>POD 类型即 plain old data 类型，简单来说，是可以直接使用 memcpy 复制的对象。</p>
<h3 id="统一的初始化"><a href="#统一的初始化" class="headerlink" title="统一的初始化"></a>统一的初始化</h3><p>在上面我们已经看到了，对于普通数组和 POD 类型，C++98&#x2F;03 可以使用初始化列表（initializer list）进行初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">long</span> l_arr[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>但是这种初始化方式的适用性非常狭窄，只有上面提到的这两种数据类型可以使用初始化列表。</p>
<p>在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，请看下面的代码。</p>
<p>【实例】通过初始化列表初始化对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">a1</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line">    Foo a2 = <span class="number">123</span>;  <span class="comment">//error: &#x27;Foo::Foo(const Foo &amp;)&#x27; is private</span></span><br><span class="line">    Foo a3 = &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    Foo a4 &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    <span class="type">int</span> a5 = &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="type">int</span> a6 &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。</p>
<p>a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。</p>
<p><code>都是用大括号进行初始化的</code>，编译器看到{}就做出一个initializer_list&lt;T&gt;，它关联一个array&lt;T,n&gt;.</p>
<p><strong>每个容器都有一个构造函数接受一个initializer_list</strong>（大括号的形式）</p>
<p>这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。</p>
<p>a4 和 a6 的写法，是 C++98&#x2F;03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。</p>
<p>这种变量名后面跟上初始化列表方法同样适用于普通数组和 POD 类型的初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br></pre></td></tr></table></figure>

<p>在初始化时，<code>&#123;&#125;</code>前面的等于号是否书写对初始化行为没有影响。</p>
<p>另外，如同读者所想的那样，new 操作符等可以用圆括号进行初始化的地方，也可以使用初始化列表：</p>
<p>int* a &#x3D; new int { 123 };<br>double b &#x3D; double { 12.12 };<br>int* arr &#x3D; new int[3] { 1, 2, 3 };</p>
<p>指针 a 指向了一个 new 操作符返回的内存，通过初始化列表方式在内存初始化时指定了值为 123。</p>
<p>b 则是对匿名对象使用列表初始化后，再进行拷贝初始化。</p>
<p>这里让人眼前一亮的是 arr 的初始化方式。堆上动态分配的数组终于也可以使用初始化列表进行初始化了。</p>
<p>除了上面所述的内容之外，列表初始化还可以直接使用在<code>函数的返回值</code>上：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>, <span class="type">double</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Foo <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">123</span>, <span class="number">321.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 return 语句就如同返回了一个 Foo(123, 321.0)。</p>
<p>由上面的这些例子可以看到，在 C++11 中使用初始化列表是非常便利的。它不仅统一了各种对象的初始化方式，而且还使代码的书写更加简单清晰。</p>
<h2 id="4-Initializer-list"><a href="#4-Initializer-list" class="headerlink" title="4.Initializer_list"></a>4.Initializer_list</h2><p><code>所有的都可以用大括号进行初始化</code>，编译器看到{}就做出一个initializer_list&lt;T&gt;，它关联一个array&lt;T,n&gt;，背后由array支撑</p>
<p><strong>每个容器都有一个构造函数接受一个initializer_list</strong>（大括号的形式）</p>
<p>拷贝一个initializer_list是一个<strong>浅拷贝</strong>，也就是array原来的指针和新复制的指针指向同一块内存，这个行为是危险的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;<span class="built_in">max</span>(&#123;<span class="number">54</span>,<span class="number">16</span>,<span class="number">5</span>&#125;)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="built_in">min</span>(&#123;<span class="number">54</span>,<span class="number">16</span>,<span class="number">5</span>&#125;)&lt;&lt;endl;</span><br><span class="line"><span class="comment">//这两种也是正确的</span></span><br></pre></td></tr></table></figure>

<p>C++11提供的新类型，定义在<initializer_list>头文件中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">initializer_list</span>;</span><br></pre></td></tr></table></figure>

<p>先说它的用处吧，然后再详细介绍一下。</p>
<p>首先有了initializer_list之后，对于STL的container的初始化就方便多了,比如以前初始化一个vector需要这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(a, a+<span class="keyword">sizeof</span>(a))</span></span>;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec;</span><br><span class="line">vec.push_back(1);</span><br><span class="line">vec.push_back(3);</span><br><span class="line">vec.push_back(3);</span><br><span class="line">vec.push_back(2);</span><br></pre></td></tr></table></figure>

<p>有了initializer_list后，就可以直接像初始化数组一样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::map&lt;string, string&gt; <span class="type">const</span> nameToBirthday = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;18841011&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;18850123&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;18870908&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;zhaoliu&quot;</span>, <span class="string">&quot;18810316&quot;</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然啦，里面的std::map必须提供参数为initializer_list的构造函数如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>( std::initializer_list&lt;value_type&gt; init,</span><br><span class="line">     <span class="type">const</span> Compare&amp; comp = <span class="built_in">Compare</span>(),</span><br><span class="line">     <span class="type">const</span> Allocator&amp; alloc = <span class="built_in">Allocator</span>() );</span><br></pre></td></tr></table></figure>

<p>其实for（initializer： list）中如果list是个形如：{a, b, c…}，那么其实list自动被构造成了initializer_list对象。</p>
<p>下面稍微介绍一下initializer_list</p>
<p>一个initializer_list当出现在以下两种情况的被自动构造：</p>
<ol>
<li>当初始化的时候使用的是大括号初始化，被自动构造。包括函数调用时和赋值</li>
<li>当涉及到for（initializer： list）,list被自动构造成initializer_list对象</li>
</ol>
<p>也就是说initializer_list对象只能用大括号{}初始化。</p>
<p><strong>拷贝一个initializer_list对象并不会拷贝里面的元素。其实只是引用而已。而且里面的元素全部都是const的。</strong></p>
<p>下面一个例子可以帮助我们更好的理解如何使用initializer_list:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    vector&lt;T&gt; v;</span><br><span class="line">    <span class="built_in">S</span>(initializer_list&lt;T&gt; l) : <span class="built_in">v</span>(l)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;constructed with a &quot;</span> &lt;&lt; l.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;-elements lists&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(std::initializer_list&lt;T&gt; l)</span> </span>&#123;</span><br><span class="line">        v.<span class="built_in">insert</span>(v.<span class="built_in">end</span>(), l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;<span class="type">const</span> T*, <span class="type">size_t</span>&gt; <span class="title">c_arr</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&amp;v[<span class="number">0</span>], v.<span class="built_in">size</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">templated_fn</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : arg)</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">//automatically construct a initializer_list </span></span><br><span class="line">                                <span class="comment">// object and copy it</span></span><br><span class="line">    s.<span class="built_in">append</span>(&#123;<span class="number">6</span>, <span class="number">7</span> , <span class="number">8</span>&#125;);         <span class="comment">//list-initialization in function call</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The vector size is now &quot;</span> &lt;&lt; s.<span class="built_in">c_arr</span>().second &lt;&lt; <span class="string">&quot; ints:&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : s.v)</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;range-for over brace-init-list: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">03</span>&#125;)   <span class="comment">//// the rule for auto makes this ranged for work</span></span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> al = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;  <span class="comment">//special rule for auto</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The list bound to auto has size() = &quot;</span> &lt;&lt; al.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//templated_fn(&#123;1, 2, 3&#125;);   //compiler error! &quot;&#123;1, 2, 3&#125;&quot; is not an expressionit has no type, and so T cannot be duduced.</span></span><br><span class="line"></span><br><span class="line">    templated_fn&lt;initializer_list&lt;<span class="type">int</span>&gt; &gt; (&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;); <span class="comment">//ok</span></span><br><span class="line">    templated_fn&lt;vector&lt;<span class="type">int</span>&gt; &gt;(&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;);           <span class="comment">//also ok</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-std-array容器"><a href="#5-std-array容器" class="headerlink" title="5. std::array容器"></a>5. std::array容器</h2><p>array容器其实就是平常的数组，加入容器使得它可以用sort那些算法</p>
<p>它没有构造和析构函数</p>
<p>std::array 保存在栈内存中，相比堆内存中的 std::vector，我们能够灵活的访问这里面的元素，从而获得更高的性能。</p>
<p>std::array 会在编译时创建一个固定大小的数组，std::array 不能够被隐式的转换成指针，使用 std::array只需指定其类型和大小即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 4&gt; arr= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = <span class="number">4</span>;</span><br><span class="line">std::array&lt;<span class="type">int</span>, len&gt; arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">// 非法, 数组大小参数必须是常量表达式1234</span></span><br></pre></td></tr></table></figure>

<p>当我们开始用上了 std::array 时，难免会遇到要将其兼容 C 风格的接口，这里有三种做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="type">int</span> 4&gt; arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C 风格接口传参</span></span><br><span class="line"><span class="comment">// foo(arr, arr.size());           // 非法, 无法隐式转换</span></span><br><span class="line"><span class="built_in">foo</span>(&amp;arr[<span class="number">0</span>], arr.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">foo</span>(arr.<span class="built_in">data</span>(), arr.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 `std::sort`</span></span><br><span class="line">std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h2 id="6-explicit"><a href="#6-explicit" class="headerlink" title="6.explicit"></a>6.explicit</h2><p>explicit专用于修饰构造函数（基本只用于构造函数，其他地方很少用），表示只能显式构造，不可以被隐式转换，根据代码看explicit的作用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;value&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a = <span class="number">1</span>; <span class="comment">// error，不可以隐式转换</span></span><br><span class="line">    <span class="function">A <span class="title">aa</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241010145150653.png" alt="image-20241010145150653"></p>
<p>告诉编译器，你不要自动帮我隐式的转换，我自己会显式的调用</p>
<h2 id="8-for循环"><a href="#8-for循环" class="headerlink" title="8.for循环"></a>8.for循环</h2><h3 id="C-11-for循环（基于范围的循环）详解"><a href="#C-11-for循环（基于范围的循环）详解" class="headerlink" title="C++11 for循环（基于范围的循环）详解"></a>C++11 for循环（基于范围的循环）详解</h3><p>1.C++ 11标准之前（C++ 98&#x2F;03 标准），如果要用 for 循环语句遍历一个数组或者容器，只能套用如下结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(表达式 1; 表达式 2; 表达式 3)&#123;</span><br><span class="line">//循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arc[] = <span class="string">&quot;http://c.biancheng.net/cplus/11/&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//for循环遍历普通数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(arc); i++) &#123;</span><br><span class="line">        cout &lt;&lt; arc[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt;<span class="built_in">myvector</span>(arc,arc<span class="number">+23</span>);</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt;::iterator iter;</span><br><span class="line">    <span class="comment">//for循环遍历 vector 容器</span></span><br><span class="line">    <span class="keyword">for</span> (iter = myvector.<span class="built_in">begin</span>(); iter != myvector.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.而 C++ 11 标准中，除了可以沿用前面介绍的用法外，还为 for 循环添加了一种全新的语法格式，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (declaration : expression)&#123;</span><br><span class="line">//循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，两个参数各自的含义如下：</p>
<ul>
<li>declaration：表示此处要定义一个变量，该变量的类型为要遍历序列中存储元素的类型。需要注意的是，C++ 11 标准中，declaration参数处定义的变量类型可以用 auto 关键字表示，该关键字可以使编译器自行推导该变量的数据类型。</li>
<li>expression：表示要遍历的序列，常见的可以为事先定义好的普通数组或者容器，还可以是用 {} 大括号初始化的序列。</li>
</ul>
<p>可以看到，同 C++ 98&#x2F;03 中 for 循环的语法格式相比较，此格式并没有明确限定 for 循环的遍历范围，这是它们最大的区别，即旧格式的 for 循环可以指定循环的范围，而 C++11 标准增加的 for 循环，只会逐个遍历 expression 参数处指定序列中的每个元素。</p>
<p>eg：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arc[] = <span class="string">&quot;http://c.biancheng.net/cplus/11/&quot;</span>;</span><br><span class="line">    <span class="comment">//for循环遍历普通数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : arc) &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;!&#x27;</span> &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt;<span class="built_in">myvector</span>(arc, arc + <span class="number">23</span>);</span><br><span class="line">    <span class="comment">//for循环遍历 vector 容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : myvector) &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有以下 2 点需要说明：</p>
<ol>
<li>程序中在遍历 myvector 容器时，定义了 auto 类型的 ch 变量，当编译器编译程序时，会通过 myvector 容器中存储的元素类型自动推导出 ch 为 char 类型。注意，这里的 ch 不是迭代器类型，而表示的是 myvector 容器中存储的每个元素。</li>
<li>仔细观察程序的输出结果，其中第一行输出的字符串和 “!” 之间还输出有一个空格，这是因为新格式的 for 循环在遍历字符串序列时，不只是遍历到最后一个字符，还会遍历位于该字符串末尾的 ‘\0’（字符串的结束标志）。之所以第二行输出的字符串和 “!” 之间没有空格，是因为 myvector 容器中没有存储 ‘\0’。</li>
</ol>
<p>3.除此之外，新语法格式的 for 循环还支持遍历用<code>&#123; &#125;</code>大括号初始化的列表，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p>4.另外值得一提的是，在使用新语法格式的 for 循环遍历某个序列时，如果需要遍历的同时修改序列中元素的值，实现方案是在 declaration 参数处定义<code>引用</code>形式的变量。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arc[] = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt;<span class="built_in">myvector</span>(arc, arc + <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//for循环遍历并修改容器中各个字符的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : myvector) &#123;</span><br><span class="line">        ch++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for循环遍历输出容器中各个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : myvector) &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>bcdef</p>
<p>如果需要在遍历序列的过程中修改器内部元素的值，就必须定义引用形式的变量；反之，建议定义<code>const &amp;</code>（常引用）形式的变量（避免了底层复制变量的过程，效率更高），也可以定义普通变量。</p>
<h3 id="C-11-for循环使用注意事项"><a href="#C-11-for循环使用注意事项" class="headerlink" title="C++11 for循环使用注意事项"></a>C++11 for循环使用注意事项</h3><ol>
<li>总的来说，基于范围的 for 循环可以遍历普通数组、string字符串、容器以及初始化列表。除此之外，for 循环冒号后还可以放置返回 string 字符串以及容器对象的函数，比如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string str = <span class="string">&quot;http://c.biancheng.net/cplus/11/&quot;</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; myvector = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function">string <span class="title">retStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">retVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> myvector;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历函数返回的 string 字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : <span class="built_in">retStr</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//遍历函数返回的 vector 容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : <span class="built_in">retVector</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p><a href="http://c.biancheng.net/cplus/11/">http://c.biancheng.net/cplus/11/</a><br>1 2 3 4 5</p>
<p>注意，基于范围的 for 循环不支持遍历函数返回的以指针形式表示的数组，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;http://c.biancheng.net/cplus/11/&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">retStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : <span class="built_in">retStr</span>()) <span class="comment">//直接报错</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因很简单，此格式的 for 循环只能遍历有明确范围的一组数据，上面程序中 retStr() 函数返回的是指针变量，遍历范围并未明确指明，所以编译失败。</p>
<p>2.值得一提的是，当基于范围的 for 循环遍历的是某函数返回的 string 对象或者容器时，整个遍历过程中，函数只会执行一次。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string str= <span class="string">&quot;http://c.biancheng.net/cplus/11/&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">retStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;retStr:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历函数返回的 string 字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : <span class="built_in">retStr</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>retStr:<br><a href="http://c.biancheng.net/cplus/11/">http://c.biancheng.net/cplus/11/</a></p>
<p>借助执行结果不难分析出，整个 for 循环遍历 str 字符串对象的过程中，retStr() 函数仅在遍历开始前执行了 1 次。</p>
<p>3.系统学过 STL 标准库的读者应该知道，基于关联式容器（包括哈希容器）底层存储机制的限制：</p>
<ol>
<li>不允许修改 map、unordered_map、multimap 以及 unordered_multimap 容器存储的键的值；</li>
<li>不允许修改 set、unordered_set、multiset 以及 unordered_multiset 容器中存储的元素的值。</li>
</ol>
<p>因此，当使用基于范围的 for 循环遍历此类型容器时，切勿修改容器中不允许被修改的数据部分，否则会导致程序的执行出现各种 Bug。</p>
<p>4.另外，基于范围的 for 循环完成对容器的遍历，其底层也是借助容器的迭代器实现的（begin和end函数来实现的）。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">        arr.<span class="built_in">push_back</span>(<span class="number">10</span>); <span class="comment">//向容器中添加元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果可能为（输出结果不唯一）：</p>
<p>1<br>-572662307<br>-572662307<br>4<br>5</p>
<p>可以看到，程序的执行结果并不是我们想要的。就是因为在 for 循环遍历 arr 容器的同时向该容器尾部添加了新的元素（对 arr 容器进行了扩增），致使遍历容器所使用的迭代器失效，整个遍历过程出现错误。</p>
<p><strong>因此，在使用基于范围的 for 循环遍历容器时，应避免在循环体中修改容器存储元素的个数。</strong></p>
<p>5.其实这个是一种拷贝的动作，下面这个代码还要考虑在c这个类中允不允许它的对象通过等于号进行构造，如下面</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">c</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">explict <span class="title">c</span><span class="params">(string s)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;c&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ch : v) &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>那么</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c eg1;</span><br><span class="line">c eg2=eg1;<span class="comment">//这个行为是不被允许的，因为有exlicit关键字，只能显式调用，所以会报错，那就不能用for循环的这个遍历</span></span><br></pre></td></tr></table></figure>

<p>不能用for范围循环这种的，因为它本质上还是一个赋值动作，eg2就是上面的ch</p>
<h2 id="9-default、-delete"><a href="#9-default、-delete" class="headerlink" title="9.&#x3D;default、&#x3D;delete"></a>9.&#x3D;default、&#x3D;delete</h2><h3 id="9-1-default"><a href="#9-1-default" class="headerlink" title="9.1 default"></a>9.1 default</h3><p>如果你自己定义了一个构造函数，那编译器不会给你默认构造函数了。</p>
<p>如果你强制加上default，就可以重新得到编译器的默认构造函数</p>
<p><strong>一般成员函数不能用这个，是给构造函数用的</strong></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241010152223392.png" alt="image-20241010152223392"></p>
<h3 id="9-2-delete"><a href="#9-2-delete" class="headerlink" title="9.2 delete"></a>9.2 delete</h3><p>C++11中，当我们定义一个类的成员函数时，如果后面使用”&#x3D;delete”去修饰，那么就表示这个函数被定义为deleted，也就意味着这个成员函数不能再被调用，否则就会出错。</p>
<p>在C++11之前，当我们希望一个类不能被拷贝，就会把构造函数定义为private，但是在C++11里就不需要这样做了，只需要在构造函数后面加上&#x3D;delete来修饰下就可以了。</p>
<p>构造函数成员函数析构函数都可以用</p>
<p>注：两者不要同时作用一个函数，会报错，编译器不知道你要干啥</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">~<span class="built_in">c</span>()=<span class="keyword">delete</span>;</span><br><span class="line">~<span class="built_in">c</span>()=<span class="keyword">default</span>;<span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<h2 id="10-Alias-Template-using-用法"><a href="#10-Alias-Template-using-用法" class="headerlink" title="10.Alias Template(using 用法)"></a>10.Alias Template(using 用法)</h2><p>Alias Template（别名模板）是一种C++编程语言中的模板技术，它允许程序员使用别名来引用已有的类型。通过别名模板，可以创建新的类型别名，使得代码更易读、更易维护。在C++11标准之后引入了别名模板的语法，使用关键字<code>using</code>来定义别名模板，它的语法格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AliasType&gt;</span><br><span class="line"><span class="keyword">using</span> AliasName = OriginalType; </span><br></pre></td></tr></table></figure>

<p>在这里，<code>AliasType</code> 是你想要定义的新类型的占位符，<code>AliasName</code> 是你给这个新类型取的名字，而 <code>OriginalType</code> 则是你想要创建别名的原始类型。这种语法使得创建类型别名更加简洁和易于理解。</p>
<p>使用别名模板可以提高代码的可读性和灵活性，尤其是在模板元编程和泛型编程中。例如，当你需要使用一个复杂的模板类型时，可以通过别名模板为它创建一个更简洁的名称，使得代码更易于理解。此外，别名模板还可以用于简化模板类型的声明，提高代码的可维护性。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241010155354561.png" alt="image-20241010155354561"></p>
<p>用 #define 达不到我们想要的结果</p>
<p>typedef无法达到任意传参的效果，我们写成int就一直得是int，而我们的本意不是这种特化的模板，是想要我们传哪个类型，T就是哪个类型我们需要的其实是一个固定以 std::string 为 key 的 map，它可以映射到 int 或另一个 std::string。然而这个简单的需求仅通过 typedef 却很难办到。</p>
<p>因此，在 C++98&#x2F;03 中往往不得不这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str_map</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::map&lt;std::string, Val&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">str_map&lt;<span class="type">int</span>&gt;::type map1;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>一个虽然简单但却略显烦琐的 str_map 外敷类是必要的。这明显让我们在复用某些泛型代码时非常难受。</p>
<p>现在，在 C++11 中终于出现了可以重定义一个模板的语法。请看下面的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">str_map_t</span> = std::map&lt;std::string, Val&gt;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">str_map_t</span>&lt;<span class="type">int</span>&gt; map1;</span><br></pre></td></tr></table></figure>

<p>这里使用新的 using 别名语法定义了 std::map 的模板别名 str_map_t。比起前面使用外敷模板加 typedef 构建的 str_map，它完全就像是一个新的 map 类模板，因此，简洁了很多。</p>
<p>实际上，using 的别名语法覆盖了 typedef 的全部功能。先来看看对普通类型的重定义示例，将这两种语法对比一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重定义unsigned int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">uint_t</span> = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"><span class="comment">// 重定义std::map</span></span><br><span class="line"><span class="keyword">typedef</span> std::map&lt;std::string, <span class="type">int</span>&gt; <span class="type">map_int_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">map_int_t</span> = std::map&lt;std::string, <span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>可以看到，在重定义普通类型上，两种使用方法的效果是等价的，唯一不同的是定义语法。</p>
<p>typedef 的定义方法和变量的声明类似：像声明一个变量一样，声明一个重定义类型，之后在声明之前加上 typedef 即可。这种写法凸显了 C&#x2F;C++ 中的语法一致性，但有时却会增加代码的阅读难度。比如重定义一个函数指针时：</p>
<p>typedef void (*func_t)(int, int);</p>
<p>与之相比，using 后面总是立即跟随新标识符（Identifier），之后使用类似赋值的语法，把现有的类型（type-id）赋给新类型：</p>
<p>using func_t &#x3D; void (*)(int, int);</p>
<p>从上面的对比中可以发现，C++11 的 using 别名语法比 typedef 更加清晰。因为 typedef 的别名语法本质上类似一种解方程的思路。而 using 语法通过赋值来定义别名，和我们平时的思考方式一致。</p>
<p>下面再通过一个对比示例，看看新的 using 语法是如何定义模板别名的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* C++98/03 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*type)</span><span class="params">(T, T)</span> type</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="type">func_t</span>&lt;<span class="type">int</span>&gt;::type xx_1;</span><br><span class="line"><span class="comment">/* C++11 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = <span class="built_in">void</span> (*)(T, T);</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="type">func_t</span>&lt;<span class="type">int</span>&gt; xx_2;</span><br></pre></td></tr></table></figure>

<p>从示例中可以看出，通过 using 定义模板别名的语法，只是在普通类型别名语法的基础上增加 template 的参数列表。使用 using 可以轻松地创建一个新的模板别名，而不需要像 C++98&#x2F;03 那样使用烦琐的外敷模板。</p>
<p>需要注意的是，using 语法和 typedef 一样，并不会创造新的类型。也就是说，上面示例中 C++11 的 using 写法只是 typedef 的等价物。虽然 using 重定义的 func_t 是一个模板，但 func_t 定义的 xx_2 并不是一个由类模板实例化后的类，而是 void(*)(int, int) 的别名。</p>
<p>因此，下面这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">void</span> (*func_call)(<span class="type">int</span>, <span class="type">int</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">func_t</span> func_call)</span></span>; <span class="comment">// error: redefinition</span></span><br></pre></td></tr></table></figure>

<p>同样是无法实现重载的，func_t 只是 void(*)(int, int) 类型的等价物。</p>
<p>细心的读者可以发现，using 重定义的 func_t 是一个模板，但它既不是类模板也不是函数模板（函数模板实例化后是一个函数），而是一种新的模板形式：模板别名（alias template）。</p>
<p>其实，通过 using 可以轻松定义任意类型的模板表达方式。比如下面这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">using</span> <span class="type">type_t</span> = T;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line"><span class="type">type_t</span>&lt;<span class="type">int</span>&gt; i;</span><br></pre></td></tr></table></figure>

<p>type_t 实例化后的类型和它的模板参数类型等价。这里，type_t 将等价于 int。</p>
<h2 id="11-template-template-parameters-双重模版参数"><a href="#11-template-template-parameters-双重模版参数" class="headerlink" title="11.template template parameters(双重模版参数)"></a>11.template template parameters(双重模版参数)</h2><p>在C++中，<code>template template parameters</code>（模板模板参数）是一种高级模板特性，它允许一个模板接受另一个模板作为参数。这种特性在编写泛型代码时非常有用，特别是当你需要定义一个模板，该模板本身需要接受另一个模板作为类型参数时。</p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>当你定义一个模板时，你可以指定它的参数类型。通常，这些参数是类型（<code>typename</code>）或非类型参数（如整数常量）。但是，模板模板参数允许你指定一个模板作为参数，这意味着你可以要求调用者提供一个符合特定签名的模板。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>模板模板参数的语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt; <span class="keyword">class</span> <span class="title class_">TemplateParam</span>&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>;</span><br></pre></td></tr></table></figure>

<p>这里，<code>TemplateParam</code>是一个模板模板参数，它本身接受一个或多个类型参数（在这个例子中是使用省略号<code>...</code>表示的可变数量）。<code>class</code>关键字用于指定<code>TemplateParam</code>是一个模板类（你也可以使用<code>typename</code>，但在这种情况下<code>class</code>更常见）。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>让我们通过一个例子来更好地理解模板模板参数。</p>
<p>假设我们想要定义一个容器类，该类可以存储任何类型的<code>std::vector</code>。我们可以使用模板模板参数来实现这一点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 定义一个模板模板参数TemplateVector，它本身是一个模板，接受一个类型参数T  </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>...&gt; <span class="keyword">class</span> <span class="title class_">TemplateVector</span>, <span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="comment">// 使用TemplateVector模板来定义一个成员变量，该变量接受T作为类型参数，并可能接受其他参数（如分配器）  </span></span><br><span class="line">    TemplateVector&lt;T&gt; vec;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;  </span><br><span class="line">        vec.<span class="built_in">push_back</span>(value);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : vec) &#123;  </span><br><span class="line">            std::cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        std::cout &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 实例化MyContainer，指定TemplateVector为std::vector，T为int  </span></span><br><span class="line">    MyContainer&lt;std::vector, <span class="type">int</span>&gt; container;  </span><br><span class="line">  </span><br><span class="line">    container.<span class="built_in">add</span>(<span class="number">1</span>);  </span><br><span class="line">    container.<span class="built_in">add</span>(<span class="number">2</span>);  </span><br><span class="line">    container.<span class="built_in">add</span>(<span class="number">3</span>);  </span><br><span class="line">  </span><br><span class="line">    container.<span class="built_in">print</span>(); <span class="comment">// 输出: 1 2 3  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>MyContainer</code>是一个模板类，它接受两个参数：<code>TemplateVector</code>和<code>T</code>。<code>TemplateVector</code>是一个模板模板参数，它本身接受一个类型参数（在这里是<code>T</code>）和可能的其他参数（如<code>std::vector</code>的分配器参数，虽然在这个例子中我们没有使用它）。</p>
<p>我们实例化<code>MyContainer</code>时，指定<code>TemplateVector</code>为<code>std::vector</code>，<code>T</code>为<code>int</code>。这样，<code>MyContainer</code>内部就使用了一个<code>std::vector&lt;int&gt;</code>作为其成员变量<code>vec</code>。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>模板模板参数必须匹配其接受的模板的签名。例如，如果<code>TemplateVector</code>期望一个接受两个类型参数的模板，那么你不能传递一个只接受一个类型参数的模板。</li>
<li>模板模板参数增加了代码的灵活性，但也增加了复杂性。在使用它们之前，请确保你理解了基本的模板概念。</li>
<li>在实际编程中，模板模板参数并不常见，但在需要高度泛型代码的情况下，它们可以非常有用。</li>
</ul>
<h3 id="Q1："><a href="#Q1：" class="headerlink" title="Q1："></a>Q1：</h3><p>MyContainer&lt;std::vector, int&gt; container;这句话为什么不写成MyContainer&lt;std::vector<int>, int&gt; container;呢？就是为什么vector后面可以不加尖括号写参数呢？</p>
<p>在C++模板编程中，当你看到像 <code>MyContainer&lt;std::vector, int&gt;</code> 这样的实例化表达式时，它实际上是在利用一个称为“模板模板参数”（template template parameter）的特性。这里的关键在于理解 <code>MyContainer</code> 的模板参数是如何定义的。</p>
<p>假设 <code>MyContainer</code> 是这样定义的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt; <span class="keyword">class</span> <span class="title class_">TemplateVector</span>, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span> &#123;  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个定义中，<code>TemplateVector</code> 是一个模板模板参数，它接受任意数量的类型参数（由 <code>typename...</code> 表示）。这意味着 <code>TemplateVector</code> 可以是任何接受至少一个类型参数的模板，例如 <code>std::vector</code>。</p>
<p>当你写 <code>MyContainer&lt;std::vector, int&gt;</code> 时，你实际上是在告诉编译器：</p>
<ul>
<li><code>TemplateVector</code> 应该被替换为 <code>std::vector</code>。</li>
<li><code>T</code> 应该被替换为 <code>int</code>。</li>
<li><code>Args...</code> 在这个特定实例中是空的，因为 <code>std::vector</code> 通常只接受一个元素类型和一个可选的分配器类型作为参数，而在这里没有提供分配器类型，所以 <code>Args...</code> 就不包含任何内容。</li>
</ul>
<p>然而，由于 <code>MyContainer</code> 的定义允许 <code>TemplateVector</code> 接受任意数量的类型参数，并且你希望将 <code>int</code> 作为 <code>std::vector</code> 的元素类型，编译器会理解你的意图，并将 <code>std::vector&lt;int&gt;</code>（隐式地，加上默认的分配器类型）作为内部使用的容器类型。</p>
<p>但是，这里有一个微妙的点：在 <code>MyContainer</code> 的定义中，你实际上并没有直接实例化 <code>std::vector</code>。相反，你提供了 <code>std::vector</code> 作为模板模板参数 <code>TemplateVector</code> 的一个实例，并指定了 <code>int</code> 作为第一个（也是在这个例子中唯一的）类型参数。然后，<code>MyContainer</code> 内部会使用这个信息来实例化一个 <code>std::vector&lt;int&gt;</code>（或更准确地说，一个 <code>std::vector&lt;int, std::allocator&lt;int&gt;&gt;</code>，因为 <code>std::vector</code> 默认使用 <code>std::allocator</code>）。</p>
<p>如果你尝试写 <code>MyContainer&lt;std::vector&lt;int&gt;, int&gt;</code>，那么这将是不正确的，因为这将意味着你正在尝试将一个已经实例化的 <code>std::vector&lt;int&gt;</code> 类型作为 <code>TemplateVector</code> 的参数，而 <code>TemplateVector</code> 需要的是一个模板类型，而不是一个已经实例化的类型。</p>
<p>简而言之，<code>MyContainer&lt;std::vector, int&gt;</code> 是正确的写法，因为它遵循了模板模板参数的语法规则，允许 <code>MyContainer</code> 内部正确地实例化一个 <code>std::vector&lt;int&gt;</code>（或带有默认分配器的等价类型）。</p>
<h3 id="Q2："><a href="#Q2：" class="headerlink" title="Q2："></a>Q2：</h3><p>什么叫而 TemplateVector 需要的是一个模板类型，而不是一个已经实例化的类型？</p>
<p>在C++模板编程中，当我们谈论“模板类型”与“已经实例化的类型”时，我们是在区分两种不同类型的实体。</p>
<ol>
<li><p><strong>模板类型（Template Type）</strong>：<br>模板类型是一个蓝图或框架，它定义了如何根据提供的类型参数（以及可能的非类型参数）来构造具体的类型。例如，<code>std::vector</code> 是一个模板类型，它接受一个类型参数（元素的类型）和一个可选的非类型参数（通常是分配器的类型，但默认使用 <code>std::allocator</code>）。</p>
<p>当我们说“<code>TemplateVector</code> 需要的是一个模板类型”时，我们是指 <code>TemplateVector</code> 这个参数在 <code>MyContainer</code> 模板的定义中预期的是一个尚未实例化的模板，比如 <code>std::vector</code>。这个模板可以在 <code>MyContainer</code> 内部根据提供的类型参数（如 <code>int</code>）被实例化。</p>
</li>
<li><p><strong>已经实例化的类型（Instantiated Type）</strong>：<br>已经实例化的类型是指根据某个模板类型和一个或多个类型参数（以及可能的非类型参数）实际构造出来的具体类型。例如，<code>std::vector&lt;int&gt;</code> 是一个已经实例化的类型，它是根据 <code>std::vector</code> 模板和类型参数 <code>int</code> 构造出来的。</p>
<p>如果我们尝试将 <code>std::vector&lt;int&gt;</code> 作为一个模板参数传递给一个期望模板类型的参数（如 <code>TemplateVector</code>），那么这将是不正确的，因为 <code>std::vector&lt;int&gt;</code> 已经是一个具体的类型了，而不是一个可以用来构造类型的模板。</p>
</li>
</ol>
<p>在 <code>MyContainer</code> 的例子中，<code>TemplateVector</code> 被定义为接受一个或多个类型参数的模板模板参数。这意味着 <code>MyContainer</code> 期望一个可以作为模板使用的类型，而不是一个已经用具体类型参数实例化过的类型。因此，当我们写 <code>MyContainer&lt;std::vector, int&gt;</code> 时，我们实际上是在告诉编译器：</p>
<ul>
<li>使用 <code>std::vector</code> 作为模板模板参数 <code>TemplateVector</code> 的值。</li>
<li>在 <code>MyContainer</code> 内部，将 <code>int</code> 作为 <code>std::vector</code> 的类型参数来实例化一个 <code>std::vector&lt;int&gt;</code>（或带有默认分配器的等价类型）。</li>
</ul>
<p>这样，<code>MyContainer</code> 就可以根据提供的模板类型（<code>std::vector</code>）和类型参数（<code>int</code>）来构造和使用一个具体的容器类型了。</p>
<h2 id="12-Type-Alias（类型别名，using用法）"><a href="#12-Type-Alias（类型别名，using用法）" class="headerlink" title="12.Type Alias（类型别名，using用法）"></a>12.Type Alias（类型别名，using用法）</h2><p>type alias（类型别名）是更通用的概念，它不仅仅限于模板。类型别名可以简单地为一个现有的类型定义一个新的名称。在 C++ 中，你可以使用 typedef 关键字或 using 关键字来创建类型别名。</p>
<p>使用 typedef 的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Integer;</span><br></pre></td></tr></table></figure>

<p>使用 using 的例子（C++11 及更高版本）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Integer = <span class="type">int</span>;</span><br></pre></td></tr></table></figure>

<p>这两种方式都会为 int 类型创建一个新的名称 Integer。之后，你可以在代码中使用 Integer 来代替 int。<br>总结</p>
<p>  Alias Template 是 C++11 引入的特性，专门用于为模板类型定义别名。<br>  Type Alias 是一个更通用的概念，可以用于任何类型，不仅仅限于模板类型。在 C++ 中，你可以使用 typedef 或 using 关键字来创建类型别名。</p>
<h2 id="13-noexcept"><a href="#13-noexcept" class="headerlink" title="13.noexcept"></a>13.noexcept</h2><p>在C++中，<code>noexcept</code>是一个说明符（specifier），用于指示某个函数或函数对象在抛出异常方面的行为。当使用<code>noexcept</code>时，你向编译器和其他程序员保证该函数不会抛出任何异常。如果函数违反了这一保证（即它实际上抛出了一个异常），那么程序将调用<code>std::terminate()</code>，这通常会导致程序异常终止。</p>
<h3 id="noexcept的用法"><a href="#noexcept的用法" class="headerlink" title="noexcept的用法"></a>noexcept的用法</h3><ol>
<li><strong>函数声明和定义中的noexcept</strong>：</li>
</ol>
<p>你可以在函数声明或定义中的函数类型之后使用<code>noexcept</code>来指定该函数不会抛出异常。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 函数体，这里不应该有throw语句，除非你想让程序异常终止。  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.<strong>构造函数和析构函数中的noexcept</strong>：</p>
<p>对于类的构造函数和析构函数来说，使用<code>noexcept</code>尤为重要，因为它们与对象的生命周期管理紧密相关。如果一个析构函数被声明为<code>noexcept</code>，那么当异常在栈展开过程中传播时，析构函数被调用时不会再次抛出异常，这有助于保证栈展开的顺利进行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>() <span class="keyword">noexcept</span>; <span class="comment">// 构造函数不会抛出异常  </span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() <span class="keyword">noexcept</span>; <span class="comment">// 析构函数也不会抛出异常  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.<strong>lambda表达式中的noexcept</strong>：</p>
<p>对于lambda表达式，你也可以使用<code>noexcept</code>来指定它不会抛出异常：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> myLambda = []() <span class="keyword">noexcept</span> -&gt; <span class="type">void</span> &#123;  </span><br><span class="line">    <span class="comment">// lambda体，这里不应该有throw语句。  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="noexcept的用途"><a href="#noexcept的用途" class="headerlink" title="noexcept的用途"></a>noexcept的用途</h3><ul>
<li><strong>性能优化</strong>：编译器可以利用<code>noexcept</code>信息来生成更高效的代码。例如，在移动语义中，如果一个函数被标记为<code>noexcept</code>，那么编译器可能更愿意使用移动构造函数而不是复制构造函数，因为移动操作通常不会抛出异常，而复制操作可能会。</li>
<li><strong>异常安全性</strong>：在异常传播的过程中，如果某个函数被声明为<code>noexcept</code>但实际上抛出了异常，那么程序将调用<code>std::terminate()</code>。这可以作为一种额外的安全措施，确保在不应该抛出异常的地方不会抛出异常。</li>
<li><strong>标准库要求</strong>：C++标准库中的一些函数和容器要求它们的参数或成员函数是<code>noexcept</code>的。例如，<code>std::vector</code>的某些成员函数（如<code>push_back</code>在元素被移动而非复制时）可能要求元素的移动构造函数是<code>noexcept</code>的，以便在需要时优化性能。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面是一个简单的示例，展示了如何使用<code>noexcept</code>以及违反它的后果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 这里我们故意抛出一个异常，以展示noexcept的效果。  </span></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;This should not happen!&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="built_in">myFunction</span>();  </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 注意：由于myFunction()是noexcept的，上面的catch块实际上不会被执行。  </span></span><br><span class="line">    <span class="comment">// 程序将直接调用std::terminate()，导致异常终止。  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，尽管我们尝试在<code>catch</code>块中捕获异常，但由于<code>myFunction()</code>被声明为<code>noexcept</code>，程序将在抛出异常时调用<code>std::terminate()</code>，而不是进入<code>catch</code>块。这将导致程序异常终止，并可能输出一条错误消息（这取决于你的编译器和运行时环境）。</p>
<h2 id="14-override"><a href="#14-override" class="headerlink" title="14.override"></a>14.override</h2><p>override用于修饰<a href="https://zhida.zhihu.com/search?content_id=232793175&content_type=Article&match_order=1&q=%E6%B4%BE%E7%94%9F%E7%B1%BB&zhida_source=entity">派生类</a>中的成员函数，标明该函数重写了基类函数，如果一个函数声明了override但父类却没有这个虚函数，编译报错，使用override关键字可以避免开发者在重写基类函数时无意产生的错误。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 确保func被重写</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fu</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// error，基类没有fu()，不可以被重写</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="15-final"><a href="#15-final" class="headerlink" title="15.final"></a>15.final</h2><p>在C++中，<code>final</code>关键字有两个主要用途：一是用于类中的虚函数，表示该函数不能被任何派生类（子类）重写（override）；二是用于类定义之后，表示该类不能被继承，即它是最终的基类，没有其他类可以从它派生。</p>
<h3 id="1-用于虚函数"><a href="#1-用于虚函数" class="headerlink" title="1. 用于虚函数"></a>1. 用于虚函数</h3><p>当一个虚函数被声明为<code>final</code>时，这意味着在派生类中不能提供一个与该函数签名相同的新定义（即不能重写该函数）。尝试这样做将导致编译错误。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base show()&quot;</span> &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 声明为final的虚函数  </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">final</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base display()&quot;</span> &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="comment">// 试图重写final函数将导致编译错误  </span></span><br><span class="line">    <span class="comment">// void display() const override &#123;  </span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; &quot;Derived display()&quot; &lt;&lt; std::endl;  </span></span><br><span class="line">    <span class="comment">// &#125;  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 可以重写非final的虚函数  </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived show()&quot;</span> &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Derived d;  </span><br><span class="line">    d.<span class="built_in">show</span>(); <span class="comment">// 输出: Derived show()  </span></span><br><span class="line">    <span class="comment">// d.display(); // 如果取消注释，由于display()在Base中被声明为final，这里将编译错误  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Base</code>类有一个虚函数<code>show()</code>和一个被声明为<code>final</code>的虚函数<code>display()</code>。<code>Derived</code>类可以重写<code>show()</code>函数，但不能重写<code>display()</code>函数，因为后者在<code>Base</code>中被声明为<code>final</code>。</p>
<h3 id="2-用于类定义"><a href="#2-用于类定义" class="headerlink" title="2. 用于类定义"></a>2. 用于类定义</h3><p>当<code>final</code>关键字用于类定义之后时，它表示该类不能被继承。这有助于防止其他开发人员意外地从该类派生新的类，从而保持类的封装性和稳定性。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FinalClass</span> <span class="keyword">final</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Doing something in FinalClass&quot;</span> &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 试图从FinalClass派生新类将导致编译错误  </span></span><br><span class="line"><span class="comment">// class AnotherClass : public FinalClass &#123;  </span></span><br><span class="line"><span class="comment">// &#125;;  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    FinalClass fc;  </span><br><span class="line">    fc.<span class="built_in">doSomething</span>(); <span class="comment">// 输出: Doing something in FinalClass  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>FinalClass</code>被声明为<code>final</code>，这意味着不能从它派生任何新类。如果尝试这样做（如注释掉的代码所示），将导致编译错误。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>final</code>关键字用于虚函数时，表示该函数不能被派生类重写。</li>
<li><code>final</code>关键字用于类定义时，表示该类不能被继承。</li>
<li>使用<code>final</code>可以提高代码的可读性和可维护性，因为它清楚地表明了哪些函数或类是不应该被修改的。</li>
</ul>
<h2 id="16-decltype"><a href="#16-decltype" class="headerlink" title="16.decltype"></a>16.decltype</h2><h3 id="C-decltype类型推导完全攻略"><a href="#C-decltype类型推导完全攻略" class="headerlink" title="C++ decltype类型推导完全攻略"></a>C++ decltype类型推导完全攻略</h3><p>decltype 是 C++11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。</p>
<p>decltype 是“declare type”的缩写，译为“声明类型”。</p>
<p>既然已经有了 auto 关键字，为什么还需要 decltype 关键字呢？因为 auto 并不适用于所有的自动类型推导场景，在某些特殊情况下 auto 用起来非常不方便，甚至压根无法使用，所以 decltype 关键字也被引入到 C++11 中。</p>
<p>auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> varname = value;</span><br><span class="line"><span class="keyword">decltype</span>(exp) varname = value;</span><br></pre></td></tr></table></figure>

<p>其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。</p>
<p>auto 根据<code>=</code>右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟<code>=</code>右边的 value 没有关系。</p>
<p>另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。decltype 可以写成下面的形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(exp) varname;</span><br></pre></td></tr></table></figure>

<h5 id="exp-注意事项"><a href="#exp-注意事项" class="headerlink" title="exp 注意事项"></a>exp 注意事项</h5><p>原则上讲，exp 就是一个普通的表达式，它可以是任意复杂的形式，但是我们必须要保证 exp 的结果是有类型的，不能是 void；例如，当 exp 调用一个返回值类型为 void 的函数时，exp 的结果也是 void 类型，此时就会导致编译错误。</p>
<p>C++ decltype 用法举例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">1</span>;  <span class="comment">//b 被推导成了 int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">10.8</span>) x = <span class="number">5.5</span>;  <span class="comment">//x 被推导成了 double</span></span><br><span class="line"><span class="keyword">decltype</span>(x + <span class="number">100</span>) y;  <span class="comment">//y 被推导成了 double</span></span><br></pre></td></tr></table></figure>

<p>可以看到，decltype 能够根据变量、字面量、带有运算符的表达式推导出变量的类型。读者请留意第 4 行，y 没有被初始化。</p>
<h4 id="decltype-推导规则"><a href="#decltype-推导规则" class="headerlink" title="decltype 推导规则"></a>decltype 推导规则</h4><p>上面的例子让我们初步感受了一下 decltype 的用法，但你不要认为 decltype 就这么简单，它的玩法实际上可以非常复杂。当程序员使用 decltype(exp) 获取类型时，编译器将根据以下三条规则得出结果：</p>
<ul>
<li>如果 exp 是一个不被括号<code>( )</code>包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。</li>
<li>如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。</li>
<li>如果 exp 是一个左值，或者被括号<code>( )</code>包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&amp;。</li>
</ul>
<p>为了更好地理解 decltype 的推导规则，下面来看几个实际的例子。</p>
<p>【实例1】exp 是一个普通表达式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> total;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> scores;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Student::total = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;r = n;</span><br><span class="line">    Student stu;</span><br><span class="line">    <span class="keyword">decltype</span>(n) a = n;  <span class="comment">//n 为 int 类型，a 被推导为 int 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(r) b = n;     <span class="comment">//r 为 const int&amp; 类型, b 被推导为 const int&amp; 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(Student::total) c = <span class="number">0</span>;  <span class="comment">//total 为类 Student 的一个 int 类型的成员变量，c 被推导为 int 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(stu.name) url = <span class="string">&quot;http://c.biancheng.net/cplus/&quot;</span>;  <span class="comment">//total 为类 Student 的一个 string 类型的成员变量， url 被推导为 string 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很简单，按照推导规则 1，对于一般的表达式，decltype 的推导结果就和这个表达式的类型一致。</p>
<p>【实例2】exp 为函数调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/函数声明</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func_int_r</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>)</span></span>;  <span class="comment">//返回值为 int&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">func_int_rr</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">//返回值为 int&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func_int</span><span class="params">(<span class="type">double</span>)</span></span>;  <span class="comment">//返回值为 int</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">fun_cint_r</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span>;  <span class="comment">//返回值为 const int&amp;</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp;&amp; <span class="title">func_cint_rr</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">//返回值为 const int&amp;&amp;</span></span><br><span class="line"><span class="comment">//decltype类型推导</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_r</span>(<span class="number">100</span>, <span class="string">&#x27;A&#x27;</span>)) a = n;  <span class="comment">//a 的类型为 int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_rr</span>()) b = <span class="number">0</span>;  <span class="comment">//b 的类型为 int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int</span>(<span class="number">10.5</span>)) c = <span class="number">0</span>;   <span class="comment">//c 的类型为 int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">fun_cint_r</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))  x = n;    <span class="comment">//x 的类型为 const int &amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_rr</span>()) y = <span class="number">0</span>;  <span class="comment">// y 的类型为 const int&amp;&amp;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，exp 中调用函数时需要带上括号和参数，但这仅仅是形式，并不会真的去执行函数代码。</p>
<p>【实例3】exp 是左值，或者被<code>( )</code>包围：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> Base obj;</span><br><span class="line">    <span class="comment">//带有括号的表达式</span></span><br><span class="line">    <span class="keyword">decltype</span>(obj.x) a = <span class="number">0</span>;  <span class="comment">//obj.x 为类的成员访问表达式，符合推导规则一，a 的类型为 int</span></span><br><span class="line">    <span class="keyword">decltype</span>((obj.x)) b = a;  <span class="comment">//obj.x 带有括号，符合推导规则三，b 的类型为 int&amp;。</span></span><br><span class="line">    <span class="comment">//加法表达式</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(n + m) c = <span class="number">0</span>;  <span class="comment">//n+m 得到一个右值，符合推导规则一，所以推导结果为 int</span></span><br><span class="line">    <span class="keyword">decltype</span>(n = n + m) d = c;  <span class="comment">//n=n+m 得到一个左值，符号推导规则三，所以推导结果为 int&amp;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们需要重点说一下左值和右值：左值是指那些在表达式执行结束后依然存在的数据，也就是持久性的数据；右值是指那些在表达式执行结束后不再存在的数据，也就是临时性的数据。有一种很简单的方法来区分左值和右值，对表达式取地址，如果编译器不报错就为左值，否则为右值。</p>
<h4 id="decltype-的实际应用"><a href="#decltype-的实际应用" class="headerlink" title="decltype 的实际应用"></a>decltype 的实际应用</h4><p>1.auto 的语法格式比 decltype 简单，所以在一般的类型推导中，使用 auto 比使用 decltype 更加方便</p>
<p>auto 只能用于类的静态成员，不能用于类的非静态成员（普通成员），如果我们想推导非静态成员的类型，这个时候就必须使用 decltype 了。下面是一个模板的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span> </span>&#123;</span><br><span class="line">        m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typename</span> T::iterator m_it;  <span class="comment">//注意这里</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    Base&lt;<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&gt; obj;</span><br><span class="line">    obj.<span class="built_in">func</span>(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>单独看 Base 类中 m_it 成员的定义，很难看出会有什么错误，但在使用 Base 类的时候，如果传入一个 const 类型的容器，编译器马上就会弹出一大堆错误信息。原因就在于，<code>T::iterator</code>并不能包括所有的迭代器类型，当 T 是一个 const 容器时，应当使用 const_iterator。</p>
<p>要想解决这个问题，在之前的 C++98&#x2F;03 版本下只能想办法把 const 类型的容器用模板特化单独处理，增加了不少工作量，看起来也非常晦涩。但是有了 C++11 的 decltype 关键字，就可以直接这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span> </span>&#123;</span><br><span class="line">        m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">T</span>().<span class="built_in">begin</span>()) m_it;  <span class="comment">//注意这里</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看起来是不是很清爽？</p>
<p>注意，有些低版本的编译器不支持<code>T().begin()</code>这种写法，以上代码我在 VS2019 下测试通过，在 VS2015 下测试失败。</p>
<p>2.auto和decltype结合</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这样写是不行的，因为编译器找不到x和y</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span> <span class="params">(x+y)</span> <span class="title">add</span><span class="params">(T2 x,T2 y)</span></span>;</span><br><span class="line"><span class="comment">//得这样写才行</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T1 x,T2 y)</span>-&gt;<span class="title">decltype</span><span class="params">(x+y)</span></span>;</span><br></pre></td></tr></table></figure>

<p>3.<code>decltype</code>在C++的模板元编程中也扮演着重要角色。元编程允许程序员在编译时执行计算和操作类型，而<code>decltype</code>提供了一种强大的方式来推断和操纵这些类型。例如，在编写泛型代码时，<strong>你可能需要基于模板参数的类型来构造新的类型</strong>。<code>decltype</code>可以帮助你实现这一点，因为它可以推断出任何给定表达式的类型。</p>
<p>4.在C++11及更高版本中，<code>decltype</code>还可以用于推断lambda表达式的类型。这对于需要将lambda表达式作为参数传递给函数或模板，并且希望保持其类型信息的情况非常有用。例如，你可能有一个接受函数对象作为参数的函数模板，并且希望它能够接受lambda表达式作为参数。使用<code>decltype</code>和<code>auto</code>关键字，你可以轻松地实现这一点。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241010185606846.png" alt="image-20241010185606846"></p>
<h4 id="汇总auto和decltype的区别"><a href="#汇总auto和decltype的区别" class="headerlink" title="汇总auto和decltype的区别"></a>汇总auto和decltype的区别</h4><h5 id="语法格式的区别"><a href="#语法格式的区别" class="headerlink" title="语法格式的区别"></a>语法格式的区别</h5><p>auto 和 decltype 都是 C++11 新增的关键字，都用于自动类型推导，但是它们的语法格式是有区别的，如下所示：</p>
<p>auto varname &#x3D; value; &#x2F;&#x2F;auto的语法格式<br>decltype(exp) varname [&#x3D; value]; &#x2F;&#x2F;decltype的语法格式</p>
<p>其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式，方括号<code>[ ]</code>表示可有可无。</p>
<p>auto 和 decltype 都会自动推导出变量 varname 的类型：</p>
<ul>
<li>auto 根据<code>=</code>右边的初始值 value 推导出变量的类型；</li>
<li>decltype 根据 exp 表达式推导出变量的类型，跟<code>=</code>右边的 value 没有关系。</li>
</ul>
<p>另外，auto 要求变量必须初始化，也就是在定义变量的同时必须给它赋值；而 decltype 不要求，初始化与否都不影响变量的类型。这很容易理解，因为 auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。</p>
<p>auto 将变量的类型和初始值绑定在一起，而 decltype 将变量的类型和初始值分开；虽然 auto 的书写更加简洁，但 decltype 的使用更加灵活。</p>
<h2 id="17-Lambda-表达式"><a href="#17-Lambda-表达式" class="headerlink" title="17.Lambda 表达式"></a>17.Lambda 表达式</h2><h3 id="C-11-lambda匿名函数用法详解"><a href="#C-11-lambda匿名函数用法详解" class="headerlink" title="C++11 lambda匿名函数用法详解"></a>C++11 lambda匿名函数用法详解</h3><p>lambda 源自希腊字母表中第 11 位的 λ，在计算机科学领域，它则是被用来表示一种匿名函数。所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。</p>
<h4 id="lambda匿名函数的定义"><a href="#lambda匿名函数的定义" class="headerlink" title="lambda匿名函数的定义"></a>lambda匿名函数的定义</h4><p>定义一个 lambda 匿名函数很简单，可以套用如下的语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[外部变量访问方式说明符] (参数) mutable noexcept/throw() -&gt; 返回值类型</span><br><span class="line">&#123;</span><br><span class="line">函数体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中各部分的含义分别为：</p>
<p>1.[外部变量方位方式说明符]<br>[ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。</p>
<blockquote>
<p>所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。</p>
</blockquote>
<p>2.(参数)<br>和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；</p>
<p><code>如果参数，关键字，返回值一个都没有，那小括号可写可不写，如果有一个那就得写小括号</code></p>
<p>3.mutable<br>此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。</p>
<p><strong>注意，对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量</strong></p>
<p>4.noexcept&#x2F;throw()<br>可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。</p>
<p>值得一提的是，如果 lambda 函数标有 noexcept 而函数体内抛出了异常，又或者使用 throw() 限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用 try-catch 捕获，会导致程序执行失败（本节后续会给出实例）。</p>
<p>5.-&gt; 返回值类型<br>指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略<code>-&gt; 返回值类型</code>。</p>
<p>6.函数体<br>和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。</p>
<p>需要注意的是，外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值。</p>
<blockquote>
<p>其中，红色标识的参数是定义 lambda 表达式时必须写的，而绿色标识的参数可以省略。</p>
</blockquote>
<p>比如，如下就定义了一个最简单的 lambda 匿名函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[]&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>显然，此 lambda 匿名函数未引入任何外部变量（[] 内为空），也没有传递任何参数，没有指定 mutable、noexcept 等关键字，没有返回值和函数体。所以，<strong>这是一个没有任何功能的 lambda 匿名函数</strong>。</p>
<h5 id="lambda匿名函数中的-外部变量"><a href="#lambda匿名函数中的-外部变量" class="headerlink" title="lambda匿名函数中的[外部变量]"></a>lambda匿名函数中的[外部变量]</h5><table>
<thead>
<tr>
<th>外部变量格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>空方括号表示当前 lambda 匿名函数中不导入任何外部变量。</td>
</tr>
<tr>
<td>[&#x3D;]</td>
<td>只有一个 &#x3D; 等号，表示以值传递的方式导入所有外部变量；</td>
</tr>
<tr>
<td>[&amp;]</td>
<td>只有一个 &amp; 符号，表示以引用传递的方式导入所有外部变量；</td>
</tr>
<tr>
<td>[val1,val2,…]</td>
<td>表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序；</td>
</tr>
<tr>
<td>[&amp;val1,&amp;val2,…]</td>
<td>表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序；</td>
</tr>
<tr>
<td>[val,&amp;val2,…]</td>
<td>以上 2 种方式还可以混合使用，变量之间没有前后次序。</td>
</tr>
<tr>
<td>[&#x3D;,&amp;val1,…]</td>
<td>表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。</td>
</tr>
<tr>
<td>[this]</td>
<td>表示以值传递的方式导入当前的 this 指针。</td>
</tr>
</tbody></table>
<blockquote>
<p>注意，单个外部变量不允许以相同的传递方式导入多次。例如 [&#x3D;，val1] 中，val1 先后被以值传递的方式导入了 2 次，这是非法的。</p>
</blockquote>
<p>调用方式举例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.最常用的，如果要调用的的话就这么写</span></span><br><span class="line"><span class="keyword">auto</span> i=[]&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;hello world&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">i</span>();</span><br><span class="line"><span class="comment">//2.这样写不是错的，但是没必要,中就是把它看成了普通函数来调用，()就是调用符</span></span><br><span class="line">[]&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;hello world&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">//3.在某个函数里面调用</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">4</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//对 a 数组中的元素进行升序排序</span></span><br><span class="line"><span class="built_in">sort</span>(num, num<span class="number">+4</span>, [=](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">bool</span>&#123; <span class="keyword">return</span> x &lt; y; &#125; );</span><br></pre></td></tr></table></figure>

<p>【例 1】lambda 匿名函数的定义和使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">4</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//对 a 数组中的元素进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(num, num<span class="number">+4</span>, [=](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">bool</span>&#123; <span class="keyword">return</span> x &lt; y; &#125; );</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n : num)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>1 2 3 4</p>
<p>调用 sort() 函数实现了对 num 数组中元素的升序排序，其中就用到了 lambda 匿名函数。</p>
<p><strong>lambda 匿名函数没有函数名称，我们仍可以为其手动设置一个名称</strong>，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//display 即为 lambda 匿名函数的函数名</span></span><br><span class="line">    <span class="keyword">auto</span> display = [](<span class="type">int</span> a,<span class="type">int</span> b) -&gt; <span class="type">void</span>&#123;cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b;&#125;;</span><br><span class="line">    <span class="comment">//调用 lambda 函数</span></span><br><span class="line">    <span class="built_in">display</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【例 2】值传递和引用传递的区别</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> all_num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//局部变量</span></span><br><span class="line">    <span class="type">int</span> num_1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num_2 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> num_3 = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda1:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda1 = [=]&#123;</span><br><span class="line">        <span class="comment">//全局变量可以访问甚至修改</span></span><br><span class="line">        all_num = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//函数体内只能使用外部变量，而无法对它们进行修改</span></span><br><span class="line">        cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda1</span>();</span><br><span class="line">    cout &lt;&lt; all_num &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda2:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda2 = [&amp;]&#123;</span><br><span class="line">        all_num = <span class="number">100</span>;</span><br><span class="line">        num_1 = <span class="number">10</span>;</span><br><span class="line">        num_2 = <span class="number">20</span>;</span><br><span class="line">        num_3 = <span class="number">30</span>;</span><br><span class="line">        cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda2</span>();</span><br><span class="line">    cout &lt;&lt; all_num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>lambda1:<br>1 2 3<br>10<br>lambda2:<br>10 20 30<br>100</p>
<p>可以看到，在创建 lambda1 和 lambda2 匿名函数的作用域中，有 num_1、num_2 和 num_3 这 3 个局部变量，另外还有 all_num 全局变量。</p>
<p>其中，lambda1 匿名函数是以 [&#x3D;] 值传递的方式导入的局部变量，这意味着默认情况下，此函数内部无法修改这 3 个局部变量的值，<strong>但全局变量 all_num 除外</strong>。相对地，lambda2 匿名函数以 [&amp;] 引用传递的方式导入这 3 个局部变量，因此在该函数的内部不就可以访问这 3 个局部变量，还可以任意修改它们。同样，也可以访问甚至修改全局变量。</p>
<blockquote>
<p>感兴趣的读者，可自行尝试在 lambda1 匿名函数中修改 num_1、num_2 或者 num_3 的值，观察编译器的报错信息。</p>
</blockquote>
<p>当然，如果我们想在 lambda1 匿名函数的基础上修改外部变量的值，可以<code>借助 mutable 关键字</code>，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda1 = [=]() <span class="keyword">mutable</span>&#123;</span><br><span class="line">    num_1 = <span class="number">10</span>;</span><br><span class="line">    num_2 = <span class="number">20</span>;</span><br><span class="line">    num_3 = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//函数体内只能使用外部变量，而无法对它们进行修改</span></span><br><span class="line">    cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由此，就可以在 lambda1 匿名函数中修改外部变量的值。但需要注意的是，<strong>这里修改的仅是 num_1、num_2、num_3 拷贝的那一份的值，真正外部变量的值并不会发生改变。</strong></p>
<p>【例 3】执行抛出异常类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> except = []()<span class="built_in">throw</span>(<span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">except</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;捕获到了整形异常&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>捕获到了整形异常</p>
<p>可以看到，except 匿名数组中指定函数体中可以抛出整形异常，因此当函数体中真正发生整形异常时，可以借助 try-catch 块成功捕获并处理。</p>
<p>在此基础上，在看一下反例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> except1 = []()<span class="keyword">noexcept</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">100</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> except2 = []()<span class="built_in">throw</span>(<span class="type">char</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">except1</span>();</span><br><span class="line">        <span class="built_in">except2</span>();</span><br><span class="line">    &#125;<span class="built_in">catch</span>(<span class="type">int</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;捕获到了整形异常&quot;</span>&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此程序运行会直接崩溃，原因很简单，except1 匿名函数指定了函数体中不发生任何异常，但函数体中却发生了整形异常；except2 匿名函数指定函数体可能会发生字符异常，但函数体中却发生了整形异常。由于指定异常类型和真正发生的异常类型不匹配，导致 try-catch 无法捕获，最终程序运行崩溃。</p>
<blockquote>
<p>如果不使用 noexcept 或者 throw()，则 lambda 匿名函数的函数体中允许发生任何类型的异常。</p>
</blockquote>
<p>注意：</p>
<ol>
<li></li>
</ol>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241010193201243.png" alt="image-20241010193201243"></p>
<p>左边，编译器编译时，进入f的id是0而不是42</p>
<p>而右边传入的是引用，调用f前已经是42了</p>
<p>2.lambda可以和仿函数进行互换，一般都会写lambda，看着比较简洁</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241010193526320.png" alt="image-20241010193526320"></p>
<h2 id="18-Rvalue-references（右值引用）"><a href="#18-Rvalue-references（右值引用）" class="headerlink" title="18.Rvalue references（右值引用）"></a>18.Rvalue references（右值引用）</h2><p>右值引用是一种新的 C++ 语法，理解起来有难度的是基于右值引用引申出的 2 种 C++ 编程技巧，分别为移动语义和完美转发。</p>
<h3 id="C-左值和右值"><a href="#C-左值和右值" class="headerlink" title="C++左值和右值"></a>C++左值和右值</h3><p>右值引用可以从字面意思上理解，指的是以引用传递（而非值传递）的方式使用 C++ 右值。接下来给大家介绍什么是 C++ 右值。</p>
<p>在 C++ 或者 C 语言中，一个表达式（可以是字面量、变量、对象、函数的返回值等）根据其使用场景不同，分为左值表达式和右值表达式。确切的说 C++ 中左值和右值的概念是从 C 语言继承过来的。</p>
<blockquote>
<p>值得一提的是，左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是”left value”、“right value” 的缩写，其实不然。lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 “read value”，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。</p>
</blockquote>
<p>通常情况下，判断某个表达式是左值还是右值，最常用的有以下 2 种方法。</p>
<p>1.可位于赋值号（&#x3D;）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="number">5</span> = a; <span class="comment">//错误，5 不能为左值</span></span><br></pre></td></tr></table></figure>

<p>其中，变量 a 就是一个左值，而字面量 5 就是一个右值。值得一提的是，C++ 中的左值也可以当做右值使用，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="number">10</span>; <span class="comment">// b 是一个左值</span></span><br><span class="line">a = b; <span class="comment">// a、b 都是左值，只不过将 b 可以当做右值使用</span></span><br></pre></td></tr></table></figure>

<p>2.有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。</p>
<p>以上面定义的变量 a、b 为例，a 和 b 是变量名，且通过 &amp;a 和 &amp;b 可以获得他们的存储地址，因此 a 和 b 都是左值；反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），因此 5、10 都是右值。</p>
<p>左值：有内存，有名字</p>
<p>右值：没名字，没内存</p>
<blockquote>
<p>注意，以上 2 种判定方法只适用于大部分场景。由于本节主要讲解右值引用，因此这里适可而止，不再对 C++ 左值和右值做深度剖析，感兴趣的读者可自行研究。</p>
</blockquote>
<h3 id="C-右值引用"><a href="#C-右值引用" class="headerlink" title="C++右值引用"></a>C++右值引用</h3><p>前面提到，其实 C++98&#x2F;03 标准中就有引用，使用 “&amp;” 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98&#x2F;03 标准中的引用又称为左值引用。</p>
<p>注意，虽然 C++98&#x2F;03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b = num;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。</p>
<p>为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。</p>
<blockquote>
<p>话说，C++标准委员会在选定右值引用符号时，既希望能选用现有 C++ 内部已有的符号，还不能与 C++ 98 &#x2F;03 标准产生冲突，最终选定了 2 个 ‘&amp;’ 表示右值引用。</p>
</blockquote>
<p>需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>程序输出结果为 100。</p>
<p>另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b = num;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>但这种定义出来的右值引用并<strong>无实际用处</strong>。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。</p>
<table>
<thead>
<tr>
<th>引用类型</th>
<th>可以引用的值类型</th>
<th>使用场景</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>非常量左值</td>
<td>常量左值</td>
<td>非常量右值</td>
<td>常量右值</td>
<td></td>
<td></td>
</tr>
<tr>
<td>非常量左值引用</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>无</td>
</tr>
<tr>
<td>常量左值引用</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>常用于类中构建拷贝构造函数</td>
</tr>
<tr>
<td>非常量右值引用</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>移动语义、完美转发</td>
</tr>
<tr>
<td>常量右值引用</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>无实际用途</td>
</tr>
</tbody></table>
<p>表中，Y 表示支持，N 表示不支持。</p>
<blockquote>
<p>其实，C++11 标准中对右值做了更细致的划分，分别称为纯右值（Pure value，简称 pvalue）和将亡值（eXpiring value，简称 xvalue ）。其中纯右值就是 C++98&#x2F;03 标准中的右值（本节中已经做了大篇幅的讲解），而将亡值则指的是和右值引用相关的表达式（比如某函数返回的 T &amp;&amp; 类型的表达式）。对于纯右值和将亡值，都属于右值，读者知道即可，不必深究。</p>
</blockquote>
<h2 id="19-移动构造函数的功能和用法"><a href="#19-移动构造函数的功能和用法" class="headerlink" title="19.移动构造函数的功能和用法"></a>19.移动构造函数的功能和用法</h2><h3 id="深浅拷贝效率问题"><a href="#深浅拷贝效率问题" class="headerlink" title="深浅拷贝效率问题"></a>深浅拷贝效率问题</h3><p>在 C++ 11 标准之前（C++ 98&#x2F;03 标准中），如果想用其它对象初始化一个同类的新对象，只能借助类中的复制（拷贝）构造函数。拷贝构造函数的实现原理很简单，就是为新对象复制一份和其它对象一模一样的数据。</p>
<blockquote>
<p>需要注意的是，当类中拥有指针类型的成员变量时，拷贝构造函数中需要以深拷贝（而非浅拷贝）的方式复制该指针成员。</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">demo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//拷贝构造函数</span></span><br><span class="line">   <span class="built_in">demo</span>(<span class="type">const</span> demo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*d.num))&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">   ~<span class="built_in">demo</span>()&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;class destruct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">demo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = <span class="built_in">get_demo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如上所示，我们为 demo 类自定义了一个拷贝构造函数。该函数在拷贝 d.num 指针成员时，必须采用深拷贝的方式，即拷贝该指针成员本身的同时，还要拷贝指针指向的内存资源。否则一旦多个对象中的指针成员指向同一块堆空间，这些对象析构时就会对该空间释放多次，这是不允许的。</p>
</blockquote>
<p>可以看到，程序中定义了一个可返回 demo 对象的 get_demo() 函数，用于在 main() 主函数中初始化 a 对象，其整个初始化的流程包含以下几个阶段：</p>
<ol>
<li>执行 get_demo() 函数内部的 demo() 语句，即调用 demo 类的默认构造函数生成一个匿名对象；</li>
<li>执行 return demo() 语句，会调用拷贝构造函数复制一份之前生成的匿名对象，并将其作为 get_demo() 函数的返回值（函数体执行完毕之前，匿名对象会被析构销毁）；</li>
<li>执行 a &#x3D; get_demo() 语句，再调用一次拷贝构造函数，将之前拷贝得到的临时对象复制给 a（此行代码执行完毕，get_demo() 函数返回的对象会被析构）；</li>
<li>程序执行结束前，会自行调用 demo 类的析构函数销毁 a。</li>
</ol>
<p>注意，目前多数编译器都会对程序中发生的拷贝操作进行优化，因此如果我们使用 VS 2017、codeblocks 等这些编译器运行此程序时，看到的往往是优化后的输出结果：</p>
<p>construct!<br>class destruct!</p>
<p>而同样的程序，如果在 Linux 上使用<code>g++ demo.cpp -fno-elide-constructors</code>命令运行（其中 demo.cpp 是程序文件的名称），就可以看到完整的输出结果：</p>
<p>construct! &lt;– 执行 demo()<br>copy construct! &lt;– 执行 return demo()<br>class destruct! &lt;– 销毁 demo() 产生的匿名对象<br>copy construct! &lt;– 执行 a &#x3D; get_demo()<br>class destruct! &lt;– 销毁 get_demo() 返回的临时对象<br>class destruct! &lt;– 销毁 a</p>
<p>如上所示，利用拷贝构造函数实现对 a 对象的初始化，底层实际上进行了 2 次拷贝（而且是深拷贝）操作。当然，对于仅申请少量堆空间的临时对象来说，深拷贝的执行效率依旧可以接受，但如果临时对象中的指针成员申请了大量的堆空间，那么 2 次深拷贝操作势必会影响 a 对象初始化的执行效率。</p>
<blockquote>
<p>事实上，此问题一直存留在以 C++ 98&#x2F;03 标准编写的 C++ 程序中。由于临时变量的产生、销毁以及发生的拷贝操作本身就是很隐晦的（编译器对这些过程做了专门的优化），且并不会影响程序的正确性，因此很少进入程序员的视野。</p>
</blockquote>
<p>那么当类中包含指针类型的成员变量，使用其它对象来初始化同类对象时，怎样才能避免深拷贝导致的效率问题呢？C++11 标准引入了解决方案，该标准中引入了右值引用的语法，借助它可以实现移动语义。</p>
<h3 id="C-移动构造函数（移动语义的具体实现）"><a href="#C-移动构造函数（移动语义的具体实现）" class="headerlink" title="C++移动构造函数（移动语义的具体实现）"></a>C++移动构造函数（移动语义的具体实现）</h3><p>所谓移动语义，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。</p>
<p>以前面程序中的 demo 类为例，该类的成员都包含一个整形的指针成员，其默认指向的是容纳一个整形变量的堆空间。当使用 get_demo() 函数返回的临时对象初始化 a 时，我们只需要将临时对象的 num 指针直接浅拷贝给 a.num，然后修改该临时对象中 num 指针的指向（通常另其指向 NULL），这样就完成了 a.num 的初始化。</p>
<blockquote>
<p>事实上，对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。</p>
</blockquote>
<p>例如，下面程序对 demo 类进行了修改：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">const</span> demo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*d.num))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加移动构造函数</span></span><br><span class="line">    <span class="built_in">demo</span>(demo &amp;&amp;d):<span class="built_in">num</span>(d.num)&#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">demo</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;class destruct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">demo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = <span class="built_in">get_demo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在之前 demo 类的基础上，我们又手动为其添加了一个构造函数。和其它构造函数不同，此构造函数使用右值引用形式的参数，又称为移动构造函数。并且在此构造函数中，num 指针变量采用的是浅拷贝的复制方式，同时在函数内部重置了 d.num，有效避免了“同一块对空间被释放多次”情况的发生。</p>
<p>在 Linux 系统中使用<code>g++ demo.cpp -o demo.exe -std=c++0x -fno-elide-constructors</code>命令执行此程序，输出结果为：</p>
<p>construct!<br>move construct!<br>class destruct!<br>move construct!<br>class destruct!<br>class destruct!</p>
<p>通过执行结果我们不难得知，当为 demo 类添加移动构造函数之后，使用临时对象初始化 a 对象过程中产生的 2 次拷贝操作，都转由移动构造函数完成。</p>
<p>我们知道，非 const 右值引用只能操作右值，程序执行结果中产生的临时对象（例如函数返回值、lambda 表达式等）既无名称也无法获取其存储地址，所以属于右值。当类中同时包含拷贝构造函数和移动构造函数时，如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。</p>
<blockquote>
<p>在实际开发中，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数，由此当用户利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数。</p>
</blockquote>
<p>如果使用左值初始化同类对象，但也想调用移动构造函数完成，有没有办法可以实现呢？</p>
<p>默认情况下，左值初始化同类对象只能通过拷贝构造函数完成，如果想调用移动构造函数，则必须使用右值进行初始化。C++11 标准中为了满足用户使用左值初始化同类对象时也通过移动构造函数完成的需求，新引入了 std::move() 函数，它可以将左值强制转换成对应的右值，由此便可以使用移动构造函数。</p>
<h2 id="20-move-函数：将左值强制转换为右值"><a href="#20-move-函数：将左值强制转换为右值" class="headerlink" title="20. move()函数：将左值强制转换为右值"></a>20. move()函数：将左值强制转换为右值</h2><p>C++11 标准中借助右值引用可以为指定类添加移动构造函数，这样当使用该类的右值对象（可以理解为临时对象）初始化同类对象时，编译器会优先选择移动构造函数。</p>
<p>注意，移动构造函数的调用时机是：<strong>用同类的右值对象初始化新对象</strong>。那么，用当前类的左值对象（有名称，能获取其存储地址的实例对象）初始化同类对象时，是否就无法调用移动构造函数了呢？当然不是，C++11 标准中已经给出了解决方案，即调用 move() 函数。</p>
<p>move 本意为 “移动”，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。</p>
<blockquote>
<p>基于 move() 函数特殊的功能，其常用于实现移动语义。</p>
</blockquote>
<p>move() 函数的用法也很简单，其语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">move</span>( arg )</span><br></pre></td></tr></table></figure>

<p>其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。</p>
<p>【例 1】move() 函数的基础应用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">movedemo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">movedemo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">movedemo</span>(<span class="type">const</span> movedemo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*d.num))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">movedemo</span>(movedemo &amp;&amp;d):<span class="built_in">num</span>(d.num)&#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:     <span class="comment">//这里应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    movedemo demo;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;demo2:\n&quot;</span>;</span><br><span class="line">    movedemo demo2 = demo;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; *demo2.num &lt;&lt; endl;   //可以执行</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;demo3:\n&quot;</span>;</span><br><span class="line">    movedemo demo3 = std::<span class="built_in">move</span>(demo);</span><br><span class="line">    <span class="comment">//此时 demo.num = NULL，因此下面代码会报运行时错误</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; *demo.num &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>construct!<br>demo2:<br>copy construct!<br>demo3:<br>move construct!</p>
<p>通过观察程序的输出结果，以及对比 demo2 和 demo3 初始化操作不难得知，demo 对象作为左值，直接用于初始化 demo2 对象，其底层调用的是拷贝构造函数；而通过调用 move() 函数可以得到 demo 对象的右值形式，用其初始化 demo3 对象，编译器会优先调用移动构造函数。</p>
<blockquote>
<p>注意，调用拷贝构造函数，并不影响 demo 对象，但如果调用移动构造函数，由于函数内部会重置 demo.num 指针的指向为 NULL，所以程序中第 30 行代码会导致程序运行时发生错误。</p>
</blockquote>
<p>【例 2】灵活使用 move() 函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">first</span>() :<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">first</span>(first &amp;&amp;d) :<span class="built_in">num</span>(d.num) &#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;first move construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:    <span class="comment">//这里应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">second</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">second</span>() :<span class="built_in">fir</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">//用 first 类的移动构造函数初始化 fir</span></span><br><span class="line">    <span class="built_in">second</span>(second &amp;&amp; sec) :<span class="built_in">fir</span>(<span class="built_in">move</span>(sec.fir)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;second move construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:    <span class="comment">//这里也应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    first fir;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    second oth;</span><br><span class="line">    second oth2 = <span class="built_in">move</span>(oth);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; *oth.fir.num &lt;&lt; endl;   //程序报运行时错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>construct!<br>first move construct!<br>second move construct</p>
<p>程序中分别构建了 first 和 second 这 2 个类，其中 second 类中包含一个 first 类对象。如果读者仔细观察不难发现，程序中使用了 2 此 move() 函数：</p>
<ul>
<li>由于 oth 为左值，如果想调用移动构造函数为 oth2 初始化，需先利用 move() 函数生成一个 oth 的右值版本；</li>
<li>oth 对象内部还包含一个 first 类对象，对于 oth.fir 来说，其也是一个左值，所以在初始化 oth.fir 时，还需要再调用一次 move() 函数。</li>
</ul>
<p>注意：一旦作为move的参数被使用后，下面的代码不能使用该参数，因为这样的行为是没有定义过的，是不安全的</p>
<h2 id="21-Perfect-Forwarding-完美转发及其实现"><a href="#21-Perfect-Forwarding-完美转发及其实现" class="headerlink" title="21.Perfect Forwarding 完美转发及其实现"></a>21.Perfect Forwarding 完美转发及其实现</h2><p>C++11 标准为 C++ 引入右值引用语法的同时，还解决了一个 C++ 98&#x2F;03 标准长期存在的短板，即使用简单的方式即可在函数模板中实现参数的完美转发。</p>
<p>首先解释一下什么是完美转发，它指的是函数模板可以将自己的参数“完美”地转发给内部调用的其它函数。所谓完美，即不仅能准确地转发参数的值，<strong>还能保证被转发参数的左、右值属性不变。</strong></p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，function() 函数模板中调用了 otherdef() 函数。在此基础上，完美转发指的是：如果 function() 函数接收到的参数 t 为左值，那么该函数传递给 otherdef() 的参数 t 也是左值；反之如果 function() 函数接收到的参数 t 为右值，那么传递给 otherdef() 函数的参数 t 也必须为右值。</p>
<p>显然，function() 函数模板并没有实现完美转发。一方面，参数 t 为非引用类型，这意味着在调用 function() 函数时，实参将值传递给形参的过程就需要额外进行一次拷贝操作；另一方面，无论调用 function() 函数模板时传递给参数 t 的是左值还是右值，对于函数内部的参数 t 来说，它有自己的名称，也可以获取它的存储地址，因此它永远都是左值，也就是说，传递给 otherdef() 函数的参数 t 永远都是左值。总之，无论从那个角度看，function() 函数的定义都不“完美”。</p>
<blockquote>
<p>读者可能会问，完美转发这样严苛的参数传递机制，很常用吗？C++98&#x2F;03 标准中几乎不会用到，但 C++11 标准为 C++ 引入了右值引用和移动语义，因此很多场景中是否实现完美转发，直接决定了该参数的传递过程使用的是拷贝语义（调用拷贝构造函数）还是移动语义（调用移动构造函数）。</p>
</blockquote>
<p>事实上，C++98&#x2F;03 标准下的 C++ 也可以实现完美转发，只是实现方式比较笨拙。通过前面的学习我们知道，C++ 98&#x2F;03 标准中只有左值引用，并且可以细分为非 const 引用和 const 引用。其中，使用非 const 引用作为函数模板参数时，只能接收左值，无法接收右值；而 const 左值引用既可以接收左值，也可以接收右值，但考虑到其 const 属性，除非被调用函数的参数也是 const 属性，否则将无法直接传递。</p>
<p>这也就意味着，单独使用任何一种引用形式，可以实现转发，但无法保证完美。因此如果使用 C++ 98&#x2F;03 标准下的 C++ 语言，我们可以采用函数模板重载的方式实现完美转发，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//重载被调用函数，查看完美转发的效果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">otherdef</span><span class="params">(<span class="type">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">otherdef</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载函数模板，分别接收左值和右值</span></span><br><span class="line"><span class="comment">//接收右值参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收左值参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">function</span>(<span class="number">5</span>);<span class="comment">//5 是右值</span></span><br><span class="line">    <span class="type">int</span>  x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">function</span>(x);<span class="comment">//x 是左值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>rvalue<br>lvalue</p>
<p>从输出结果中可以看到，对于右值 5 来说，它实际调用的参数类型为 const T&amp; 的函数模板，由于 t 为 const 类型，所以 otherdef() 函数实际调用的也是参数用 const 修饰的函数，所以输出“rvalue”；对于左值 x 来说，2 个重载模板函数都适用，C++编译器会选择最适合的参数类型为 T&amp; 的函数模板，进而 therdef() 函数实际调用的是参数类型为非 const 的函数，输出“lvalue”。</p>
<p>显然，使用重载的模板函数实现完美转发也是有弊端的，此实现方式仅适用于模板函数仅有少量参数的情况，否则就需要编写大量的重载函数模板，造成代码的冗余。为了方便用户更快速地实现完美转发，C++ 11 标准中允许在函数模板中使用右值引用来实现完美转发。</p>
<p>C++11 标准中规定，通常情况下右值引用形式的参数只能接收右值，不能接收左值。但对于函数模板中使用右值引用语法定义的参数来说，它不再遵守这一规定，既可以接收右值，也可以接收左值（此时的右值引用又被称为“万能引用”）。</p>
<p>仍以 function() 函数为例，在 C++11 标准中实现完美转发，只需要编写如下一个模板函数即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此模板函数的参数 t 既可以接收左值，也可以接收右值。但仅仅使用右值引用作为函数模板的参数是远远不够的，还有一个问题继续解决，即如果调用 function() 函数时为其传递一个左值引用或者右值引用的实参，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp; num = n;</span><br><span class="line"><span class="built_in">function</span>(num); <span class="comment">// T 为 int&amp;</span></span><br><span class="line"><span class="type">int</span> &amp;&amp; num2 = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">function</span>(num2); <span class="comment">// T 为 int &amp;&amp;</span></span><br></pre></td></tr></table></figure>

<p>其中，由 function(num) 实例化的函数底层就变成了 function(int &amp; &amp; t)，同样由 function(num2) 实例化的函数底层则变成了 function(int &amp;&amp; &amp;&amp; t)。要知道，C++98&#x2F;03 标准是不支持这种用法的，而 C++ 11标准为了更好地实现完美转发，特意为其指定了新的类型匹配规则，又称为引用折叠规则（假设用 A 表示实际传递参数的类型）：</p>
<ul>
<li>当实参为左值或者左值引用（A&amp;）时，函数模板中 T&amp;&amp; 将转变为 A&amp;（A&amp; &amp;&amp; &#x3D; A&amp;）；</li>
<li>当实参为右值或者右值引用（A&amp;&amp;）时，函数模板中 T&amp;&amp; 将转变为 A&amp;&amp;（A&amp;&amp; &amp;&amp; &#x3D; A&amp;&amp;）。</li>
</ul>
<blockquote>
<p>我们只需要知道，在实现完美转发时，只要函数模板的参数类型为 T&amp;&amp;，则 C++ 可以自行准确地判定出实际传入的实参是左值还是右值。</p>
</blockquote>
<p>通过将函数模板的形参类型设置为 T&amp;&amp;，我们可以很好地解决接收左、右值的问题。但除此之外，还需要解决一个问题，即无论传入的形参是左值还是右值，对于函数模板内部来说，形参既有名称又能寻址，因此它都是左值。那么如何才能将函数模板接收到的形参连同其左、右值属性，一起传递给被调用的函数呢？</p>
<p>C++11 标准的开发者已经帮我们想好的解决方案，该新标准还引入了一个模板函数 forword()，我们只需要调用该函数，就可以很方便地解决此问题。仍以 function 模板函数为例，如下演示了该函数模板的用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//重载被调用函数，查看完美转发的效果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">otherdef</span><span class="params">(<span class="type">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">otherdef</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现完美转发的函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">function</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="type">int</span>  x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">function</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>rvalue<br>lvalue</p>
<p>注意程序中第 12~16 行，此 function() 模板函数才是实现完美转发的最终版本。可以看到，forword() 函数模板用于修饰被调用函数中需要维持参数左、右值属性的参数。</p>
<p>总的来说，在定义模板函数时，我们采用右值引用的语法格式定义参数类型，由此该函数既可以接收外界传入的左值，也可以接收右值；其次，还需要使用 C++11 标准库提供的 forword() 模板函数修饰被调用函数中需要维持左、右值属性的参数。由此即可轻松实现函数模板中参数的完美转发。</p>
<h2 id="22-array容器"><a href="#22-array容器" class="headerlink" title="22.array容器"></a>22.array容器</h2><p>同 5 .</p>
<h2 id="23-hashtable-无序容器"><a href="#23-hashtable-无序容器" class="headerlink" title="23.hashtable 无序容器"></a>23.hashtable 无序容器</h2><p>C++11 引入了两组无序容器： </p>
<p><code>std::unordered_set/std::unordered_multiset</code></p>
<p><code>std::unordered_map/std::unordered_multimap</code>。</p>
<p>无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)。</p>
<p>背后底层是哈希表</p>
<h2 id="24-tuple"><a href="#24-tuple" class="headerlink" title="24.tuple"></a>24.tuple</h2><p>C++11 标准新引入了<strong>一种类模板</strong>，命名为 <strong>tuple</strong>（中文可直译为元组）。tuple 最大的特点是：<strong>实例化的对象可以存储任意数量、任意类型的数据。</strong></p>
<p>tuple 的应用场景很广泛，例如当需要存储多个不同类型的元素时，可以使用 tuple；当函数需要返回多个数据时，可以将这些数据存储在 tuple 中，函数只需返回一个 tuple 对象即可。</p>
<h3 id="tuple对象的创建"><a href="#tuple对象的创建" class="headerlink" title="tuple对象的创建"></a>tuple对象的创建</h3><p>tuple 本质是一个以可变模板参数定义的类模板，它定义在 头文件并位于 std 命名空间中。因此要想使用 tuple 类模板，程序中需要首先引入以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::tuple;</span><br></pre></td></tr></table></figure>

<p>实例化 tuple 模板类对象常用的方法有两种，一种是借助该类的构造函数，另一种是借助 make_tuple() 函数。</p>
<h5 id="1-类的构造函数"><a href="#1-类的构造函数" class="headerlink" title="1) 类的构造函数"></a>1) 类的构造函数</h5><p>tuple 模板类提供有很多构造函数，包括：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>) 默认构造函数</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">tuple</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">2</span>) 拷贝构造函数</span><br><span class="line"><span class="built_in">tuple</span> (<span class="type">const</span> tuple&amp; tpl);</span><br><span class="line"><span class="number">3</span>) 移动构造函数</span><br><span class="line"><span class="built_in">tuple</span> (tuple&amp;&amp; tpl);</span><br><span class="line"><span class="number">4</span>) 隐式类型转换构造函数</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... UTypes&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (<span class="type">const</span> tuple&lt;UTypes...&gt;&amp; tpl); <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... UTypes&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (tuple&lt;UTypes...&gt;&amp;&amp; tpl);      <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">5</span>) 支持初始化列表的构造函数</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">tuple</span> <span class="params">(<span class="type">const</span> Types&amp;... elems)</span></span>;  <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... UTypes&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">tuple</span> <span class="params">(UTypes&amp;&amp;... elems)</span></span>;  <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">6</span>) 将pair对象转换为tuple对象</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U1</span>, <span class="keyword">class</span> <span class="title class_">U2</span>&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (<span class="type">const</span> pair&lt;U1,U2&gt;&amp; pr);       <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U1</span>, <span class="keyword">class</span> <span class="title class_">U2</span>&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (pair&lt;U1,U2&gt;&amp;&amp; pr);            <span class="comment">//右值方式</span></span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span>        <span class="comment">// std::tuple</span></span></span><br><span class="line"><span class="keyword">using</span> std::tuple;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; first;                             <span class="comment">// 1)   first&#123;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">second</span><span class="params">(first)</span></span>;                     <span class="comment">// 2)   second&#123;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">third</span><span class="params">(std::make_tuple(<span class="number">20</span>, <span class="string">&#x27;b&#x27;</span>))</span></span>;   <span class="comment">// 3)   third&#123;20,&#x27;b&#x27;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">long</span>, <span class="type">char</span>&gt; <span class="title">fourth</span><span class="params">(third)</span></span>;                    <span class="comment">// 4)的左值方式, fourth&#123;20,&#x27;b&#x27;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">fifth</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;                    <span class="comment">// 5)的右值方式, fifth&#123;10.&#x27;a&#x27;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">sixth</span><span class="params">(std::make_pair(<span class="number">30</span>, <span class="string">&#x27;c&#x27;</span>))</span></span>;    <span class="comment">// 6)的右值方式, sixth&#123;30,&#x27;&#x27;c&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-make-tuple-函数"><a href="#2-make-tuple-函数" class="headerlink" title="2) make_tuple()函数"></a>2) make_tuple()函数</h5><p>上面程序中，我们已经用到了 make_tuple() 函数，它以模板的形式定义在 头文件中，功能是创建一个 tuple 右值对象（或者临时对象）。</p>
<p>对于 make_tuple() 函数创建了 tuple 对象，我们可以上面程序中那样作为移动构造函数的参数，也可以这样用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = std::<span class="built_in">make_tuple</span> (<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>);   <span class="comment">// tuple &lt; int, char &gt;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">0</span>; <span class="type">int</span> b[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">auto</span> second = std::<span class="built_in">make_tuple</span> (a,b);     <span class="comment">// tuple &lt; int, int* &gt;</span></span><br></pre></td></tr></table></figure>

<p>程序中分别创建了 first 和 second 两个 tuple 对象，它们的类型可以直接用 auto 表示。</p>
<h3 id="tuple常用函数"><a href="#tuple常用函数" class="headerlink" title="tuple常用函数"></a>tuple常用函数</h3><p>tupe 模板类提供了一个功能实用的成员函数， 头文件中也提供了一些和操作 tuple 对象相关的函数模板和类模板，如表 1 所示。</p>
<table>
<thead>
<tr>
<th>函数或类模板</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>tup1.swap(tup2) swap(tup1, tup2)</td>
<td>tup1 和 tup2 表示类型相同的两个 tuple 对象，tuple 模板类中定义有一个 swap() 成员函数， 头文件还提供了一个同名的 swap() 全局函数。 swap() 函数的功能是交换两个 tuple 对象存储的内容。</td>
</tr>
<tr>
<td>get(tup)</td>
<td>tup 表示某个 tuple 对象，num 是一个整数，get() 是 头文件提供的全局函数，功能是返回 tup 对象中第 num+1 个元素。</td>
</tr>
<tr>
<td>tuple_size::value</td>
<td>tuple_size 是定义在 头文件的类模板，它只有一个成员变量 value，功能是获取某个 tuple 对象中元素的个数，type 为该tuple 对象的类型。</td>
</tr>
<tr>
<td>tuple_element&lt;I, type&gt;::type</td>
<td>tuple_element 是定义在 头文件的类模板，它只有一个成员变量 type，功能是获取某个 tuple 对象第 I+1 个元素的类型。</td>
</tr>
<tr>
<td>forward_as_tuple&lt;args…&gt;</td>
<td>args… 表示 tuple 对象存储的多个元素，该函数的功能是创建一个 tuple 对象，内部存储的 args… 元素都是右值引用形式的。</td>
</tr>
<tr>
<td>tie(args…) &#x3D; tup</td>
<td>tup 表示某个 tuple 对象，tie() 是 头文件提供的，功能是将 tup 内存储的元素逐一赋值给 args… 指定的左值变量。</td>
</tr>
<tr>
<td>tuple_cat(args…)</td>
<td>args… 表示多个 tuple 对象，该函数是 头文件提供的，功能是创建一个 tuple 对象，此对象包含 args… 指定的所有 tuple 对象内的元素。</td>
</tr>
</tbody></table>
<blockquote>
<p>tuple 模板类对赋值运算符 &#x3D; 进行了重载，使得同类型的 tuple 对象可以直接赋值。此外，tuple 模板类还重载了 &#x3D;&#x3D;、!&#x3D;、&lt;、&gt;、&gt;&#x3D;、&lt;&#x3D; 这几个比较运算符，同类型的 tuple 对象可以相互比较（逐个比较各个元素）。</p>
</blockquote>
<p>下面的程序给您演示了表 1 中一部分函数模板和类模板的功能：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//创建一个 tuple 对象存储 10 和 &#x27;x&#x27;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">mytuple</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//计算 mytuple 存储元素的个数</span></span><br><span class="line">    size = std::tuple_size&lt;<span class="keyword">decltype</span>(mytuple)&gt;::value;</span><br><span class="line">    <span class="comment">//输出 mytuple 中存储的元素</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(mytuple) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//修改指定的元素</span></span><br><span class="line">    std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//使用 makde_tuple() 创建一个 tuple 对象</span></span><br><span class="line">    <span class="keyword">auto</span> bar = std::<span class="built_in">make_tuple</span>(<span class="string">&quot;test&quot;</span>, <span class="number">3.1</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="comment">//拆解 bar 对象，分别赋值给 mystr、mydou、myint</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* mystr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">double</span> mydou;</span><br><span class="line">    <span class="type">int</span> myint;</span><br><span class="line">    <span class="comment">//使用 tie() 时，如果不想接受某个元素的值，实参可以用 std::ignore 代替</span></span><br><span class="line">    std::<span class="built_in">tie</span>(mystr, mydou, myint) = bar;</span><br><span class="line">    <span class="comment">//std::tie(std::ignore, std::ignore, myint) = bar;  //只接收第 3 个整形值</span></span><br><span class="line">    <span class="comment">//将 mytuple 和 bar 中的元素整合到 1 个 tuple 对象中</span></span><br><span class="line">    <span class="keyword">auto</span> mycat = std::<span class="built_in">tuple_cat</span>(mytuple, bar);</span><br><span class="line">    size = std::tuple_size&lt;<span class="keyword">decltype</span>(mycat)&gt;::value;</span><br><span class="line">    std::cout &lt;&lt; size &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>10 x<br>100<br>5</p>
<h2 id="25-union-非受限联合体"><a href="#25-union-非受限联合体" class="headerlink" title="25.union 非受限联合体"></a>25.union 非受限联合体</h2><p>在 C&#x2F;<a href="http://c.biancheng.net/cplus/">C++</a> 中，联合体（Union）是一种构造数据类型。在一个联合体内，我们可以定义多个不同类型的成员，这些成员将会共享同一块内存空间。老版本的 C++ 为了和C语言保持兼容，对联合体的数据成员的类型进行了很大程度的限制，这些限制在今天看来并没有必要，因此 C++11 取消了这些限制。</p>
<p>C++11 标准规定，任何非引用类型都可以成为联合体的数据成员，这种联合体也被称为非受限联合体。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">bool</span> g, <span class="type">int</span> a): <span class="built_in">gender</span>(g), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> gender;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">T</span>&#123;</span><br><span class="line">    Student s;  <span class="comment">// 含有非POD类型的成员，gcc-5.1.0  版本报错</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，因为 Student 类带有自定义的构造函数，所以是一个非 POD 类型的，这导致编译器报错。这种规定只是 C++ 为了兼容C语言而制定，然而在长期的编程实践中发现，这种规定是没有必要的。</p>
<p>接下来，我们具体看一下 C++11 对 C++98 的改进。</p>
<h5 id="1-C-11-允许非-POD-类型"><a href="#1-C-11-允许非-POD-类型" class="headerlink" title="1. C++11 允许非 POD 类型"></a>1. C++11 允许非 POD 类型</h5><p>C++98 不允许联合体的成员是非 POD 类型，但是 C++1 1 取消了这种限制。</p>
<p>POD 是 C++ 中一个比较重要的概念，在这里我们做一个简单介绍。POD 是英文 Plain Old Data 的缩写，用来描述一个类型的属性。</p>
<p>POD 类型一般具有以下几种特征（包括 class、union 和 struct等）：</p>
<ol>
<li>没有用户自定义的构造函数、析构函数、拷贝构造函数和移动构造函数。</li>
<li>不能包含虚函数和虚基类。</li>
<li>非静态成员必须声明为 public。</li>
<li>类中的第一个非静态成员的类型与其基类不同，例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B2</span> : B1 &#123; B1 b; &#125;;</span><br></pre></td></tr></table></figure>

<p>class B2 的第一个非静态成员 b 是基类类型，所以它不是 POD 类型。</p>
<ol>
<li>在类或者结构体继承时，满足以下两种情况之一：</li>
</ol>
<ul>
<li>派生类中有非静态成员，且只有一个仅包含静态成员的基类；</li>
<li>基类有非静态成员，而派生类没有非静态成员。</li>
</ul>
<p>我们来看具体的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span> &#123; <span class="type">static</span> <span class="type">int</span> n; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B2</span> : B1 &#123; <span class="type">int</span> n1; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B3</span> : B2 &#123; <span class="type">static</span> <span class="type">int</span> n2; &#125;;</span><br></pre></td></tr></table></figure>

<p>对于 B2，派生类 B2 中有非静态成员，且只有一个仅包含静态成员的基类 B1，所以它是 POD 类型。对于 B3，基类 B2 有非静态成员，而派生类 B3 没有非静态成员，所以它也是 POD 类型。</p>
<ol>
<li>所有非静态数据成员均和其基类也符合上述规则（递归定义），也就是说 POD 类型不能包含非 POD 类型的数据。</li>
<li>此外，所有兼容C语言的数据类型都是 POD 类型（struct、union 等不能违背上述规则）。</li>
</ol>
<h5 id="2-C-11-允许联合体有静态成员"><a href="#2-C-11-允许联合体有静态成员" class="headerlink" title="2. C++11 允许联合体有静态成员"></a>2. C++11 允许联合体有静态成员</h5><p>C++11 删除了联合体不允许拥有静态成员的限制。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">U</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，静态成员变量只能在联合体内定义，却不能在联合体外使用，这使得该规则很没用。</p>
<h3 id="非受限联合体的赋值注意事项"><a href="#非受限联合体的赋值注意事项" class="headerlink" title="非受限联合体的赋值注意事项"></a>非受限联合体的赋值注意事项</h3><p>C++11 规定，如果非受限联合体内有一个非 POD 的成员，而该成员拥有自定义的构造函数，那么这个非受限联合体的默认构造函数将被编译器删除；其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值操作符以及析构函数等，也将被删除。</p>
<p>这条规则可能导致对象构造失败，请看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">U</span> &#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;   <span class="comment">// 构造失败，因为 U 的构造函数被删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，因为 string 类拥有自定义的构造函数，所以 U 的构造函数被删除；定义 U 的类型变量 u 需要调用默认构造函数，所以 u 也就无法定义成功。</p>
<p>解决上面问题的一般需要用到 placement new（稍后会讲解这个概念），代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">U</span> &#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">U</span>() &#123; <span class="keyword">new</span>(&amp;s) string; &#125;</span><br><span class="line">    ~<span class="built_in">U</span>() &#123; s.~<span class="built_in">string</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造时，采用 placement new 将 s 构造在其地址 &amp;s 上，这里 placement new 的唯一作用只是调用了一下 string 类的构造函数。注意，在析构时还需要调用 string 类的析构函数。</p>
<h5 id="placement-new-是什么？"><a href="#placement-new-是什么？" class="headerlink" title="placement new 是什么？"></a>placement new 是什么？</h5><p>placement new 是 new 关键字的一种进阶用法，既可以在栈（stack）上生成对象，也可以在堆（heap）上生成对象。相对应地，我们把常见的 new 的用法称为 operator new，它只能在 heap 上生成对象。</p>
<p>placement new 的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span>(address) <span class="built_in">ClassConstruct</span>(…)</span><br></pre></td></tr></table></figure>

<p>address 表示已有内存的地址，该内存可以在栈上，也可以在堆上；ClassConstruct(…) 表示调用类的构造函数，如果构造函数没有参数，也可以省略括号。</p>
<p>placement new 利用已经申请好的内存来生成对象，它不再为对象分配新的内存，而是将对象数据放在 address 指定的内存中。在本例中，placement new 使用的是 s 的内存空间。</p>
<h3 id="非受限联合体的匿名声明和“枚举式类”"><a href="#非受限联合体的匿名声明和“枚举式类”" class="headerlink" title="非受限联合体的匿名声明和“枚举式类”"></a>非受限联合体的匿名声明和“枚举式类”</h3><p>匿名联合体是指不具名的联合体（也即没有名字的联合体），一般定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">U</span>&#123;</span><br><span class="line"><span class="keyword">union</span> &#123; <span class="type">int</span> x; &#125;; <span class="comment">//此联合体为匿名联合体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，联合体 U 内定义了一个不具名的联合体，该联合体包含一个 int 类型的成员变量，我们称这个联合体为匿名联合体。</p>
<p>同样的，非受限联合体也可以匿名，而当非受限的匿名联合体运用于类的声明时，这样的类被称为“枚举式类”。示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">bool</span> g, <span class="type">int</span> a): <span class="built_in">gender</span>(g), <span class="built_in">age</span>(a)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> gender;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span> &#123; STUDENT, NATIVE, FOREIGENR &#125;;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="type">bool</span> g, <span class="type">int</span> a) : <span class="built_in">s</span>(g, a) &#123; t = STUDENT; &#125;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="type">int</span> i) : <span class="built_in">id</span>(i) &#123; t = NATIVE; &#125;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="type">const</span> <span class="type">char</span>* n, <span class="type">int</span> s) &#123;</span><br><span class="line">        <span class="type">int</span> size = (s &gt; <span class="number">9</span>) ? <span class="number">9</span> : s;</span><br><span class="line">        <span class="built_in">memcpy</span>(name , n, size);</span><br><span class="line">        name[s] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        t = FOREIGENR;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Singer</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type t;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Student s;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="literal">true</span>, <span class="number">13</span>);</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="number">310217</span>);</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="string">&quot;J Michael&quot;</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中使用了一个匿名非受限联合体，它作为类 Singer 的“变长成员”来使用，这样的变长成员给类的编写带来了更大的灵活性，这是 C++98 标准中无法达到的（编译器会报<code>member &#39;Student Singer::&lt;anonymous union&gt;::s&#39; with constructor not allowed in union</code>错误）。</p>
<h2 id="26-constexpr：验证是否为常量表达式"><a href="#26-constexpr：验证是否为常量表达式" class="headerlink" title="26.constexpr：验证是否为常量表达式"></a>26.constexpr：验证是否为常量表达式</h2><p>constexpr 是 C++ 11 标准新引入的关键字，不过在讲解其具体用法和功能之前，读者需要先搞清楚 C++ 常量表达式的含义。</p>
<p>所谓常量表达式，指的就是由多个（≥1）常量组成的表达式。换句话说，如果表达式中的成员都是常量，那么该表达式就是一个常量表达式。这也意味着，常量表达式一旦确定，其值将无法修改。</p>
<p>实际开发中，我们经常会用到常量表达式。以定义数组为例，数组的长度就必须是一个常量表达式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1)</span></span><br><span class="line"><span class="type">int</span> url[<span class="number">10</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 2)</span></span><br><span class="line"><span class="type">int</span> url[<span class="number">6</span> + <span class="number">4</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 3)</span></span><br><span class="line"><span class="type">int</span> length = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> url[length];<span class="comment">//错误，length是变量</span></span><br></pre></td></tr></table></figure>

<p>上述代码演示了 3 种定义 url 数组的方式，其中第 1、2 种定义 url 数组时，长度分别为 10 和 6+4，显然它们都是常量表达式，可以用于表示数组的长度；第 3 种 url 数组的长度为 length，它是变量而非常量，因此不是一个常量表达式，无法用于表示数组的长度。</p>
<blockquote>
<p>常量表达式的应用场景还有很多，比如匿名枚举、switch-case 结构中的 case 表达式等，感兴趣的读者可自行编码测试，这里不再过多举例。</p>
</blockquote>
<p>我们知道，C++ 程序的执行过程大致要经历编译、链接、运行这 3 个阶段。值得一提的是，常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果；而常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p>
<p>对于用 C++ 编写的程序，性能往往是永恒的追求。那么在实际开发中，如何才能判定一个表达式是否为常量表达式，进而获得在编译阶段即可执行的“特权”呢？除了人为判定外，C++11 标准还提供有 constexpr 关键字。</p>
<p>constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。</p>
<blockquote>
<p>注意，获得在编译阶段计算出结果的能力，并不代表 constexpr 修饰的表达式一定会在程序编译阶段被执行，具体的计算时机还是编译器说了算。</p>
</blockquote>
<h3 id="constexpr修饰普通变量"><a href="#constexpr修饰普通变量" class="headerlink" title="constexpr修饰普通变量"></a>constexpr修饰普通变量</h3><p>C++11 标准中，定义变量时可以用 constexpr 修饰，从而使该变量获得在编译阶段即可计算出结果的能力。</p>
<p>值得一提的是，使用 constexpr 修改普通变量时，变量必须经过初始化且初始值必须是一个常量表达式。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> num = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> url[num] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    couts&lt;&lt; url[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>2</p>
<blockquote>
<p>读者可尝试将 constexpr 删除，此时编译器会提示“url[num] 定义中 num 不可用作常量”。</p>
</blockquote>
<p>可以看到，程序第 6 行使用 constexpr 修饰 num 变量，同时将 “1+2+3” 这个常量表达式赋值给 num。由此，编译器就可以在编译时期对 num 这个表达式进行计算，因为 num 可以作为定义数组时的长度。</p>
<p>有读者可能发现，将此示例程序中的 constexpr 用 const 关键字替换也可以正常执行，这是因为 num 的定义同时满足“num 是 const 常量且使用常量表达式为其初始化”这 2 个条件，由此编译器会认定 num 是一个常量表达式。</p>
<blockquote>
<p>注意，const 和 constexpr 并不相同，关于它们的区别，我们会在下一节做详细讲解。</p>
</blockquote>
<p>另外需要重点提出的是，当常量表达式中包含浮点数时，考虑到程序编译和运行所在的系统环境可能不同，常量表达式在编译阶段和运行阶段计算出的结果精度很可能会受到影响，因此 C++11 标准规定，浮点常量表达式在编译阶段计算的精度要至少等于（或者高于）运行阶段计算出的精度。</p>
<h3 id="constexpr修饰函数"><a href="#constexpr修饰函数" class="headerlink" title="constexpr修饰函数"></a>constexpr修饰函数</h3><p>constexpr 还可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。</p>
<p>注意，constexpr 并非可以修改任意函数的返回值。换句话说，一个函数要想成为常量表达式函数，必须满足如下 4 个条件。</p>
<ol>
<li>整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这个函数是无法通过编译的，因为该函数的返回值用 constexpr 修饰，但函数内部包含多条语句。</p>
<p>如下是正确的定义 display() 常量表达式函数的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以添加 using 执行、typedef 语句以及 static_assert 断言</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，display() 函数的返回值是用 constexpr 修饰的 int 类型值，且该函数的函数体中只包含一个 return 语句。</p>
<ol>
<li>该函数必须有返回值，即函数的返回值类型不能是 void。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像上面这样定义的返回值类型为 void 的函数，不属于常量表达式函数。原因很简单，因为通过类似的函数根本无法获得一个常量。</p>
<ol>
<li>函数在使用之前，必须有对应的定义语句。我们知道，函数的使用分为“声明”和“定义”两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其它文件中），但常量表达式函数在使用前，必须要有该函数的定义。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//普通函数的声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="type">int</span> a[<span class="built_in">display</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用普通函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">noconst_dis</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数的定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>3<br>6</p>
<blockquote>
<p>读者可自行将 display() 常量表达式函数的定义调整到 main() 函数之后，查看编译器的报错信息。</p>
</blockquote>
<p>可以看到，普通函数在调用时，只需要保证调用位置之前有相应的声明即可；而常量表达式函数则不同，调用位置之前必须要有该函数的定义，否则会导致程序编译失败。</p>
<ol>
<li>return 返回的表达式必须是常量表达式，举个例子：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="type">int</span> a[<span class="built_in">display</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序无法通过编译，编译器报“display(3) 的结果不是常量”的异常。</p>
<p>常量表达式函数的返回值必须是常量表达式的原因很简单，如果想在程序编译阶段获得某个函数返回的常量，则该函数的 return 语句中就不能包含程序运行阶段才能确定值的变量。</p>
<blockquote>
<p>注意，在常量表达式函数的 return 语句中，不能包含赋值的操作（例如 return x&#x3D;1 在常量表达式函数中不允许的）。另外，用 constexpr 修改函数时，函数本身也是支持递归的，感兴趣的读者可自行尝试编码测试。</p>
</blockquote>
<h3 id="constexpr修饰类的构造函数"><a href="#constexpr修饰类的构造函数" class="headerlink" title="constexpr修饰类的构造函数"></a>constexpr修饰类的构造函数</h3><p>对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> mt &#123; <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    cout &lt;&lt; mt.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mt.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此程序是无法通过编译的，编译器会抛出“constexpr不能修饰自定义类型”的异常。</p>
<p>当我们想自定义一个可产生常量的类型时，正确的做法是在该类型的内部添加一个常量构造函数。例如，修改上面的错误示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myType</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">myType</span><span class="params">(<span class="type">char</span> *name,<span class="type">int</span> age)</span>:name(name),age(age)&#123;</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> mt &#123; <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    cout &lt;&lt; mt.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mt.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>zhangsan 10</p>
<p>可以看到，在 myType 结构体中自定义有一个构造函数，借助此函数，用 constexpr 修饰的 myType 类型的 my 常量即可通过编译。</p>
<p>注意，constexpr 修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。</p>
<p>前面提到，constexpr 可用于修饰函数，而类中的成员方法完全可以看做是“位于类这个命名空间中的函数”，所以 constexpr 也可以修饰类中的成员函数，只不过此函数必须满足前面提到的 4 个条件。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myType</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">myType</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,<span class="type">int</span> age)</span>:name(name),age(age)&#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span> * <span class="title">getname</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> mt &#123; <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span> * name = mt.<span class="built_in">getname</span>();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> age = mt.<span class="built_in">getage</span>();</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>zhangsan 10</p>
<blockquote>
<p>注意，C++11 标准中，不支持用 constexpr 修饰带有 virtual 的成员方法。</p>
</blockquote>
<h3 id="constexpr修饰模板函数"><a href="#constexpr修饰模板函数" class="headerlink" title="constexpr修饰模板函数"></a>constexpr修饰模板函数</h3><p>C++11 语法中，constexpr 可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。</p>
<p>针对这种情况下，C++11 标准规定，如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myType</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">dispaly</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">myType</span> stu&#123;<span class="string">&quot;zhangsan&quot;</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">//普通函数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">myType</span> ret = <span class="built_in">dispaly</span>(stu);</span><br><span class="line">    cout &lt;&lt; ret.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ret.age &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//常量表达式函数</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> ret1 = <span class="built_in">dispaly</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; ret1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>zhangsan 10<br>10</p>
<p>可以看到，示例程序中定义了一个模板函数 display()，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：</p>
<ul>
<li>第 20 行代码处，当模板函数中以自定义结构体 myType 类型进行实例化时，由于该结构体中没有定义常量表达式构造函数，所以实例化后的函数不是常量表达式函数，此时 constexpr 是无效的；</li>
<li>第 23 行代码处，模板函数的类型 T 为 int 类型，实例化后的函数符合常量表达式函数的要求，所以该函数的返回值就是一个常量表达式。</li>
</ul>
<h3 id="constexpr和const的区别"><a href="#constexpr和const的区别" class="headerlink" title="constexpr和const的区别"></a>constexpr和const的区别</h3><p>我们知道，constexpr 是 C++ 11 标准新添加的关键字，在此之前（C++ 98&#x2F;03标准）只有 const 关键字，其在实际使用中经常会表现出两种不同的语义。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dis_1</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//错误，x是只读的变量</span></span><br><span class="line">    array &lt;<span class="type">int</span>,x&gt; myarr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; myarr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dis_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    array &lt;<span class="type">int</span>,x&gt; myarr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; myarr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">dis_1</span>(<span class="number">5</span>);</span><br><span class="line">   <span class="built_in">dis_2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，dis_1() 和 dis_2() 函数中都包含一个 const int x，但 dis_1() 函数中的 x 无法完成初始化 array 容器的任务，而 dis_2() 函数中的 x 却可以。</p>
<p>这是因为，dis_1() 函数中的“const int x”只是想强调 x 是一个只读的变量，其本质仍为变量，无法用来初始化 array 容器；而 dis_2() 函数中的“const int x”，表明 x 是一个只读变量的同时，x 还是一个值为 5 的常量，所以可以用来初始化 array 容器。</p>
<p>C++ 11标准中，为了解决 const 关键字的双重语义问题，保留了 const 表示“只读”的语义，而将“常量”的语义划分给了新添加的 constexpr 关键字。因此 C++11 标准中，建议将 const 和 constexpr 的功能区分开，即凡是表达“只读”语义的场景都使用 const，表达“常量”语义的场景都使用 constexpr。</p>
<blockquote>
<p>在上面的实例程序中，dis_2() 函数中使用 const int x 是不规范的，应使用 constexpr 关键字。</p>
</blockquote>
<p>有读者可能会问，“只读”不就意味着其不能被修改吗？答案是否定的，“只读”和“不允许被修改”之间并没有必然的联系，举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp; con_b = a;</span><br><span class="line">    cout &lt;&lt; con_b &lt;&lt; endl;</span><br><span class="line">    a = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; con_b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>10<br>20</p>
<p>可以看到，程序中用 const 修饰了 con_b 变量，表示该变量“只读”，即无法通过变量自身去修改自己的值。但这并不意味着 con_b 的值不能借助其它变量间接改变，通过改变 a 的值就可以使 con_b 的值发生变化。</p>
<p>在大部分实际场景中，const 和 constexpr 是可以混用的，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span> + <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">5</span> + <span class="number">4</span>;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>它们是完全等价的，都可以在程序的编译阶段计算出结果。但在某些场景中，必须明确使用 constexpr，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">sqr1</span><span class="params">(<span class="type">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg*arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">sqr2</span><span class="params">(<span class="type">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg*arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>,sqr1(10)&gt; mylist1;<span class="comment">//可以，因为sqr1时constexpr函数</span></span><br><span class="line">    array&lt;<span class="type">int</span>,sqr2(10)&gt; mylist1;<span class="comment">//不可以，因为sqr2不是constexpr函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，因为 sqr2() 函数的返回值仅有 const 修饰，而没有用更明确的 constexpr 修饰，导致其无法用于初始化 array 容器（只有常量才能初始化 array 容器）。</p>
<p>总的来说在 C++ 11 标准中，const 用于为修饰的变量添加“只读”属性；而 constexpr 关键字则用于指明其后是一个常量（或者常量表达式），编译器在编译程序时可以顺带将其结果计算出来，而无需等到程序运行阶段，这样的优化极大地提高了程序的执行效率。</p>
<h2 id="27-long-long超长整形详解"><a href="#27-long-long超长整形详解" class="headerlink" title="27.long long超长整形详解"></a>27.long long超长整形详解</h2><p>C++ 11 标准中，基于整数大小的考虑，共提供了如表 1 所示的这些数据类型。与此同时，标准中还明确限定了各个数据类型最少占用的位数。</p>
<table>
<thead>
<tr>
<th>整数类型</th>
<th>等价类型</th>
<th>C++11标准规定占用最少位数</th>
</tr>
</thead>
<tbody><tr>
<td>short</td>
<td>short int（有符号短整型）</td>
<td>至少 16 位（2 个字节）</td>
</tr>
<tr>
<td>signed short</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed short int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>unsigned short</td>
<td>unsigned short int（无符号短整型）</td>
<td></td>
</tr>
<tr>
<td>unsigned short int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>int</td>
<td>int（有符号整形）</td>
<td>至少 16 位（2 个字节）</td>
</tr>
<tr>
<td>signed</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>unsigned</td>
<td>unsigned int（无符号整形）</td>
<td></td>
</tr>
<tr>
<td>unsigned int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>long</td>
<td>long int（有符号长整形）</td>
<td>至少 32 位（4 个字节）</td>
</tr>
<tr>
<td>long int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed long</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed long int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>unsigned long</td>
<td>unsigned long int（无符号长整形）</td>
<td></td>
</tr>
<tr>
<td>unsigned long int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>long long（C++11）</td>
<td>long long int（有符号超长整形）</td>
<td>至少 64 位（8 个字节）</td>
</tr>
<tr>
<td>long long int（C++11）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed long long（C++11）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed long long int（C++11）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>unsigned long long（C++11）</td>
<td>unsigned long long int（无符号超长整型）</td>
<td></td>
</tr>
<tr>
<td>unsigned long long int（C++11）</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>C++11 标准规定，每种整数类型必须同时具备有符号（signed）和无符号（unsigned）两种类型，且每种具体的有符号整形和无符号整形所占用的存储空间（也就是位数）必须相同。注意，C++11 标准中只限定了每种类型最少占用多少存储空间，不同的平台可以占用不同的存储空间。</p>
</blockquote>
<p>在表 1 罗列的这些数据类型中，long long 超长整型是 C++ 11 标准新添加的，接下来就对该整数类型做具体的介绍。</p>
<p>说道 C++ 标准委员会将 long long 整形写入 C++ 11 标准中，其实早在 1995 年，就有人提议将 long long 整形写入 C++ 98 标准，但被委员会拒绝了。而后 long long 整形被 C99 标准（C语言标准之一）采纳，并逐渐被很多编译器支持，于是 C++ 标准委员会重新决定将 long long 整形写入 C++ 11 标准中。</p>
<p>如同 long 类型整数需明确标注 “L” 或者 “l” 后缀一样，要使用 long long 类型的整数，也必须标注对应的后缀：</p>
<ul>
<li>对于有符号 long long 整形，后缀用 “LL” 或者 “ll” 标识。例如，“10LL” 就表示有符号超长整数 10；</li>
<li>对于无符号 long long 整形，后缀用 “ULL”、“ull”、“Ull” 或者 “uLL” 标识。例如，“10ULL” 就表示无符号超长整数 10；</li>
</ul>
<blockquote>
<p>如果不添加任何标识，则所有的整数都会默认为 int 类型。</p>
</blockquote>
<p>对于任意一种数据类型，读者可能更关心的是此类型的取值范围。对于 long long 类型来说，如果想了解当前平台上 long long 整形的取值范围，可以使用<code>&lt;climits&gt;</code>头文件中与 long long 整形相关的 3 个宏，分别为 LLONG_MIN、LLONG_MAX 和 ULLONG_MIN：</p>
<ol>
<li>LLONG_MIN：代表当前平台上最小的 long long 类型整数；</li>
<li>LLONG_MAX：代表当前平台上最大的 long long 类型整数；</li>
<li>ULLONG_MIN：代表当前平台上最大的 unsigned long long 类型整数（无符号超长整型的最小值为 0）；</li>
</ol>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;long long最大值：&quot;</span> &lt;&lt; LLONG_MIN &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; hex &lt;&lt; LLONG_MIN &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; dec &lt;&lt;<span class="string">&quot;long long最小值：&quot;</span> &lt;&lt; LLONG_MAX &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; hex &lt;&lt; LLONG_MAX &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; dec &lt;&lt; <span class="string">&quot;unsigned long long最大值：&quot;</span> &lt;&lt; ULLONG_MAX &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; hex &lt;&lt; ULLONG_MAX;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为（不唯一）：</p>
<p>long long最大值：-9223372036854775808 8000000000000000<br>long long最小值：9223372036854775807 7fffffffffffffff<br>unsigned long long最大值：18446744073709551615 ffffffffffffffff</p>
<p>此程序中，输出了各最大值和最小值对应的十六进制，显然在当前平台（Windows10 64位操作系统）上，long long 超长整型占用 64 位（也就是 16 个字节）的存储空间。读者可自行在自己的机器上运行此段代码，即可轻松得知 long long 类型在自己机器上所占用的字节数。</p>
<h2 id="28-智能指针"><a href="#28-智能指针" class="headerlink" title="28.智能指针"></a>28.智能指针</h2><h3 id="1-shared-ptr智能指针（超级详细）"><a href="#1-shared-ptr智能指针（超级详细）" class="headerlink" title="1.shared_ptr智能指针（超级详细）"></a>1.shared_ptr智能指针（超级详细）</h3><p>在实际的 C++ 开发中，我们经常会遇到诸如程序运行中突然崩溃、程序运行所用内存越来越多最终不得不重启等问题，这些问题往往都是内存资源管理不当造成的。比如：</p>
<ul>
<li>有些内存资源已经被释放，但指向它的指针并没有改变指向（成为了野指针），并且后续还在使用；</li>
<li>有些内存资源已经被释放，后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）；</li>
<li>没有及时释放不再使用的内存资源，造成内存泄漏，程序占用的内存资源越来越多。</li>
</ul>
<p>针对以上这些情况，很多程序员认为 C++ 语言应该提供更友好的内存管理机制，这样就可以将精力集中于开发项目的各个功能上。</p>
<p>事实上，显示内存管理的替代方案很早就有了，早在 1959 年前后，就有人提出了“垃圾自动回收”机制。所谓垃圾，指的是那些不再使用或者没有任何指针指向的内存空间，而“回收”则指的是将这些“垃圾”收集起来以便再次利用。</p>
<p>如今，垃圾回收机制已经大行其道，得到了诸多编程语言的支持，例如 Java、Python、C#、PHP 等。而 C++ 虽然从来没有公开得支持过垃圾回收机制，但 C++98&#x2F;03 标准中，支持使用 auto_ptr 智能指针来实现堆内存的自动回收；C++11 新标准在废弃 auto_ptr 的同时，增添了 unique_ptr、shared_ptr 以及 weak_ptr 这 3 个智能指针来实现堆内存的自动回收。</p>
<p>所谓智能指针，可以从字面上理解为“智能”的指针。具体来讲，智能指针和普通指针的用法是相似的，不同之处在于，智能指针可以在适当时机自动释放分配的内存。也就是说，使用智能指针可以很好地避免“忘记释放内存而导致内存泄漏”问题出现。由此可见，C++ 也逐渐开始支持垃圾回收机制了，尽管目前支持程度还有限。</p>
<blockquote>
<p>C++ 智能指针底层是采用引用计数的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值减 1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。</p>
</blockquote>
<p>接下来，我们将分别对 shared_ptr、unique_ptr 以及 weak_ptr 这 3 个智能指针的特性和用法做详细的讲解，本节先介绍 shared_ptr 智能指针。</p>
<h4 id="C-11-shared-ptr智能指针"><a href="#C-11-shared-ptr智能指针" class="headerlink" title="C++11 shared_ptr智能指针"></a>C++11 shared_ptr智能指针</h4><p>实际上，每种智能指针都是以类模板的方式实现的，shared_ptr 也不例外。shared_ptr（其中 T 表示指针指向的具体数据类型）的定义位于<code>&lt;memory&gt;</code>头文件，并位于 std 命名空间中，因此在使用该类型指针时，程序中应包含如下 2 行代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，第 2 行代码并不是必须的，也可以不添加，则后续在使用 shared_ptr 智能指针时，就需要明确指明<code>std::</code>。</p>
</blockquote>
<p>值得一提的是，和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。</p>
<h5 id="1、shared-ptr智能指针的创建"><a href="#1、shared-ptr智能指针的创建" class="headerlink" title="1、shared_ptr智能指针的创建"></a>1、shared_ptr智能指针的创建</h5><p>shared_ptr 类模板中，提供了多种实用的构造函数，这里给读者列举了几个常用的构造函数（以构建指向 int 类型数据的智能指针为例）。</p>
<ol>
<li>通过如下 2 种方式，可以构造出 shared_ptr 类型的空智能指针：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p1;             <span class="comment">//不传入任何实参std::shared_ptr&lt;int&gt; p2(nullptr);    //传入空指针 nullptr</span></span><br></pre></td></tr></table></figure>

<p>注意，空的 shared_ptr 指针，其初始引用计数为 0，而不是 1。</p>
<ol>
<li>在构建 shared_ptr 智能指针，也可以明确其指向。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p>由此，我们就成功构建了一个 shared_ptr 智能指针，其指向一块存有 10 这个 int 类型数据的堆内存空间。</p>
<p>同时，C++11 标准中还提供了 std::make_shared 模板函数，其可以用于初始化 shared_ptr 智能指针，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p3 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>以上 2 种方式创建的 p3 是完全相同。</p>
<ol>
<li>除此之外，shared_ptr 模板还提供有相应的拷贝构造函数和移动构造函数，例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用拷贝构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(p3)</span></span>;<span class="comment">//或者 std::shared_ptr&lt;int&gt; p4 = p3;</span></span><br><span class="line"><span class="comment">//调用移动构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>; <span class="comment">//或者 std::shared_ptr&lt;int&gt; p5 = std::move(p4);</span></span><br></pre></td></tr></table></figure>

<p>如上所示，p3 和 p4 都是 shared_ptr 类型的智能指针，因此可以用 p3 来初始化 p4，由于 p3 是左值，因此会调用拷贝构造函数。需要注意的是，如果 p3 为空智能指针，则 p4 也为空智能指针，其引用计数初始值为 0；反之，则表明 p4 和 p3 指向同一块堆内存，同时该堆空间的引用计数会加 1。</p>
<p>而对于 std::move(p4) 来说，该函数会强制将 p4 转换成对应的右值，因此初始化 p5 调用的是移动构造函数。另外和调用拷贝构造函数不同，用 std::move(p4) 初始化 p5，会使得 p5 拥有了 p4 的堆内存，而 p4 则变成了空智能指针。</p>
<p>注意，同一普通指针不能同时为多个 shared_ptr 对象赋值，否则会导致程序发生异常。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(ptr)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(ptr)</span></span>;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<ol>
<li>在初始化 shared_ptr 智能指针时，还可以自定义所指堆内存的释放规则，这样当堆内存的引用计数为 0 时，会优先调用我们自定义的释放规则。</li>
</ol>
<p>在某些场景中，自定义释放规则是很有必要的。比如，对于申请的动态数组来说，shared_ptr 指针默认的释放规则是不支持释放数组的，只能自定义对应的释放规则，才能正确地释放申请的堆内存。</p>
<p>对于申请的动态数组，释放规则可以使用 C++11 标准中提供的 default_delete 模板类，我们也可以自定义释放规则：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定 default_delete 作为释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p6</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], std::default_delete&lt;<span class="type">int</span>[]&gt;())</span></span>;</span><br><span class="line"><span class="comment">//自定义释放规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteInt</span><span class="params">(<span class="type">int</span>*p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> []p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化智能指针，并自定义释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p7</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], deleteInt)</span></span>;</span><br></pre></td></tr></table></figure>

<p>实际上借助 lambda 表达式，我们还可以像如下这样初始化 p7，它们是完全相同的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p7</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span>* p) &#123;<span class="keyword">delete</span>[]p; &#125;)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="2、shared-ptr模板类提供的成员方法"><a href="#2、shared-ptr模板类提供的成员方法" class="headerlink" title="2、shared_ptr模板类提供的成员方法"></a>2、shared_ptr模板类提供的成员方法</h5><p>为了方便用户使用 shared_ptr 智能指针，shared_ptr 模板类还提供有一些实用的成员方法，它们各自的功能如表 1 所示。</p>
<table>
<thead>
<tr>
<th>成员方法名</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>operator&#x3D;()</td>
<td>重载赋值号，使得同一类型的 shared_ptr 智能指针可以相互赋值。</td>
</tr>
<tr>
<td>operator*()</td>
<td>重载 * 号，获取当前 shared_ptr 智能指针对象指向的数据。</td>
</tr>
<tr>
<td>operator-&gt;()</td>
<td>重载 -&gt; 号，当智能指针指向的数据类型为自定义的结构体时，通过 -&gt; 运算符可以获取其内部的指定成员。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个相同类型 shared_ptr 智能指针的内容。</td>
</tr>
<tr>
<td>reset()</td>
<td>当函数没有实参时，该函数会使当前 shared_ptr 所指堆内存的引用计数减 1，同时将当前对象重置为一个空指针；当为函数传递一个新申请的堆内存时，则调用该函数的 shared_ptr 对象会获得该存储空间的所有权，并且引用计数的初始值为 1。</td>
</tr>
<tr>
<td>get()</td>
<td>获得 shared_ptr 对象内部包含的普通指针。</td>
</tr>
<tr>
<td>use_count()</td>
<td>返回同当前 shared_ptr 对象（包括它）指向相同的所有 shared_ptr 对象的数量。</td>
</tr>
<tr>
<td>unique()</td>
<td>判断当前 shared_ptr 对象指向的堆内存，是否不再有其它 shared_ptr 对象再指向它。</td>
</tr>
<tr>
<td>operator bool()</td>
<td>判断当前 shared_ptr 对象是否为空智能指针，如果是空指针，返回 false；反之，返回 true。</td>
</tr>
</tbody></table>
<blockquote>
<p>除此之外，C++11 标准还支持同一类型的 shared_ptr 对象，或者 shared_ptr 和 nullptr 之间，进行 &#x3D;&#x3D;，!&#x3D;，&lt;，&lt;&#x3D;，&gt;，&gt;&#x3D; 运算。</p>
</blockquote>
<p>下面程序给大家演示了 shared_ptr 智能指针的基本用法，以及该模板类提供了一些成员方法的用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构建 2 个智能指针</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    <span class="comment">//输出 p2 指向的数据</span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    p<span class="number">1.</span><span class="built_in">reset</span>();<span class="comment">//引用计数减 1,p1为空指针</span></span><br><span class="line">    <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上操作，并不会影响 p2</span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//判断当前和 p2 同指向的智能指针有多少个</span></span><br><span class="line">    cout &lt;&lt; p<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>10<br>p1 为空<br>10<br>1</p>
<h3 id="2-unique-ptr智能指针"><a href="#2-unique-ptr智能指针" class="headerlink" title="2.unique_ptr智能指针"></a>2.unique_ptr智能指针</h3><p>作为智能指针的一种，unique_ptr 指针自然也具备“在适当时机自动释放堆内存空间”的能力。和 shared_ptr 指针最大的不同之处在于，unique_ptr 指针指向的堆内存无法同其它 unique_ptr 共享，也就是说，每个 unique_ptr 指针都独自拥有对其所指堆内存空间的所有权。</p>
<blockquote>
<p>这也就意味着，每个 unique_ptr 指针指向的堆内存空间的引用计数，都只能为 1，一旦该 unique_ptr 指针放弃对所指堆内存空间的所有权，则该空间会被立即释放回收。</p>
</blockquote>
<p>unique_ptr 智能指针是以模板类的形式提供的，unique_ptr（T 为指针所指数据的类型）定义在<code>&lt;memory&gt;</code>头文件，并位于 std 命名空间中。因此，要想使用 unique_ptr 类型指针，程序中应首先包含如下 2 条语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第 2 句并不是必须的，可以不添加，则后续在使用 unique_ptr 指针时，必须标注<code>std::</code>。</p>
</blockquote>
<h4 id="unique-ptr智能指针的创建"><a href="#unique-ptr智能指针的创建" class="headerlink" title="unique_ptr智能指针的创建"></a>unique_ptr智能指针的创建</h4><p>考虑到不同实际场景的需要，unique_ptr 模板类提供了多个实用的构造函数，这里给读者列举了几种常用的构造 unique_ptr 智能指针的方式。</p>
<ol>
<li>通过以下 2 种方式，可以创建出空的 unique_ptr 指针：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>创建 unique_ptr 指针的同时，也可以明确其指向。例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;int&gt; p3(new int);</span><br></pre></td></tr></table></figure>

<p>由此就创建出了一个 p3 智能指针，其指向的是可容纳 1 个整数的堆存储空间。</p>
<blockquote>
<p>和可以用 make_shared() 模板函数初始化 shared_ptr 指针不同，C++11 标准中并没有为 unique_ptr 类型指针添加类似的模板函数。</p>
</blockquote>
<ol>
<li>基于 unique_ptr 类型指针不共享各自拥有的堆内存，因此 C++11 标准中的 unique_ptr 模板类没有提供拷贝构造函数，只提供了移动构造函数。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(p4)</span></span>;<span class="comment">//错误，堆内存不共享</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>;<span class="comment">//正确，调用移动构造函数</span></span><br></pre></td></tr></table></figure>

<p>值得一提的是，对于调用移动构造函数的 p4 和 p5 来说，p5 将获取 p4 所指堆空间的所有权，而 p4 将变成空指针（nullptr）。</p>
<ol>
<li>默认情况下，unique_ptr 指针采用 std::default_delete 方法释放堆内存。当然，我们也可以自定义符合实际场景的释放规则。值得一提的是，和 shared_ptr 指针不同，为 unique_ptr 自定义释放规则，只能采用函数对象的方式。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义的释放规则</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myDel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>, myDel&gt; <span class="title">p6</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//std::unique_ptr&lt;int, myDel&gt; p6(new int, myDel());</span></span><br></pre></td></tr></table></figure>

<h4 id="unique-ptr模板类提供的成员方法"><a href="#unique-ptr模板类提供的成员方法" class="headerlink" title="unique_ptr模板类提供的成员方法"></a>unique_ptr模板类提供的成员方法</h4><p>为了方便用户使用 unique_ptr 智能指针，unique_ptr 模板类还提供有一些实用的成员方法，它们各自的功能如表 1 所示。</p>
<table>
<thead>
<tr>
<th>成员函数名</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>operator*()</td>
<td>获取当前 unique_ptr 指针指向的数据。</td>
</tr>
<tr>
<td>operator-&gt;()</td>
<td>重载 -&gt; 号，当智能指针指向的数据类型为自定义的结构体时，通过 -&gt; 运算符可以获取其内部的指定成员。</td>
</tr>
<tr>
<td>operator &#x3D;()</td>
<td>重载了 &#x3D; 赋值号，从而可以将 nullptr 或者一个右值 unique_ptr 指针直接赋值给当前同类型的 unique_ptr 指针。</td>
</tr>
<tr>
<td>operator</td>
<td>重载了 [] 运算符，当 unique_ptr 指针指向一个数组时，可以直接通过 [] 获取指定下标位置处的数据。</td>
</tr>
<tr>
<td>get()</td>
<td>获取当前 unique_ptr 指针内部包含的普通指针。</td>
</tr>
<tr>
<td>get_deleter()</td>
<td>获取当前 unique_ptr 指针释放堆内存空间所用的规则。</td>
</tr>
<tr>
<td>operator bool()</td>
<td>unique_ptr 指针可直接作为 if 语句的判断条件，以判断该指针是否为空，如果为空，则为 false；反之为 true。</td>
</tr>
<tr>
<td>release()</td>
<td>释放当前 unique_ptr 指针对所指堆内存的所有权，但该存储空间并不会被销毁。</td>
</tr>
<tr>
<td>reset§</td>
<td>其中 p 表示一个普通指针，如果 p 为 nullptr，则当前 unique_ptr 也变成空指针；反之，则该函数会释放当前 unique_ptr 指针指向的堆内存（如果有），然后获取 p 所指堆内存的所有权（p 为 nullptr）。</td>
</tr>
<tr>
<td>swap(x)</td>
<td>交换当前 unique_ptr 指针和同类型的 x 指针。</td>
</tr>
</tbody></table>
<blockquote>
<p>除此之外，C++11标准还支持同类型的 unique_ptr 指针之间，以及 unique_ptr 和 nullptr 之间，做 &#x3D;&#x3D;，!&#x3D;，&lt;，&lt;&#x3D;，&gt;，&gt;&#x3D; 运算。</p>
</blockquote>
<p>下面程序给大家演示了 unique_ptr 智能指针的基本用法，以及该模板类提供了一些成员方法的用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">    *p5 = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// p 接收 p5 释放的堆内存</span></span><br><span class="line">    <span class="type">int</span> * p = p<span class="number">5.</span><span class="built_in">release</span>();</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//判断 p5 是否为空指针</span></span><br><span class="line">    <span class="keyword">if</span> (p5) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p5 is not nullptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p5 is nullptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; p6;</span><br><span class="line">    <span class="comment">//p6 获取 p 的所有权</span></span><br><span class="line">    p<span class="number">6.</span><span class="built_in">reset</span>(p);</span><br><span class="line">    cout &lt;&lt; *p6 &lt;&lt; endl;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>10<br>p5 is nullptr<br>10</p>
<h3 id="3-weak-ptr智能指针"><a href="#3-weak-ptr智能指针" class="headerlink" title="3.weak_ptr智能指针"></a>3.weak_ptr智能指针</h3><p>在 C++98&#x2F;03 的基础上，C++11 标准新引入了 shared_ptr、unique_ptr 以及 weak_ptr 这 3 个智能指针。其中，shared_ptr 和 unique_ptr 已经在前面章节做了详细地介绍，本节重点讲解 weak_ptr 智能指针的特性和用法。</p>
<h4 id="weak-ptr智能指针"><a href="#weak-ptr智能指针" class="headerlink" title="weak_ptr智能指针"></a>weak_ptr智能指针</h4><p>和 shared_ptr、unique_ptr 类型指针一样，weak_ptr 智能指针也是以模板类的方式实现的。weak_ptr（ T 为指针所指数据的类型）定义在<code>&lt;memory&gt;</code>头文件，并位于 std 命名空间中。因此，要想使用 weak_ptr 类型指针，程序中应首先包含如下 2 条语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第 2 句并不是必须的，可以不添加，则后续在使用 unique_ptr 指针时，必须标注<code>std::</code>。</p>
</blockquote>
<p>需要注意的是，C++11标准虽然将 weak_ptr 定位为智能指针的一种，但该类型指针通常不单独使用（没有实际用处），只能和 shared_ptr 类型指针搭配使用。甚至于，我们可以将 weak_ptr 类型指针视为 shared_ptr 指针的一种辅助工具，借助 weak_ptr 类型指针， 我们可以获取 shared_ptr 指针的一些状态信息，比如有多少指向相同的 shared_ptr 指针、shared_ptr 指针指向的堆内存是否已经被释放等等。</p>
<p>需要注意的是，当 weak_ptr 类型指针的指向和某一 shared_ptr 指针相同时，weak_ptr 指针并不会使所指堆内存的引用计数加 1；同样，当 weak_ptr 指针被释放时，之前所指堆内存的引用计数也不会因此而减 1。也就是说，weak_ptr 类型指针并不会影响所指堆内存空间的引用计数。</p>
<p>除此之外，weak_ptr 模板类中没有重载 * 和 -&gt; 运算符，这也就意味着，weak_ptr 类型指针只能访问所指的堆内存，而无法修改它。</p>
<h5 id="1、weak-ptr指针的创建"><a href="#1、weak-ptr指针的创建" class="headerlink" title="1、weak_ptr指针的创建"></a>1、weak_ptr指针的创建</h5><p>创建一个 weak_ptr 指针，有以下 3 种方式：</p>
<ol>
<li>可以创建一个空 weak_ptr 指针，例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; wp1;</span><br></pre></td></tr></table></figure>

<ol>
<li>凭借已有的 weak_ptr 指针，可以创建一个新的 weak_ptr 指针，例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp2</span> <span class="params">(wp1)</span></span>;</span><br></pre></td></tr></table></figure>

<p>若 wp1 为空指针，则 wp2 也为空指针；反之，如果 wp1 指向某一 shared_ptr 指针拥有的堆内存，则 wp2 也指向该块存储空间（可以访问，但无所有权）。</p>
<ol>
<li>weak_ptr 指针更常用于指向某一 shared_ptr 指针拥有的堆内存，因为在构建 weak_ptr 指针对象时，可以利用已有的 shared_ptr 指针为其初始化。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span> <span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp3</span> <span class="params">(sp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>由此，wp3 指针和 sp 指针有相同的指针。再次强调，weak_ptr 类型指针不会导致堆内存空间的引用计数增加或减少。</p>
<h5 id="2-weak-ptr模板类提供的成员方法"><a href="#2-weak-ptr模板类提供的成员方法" class="headerlink" title="2) weak_ptr模板类提供的成员方法"></a>2) weak_ptr模板类提供的成员方法</h5><p>和 shared_ptr、unique_ptr 相比，weak_ptr 模板类提供的成员方法不多，表 1 罗列了常用的成员方法及各自的功能。</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>operator&#x3D;()</td>
<td>重载 &#x3D; 赋值运算符，是的 weak_ptr 指针可以直接被 weak_ptr 或者 shared_ptr 类型指针赋值。</td>
</tr>
<tr>
<td>swap(x)</td>
<td>其中 x 表示一个同类型的 weak_ptr 类型指针，该函数可以互换 2 个同类型 weak_ptr 指针的内容。</td>
</tr>
<tr>
<td>reset()</td>
<td>将当前 weak_ptr 指针置为空指针。</td>
</tr>
<tr>
<td>use_count()</td>
<td>查看指向和当前 weak_ptr 指针相同的 shared_ptr 指针的数量。</td>
</tr>
<tr>
<td>expired()</td>
<td>判断当前 weak_ptr 指针为否过期（指针为空，或者指向的堆内存已经被释放）。</td>
</tr>
<tr>
<td>lock()</td>
<td>如果当前 weak_ptr 已经过期，则该函数会返回一个空的 shared_ptr 指针；反之，该函数返回一个和当前 weak_ptr 指向相同的 shared_ptr 指针。</td>
</tr>
</tbody></table>
<blockquote>
<p>再次强调，weak_ptr 模板类没有重载 * 和 -&gt; 运算符，因此 weak_ptr 类型指针只能访问某一 shared_ptr 指针指向的堆内存空间，无法对其进行修改。</p>
</blockquote>
<p>下面的样例演示了 weak_ptr 指针以及表 1 中部分成员方法的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(sp1)</span></span>;</span><br><span class="line">    <span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(sp2)</span></span>;</span><br><span class="line">    <span class="comment">//输出和 wp 同指向的 shared_ptr 类型指针的数量</span></span><br><span class="line">    cout &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//释放 sp2</span></span><br><span class="line">    sp<span class="number">2.</span><span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//借助 lock() 函数，返回一个和 wp 同指向的 shared_ptr 类型指针，获取其存储的数据</span></span><br><span class="line">    cout &lt;&lt; *(wp.<span class="built_in">lock</span>()) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>2<br>1<br>10</p>
<blockquote>
<p>有关表 1 中其它成员函数的用法，感兴趣的读者可直接查看 <a href="http://www.cplusplus.com/reference/memory/weak_ptr/">weak_ptr 官网</a>。</p>
</blockquote>
<p>注：笔记根据侯捷视频和其他博客整理得来，仅供自己查阅方便</p>
<p><a href="https://blog.csdn.net/qq_41854911/article/details/119657617#C11usingtypedef_692">C++11、C++14、C++17、C++20新特性总结（5万字详解）_c++11和c++17的区别-CSDN博客</a></p>
<p><a href="https://www.cnblogs.com/linuxAndMcu/p/11600553.html#_label7_2">C++11 新特性总结 - fengMisaka - 博客园 (cnblogs.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/650986900">C++11新特性（全详解） - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>从零开始的C++の学习之路</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马程序员C++核心编程学习笔记</title>
    <url>/2023/07/22/C++/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E7%B2%BE%E7%BE%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="黑马程序员C-核心编程学习笔记"><a href="#黑马程序员C-核心编程学习笔记" class="headerlink" title="黑马程序员C++核心编程学习笔记"></a>黑马程序员C++核心编程学习笔记</h1><h1 id="一、内存"><a href="#一、内存" class="headerlink" title="一、内存"></a>一、内存</h1><h2 id="1-1-内存四区"><a href="#1-1-内存四区" class="headerlink" title="1.1 内存四区"></a>1.1 内存四区</h2><p>C++程序在执行时，将内存大致分为4个区域：代码区，全局区，栈区，堆区</p>
<ul>
<li><p><strong>代码区</strong>：存放函数体的的二进制代码，操作系统管理。</p>
<p> 🔵<strong>特点</strong>：①共享 ：对于频繁被执行的程序，只需要在内存中有一份代码即可。<br>    ②只读：目的是防止程序意外地修改了它的指令。</p>
</li>
<li><p><strong>全局区</strong>：存放全局变量、静态变量和常量（除了const修饰的局部变量）。程序结束时由操作系统释放。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> l_a = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//静态变量</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//常量：字符串常量/const修饰的变量（全局/局部变量）</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;局部变量l_a的十进制地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;l_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;全局变量g_a的十进制地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;g_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;静态变量s_a的十进制地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;字符串常量a的十进制地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;const修饰的全局变量c_g_a的十进制地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;const修饰的局部变量c_l_a的十进制地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/40700be692a24a1681d7e38cabf0fff2.png" alt="在这里插入图片描述"></p>
<ul>
<li><p><strong>栈区</strong>：存放函数的参数值、局部变量。由编译器自动分配和释放。</p>
<p> 🔴<strong>注意</strong>：不要返回局部变量的地址。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">funcation</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;<span class="comment">//存放在栈区，栈区的数据在函数执行完后自动释放</span></span><br><span class="line">	<span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = funcation();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;局部变量a的值为：&quot;</span>&lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//第一次正常打印，因为编译器做了保留</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;局部变量a的值为：&quot;</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/35877799a99f4d2dafee23b397276962.png" alt="在这里插入图片描述"></p>
<ul>
<li><strong>堆区</strong>：由程序员分配（<code>new</code>）和释放（<code>delete</code>），若程序员不释放，程序结束时由操作系统回收。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">funcation</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//new关键字，可以将数据开辟到堆区上</span></span><br><span class="line">	<span class="comment">//指针本质上也是局部变量，存放在栈区上，但是保存的数据在堆区</span></span><br><span class="line">	<span class="type">int</span>* p = new <span class="type">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = funcation();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/ddca51c970f946ecb40c17dd7c1cb869.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>Tip：</p>
<ul>
<li>程序运行前分为：代码区，全局区</li>
<li>程序运行后分为：栈区,堆区</li>
</ul>
</blockquote>
<p>[注]： 关于内存更详细的知识👉<a href="https://blog.csdn.net/m0_51350326/article/details/119916034?spm=1001.2014.3001.5501">深度剖析数据在内存中的存储</a>👉<a href="https://blog.csdn.net/m0_51350326/article/details/119857102?spm=1001.2014.3001.5501">几分钟让你了解什么是函数栈帧的创建和销毁</a></p>
<h2 id="1-2-new操作符"><a href="#1-2-new操作符" class="headerlink" title="1.2 new操作符"></a>1.2 new操作符</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//new的基本用法</span></span><br><span class="line"><span class="type">int</span>* p = new <span class="type">int</span>(<span class="number">10</span>);<span class="comment">//在堆区创建整型变量，返回该变量的地址</span></span><br><span class="line">delete p;<span class="comment">//释放</span></span><br><span class="line"><span class="type">int</span>* parr = new <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//在堆区创建一个元素为10的整型数组，返回数组首元素的地址</span></span><br><span class="line">delete[] arr;<span class="comment">//释放一个数组 </span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>测试<code>delete</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">funcation</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = new <span class="type">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = funcation();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	delete p;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/ee3f290d55e14486b19fdd5a99f7afc7.png" alt="img"> <img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/a10a855ff9134e719f99802d39ab10a2.png" alt="img"></p>
<h1 id="二、引用"><a href="#二、引用" class="headerlink" title="二、引用"></a>二、引用</h1><h2 id="2-1-引用基本使用和注意事项"><a href="#2-1-引用基本使用和注意事项" class="headerlink" title="2.1 引用基本使用和注意事项"></a>2.1 引用基本使用和注意事项</h2><p>​    <strong>作用</strong>：给变量起个别名。<br>​    <strong>语法</strong>：<code>数据类型</code> <code>&amp;</code> <code>别名</code>&#x3D;<code>原名</code><br>​    <strong>本质</strong>：指针常量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = a;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>​    🔴<strong>注意</strong>：<br>​      ①引用必须初始化。<br>​      ②引用一旦初始化就不可以更改了（如下的例子相当于<code>int *const b=&amp;a</code>）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//①引用必须初始化</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span>&amp; b;<span class="comment">//错了！！！</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//②引用一旦初始化就不可以更改了</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span>&amp; b = a;</span><br><span class="line">	<span class="type">int</span>&amp; b = c; <span class="comment">//错了！！！</span></span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-引用做函数参数"><a href="#2-2-引用做函数参数" class="headerlink" title="2.2 引用做函数参数"></a>2.2 引用做函数参数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="comment">/*实现数值交换*/</span></span><br><span class="line"><span class="comment">//1.传址交换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap1</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.引用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap2</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span><span class="comment">//起别名可以和原名一样</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	swap1(&amp;a, &amp;b);</span><br><span class="line">	swap2(a, b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-引用函数返回值"><a href="#2-3-引用函数返回值" class="headerlink" title="2.3 引用函数返回值"></a>2.3 引用函数返回值</h2><p>   🔴<strong>注意</strong>：<br>      ①不要返回局部变量的引用。函数返回时，局部变量会被释放，引用或指针指向的内容会失效<br>      ②函数的调用可以作为左值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="comment">//①不要返回局部变量的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>&amp; ret = <span class="built_in">test1</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret=&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret=&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">test1</span>() = <span class="number">20</span>; <span class="comment">//②如果函数的返回值为引用，函数的调用可以作为左值</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret=&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret=&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/ee101ab6e06547a6929c9991a48e34bd.png" alt="在这里插入图片描述"></p>
<h2 id="2-3-常量引用"><a href="#2-3-常量引用" class="headerlink" title="2.3 常量引用"></a>2.3 常量引用</h2><p>​    <strong>目的</strong>：用来修饰形参，防止误操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;ret=<span class="number">10</span>; <span class="comment">//错了！，引用本身需要一个合法的内存空间。</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">相当于编译器先创建一个临时变量:int temp=10;</span></span><br><span class="line"><span class="comment">然后进行起别名:int&amp; ret=temp;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ret = <span class="number">10</span>;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>   🔴<strong>注意</strong>：用常量引用之后不可以更改数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; ret = <span class="number">10</span>;</span><br><span class="line">	ret = <span class="number">100</span>;<span class="comment">//err</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ret=&quot;</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/5b8088956bb64af9a242d331378673ec.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>C++推荐引用，因为语法方便，编译器帮我们做了指针的内容。</p>
</blockquote>
<h1 id="三、函数提高"><a href="#三、函数提高" class="headerlink" title="三、函数提高"></a>三、函数提高</h1><h2 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h2><p>​    <strong>语法</strong>：<code>返回类型</code> <code>函数名</code> <code>（参数 =默认值）</code> <code>&#123;&#125;</code><br>​    <strong>用法</strong>：如果自己传入数据就用自己的，如果没有就用默认值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> b = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> c = <span class="built_in">Add</span>(a, b);</span><br><span class="line">	<span class="type">int</span> e = <span class="built_in">Add</span>(a);</span><br><span class="line">	<span class="type">int</span> f = <span class="built_in">Add</span>(b);</span><br><span class="line">	<span class="type">int</span> g = <span class="built_in">Add</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c=&quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;e=&quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;f=&quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;g=&quot;</span> &lt;&lt; g &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/f58fe79deef443e69ae5174ae13fd48a.png" alt="在这里插入图片描述"></p>
<p>   🔴<strong>注意</strong>：</p>
<p>​      ①默认值必须放在右边。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c)</span>;<span class="comment">//err</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>​      ②声明和实现，有且只能有一个有默认参数。否则可能出现二义。</p>
<h2 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h2><p>​    <strong>语法</strong>：<code>返回类型</code> <code>函数名</code> <code>（数据类型）</code> <code>&#123;&#125;</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;haha&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b=<span class="number">10</span>)</span><span class="comment">//占位参数可以有默认参数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;haha&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	test1(<span class="number">1</span>);<span class="comment">//err</span></span><br><span class="line">	test1(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	test2(<span class="number">1</span>);</span><br><span class="line">	test2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h2><p>​    <strong>作用</strong>：函数名可以相同，提高复用率。<br>​    <strong>满足条件</strong>：<br>​       ①同一个作用域。<br>​       ②函数名称相同。<br>​       ③参数类型不同&#x2F;个数不同&#x2F;顺序不同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="comment">//在全局作用域</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用test( )&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用test(int a)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">double</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用test(double a)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用test(int a, int b)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用test(int a, double b)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用test(double a, int b)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	test();</span><br><span class="line">	test(<span class="number">1</span>);</span><br><span class="line">	test(<span class="number">3.14</span>);</span><br><span class="line">	test(<span class="number">1</span>,<span class="number">3.14</span>);</span><br><span class="line">	test(<span class="number">3.14</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/81d7eadc48e241bb9010c3cab61bab76.png" alt="在这里插入图片描述"></p>
<p>   🔴<strong>注意</strong>：<br>       ①函数的返回值不可以作为函数重载的条件！出现二义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用test(int a)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用test(int a)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/cc6d476ded9a4d1eab6c7ec219a97f60.png" alt="在这里插入图片描述"><br>      ②引用作为重载条件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="comment">//引用作为重载条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> &amp;a)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用test(int &amp;a)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用test(const int&amp; b)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">	test(a);</span><br><span class="line">	test(b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/3e33b181d9aa42d3bd1aeb8386c12607.png" alt="在这里插入图片描述"><br>      ③函数重载碰到默认参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="comment">//函数重载碰到默认参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b=<span class="number">10</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用test(int &amp;a)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用test(const int&amp; b)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	test(<span class="number">10</span>);<span class="comment">//err,出现二义</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/2920035c2b824606b3deb21642d0a5d0.png" alt="在这里插入图片描述"></p>
<h1 id="四、类与对象"><a href="#四、类与对象" class="headerlink" title="四、类与对象"></a>四、类与对象</h1><p>C++面向对象三大特性：封装、继承、多态</p>
<h2 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h2><p>🟦<strong>意义</strong>：<br>     ①将属性和行为作为一个整体。(放在一个<code>class</code>里面)<br>     ②将属性和行为加以权限控制。<br>     <code>public</code>公共权限：类内外都可以访问<br>     <code>protected</code>保护权限： 类外不可以访问<br>     <code>private</code>私有权限： 类外不可以访问</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.1定义一个圆类</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="comment">//class 定义一个类 circle是类的名字</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//访问权限：公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//属性</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="comment">//行为</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">circumference</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> r * PI * <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	circle c1;<span class="comment">//创建具体的圆（对象）（实例化）</span></span><br><span class="line">	c<span class="number">1.</span>r = <span class="number">10</span>;<span class="comment">//给具体的圆的属性赋值</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;圆的周长为:&quot;</span> &lt;&lt; c<span class="number">1.</span><span class="built_in">circumference</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br><span class="line"><span class="comment">//eg.2设计一个学生类</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//属性</span></span><br><span class="line">	string name;<span class="comment">//string 类处理起字符串来会方便很多，完全可以代替C语言中的字符数组或字符串指针。</span></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="comment">//行为</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;学号：&quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	student s1;</span><br><span class="line">	s<span class="number">1.</span>name = <span class="string">&quot;xiyang&quot;</span>;</span><br><span class="line">	s<span class="number">1.</span>id = <span class="number">1</span>;</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">show</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br><span class="line"><span class="comment">//eg.3 公共权限，私有权限，保护权限访问的例子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string car;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> password;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		name = <span class="string">&quot;zyz&quot;</span>;</span><br><span class="line">		car = <span class="string">&quot;ofo&quot;</span>;</span><br><span class="line">		password = <span class="number">123</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person p1;</span><br><span class="line">	p<span class="number">1.</span>name = <span class="string">&quot;xiyang&quot;</span>;</span><br><span class="line">	p<span class="number">1.</span>car = <span class="string">&quot;ufo&quot;</span>; <span class="comment">//err</span></span><br><span class="line">	p<span class="number">1.</span>password = <span class="number">456</span>;<span class="comment">//err</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>🔴<strong>注意</strong>：<code>struct</code>与<code>class</code>的区别：<br><code>struct</code>默认权限为：共有<br><code>class</code>默认权限为：私有</p>
</blockquote>
<h3 id="4-1-1-成员属性设置为私有"><a href="#4-1-1-成员属性设置为私有" class="headerlink" title="4.1.1 成员属性设置为私有"></a>4.1.1 成员属性设置为私有</h3><p>🟦<strong>意义</strong>：<br>     ①可以直接控制读写的权限。<br>     ②对于写可以检测数据的有效性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string name;<span class="comment">//可读写</span></span><br><span class="line">	<span class="type">int</span> age;<span class="comment">//只读</span></span><br><span class="line">	string lover;<span class="comment">//只写</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetName</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		name = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">string <span class="title">GetName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		age = <span class="number">18</span>;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetLover</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		lover = s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person p1;</span><br><span class="line">	p<span class="number">1.</span><span class="built_in">SetName</span>(<span class="string">&quot;xiyang&quot;</span>);</span><br><span class="line">	p<span class="number">1.</span><span class="built_in">SetLover</span>(<span class="string">&quot;薇尔莉特·伊芙加登&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名为：&quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">GetName</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;年龄为：&quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">GetAge</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435</span></span><br></pre></td></tr></table></figure>

<h3 id="设计案例1：立方体类"><a href="#设计案例1：立方体类" class="headerlink" title="设计案例1：立方体类"></a>设计案例1：立方体类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">要求：</span></span><br><span class="line"><span class="comment">1.设计一个立方体类</span></span><br><span class="line"><span class="comment">2.求出立方体的面积和体积</span></span><br><span class="line"><span class="comment">3.分别用全局函数和成员函数判断两个立方体是否相等</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cube</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//属性</span></span><br><span class="line">	<span class="type">int</span> L;</span><br><span class="line">	<span class="type">int</span> W;</span><br><span class="line">	<span class="type">int</span> H;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//行为</span></span><br><span class="line">	<span class="comment">//设置 获取长，宽，高</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetL</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		L = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetL</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetW</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		W = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetW</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> W;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetH</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		H = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetH</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> H;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获得面积</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">S</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span> * ((L * W) + (L * H) + (W * H));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获得体积</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">V</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> L * W * H;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//成员函数判断</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isSameByClass</span><span class="params">(cube&amp; c)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (c.<span class="built_in">GetL</span>() == L &amp;&amp; c.<span class="built_in">GetW</span>() ==W &amp;&amp; c.<span class="built_in">GetH</span>() == H)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数判断</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(cube&amp; c1, cube&amp; c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (c<span class="number">1.</span><span class="built_in">GetL</span>() == c<span class="number">2.</span><span class="built_in">GetL</span>() &amp;&amp; c<span class="number">1.</span><span class="built_in">GetW</span>() == c<span class="number">2.</span><span class="built_in">GetW</span>() &amp;&amp; c<span class="number">1.</span><span class="built_in">GetH</span>() == c<span class="number">2.</span><span class="built_in">GetH</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cube c1,c2;</span><br><span class="line">	c<span class="number">1.</span><span class="built_in">SetL</span>(<span class="number">10</span>);</span><br><span class="line">	c<span class="number">1.</span><span class="built_in">SetW</span>(<span class="number">10</span>);</span><br><span class="line">	c<span class="number">1.</span><span class="built_in">SetH</span>(<span class="number">10</span>);</span><br><span class="line">	c<span class="number">2.</span><span class="built_in">SetL</span>(<span class="number">10</span>);</span><br><span class="line">	c<span class="number">2.</span><span class="built_in">SetW</span>(<span class="number">5</span>);</span><br><span class="line">	c<span class="number">2.</span><span class="built_in">SetH</span>(<span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一个立方体的面积为：&quot;</span> &lt;&lt; c<span class="number">1.</span><span class="built_in">S</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一个立方体的体积为：&quot;</span> &lt;&lt; c<span class="number">1.</span><span class="built_in">V</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="type">bool</span> ret1 = <span class="built_in">isSame</span>(c1, c2);</span><br><span class="line">	<span class="keyword">if</span> (ret1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;全局函数判断c1 c2相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;全局函数判断c1 c2不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> ret2 = c<span class="number">1.</span><span class="built_in">isSameByClass</span>(c2);</span><br><span class="line">	<span class="keyword">if</span> (ret2)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;成员函数判断c1 c2相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;成员函数判断c1 c2不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/6ab1340c42e444adacb782556c38ca77.png" alt="在这里插入图片描述"></p>
<h3 id="设计案例2：点和圆的关系"><a href="#设计案例2：点和圆的关系" class="headerlink" title="设计案例2：点和圆的关系"></a>设计案例2：点和圆的关系</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*要求：</span></span><br><span class="line"><span class="comment"> 1.设计一个圆形类和一个点类</span></span><br><span class="line"><span class="comment"> 2.计算点和圆的关系</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由简单的数学可知：一个点（x，y）和圆的（x，y，r）的关系有三种：</span></span><br><span class="line"><span class="comment">//1.点在圆内：点到圆心的距离d &lt; r</span></span><br><span class="line"><span class="comment">//2.点在圆上：d=r</span></span><br><span class="line"><span class="comment">//3.点在圆外：d&gt;r</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> r;<span class="comment">//写+读</span></span><br><span class="line">	<span class="type">int</span> x;<span class="comment">//写+读</span></span><br><span class="line">	<span class="type">int</span> y;<span class="comment">//写+读</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetX</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		x = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetY</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		y = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetY</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetR</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		r = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetR</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> x;<span class="comment">//写</span></span><br><span class="line">	<span class="type">int</span> y;<span class="comment">//写</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetX</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		x = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetY</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		y = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">location</span><span class="params">(circle&amp; c)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ((x - c.<span class="built_in">GetX</span>()) * (x - c.<span class="built_in">GetX</span>()) + (y - c.<span class="built_in">GetY</span>()) * (y - c.<span class="built_in">GetY</span>()) == c.<span class="built_in">GetR</span>() * c.<span class="built_in">GetR</span>())</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((x - c.<span class="built_in">GetX</span>()) * (x - c.<span class="built_in">GetX</span>()) + (y - c.<span class="built_in">GetY</span>()) * (y - c.<span class="built_in">GetY</span>()) &gt; c.<span class="built_in">GetR</span>() * c.<span class="built_in">GetR</span>())</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	circle c;</span><br><span class="line">	point p;</span><br><span class="line">	c.<span class="built_in">SetX</span>(<span class="number">0</span>);</span><br><span class="line">	c.<span class="built_in">SetY</span>(<span class="number">0</span>);</span><br><span class="line">	c.<span class="built_in">SetR</span>(<span class="number">1</span>);</span><br><span class="line">	p.<span class="built_in">SetX</span>(<span class="number">0</span>);</span><br><span class="line">	p.<span class="built_in">SetY</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> ret = p.<span class="built_in">location</span>(c);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;点在圆外&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;点在圆内&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;点在圆上&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889</span></span><br></pre></td></tr></table></figure>

<p><strong>优化</strong>：因为圆类里面包含点类（转到目录4.3.2.4类对象作为类的成员）</p>
<h2 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h2><p>C++利用构造函数和析构函数解决了对象的初始化和清理。对象的初始化和清理工作是编译器强制要求我们做的事情，因此就算我们不提供构造和析构，编译器也会提供，只不过编译器提供的是构造函数和析构函数的空实现。</p>
<h3 id="4-3-1-构造函数"><a href="#4-3-1-构造函数" class="headerlink" title="4.3.1 构造函数"></a>4.3.1 构造函数</h3><p>​      <strong>定义</strong>：主要作用在创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。<br>​      <strong>语法</strong>：<code>类名</code> <code>()</code> <code>&#123; &#125;</code><br>​      <strong>分类</strong>：按参数分：有参，无参；按类型分：普通构造，拷贝构造。<br>​      <strong>调用方式</strong>：括号法，显示法，隐式转换法.<br>🔴<strong>注意</strong>：<br>​     ①构造函数可以有参数，因此可以重载。<br>​     ②程序在调用对象时会自动调用构造，无须手动调用，且只用调用一次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造的分类和调用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（普通构造）（默认构造）</span></span><br><span class="line">	<span class="built_in">person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参（普通构造）</span></span><br><span class="line">	<span class="built_in">person</span>(<span class="type">int</span> a)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">person</span>(<span class="type">const</span> person &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		age = p.age;<span class="comment">//克隆数据</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//括号法</span></span><br><span class="line">	person p1;<span class="comment">//叫括号法，但是不能加(),加了()编译器会认为是一个函数声明</span></span><br><span class="line">	<span class="function">person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//p2的年龄初始化为10</span></span><br><span class="line">	<span class="function">person <span class="title">p3</span><span class="params">(p2)</span></span>;  </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//显示法</span></span><br><span class="line">	person p4 = <span class="built_in">person</span>();</span><br><span class="line">	person p5 = <span class="built_in">person</span>(<span class="number">10</span>);</span><br><span class="line">	person p6 = <span class="built_in">person</span>(p5);</span><br><span class="line">	<span class="comment">//person()为匿名对象，没有名字，但创建了对象</span></span><br><span class="line">	<span class="comment">//不要用拷贝构造函数初始化匿名对象，如person(p3)，等价于person p3</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//隐式转换法</span></span><br><span class="line">	person p7 = <span class="number">10</span>;<span class="comment">//转换为：person p7=person(10)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>构造函数的调用规则</strong>：<br>创建一个类，C++至少给每一个类添加4个函数：默认构造(空实现)，析构函数(空实现)，拷贝构造(值拷贝)，赋值运算符Operator&#x3D;对属性进行值拷贝（4.5.4中介绍）<br>  ①如果用户定义一个有参构造函数，C++不会提供默认构造函数，但是会提供拷贝构造函数。<br>  ②如果用户定义一个拷贝构造函数，C++不会提供别的构造函数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.①如果用户定义一个有参构造函数，C++不会提供默认构造函数，但是会提供拷贝构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>(<span class="type">int</span> a)</span><br><span class="line">	&#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;默认构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span>  <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person p1;<span class="comment">//err</span></span><br><span class="line">	<span class="function">person <span class="title">p2</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">person <span class="title">p3</span><span class="params">(p2)</span></span>;<span class="comment">//拷贝构造函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p<span class="number">2.</span><span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324</span></span><br><span class="line"><span class="comment">//②如果用户定义一个拷贝构造函数，C++不会提供别的构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>(<span class="type">const</span> person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		age = p.age;<span class="comment">//克隆数据</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span>  <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person p1;<span class="comment">//err</span></span><br><span class="line">	<span class="function">person <span class="title">p2</span><span class="params">(<span class="number">18</span>)</span></span>;<span class="comment">//err</span></span><br><span class="line">	<span class="function">person <span class="title">p3</span><span class="params">(p1)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p<span class="number">2.</span><span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-2-析构函数"><a href="#4-3-2-析构函数" class="headerlink" title="4.3.2 析构函数"></a>4.3.2 析构函数</h3><p>​      <strong>定义</strong>：主要作用在于对象销毁前系统自动调用，执行一些清理工作。<br>​      <strong>语法</strong>：<code>~类名</code> <code>()</code> <code>&#123; &#125;</code></p>
<p>🔴<strong>注意</strong>：<br>     ①析构函数不可以有参数，因此不可以重载。<br>     ②程序在对象销毁前会自动调用析构，无须手动调用，且只用调用一次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg. 构造函数和析构函数例子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person p;<span class="comment">//创建在栈上，在对象销毁前自动调用析构函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/6be5385222ca41b99188a3780908e0ee.png" alt="在这里插入图片描述"></p>
<h4 id="4-3-2-1-拷贝函数调用的时机"><a href="#4-3-2-1-拷贝函数调用的时机" class="headerlink" title="4.3.2.1 拷贝函数调用的时机"></a>4.3.2.1 拷贝函数调用的时机</h4><p>​     C++中拷贝函数调用一般有三种情况：<br>​         ①使用一个已创建完毕的对象来初始化一个新对象。<br>​         ②值传递的方式给函数参数传值。<br>​         ③以值的方式返回局部对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;默认构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">person</span>(<span class="type">int</span> a)</span><br><span class="line">	&#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;默认构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">person</span>(<span class="type">const</span> person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		age = p.age;<span class="comment">//克隆数据</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span>  <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">(person p)</span><span class="comment">//仅仅测试</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">person <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person p;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//使用一个已创建完毕的对象来初始化一个新对象</span></span><br><span class="line">	<span class="function">person <span class="title">p1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p<span class="number">2.</span><span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//值传递的方式给函数参数传值</span></span><br><span class="line">	person p3;</span><br><span class="line">	<span class="built_in">test1</span>(p3);</span><br><span class="line">	<span class="comment">//以值的方式返回局部对象</span></span><br><span class="line">	<span class="built_in">test2</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-2-2-深拷贝与浅拷贝"><a href="#4-3-2-2-深拷贝与浅拷贝" class="headerlink" title="4.3.2.2 深拷贝与浅拷贝"></a>4.3.2.2 深拷贝与浅拷贝</h4><ul>
<li><strong>浅拷贝</strong>：简单的赋值拷贝。</li>
<li><strong>深拷贝</strong>：在堆区重新申请空间，进行拷贝。</li>
</ul>
<p>❗ <strong>浅拷贝存在的问题</strong>：堆区内容重复释放。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/fc89a3bffb0240ba8b9a4428d9f5eb69.png" alt="在这里插入图片描述"></p>
<p>✅解决方案·<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/1d1e3554a40a4ed3a138897c3bbecda9.png" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>(<span class="type">int</span> a,<span class="type">int</span> h)</span><br><span class="line">	&#123;</span><br><span class="line">		age = a;</span><br><span class="line">		height = <span class="keyword">new</span> <span class="built_in">int</span>(h);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">person</span>(<span class="type">const</span> person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		<span class="comment">//height=p.height;//编译器默认实现</span></span><br><span class="line">		height = <span class="keyword">new</span> <span class="built_in">int</span>(*(p.height));</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (height != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> height;</span><br><span class="line">			height = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span>  <span class="title">GetAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> *height;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> *height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">160</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">GetAge</span>() &lt;&lt; <span class="string">&quot; p1的身高为：&quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">GetHeight</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="function">person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p<span class="number">2.</span><span class="built_in">GetAge</span>() &lt;&lt; <span class="string">&quot; p2的身高为：&quot;</span> &lt;&lt; p<span class="number">2.</span><span class="built_in">GetHeight</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-3-初始化列表"><a href="#4-3-3-初始化列表" class="headerlink" title="4.3.3 初始化列表"></a>4.3.3 初始化列表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//初始化列表初始化属性</span></span><br><span class="line">	<span class="built_in">person</span>() :<span class="built_in">age</span>(<span class="number">10</span>), <span class="built_in">key</span>(<span class="number">123</span>), <span class="built_in">height</span>(<span class="number">160</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">age</span>(a), <span class="built_in">key</span>(b), <span class="built_in">height</span>(c)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	<span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person p1;</span><br><span class="line">	<span class="function">person <span class="title">p2</span><span class="params">(<span class="number">18</span>, <span class="number">456</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄，密码，身高为：\n&quot;</span> &lt;&lt; p<span class="number">1.</span>age &lt;&lt; p<span class="number">1.</span>key &lt;&lt; p<span class="number">1.</span>height&lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄，密码，身高为：\n&quot;</span> &lt;&lt; p<span class="number">2.</span>age &lt;&lt; p<span class="number">2.</span>key &lt;&lt; p<span class="number">2.</span>height&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-4-类对象作为类的成员"><a href="#4-3-4-类对象作为类的成员" class="headerlink" title="4.3.4 类对象作为类的成员"></a>4.3.4 类对象作为类的成员</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">phone</span>(string p):<span class="built_in">PhoneName</span>(p)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	string PhoneName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">person</span>(string s,string p) : <span class="built_in">name</span>(s),<span class="built_in">Phone</span>(p)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	string name;</span><br><span class="line">	phone Phone;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">person <span class="title">p1</span><span class="params">(<span class="string">&quot;xiyang&quot;</span>, <span class="string">&quot;huawei&quot;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;名字：&quot;</span> &lt;&lt; p<span class="number">1.</span>name &lt;&lt; <span class="string">&quot;手机：&quot;</span> &lt;&lt; p<span class="number">1.</span>Phone.PhoneName &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627</span></span><br></pre></td></tr></table></figure>

<p>🔴<strong>注意</strong>：若<code>class</code>里面有其他类，则先构造其他类，再构造自身。析构相反。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">phone</span>(string p):<span class="built_in">PhoneName</span>(p)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">phone</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	string PhoneName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">person</span>(string s,string p) : <span class="built_in">name</span>(s),<span class="built_in">Phone</span>(p)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	string name;</span><br><span class="line">	phone Phone;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">person <span class="title">p1</span><span class="params">(<span class="string">&quot;xiyang&quot;</span>, <span class="string">&quot;huawei&quot;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;名字：&quot;</span> &lt;&lt; p<span class="number">1.</span>name &lt;&lt; <span class="string">&quot;手机：&quot;</span> &lt;&lt; p<span class="number">1.</span>Phone.PhoneName &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/0d02a6a336034180ad6d5ae3fc0e8ece.png" alt="在这里插入图片描述"></p>
<h3 id="4-3-5-静态成员"><a href="#4-3-5-静态成员" class="headerlink" title="4.3.5 静态成员"></a>4.3.5 静态成员</h3><ol>
<li>静态成员变量：<br>🔵<strong>特点</strong>：<br>   ①所有对象共享一份数据。<br>   ②在编译阶段分配内存。<br>   ③类内声明，类外初始化。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a;<span class="comment">//类内声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> person::a = <span class="number">100</span>;<span class="comment">//类外初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person p1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的值为：&quot;</span> &lt;&lt; p<span class="number">1.</span>a &lt;&lt; endl;</span><br><span class="line">	person p2;</span><br><span class="line">	p<span class="number">2.</span>a = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的值为：&quot;</span> &lt;&lt; p<span class="number">1.</span>a &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>

<p>🔴<strong>注意</strong>：<br>   ① 静态成员变量不属于某一个对象。因此有两种访问方式：①类名访问，②对象访问。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> person::a = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//对象访问</span></span><br><span class="line">	person p1;</span><br><span class="line">	cout &lt;&lt; p<span class="number">1.</span>a &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//类名访问</span></span><br><span class="line">	cout  &lt;&lt; person::a &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<p>   ②静态成员变量也有访问权限。</p>
<ol>
<li>静态成员函数：<br>🔵<strong>特点</strong>：<br>   ①所有对象共享一个函数。<br>   ②静态成员函数只能访问静态成员函数。<br>🔴<strong>注意</strong>：静态成员函数也有访问权限。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态成员函数的访问</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;static void test()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//对象访问</span></span><br><span class="line">	person p;</span><br><span class="line">	p.<span class="built_in">test</span>();</span><br><span class="line">	<span class="comment">//成员访问</span></span><br><span class="line">	person::<span class="built_in">test</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br><span class="line"><span class="comment">//静态成员函数只能访问静态成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		a = <span class="number">200</span>;</span><br><span class="line">		b = <span class="number">200</span>;<span class="comment">//err，对象不明</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;static void test()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a;<span class="comment">//静态成员函数访问静态成员变量</span></span><br><span class="line">	<span class="type">int</span> b;<span class="comment">//非静态成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> person::a = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person p;</span><br><span class="line">	p.<span class="built_in">test</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre></td></tr></table></figure>

<h2 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h2><h3 id="4-4-1-成员变量和成员函数分开存储"><a href="#4-4-1-成员变量和成员函数分开存储" class="headerlink" title="4.4.1 成员变量和成员函数分开存储"></a>4.4.1 成员变量和成员函数分开存储</h3><p>在C++中，类的成员变量和成员函数分开存储，只有非静态成员变量才属于类的对象上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person1</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;<span class="comment">//非静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person3</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> b;<span class="comment">//静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person4</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> b;<span class="comment">//静态成员变量</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span><span class="comment">//非静态成员函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//空对象占用内存是 1</span></span><br><span class="line">	<span class="comment">//C++会给每一个空对象分配一个字节的内存空间，为了区分空对象占内存的位置</span></span><br><span class="line">	<span class="comment">//每一个空对象也应该有一个独一无二的内存地址</span></span><br><span class="line">	person1 p1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(p)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p1) &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//虽然空对象有一个字节，但是一旦类里面不为空就跟着类中字节走</span></span><br><span class="line">	person2 p2;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(p)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p2) &lt;&lt; endl;<span class="comment">//4</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//静态成员变量不属于类对象上的</span></span><br><span class="line">	person3 p3;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(p)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p3) &lt;&lt; endl;<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//类的成员变量和成员函数分开存储</span></span><br><span class="line">	person4 p4;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(p)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p4) &lt;&lt; endl;<span class="comment">//4</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-2-this指针概念"><a href="#4-4-2-this指针概念" class="headerlink" title="4.4.2 this指针概念"></a>4.4.2 this指针概念</h3><p>​      <strong>定义</strong>：this指针指向被调用的成员函数所属的对象。<br>🔵<strong>特点</strong>：<br>​     ①this指针隐含在每一个非静态成员函数内的一种指针。<br>​     ②this指针不需要定义，可直接使用。<br>🟦<strong>意义</strong>：<br>​     ①当形参和成员变量同名时，可以用this指针来区分。<br>​     ②在类的非静态成员函数中返回对象本身，可以用<code>retrun *this</code></p>
<p>❗<strong>形参和成员变量名字相同</strong>：<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/bc96a41857804bb581b51ca8d80bb37e.png" alt="在这里插入图片描述"></p>
<p>✅<strong>解决方案</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.当形参和成员变量同名时，可以用this指针来区分。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//this 指向被调用的成员函数所属的对象</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; p<span class="number">1.</span>age &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/709416551d6342d2b522dcf9a686a985.png" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在类的非静态成员函数中返回对象本身，可以用retrun *this</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">person&amp; <span class="title">test</span><span class="params">(person p)</span><span class="comment">//person一定要加&amp;，使用本体</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">person <span class="title">p2</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="comment">//链式编程</span></span><br><span class="line">	p<span class="number">2.</span><span class="built_in">test</span>(p1).<span class="built_in">test</span>(p1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p<span class="number">2.</span>age &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/b3b3553a693249ed8c0dadae443b652b.png" alt="在这里插入图片描述"></p>
<h3 id="4-4-3-空指针访问成员函数"><a href="#4-4-3-空指针访问成员函数" class="headerlink" title="4.4.3 空指针访问成员函数"></a>4.4.3 空指针访问成员函数</h3><p>C++中空指针可以调用成员函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;test1&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;age=&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;age&lt;&lt; endl;<span class="comment">//err，传入的指针为空</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person *p=<span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;<span class="built_in">test1</span>();</span><br><span class="line">	p-&gt;<span class="built_in">test2</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>-&gt;age==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;<span class="comment">//提高代码的健壮性</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;age=&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;age&lt;&lt; endl;<span class="comment">//err，传入的指针为空</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-4-const修饰成员函数"><a href="#4-4-4-const修饰成员函数" class="headerlink" title="4.4.4 const修饰成员函数"></a>4.4.4 const修饰成员函数</h3><p>​      <strong>常函数</strong>：成员函数后<code>const</code><br>🔵<strong>特点</strong>：<br>​     ①常函数内不可以修改成员属性。<br>​     ②成员属性声明时加关键字<code>mutable</code>后，在常函数中依然可以修改。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		a = <span class="number">100</span>;</span><br><span class="line">		b = <span class="number">200</span>; <span class="comment">//err b是常量不可以修改</span></span><br><span class="line">		c = <span class="number">300</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在成员函数后加const，修饰的是this指向，让指针指向的值不能改变</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		a = <span class="number">100</span>;  <span class="comment">//err 相当于this-&gt;a=100 </span></span><br><span class="line">		b = <span class="number">200</span>;  <span class="comment">//err b是常量不可修改</span></span><br><span class="line">		c = <span class="number">300</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> b;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person p;</span><br><span class="line">	p.<span class="built_in">test1</span>();</span><br><span class="line">	p.<span class="built_in">test2</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>常对象</strong>：声明对象前加<code>const</code><br>🔵<strong>特点</strong>：<br>​     ①常对象只能调用常函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> b;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> person p;<span class="comment">//不能修改指针指向的值</span></span><br><span class="line">	p.a = <span class="number">100</span>;<span class="comment">//err</span></span><br><span class="line">	p.b = <span class="number">200</span>;<span class="comment">//err</span></span><br><span class="line">	p.c = <span class="number">300</span>;</span><br><span class="line">	p.<span class="built_in">test1</span>();<span class="comment">//err 常对象只能调用常函数</span></span><br><span class="line">	p.<span class="built_in">test2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure>

<h2 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h2><p>​      <strong>目的</strong>：让一个函数或类，访问另一个类中的私有成员。<br>​      <strong>关键字</strong>：<code>friend</code><br>​      <strong>实现</strong>：<br>​         ①全局函数做友元。<br>​         ②类做友元。<br>​         ③成员函数做友元。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局函数做友元</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">test2</span><span class="params">(building* b)</span></span>;<span class="comment">//声明友元函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string bedroom;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">building</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		bedroom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">		livingroom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	string livingroom;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">(building* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;访问&quot;</span> &lt;&lt; b-&gt;livingroom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;访问&quot;</span> &lt;&lt; b-&gt;bedroom&lt;&lt; endl;<span class="comment">//err 不可访问私有成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">(building* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;访问&quot;</span> &lt;&lt; b-&gt;livingroom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;访问&quot;</span> &lt;&lt; b-&gt;bedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	building b1;</span><br><span class="line">	<span class="built_in">test1</span>(&amp;b1);</span><br><span class="line">	<span class="built_in">test2</span>(&amp;b1);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031</span></span><br><span class="line"><span class="comment">//类做友元</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">gay2</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">building</span>();</span><br><span class="line">	string livingroom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string bedroom;</span><br><span class="line">&#125;;</span><br><span class="line">building::<span class="built_in">building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	bedroom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">	livingroom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非友元</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">gay1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">gay1</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">vist</span><span class="params">()</span></span>;</span><br><span class="line">	building* b;</span><br><span class="line">&#125;;</span><br><span class="line">gay1::<span class="built_in">gay1</span>()</span><br><span class="line">&#123;</span><br><span class="line">	b = <span class="keyword">new</span> building;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gay1::vist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;朋友在访问&quot;</span> &lt;&lt; b-&gt;livingroom &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt; <span class="string">&quot;朋友在访问&quot;</span> &lt;&lt; b-&gt;bedroom &lt;&lt; endl;<span class="comment">//err 没有访问权限</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//友元</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">gay2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">gay2</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">vist</span><span class="params">()</span></span>;</span><br><span class="line">	building* b;</span><br><span class="line">&#125;;</span><br><span class="line">gay2::<span class="built_in">gay2</span>()</span><br><span class="line">&#123;</span><br><span class="line">	b = <span class="keyword">new</span> building;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gay2::vist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;朋友在访问&quot;</span> &lt;&lt; b-&gt;livingroom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;朋友在访问&quot;</span> &lt;&lt; b-&gt;bedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gay1  g1;</span><br><span class="line">	g<span class="number">1.</span><span class="built_in">vist</span>();</span><br><span class="line">	gay2 g2;</span><br><span class="line">	g<span class="number">2.</span><span class="built_in">vist</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657</span></span><br><span class="line"><span class="comment">//成员函数做友元</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">building</span>;<span class="comment">//当用到友元成员函数时，需注意友元声明与友元定义之间的互相依赖。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">gay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">gay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span>;</span><br><span class="line">	building* b;</span><br><span class="line">&#125;;</span><br><span class="line">gay::<span class="built_in">gay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	b = <span class="keyword">new</span> building;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gay::test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;正在访问&quot;</span> &lt;&lt; b-&gt;livingroom &lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;正在访问&quot;</span> &lt;&lt; b-&gt;bedroom &lt;&lt; endl;<span class="comment">//err </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gay::test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;正在访问&quot;</span> &lt;&lt; b-&gt;livingroom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;正在访问&quot;</span> &lt;&lt; b-&gt;bedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">building</span>();</span><br><span class="line">	string livingroom;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">gay::test2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string bedroom;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">building::<span class="built_in">building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	bedroom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">	livingroom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gay g1;</span><br><span class="line">	g<span class="number">1.</span><span class="built_in">test1</span>();</span><br><span class="line">	g<span class="number">1.</span><span class="built_in">test2</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546</span></span><br></pre></td></tr></table></figure>

<h2 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h2><p>运算符重载对已有的运算符重新定义，赋予另一种功能，以适应不同的数据类型。</p>
<h3 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h3><p>​      <strong>作用</strong>：实现两个自定义数据类型相加的运算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="comment">//加号运算符重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>(<span class="type">int</span> x, <span class="type">int</span> y) :<span class="built_in">a</span>(x), <span class="built_in">b</span>(y)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载运算符operator</span></span><br><span class="line">	<span class="comment">//成员函数重载+号</span></span><br><span class="line">	person <span class="keyword">operator</span>+(person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">person <span class="title">temp</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">		temp.a = <span class="keyword">this</span>-&gt;a + p.a;</span><br><span class="line">		temp.b = <span class="keyword">this</span>-&gt;b + p.b;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数重载+号</span></span><br><span class="line">person <span class="keyword">operator</span>+(person&amp; p1, person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">person <span class="title">temp</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">	temp.a = p<span class="number">1.</span>a + p<span class="number">2.</span>a;</span><br><span class="line">	temp.b = p<span class="number">1.</span>b + p<span class="number">2.</span>b;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">person <span class="title">p2</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	person p3 = p1+p2;<span class="comment">//方法一(若用此方法需要屏蔽上面一种重载方式，避免多个运算符+与操作数匹配)</span></span><br><span class="line">	person p3 = p<span class="number">1.</span><span class="keyword">operator</span>+(p2);<span class="comment">//方法二</span></span><br><span class="line">	person p3 = <span class="keyword">operator</span>+(p1, p2);<span class="comment">//方法三</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637</span></span><br></pre></td></tr></table></figure>

<p>🔴<strong>注意</strong>：不要滥用运算重载符。</p>
<h3 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h3><p>​      <strong>作用</strong>：可以输出自定义类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//舍弃成员函数重载，p.operator&lt;&lt;cout相当于p&lt;&lt;cout与期望不相符</span></span><br><span class="line">	<span class="comment">//void operator&lt;&lt;(cout)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="built_in">person</span>(<span class="type">int</span> x) :<span class="built_in">a</span>(x)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数重载左移运算符</span></span><br><span class="line"><span class="comment">//cout属于标准输出流ostream类型</span></span><br><span class="line"><span class="comment">//返回ostream是链式编程思想，返回后cout&lt;&lt;p&lt;&lt;...后面可以再利用</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;p中a的值为：&quot;</span>&lt;&lt; p.a&lt;&lt;<span class="string">&quot;p中b的值为：&quot;</span>&lt;&lt; p.b&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">person <span class="title">p</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; p;<span class="comment">//方法一</span></span><br><span class="line">	<span class="keyword">operator</span>&lt;&lt;(cout, p);<span class="comment">//方法二</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031</span></span><br></pre></td></tr></table></figure>

<h3 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重载递增运算符</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInt</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, MyInt m);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyInt</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		num = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//前置++</span></span><br><span class="line">	<span class="comment">//&amp;的作用是对同一个数据进行递增</span></span><br><span class="line">	MyInt&amp; <span class="keyword">operator</span>++()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//先++</span></span><br><span class="line">		num++;</span><br><span class="line">		<span class="comment">//再返回</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//后置++</span></span><br><span class="line">	<span class="comment">//int是占位参数</span></span><br><span class="line">	MyInt <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//先暂存</span></span><br><span class="line">		MyInt temp = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="comment">//再++</span></span><br><span class="line">		num++;</span><br><span class="line">		<span class="comment">//返回暂存的数据</span></span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, MyInt m)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; m.num;</span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyInt m;</span><br><span class="line">	cout &lt;&lt; ++m &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;m++&lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546</span></span><br></pre></td></tr></table></figure>

<p>🔴<strong>注意</strong>：前置++，返回是引用。后置++，返回的是值。</p>
<h3 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h3><p>​    创建一个类，C++至少给每一个类添加4个函数：默认构造(空实现)，析构函数(空实现)，拷贝构造(值拷贝)，赋值运算符Operator&#x3D;对属性进行值拷贝</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值运算符的重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>(<span class="type">int</span> a)</span><br><span class="line">	&#123;</span><br><span class="line">		age=<span class="keyword">new</span> <span class="built_in">int</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> age;</span><br><span class="line">			age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载赋值运算符以避免浅拷贝带来的问题</span></span><br><span class="line">	person&amp; <span class="keyword">operator</span>=(person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//age=p.age;//编译器默认实现</span></span><br><span class="line">		<span class="keyword">if</span> (age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> age;</span><br><span class="line">			age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.age);</span><br><span class="line">		<span class="comment">//返回自身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> *age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">	p3=p2 = p1;</span><br><span class="line">	cout &lt;&lt; *(p<span class="number">2.</span>age) &lt;&lt; endl;<span class="comment">//10</span></span><br><span class="line">	cout &lt;&lt; *(p<span class="number">3.</span>age) &lt;&lt; endl;<span class="comment">//10</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041</span></span><br></pre></td></tr></table></figure>

<h3 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h3><p>​      <strong>作用</strong>：重载关系运算符，可以让两个自定义类型对象进行对比操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关系运算符重载 == !=</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>(string s,<span class="type">int</span> a):<span class="built_in">name</span>(s),<span class="built_in">age</span>(a)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;name == p.name &amp;&amp; <span class="keyword">this</span>-&gt;age == p.age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">person <span class="title">p1</span><span class="params">(<span class="string">&quot;xi&quot;</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">person <span class="title">p2</span><span class="params">(<span class="string">&quot;xi&quot;</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (p1 == p2)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1和p2相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1和p2不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132</span></span><br></pre></td></tr></table></figure>

<h3 id="4-5-6-函数调用运算符重载（仿函数）"><a href="#4-5-6-函数调用运算符重载（仿函数）" class="headerlink" title="4.5.6 函数调用运算符重载（仿函数）"></a>4.5.6 函数调用运算符重载（仿函数）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数调用运算符重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span><span class="comment">//与函数调用长得差不多，所以被称为仿函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint m1,m2;</span><br><span class="line">	<span class="built_in">m1</span>(<span class="string">&quot;xiyang&quot;</span>);</span><br><span class="line">	<span class="built_in">m2</span>(<span class="string">&quot;xiyang&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre></td></tr></table></figure>

<h2 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6 继承"></a>4.6 继承</h2><h3 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h3><p>  例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同。接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通实现页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">head</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foot</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cpp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">head</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foot</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;CPP学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">head</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foot</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;java下载视频页面如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	java j;</span><br><span class="line">	j.<span class="built_in">head</span>();</span><br><span class="line">	j.<span class="built_in">foot</span>();</span><br><span class="line">	j.<span class="built_in">left</span>();</span><br><span class="line">	j.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;cpp下载视频页面如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cpp c;</span><br><span class="line">	c.<span class="built_in">head</span>();</span><br><span class="line">	c.<span class="built_in">foot</span>();</span><br><span class="line">	c.<span class="built_in">left</span>();</span><br><span class="line">	c.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;python下载视频页面如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	python p;</span><br><span class="line">	p.<span class="built_in">head</span>();</span><br><span class="line">	p.<span class="built_in">foot</span>();</span><br><span class="line">	p.<span class="built_in">left</span>();</span><br><span class="line">	p.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test1</span>();</span><br><span class="line">	<span class="built_in">test2</span>();</span><br><span class="line">	<span class="built_in">test3</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899</span></span><br><span class="line"><span class="comment">//继承写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">head</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foot</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span> :<span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;java学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cpp</span> :<span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;cpp学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">python</span> :<span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>优势</strong>：减少重复代码<br>​      <strong>语法</strong>：<code>class 子类 : 继承方式</code></p>
<h3 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h3><p>​    一共有三中继承方式： ①公共继承②保护继承③私有继承</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son1</span> :<span class="keyword">public</span> father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		a = <span class="number">10</span>;<span class="comment">//父类中的公共权限成员，子类也是公共权限</span></span><br><span class="line">		b = <span class="number">10</span>;<span class="comment">//父类中的保护权限成员，子类也是保护权限</span></span><br><span class="line">		<span class="comment">//c = 10;//err 父类的私有权限成员，子类无法访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test11</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	son1 s;</span><br><span class="line">	s.a;</span><br><span class="line">	<span class="comment">//s.b;//err保护权限，类外无法访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son2</span> :<span class="keyword">protected</span> father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		a = <span class="number">10</span>;<span class="comment">//父类中的公共权限成员，子类是保护权限</span></span><br><span class="line">		b = <span class="number">10</span>;<span class="comment">//父类中的保护权限成员，子类是保护权限</span></span><br><span class="line">		<span class="comment">//c = 10;//err 父类的私有权限成员，子类无法访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test22</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	son2 s;</span><br><span class="line">	<span class="comment">//s.a;//err保护权限，类外无法访问</span></span><br><span class="line">	<span class="comment">//s.b;//err保护权限，类外无法访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son3</span> :<span class="keyword">private</span> father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		a = <span class="number">10</span>;<span class="comment">//父类中的公共权限成员，子类是私有权限</span></span><br><span class="line">		b = <span class="number">10</span>;<span class="comment">//父类中的保护权限成员，子类是私有权限</span></span><br><span class="line">		<span class="comment">//c = 10;//err 父类的私有权限成员，子类无法访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test22</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	son3 s;</span><br><span class="line">	<span class="comment">//s.a;//err私有权限，类外无法访问</span></span><br><span class="line">	<span class="comment">//s.b;//err私有权限，类外无法访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364</span></span><br></pre></td></tr></table></figure>

<h3 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h3><p>   ❗ <strong>Q</strong>:从父类继承过来的成员，哪些属于子类对象中？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> d;<span class="comment">//不继承</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> e;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//父类中的所有非静态成员属性都会被子类继承</span></span><br><span class="line">	<span class="comment">//父类的私有成员被编译器隐藏，访问不到但是被继承</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of(son)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(son) &lt;&lt; endl;<span class="comment">//16</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure>

<p><strong>用工具查看</strong>：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/2c43ff4e621b466bacee169fcd5e00cf.png" alt="在这里插入图片描述"><br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/87d4075c34364dd89f890ecaba57f859.png" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cl /d1 reportSingleClassLayout查看的类名 所属文件名</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/d958080d8cc443f2b5adc2d124178f72.png" alt="在这里插入图片描述"><br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/26421286b4a0499abeb1d18a84dfa5b1.png" alt="在这里插入图片描述"></p>
<h3 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">father</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;father的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">father</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;father的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;son的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;son的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	son s;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/35dd2b9c4adf4bf89ad67009c98b6984.png" alt="在这里插入图片描述"></p>
<h3 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">father</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		a = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;father中的test()函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> father::b=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		a = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;son中的test()函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> son::b = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	son s;</span><br><span class="line">	<span class="comment">//同名非静态属性处理方式</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;son中a=&quot;</span> &lt;&lt; s.a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;father中a=&quot;</span> &lt;&lt; s.father::a &lt;&lt; endl;<span class="comment">//通过子类对象访问父类对象成员需要加作用域</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//同名函数处理方式1hj</span></span><br><span class="line">	s.<span class="built_in">test</span>();</span><br><span class="line">	s.father::<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//同名静态属性处理方式</span></span><br><span class="line">	<span class="comment">//方法一：对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;对象访问son中b=&quot;</span> &lt;&lt; s.b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;对象访问father中b=&quot;</span> &lt;&lt; s.father::b &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//方法二：类名访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;类名访问son中b = &quot;</span> &lt;&lt; son::b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;类名访问father中b = &quot;</span> &lt;&lt; father::b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;类名访问father中b = &quot;</span> &lt;&lt; son::father::b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>①子类对象访问子类同名成员：直接访问<br>②子类对象访问父类同名成员：加作用域<code>::</code></p>
</blockquote>
<h3 id="4-6-6-多继承语法"><a href="#4-6-6-多继承语法" class="headerlink" title="4.6.6 多继承语法"></a>4.6.6 多继承语法</h3><p>​      <strong>语法</strong>：<code>class 子类 ：继承方式 父类1，继承方式 父类2，...</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg .用法与上面的大同小异，多继承可能会引发父类中有同名成员出现，需要加作用域区分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">father1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">father1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		a = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">father2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">father2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		b = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father1, <span class="keyword">public</span> father2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		c = <span class="number">10</span>;</span><br><span class="line">		d = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof (son)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(son) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;father1中a的值&quot;</span> &lt;&lt; s.a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637</span></span><br></pre></td></tr></table></figure>

<p>🔴<strong>注意</strong>：<strong>C++实际开发中不建议用多继承</strong></p>
<h3 id="4-6-7-菱形继承"><a href="#4-6-7-菱形继承" class="headerlink" title="4.6.7 菱形继承"></a>4.6.7 菱形继承</h3><p>​      <strong>定义</strong>：两个派生类继承同一个基类，又有某个类同时继承者两个派生类。<img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/b61c1b78fc2e4f20b7555abee5e6a2ed.png" alt="在这里插入图片描述"><br>❗<strong>Q</strong>:菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义<br>✅:虚继承可以解决菱形继承问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//关键字virtual将yang变成虚继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">yang</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> animal&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuo</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> animal&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YangTuo</span> :<span class="keyword">public</span> yang, <span class="keyword">public</span> tuo&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	YangTuo yt;</span><br><span class="line">	yt.yang::age = <span class="number">10</span>;</span><br><span class="line">	yt.tuo::age = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//数据只有一份</span></span><br><span class="line">	cout &lt;&lt; yt.yang::age &lt;&lt; endl;<span class="comment">//20</span></span><br><span class="line">	cout &lt;&lt; yt.tuo::age &lt;&lt; endl;<span class="comment">//20</span></span><br><span class="line">	cout &lt;&lt; yt.age &lt;&lt; endl;<span class="comment">//20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre></td></tr></table></figure>

<h2 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7 多态"></a>4.7 多态</h2><h3 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h3><p>​      <strong>分类</strong>：<br>​      ①静态多态：函数重载 和 运算符重载<br>​      ①动态多态：派生类和虚函数实现运行时多态</p>
<p>🔵<strong>特点</strong>：</p>
<ul>
<li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">breathe</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物呼吸&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物叫&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span>:<span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">breathe</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;喵呼吸&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;miaomiao~&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//地址早绑定 在编译阶段确定函数地址</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSpeak</span><span class="params">(animal &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	a.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地址晚绑定 在函数前加 virtual，在运行阶段确定地址</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoBreathe</span><span class="params">(animal&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	a.<span class="built_in">breathe</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cat c;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(c);<span class="comment">//miaomiao~</span></span><br><span class="line">	<span class="built_in">DoBreathe</span>(c);<span class="comment">//动物呼吸</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>动态多态满足条件:</strong><br>①有继承关系<br>②子类重写父类中的虚函数（子类的<code>virtual</code>可有可无）</p>
</blockquote>
<blockquote>
<p><strong>动态多态的使用</strong>：父类的指针或引用，执行子类对象。</p>
</blockquote>
<h3 id="4-7-2-多态原理剖析（图解）"><a href="#4-7-2-多态原理剖析（图解）" class="headerlink" title="4.7.2 多态原理剖析（图解）"></a>4.7.2 多态原理剖析（图解）</h3><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/aac0e502fe2e42d192359879cdb68435.png" alt="在这里插入图片描述"></p>
<h3 id="4-7-3-多态案例一：计算器类"><a href="#4-7-3-多态案例一：计算器类" class="headerlink" title="4.7.3 多态案例一：计算器类"></a>4.7.3 多态案例一：计算器类</h3><p>  <strong>案例描述：</strong><br><em>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通写法  + - * /</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">calculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetResult</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="string">&quot;+&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> a + b;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;-&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> a - b;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;*&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> a * b;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;/&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> a / b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	calculator c;</span><br><span class="line">	string s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;输入两个整型数字的+-*/运算：&quot;</span> &lt;&lt; endl;;</span><br><span class="line">	cin &gt;&gt; c.a &gt;&gt;s&gt;&gt; c.b;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; c.<span class="built_in">GetResult</span>(s) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627</span></span><br></pre></td></tr></table></figure>

<p><strong>❗局限</strong>：扩展新的功能，需要修改源码。<br>✅：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多态写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//加法计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//减法计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a - b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//乘法计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mul</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a * b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//除法计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Div</span>:<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a / b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Do</span><span class="params">(AbstractCalculator&amp; ac2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ac<span class="number">2.</span><span class="built_in">GetResult</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//加法</span></span><br><span class="line">	<span class="comment">//父类的指针或引用，执行子类对象</span></span><br><span class="line">	AbstractCalculator* ac = <span class="keyword">new</span> Add;</span><br><span class="line">	ac-&gt;a = <span class="number">10</span>;</span><br><span class="line">	ac-&gt;b = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; ac-&gt;a &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; ac-&gt;b &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; ac-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//记得销毁</span></span><br><span class="line">	<span class="keyword">delete</span> ac;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//减法</span></span><br><span class="line">	ac = <span class="keyword">new</span> Sub;</span><br><span class="line">	ac-&gt;a = <span class="number">10</span>;</span><br><span class="line">	ac-&gt;b = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; ac-&gt;a &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; ac-&gt;b &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; ac-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//记得销毁</span></span><br><span class="line">	<span class="keyword">delete</span> ac;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//乘法除法同理</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>多态优势</strong>：<br>①组织结构清晰，可读性强。<br>②对于前期和后期扩展及维护性高。</p>
</blockquote>
<h3 id="4-7-4-纯虚函数和抽象类"><a href="#4-7-4-纯虚函数和抽象类" class="headerlink" title="4.7.4 纯虚函数和抽象类"></a>4.7.4 纯虚函数和抽象类</h3><p>  在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为<strong>纯虚函数</strong></p>
<p>​      <strong>纯虚函数定义</strong>：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code><br>​      <strong>抽象类定义</strong>：当类中有了纯虚函数，这个类也称为<strong>抽象类</strong></p>
<p>🔵<strong>抽象类的特点</strong>：<br>      ①无法实例化对象<br>      ②子类必须重写抽象类中的纯虚函数，否则也属于抽象类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//纯虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son1</span> :<span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son2</span> :<span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//base b;//err 抽象类无法实例化对象</span></span><br><span class="line">	<span class="comment">//new base;//err </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//son1 s;//子类必须重写抽象类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line">	son2 s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure>

<h3 id="4-7-5-多态案例二：制作饮品"><a href="#4-7-5-多态案例二：制作饮品" class="headerlink" title="4.7.5 多态案例二：制作饮品"></a>4.7.5 多态案例二：制作饮品</h3><p><strong>案例描述</strong>：<br>  制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料。<br>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//煮水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BoilWater</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span> ;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">IntoCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomeing</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//制作饮品</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Make</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">BoilWater</span>();</span><br><span class="line">		<span class="built_in">Brew</span>();</span><br><span class="line">		<span class="built_in">IntoCup</span>();</span><br><span class="line">		<span class="built_in">PutSomeing</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> :<span class="keyword">public</span> AbstractDrinking</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//煮水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BoilWater</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮500ml水&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入10g茶叶&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">IntoCup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;倒入杯子里&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomeing</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入柠檬&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> :<span class="keyword">public</span> AbstractDrinking</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//煮水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BoilWater</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮500ml水&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入一勺咖啡&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">IntoCup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;倒入杯子里&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomeing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入牛奶&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoMake</span><span class="params">(AbstractDrinking* ad)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ad-&gt;<span class="built_in">Make</span>();</span><br><span class="line">	<span class="keyword">delete</span> ad;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//做一杯茶</span></span><br><span class="line">	<span class="built_in">DoMake</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">	<span class="comment">//做一杯咖啡</span></span><br><span class="line">	<span class="built_in">DoMake</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879</span></span><br></pre></td></tr></table></figure>

<h3 id="4-7-6-虚析构函数和抽象类"><a href="#4-7-6-虚析构函数和抽象类" class="headerlink" title="4.7.6 虚析构函数和抽象类"></a>4.7.6 虚析构函数和抽象类</h3><p>  多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码，将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong>就可以解决</p>
<p>​      <strong>虚析构语法</strong>：<code>virtual ~类名()&#123;&#125;</code><br>​      <strong>纯虚析构语法</strong>：<code>virtual ~类名() = 0;</code> <code>类名::~类名()&#123;&#125;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Animal</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Animal</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal析构函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//虚析构可以解决 父类指针释放子类对象时不干净的问题</span></span><br><span class="line">	<span class="comment">//virtual ~Animal()</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;Animal虚析构函数的调用&quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//纯虚析构</span></span><br><span class="line">	<span class="comment">//virtual ~Animal() = 0;</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//纯虚析构函数要有具体的函数实现</span></span><br><span class="line"><span class="comment">//Animal::~Animal()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;Animal纯虚析构函数的调用&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Cat</span>(string n)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat的构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		name = <span class="keyword">new</span> <span class="built_in">string</span>(n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; *name&lt;&lt;<span class="string">&quot;miao~&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Cat</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat的析构函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (name != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> name;</span><br><span class="line">			name = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	string *name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Animal* a = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;mimi&quot;</span>);</span><br><span class="line">	a-&gt;<span class="built_in">speak</span>();</span><br><span class="line">	<span class="comment">//父类指针在析构时候，不会调用子类中的析构函数，导致子类如果有堆区的属性，会出现内存的泄露</span></span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>虚析构和纯虚析构共性</strong>:<br>①可以解决父类指针释放子类对象<br>②都需要有具体的函数实现</p>
</blockquote>
<p>🔴<strong>注意</strong>：纯虚析构，该类属于抽象类，无法实例化对象</p>
<h3 id="4-7-7-多态案例三：电脑组装"><a href="#4-7-7-多态案例三：电脑组装" class="headerlink" title="4.7.7 多态案例三：电脑组装"></a>4.7.7 多态案例三：电脑组装</h3><p><strong>案例描述</strong>：<br>  电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）<br>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商<br>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口<br>测试时组装三台不同的电脑进行工作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calulate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//intel 厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">calulate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的CPU工作啦！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的VideoCard工作啦！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的Memory工作啦！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//XiaoMi厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XiaoMiCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">calulate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;XiaoMi的CPU工作啦！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XiaoMiVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;XiaoMi的VideoCard工作啦！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XiaoMiMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;XiaoMi的Memory工作啦！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Computer</span>(CPU* cpu, VideoCard* videpcard, Memory* memory)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cpu = cpu;</span><br><span class="line">		<span class="keyword">this</span>-&gt;videpcard = videpcard;</span><br><span class="line">		<span class="keyword">this</span>-&gt;memory = memory;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cpu-&gt;<span class="built_in">calulate</span>();</span><br><span class="line">		videpcard-&gt;<span class="built_in">display</span>();</span><br><span class="line">		memory-&gt;<span class="built_in">storage</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Computer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (cpu!= <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> cpu;</span><br><span class="line">			cpu = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (videpcard!= <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> videpcard;</span><br><span class="line">			videpcard = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (memory!= <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> memory;</span><br><span class="line">			memory = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	CPU* cpu;</span><br><span class="line">	VideoCard* videpcard;</span><br><span class="line">	Memory* memory;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CPU* intel_cpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">	VideoCard* intel_vc = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">	Memory* intel_m = <span class="keyword">new</span> IntelMemory;</span><br><span class="line">	<span class="function">Computer <span class="title">c1</span><span class="params">(intel_cpu, intel_vc, intel_m)</span></span>;</span><br><span class="line">	c<span class="number">1.</span><span class="built_in">DoWork</span>();</span><br><span class="line">	</span><br><span class="line">	CPU* xiaomi_cpu = <span class="keyword">new</span> XiaoMiCPU;</span><br><span class="line">	VideoCard* xiaomi_vc = <span class="keyword">new</span> XiaoMiVideoCard;</span><br><span class="line">	Memory* xiaomi_m = <span class="keyword">new</span> XiaoMiMemory;</span><br><span class="line">	<span class="function">Computer <span class="title">c2</span><span class="params">(xiaomi_cpu, xiaomi_vc, xiaomi_m)</span></span>;</span><br><span class="line">	c<span class="number">2.</span><span class="built_in">DoWork</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/3d875bbba0434f3cbb602db55ef0114d.png" alt="在这里插入图片描述"></p>
<h1 id="五、文件"><a href="#五、文件" class="headerlink" title="五、文件"></a>五、文件</h1><h2 id="5-1-文本文件"><a href="#5-1-文本文件" class="headerlink" title="5.1 文本文件"></a>5.1 文本文件</h2><p>  程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放，通过<strong>文件</strong>可以将<strong>数据持久化</strong><br>  C++中对文件操作需要包含头文件<code>&lt; fstream &gt;</code></p>
<p>  文件类型分为两种：<br>   ①<strong>文本文件</strong> - 文件以文本的<strong>ASCII码</strong>形式存储在计算机中<br>   ②<strong>二进制文件</strong> - 文件以文本的<strong>二进制形式</strong>存储在计算机中，用户一般不能直接读懂它们</p>
<p>  操作文件的三大类:<br>   ①ofstream：写操作<br>   ②ifstream： 读操作<br>   ③fstream ： 读写操作</p>
<h3 id="5-1-1-写文件"><a href="#5-1-1-写文件" class="headerlink" title="5.1.1 写文件"></a>5.1.1 写文件</h3><p><strong>写文件步骤如下</strong>：</p>
<ol>
<li>包含头文件: <code>#include &lt;fstream&gt;</code></li>
<li>创建流对象: <code>ofstream ofs;</code></li>
<li>打开文件: <code>ofs.open(“文件路径”,打开方式);</code></li>
<li>写数据: <code>ofs &lt;&lt; &quot;写入的数据&quot;;</code></li>
<li>关闭文件:<code>ofs.close();</code></li>
</ol>
<p><strong>文件打开方式</strong>：</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
</tbody></table>
<p>🔴<strong>注意</strong>：文件打开方式可以配合使用，利用<code>|</code>操作符。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1.头文件</span></span><br><span class="line">	<span class="comment">//2.创建流对象</span></span><br><span class="line">	ofstream ofs;</span><br><span class="line">	<span class="comment">//3.打开文件,方式为：为写</span></span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line">	<span class="comment">//4.写数据</span></span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//5.关闭文件</span></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/fb5bef70be15468b9a6a0da4bcfc3f93.png" alt="在这里插入图片描述"></p>
<h3 id="5-1-2-读文件"><a href="#5-1-2-读文件" class="headerlink" title="5.1.2 读文件"></a>5.1.2 读文件</h3><p><strong>读文件步骤如下</strong>：</p>
<ol>
<li>包含头文件: <code>#include &lt;fstream&gt;</code></li>
<li>创建流对象: <code>ifstream ifs;</code></li>
<li>打开文件并判断文件是否打开成功: <code>ifs.open(“文件路径”,打开方式);</code></li>
<li>读数据: 四种方式读取</li>
<li>关闭文件: <code>ifs.close();</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1.包含头文件</span></span><br><span class="line">	<span class="comment">//2.创建流对象</span></span><br><span class="line">	ifstream ifs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.打开文件并判断文件是否打开成功</span></span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//4.读数据</span></span><br><span class="line">	<span class="comment">//第一种方式</span></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (ifs &gt;&gt; buf)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种</span></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (ifs.<span class="built_in">getline</span>(buf,<span class="built_in">sizeof</span>(buf)))</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//第三种</span></span><br><span class="line">	string buf;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(ifs, buf))</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//第四种</span></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)<span class="comment">//end of file</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//5.关闭文件</span></span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h2><p>  以二进制的方式对文件进行读写操作打开方式要指定为 <code>ios::binary</code></p>
<h3 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h3><p>  二进制方式写文件主要利用流对象调用成员函数<code>write</code><br>  <strong>函数原型</strong> ：<code>ostream&amp; write(const char * buffer,int len);</code><br>  <strong>参数解释</strong>：字符指针<code>buffer</code>指向内存中一段存储空间。<code>len</code>是读写的字节数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、包含头文件</span></span><br><span class="line">	<span class="comment">//2、创建输出流对象</span></span><br><span class="line">	<span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">	<span class="comment">//3、打开文件</span></span><br><span class="line">	<span class="comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span></span><br><span class="line">	Person p = &#123; <span class="string">&quot;张三&quot;</span>  , <span class="number">18</span> &#125;;</span><br><span class="line">	<span class="comment">//4、写文件</span></span><br><span class="line">	ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line">	<span class="comment">//5、关闭文件</span></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/095a9468e60c4c3c8fd6f47556dc3c9b.png" alt="在这里插入图片描述"></p>
<h3 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h3><p>  二进制方式读文件主要利用流对象调用成员函数<code>read</code><br>  <strong>函数原型</strong>：<code>istream&amp; read(char *buffer,int len);</code><br>  <strong>参数解释</strong>：字符指针<code>buffer</code>指向内存中一段存储空间。<code>len</code>是读写的字节数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1.包含头文件</span></span><br><span class="line">	<span class="comment">//2.创建流对象</span></span><br><span class="line">	<span class="comment">//3.打开文件并判断文件是否打开成功</span></span><br><span class="line">	<span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//4.读文件(读到的是正常的不是乱码)</span></span><br><span class="line">	Person p;</span><br><span class="line">	ifs.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//5.关闭文件</span></span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031</span></span><br></pre></td></tr></table></figure>

<p>文章知识点与官方知识档案匹配，可进一步学</p>
]]></content>
      <categories>
        <category>从零开始的C++の学习之路</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马程序员C++提高编程</title>
    <url>/2023/07/22/C++/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B%E7%B2%BE%E7%BE%8E%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="黑马程序员C-提高编程"><a href="#黑马程序员C-提高编程" class="headerlink" title="黑马程序员C++提高编程"></a>黑马程序员C++提高编程</h1><hr>
<blockquote>
<p>提高阶段主要针对泛型编程和STL技术</p>
</blockquote>
<h1 id="一、模板"><a href="#一、模板" class="headerlink" title="一、模板"></a>一、模板</h1><p>  模板就是建立通用的模具，大大提高复用性,也是泛型编程的思想。C++提供两种模板机制：①函数模板 ②类模板</p>
<p>🔴<strong>注意</strong>：<br>  ① 模板不是万能的。<br>  ② 模板不能直接使用。</p>
<h2 id="1-1-函数模板"><a href="#1-1-函数模板" class="headerlink" title="1.1 函数模板"></a>1.1 函数模板</h2><h3 id="1-1-1-函数模板基础知识"><a href="#1-1-1-函数模板基础知识" class="headerlink" title="1.1.1 函数模板基础知识"></a>1.1.1 函数模板基础知识</h3><p>​      <strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span> T &gt;   </span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure>

<p>​       <em>解释</em>：<code>template</code>— 声明创建模板；<code>typename</code> — 可以用<code>class</code>代替；<code>T</code> — 通用的数据类型<br>​      <strong>使用</strong>：①自动类型推导 ②显示指定类型</p>
<p>🟦<strong>意义</strong>：提高复用性，将类型参数化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数模板的使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">MySwap</span>(a, b);<span class="comment">//自动类型推导</span></span><br><span class="line">	<span class="built_in">MySwap</span>&lt;<span class="type">int</span>&gt;(a, b);<span class="comment">//显示类型推导</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🔴<strong>注意</strong>：</p>
<p>  ① 自动类型推导，必须推导出一致的数据类型T。<br>  ② 模板必须要确定出T的数据类型，才可以使用，因为自动类型推导推不出来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动类型推导必须推出一致的类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">double</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">MySwap</span>(a, b);<span class="comment">//err</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板必须要确定出T的数据类型，才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySwap</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;MySwap的调用&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">MySwap</span>( );<span class="comment">//err 自动类型推导推导不出数据类型</span></span><br><span class="line">	<span class="built_in">MySwap</span>&lt;<span class="type">int</span>&gt;();<span class="comment">//显示指定类型强制推导数据类型</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="案例一：-数组排序"><a href="#案例一：-数组排序" class="headerlink" title="案例一： 数组排序"></a>案例一： 数组排序</h2><p><strong>问题描述</strong>：<br>  利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序； 排序规则从大到小，排序算法为选择排序；分别利用<code>char</code>数组和<code>int</code>数组进行测试</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(T arr[], <span class="type">int</span> sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySort</span><span class="params">(T arr[], <span class="type">int</span> sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		T max = arr[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; sz; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">MySwap</span>(arr[j], arr[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">MyPrint</span>(arr,sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//字符数组测试</span></span><br><span class="line">	<span class="type">char</span> arr1[] = <span class="string">&quot;badcfeg&quot;</span>;</span><br><span class="line">	<span class="built_in">MySort</span>(arr1, <span class="built_in">sizeof</span>(arr1) / <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">	<span class="comment">//整形数组测试</span></span><br><span class="line">	<span class="type">int</span> arr2[] = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span> &#125;;</span><br><span class="line">	<span class="built_in">MySort</span>(arr2, <span class="built_in">sizeof</span>(arr2) / <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-1-普通函数与函数模板"><a href="#1-2-1-普通函数与函数模板" class="headerlink" title="1.2.1 普通函数与函数模板"></a>1.2.1 普通函数与函数模板</h3><p><strong>普通函数与函数模板的区别</strong>：</p>
<ol>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">MyAdd</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">char</span> c = a;</span><br><span class="line">	cout&lt;&lt; <span class="built_in">add</span>(a, b) &lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">add</span>(a, c) &lt;&lt; endl;<span class="comment">//普通函数可以发生隐式类型转换</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">MyAdd</span>(a, b) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">MyAdd</span>(a, c) &lt;&lt; endl;<span class="comment">//err 自动类型推导无法进行隐式类型转换</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">MyAdd</span>&lt;<span class="type">int</span>&gt;(a, c) &lt;&lt; endl;<span class="comment">//显示显示指定类型可以进行隐式类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>普通函数与函数模板调用规则</strong>：</p>
<ol>
<li>同名普通函数与函数模板，优先调用普通函数。</li>
<li>可以通过空模板参数列表来强制调用函数模板。</li>
<li>如果函数模板可以产生更好的匹配,优先调用函数模板</li>
<li>函数模板可以函数重载</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;普通函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;函数模板调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;重载调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//1.同名普通函数与函数模板，优先调用普通函数。</span></span><br><span class="line">	<span class="built_in">print</span>(a);<span class="comment">//输出：普通函数调用</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.可以通过空模板参数列表来强制调用函数模板。</span></span><br><span class="line">	print&lt;&gt;(a);<span class="comment">//输出：函数模板调用</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.如果函数模板可以产生更好的匹配,优先调用函数模板</span></span><br><span class="line">	<span class="type">char</span> c = a;</span><br><span class="line">	<span class="built_in">print</span>(c);<span class="comment">//输出：函数模板调用</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.函数模板可以函数重载</span></span><br><span class="line">	<span class="built_in">print</span>(a, <span class="number">1</span>);<span class="comment">//输出：重载调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-函数模板的局限性"><a href="#1-2-2-函数模板的局限性" class="headerlink" title="1.2.2 函数模板的局限性"></a>1.2.2 函数模板的局限性</h3><p>❗ 模板的通用性并不是万能的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   	a = b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组或是一个类，就无法实现了</p>
<p>✅ 可以为这些特定的类型提供具体化的模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">person</span>(string name,<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//特定的类型提供具体化的模板</span></span><br><span class="line"><span class="comment">//具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="function"><span class="type">bool</span> <span class="title">test</span><span class="params">(person p1, person p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p<span class="number">1.</span>age == p<span class="number">2.</span>age &amp;&amp; p<span class="number">1.</span>name == p<span class="number">2.</span>name)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">person <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">person <span class="title">p2</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">test</span>(p1, p2))</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a==b&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a!=b&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-类模板"><a href="#1-2-类模板" class="headerlink" title="1.2 类模板"></a>1.2 类模板</h2><h3 id="1-2-1-类模板的基础知识"><a href="#1-2-1-类模板的基础知识" class="headerlink" title="1.2.1 类模板的基础知识"></a>1.2.1 类模板的基础知识</h3><p>​      <strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span> T &gt;   </span><br><span class="line">函数声明或定义</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>​       <em>解释</em>：<code>template</code>— 声明创建模板；<code>typename</code> — 可以用<code>class</code>代替；<code>T</code> — 通用的数据类型</p>
<p>​      <strong>作用</strong>：建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类模板的使用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>(NameType name,AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	NameType name;</span><br><span class="line">	AgeType age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person &lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;xiyang&quot;</span>, <span class="number">18</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-类模板与函数模板"><a href="#1-2-2-类模板与函数模板" class="headerlink" title="1.2.2 类模板与函数模板"></a>1.2.2 类模板与函数模板</h3><p>两者使用的区别主要有两个：</p>
<ol>
<li>类模板无法进行自动类型推导。（函数模板可以进行自动类型推导）</li>
<li>类模板在模板的参数列表中可以有默认参数，如果自己传了就用自己传的，没有传就用默认的即等于号后面的。（函数模板不可以用）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span>=<span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>(NameType name,AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	NameType name;</span><br><span class="line">	AgeType age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1.类模板没有自动类型推导</span></span><br><span class="line">	<span class="function">person <span class="title">p1</span><span class="params">(<span class="string">&quot;xiyang&quot;</span>, <span class="number">18</span>)</span></span>;<span class="comment">//err</span></span><br><span class="line">	<span class="comment">//2.类模板在模板参数列表中可以有默认参数</span></span><br><span class="line">	person &lt;string&gt;<span class="built_in">p2</span>(<span class="string">&quot;xiyang&quot;</span>, <span class="number">18</span>);</span><br><span class="line">	person &lt;string&gt;<span class="built_in">p3</span>(<span class="string">&quot;xiyang&quot;</span>,<span class="number">18.1</span>);</span><br><span class="line">	cout &lt;&lt; p<span class="number">3.</span>age;<span class="comment">//输出：18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-3-类模板中的成员函数创建时机"><a href="#1-2-3-类模板中的成员函数创建时机" class="headerlink" title="1.2.3 类模板中的成员函数创建时机"></a>1.2.3 类模板中的成员函数创建时机</h3><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ol>
<li>普通类中成员函数一开始就创建。</li>
<li>类模板中的成员函数只有调用时才创建。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;test1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;test2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T t;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		t.<span class="built_in">test1</span>();</span><br><span class="line">		t.<span class="built_in">test2</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyClass&lt;person1&gt; mc;</span><br><span class="line">	<span class="comment">//没有编译之前不会报错，编译之后报错</span></span><br><span class="line">	<span class="comment">//说明类模板的成员函数是在调用后创建的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-4-类模板成员函数类外实现"><a href="#1-2-4-类模板成员函数类外实现" class="headerlink" title="1.2.4 类模板成员函数类外实现"></a>1.2.4 类模板成员函数类外实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>(T name);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">	T name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数的类外实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">person&lt;T&gt;::<span class="built_in">person</span>(T name)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数的类外实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> person&lt;T&gt;::<span class="built_in">print</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类模板：</p>
<p>person<T>::person(T name)</p>
<p>void person<T>::print()</p>
<p>普通类：</p>
<p>person::person(string name)</p>
<p>void person::print()</p>
<p><strong>类模板多了一个模板的参数列表</strong></p>
<h3 id="1-2-5-类模板的对象做函数参数"><a href="#1-2-5-类模板的对象做函数参数" class="headerlink" title="1.2.5 类模板的对象做函数参数"></a>1.2.5 类模板的对象做函数参数</h3><p>学习目标：类模板实例化出的对象，向函数传参的方式</p>
<p>有三种方式：</p>
<ol>
<li>指定传入的类型 — 直接显示对象的数据类型（使用比较广泛，比较常用）</li>
<li>参数模板化 — 将对象中的参数变为模板进行传递</li>
<li>整个类模板化 — 将这个对象类型 模板化进行传递</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">NameType</span>,<span class="keyword">class</span> <span class="title class_">AgeType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>(NameType name,AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="keyword">this</span>-&gt;name  &lt;&lt; <span class="keyword">this</span>-&gt;age;</span><br><span class="line">	&#125;</span><br><span class="line">	NameType name;</span><br><span class="line">	AgeType age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print1</span><span class="params">(person &lt;string, <span class="type">int</span>&gt;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2</span><span class="params">(person &lt;T1 , T2&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T1的类型:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;<span class="comment">//模板推出的数据类型</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T2的类型:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print3</span><span class="params">(T&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T的数据类型：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person &lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;xiyang&quot;</span>, <span class="number">18</span>);</span><br><span class="line">	<span class="comment">// 1.指定传入的类型</span></span><br><span class="line">	<span class="built_in">print1</span>(p);</span><br><span class="line">	<span class="comment">// 2.参数模板化</span></span><br><span class="line">	<span class="built_in">print2</span>(p);</span><br><span class="line">	<span class="comment">// 3.整个类模板化</span></span><br><span class="line">	<span class="built_in">print3</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-6-类模板与继承"><a href="#1-2-6-类模板与继承" class="headerlink" title="1.2.6 类模板与继承"></a>1.2.6 类模板与继承</h3><p>🔴<strong>注意</strong>：</p>
<ol>
<li><p>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型（否则会报错）</p>
<p><strong>class Son :public Base{};（报错）</strong></p>
<p><strong>class Son1 :public Base <int>{};（正确）</strong></p>
</li>
<li><p>如果不指定，编译器无法给子类分配内存</p>
</li>
<li><p>如果想灵活指定出父类中T的类型，子类也需变为类模板</p>
<p><strong>class Son2 :public Base<T>{};</strong></p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">	T m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base&#123;&#125;;  <span class="comment">//err T没有指定类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base &lt;<span class="type">int</span>&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//灵活指定父类中的T类型，子类也需要变类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> :<span class="keyword">public</span> Base&lt;T&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-7-类模板分文件编写"><a href="#1-2-7-类模板分文件编写" class="headerlink" title="1.2.7 类模板分文件编写"></a>1.2.7 类模板分文件编写</h3><p>❗ 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</p>
<p>解决：</p>
<p>1.直接包含.cpp源文件</p>
<p>2.将声明和实现写在同一个文件中，并更改后缀名为.hpp,hpp是约定的名称，并不是强制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//person.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>,<span class="keyword">class</span> <span class="title class_">AgeType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>(NameType name,AgeType age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">	NameType name;</span><br><span class="line">	AgeType age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//person.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.h&quot;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span>&gt;</span><br><span class="line">person&lt;NameType, AgeType&gt;::<span class="built_in">person</span>(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span>&gt;</span><br><span class="line"><span class="type">void</span> person&lt;NameType, AgeType&gt;::<span class="built_in">print</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;xiyang&quot;</span>, <span class="number">18</span>);</span><br><span class="line">	p.<span class="built_in">print</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637</span></span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/dad7ac3a7abc4a4da4a32d4d117738ef.png" alt="在这里插入图片描述"><br>✅ <strong>解决方案</strong>：<br>① 在test.cpp中，将 person.h 改为 person.cpp<br>② 直接将 person.h 和 person.cpp 合并，后缀为<code>.hpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//person.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>,<span class="keyword">class</span> <span class="title class_">AgeType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>(NameType name,AgeType age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">	NameType name;</span><br><span class="line">	AgeType age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span>&gt;</span><br><span class="line">person&lt;NameType, AgeType&gt;::<span class="built_in">person</span>(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span>&gt;</span><br><span class="line"><span class="type">void</span> person&lt;NameType, AgeType&gt;::<span class="built_in">print</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425</span></span><br><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;xiyang&quot;</span>, <span class="number">18</span>);</span><br><span class="line">	p.<span class="built_in">print</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-8-类模板与友元"><a href="#1-2-8-类模板与友元" class="headerlink" title="1.2.8 类模板与友元"></a>1.2.8 类模板与友元</h3><p>掌握类模板配合友元函数的类内和类外实现</p>
<ul>
<li><p>全局函数类内实现 - 直接在类内声明友元即可</p>
</li>
<li><p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p>
<p>建议：全局函数做类内实现，用法简单，而且编译器可以直接识别</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类模板与友元</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2</span><span class="params">(person&lt;T1, T2&gt;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;类外&quot;</span> &lt;&lt; p.age &lt;&lt; p.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1.全局函数在类内实现</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">print1</span><span class="params">(person&lt;T1, T2&gt; &amp;p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;类内&quot;</span> &lt;&lt; p.age &lt;&lt; p.name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2.全局函数类外实现</span></span><br><span class="line">	<span class="comment">//类外实现需要让编译器提前看到，所以全局函数放在前面</span></span><br><span class="line">	<span class="comment">//全局函数放在前面的同时，需要再提前看到person类，所以还需要声明person类</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">void</span> print2&lt;&gt;(person&lt;T1, T2&gt;&amp; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>(T1 name, T2 age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 name;</span><br><span class="line">	T2 age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//全局函数类内实现测试</span></span><br><span class="line">	person &lt;string, <span class="type">int</span> &gt; <span class="built_in">p1</span> (<span class="string">&quot;xiyang&quot;</span>, <span class="number">18</span>);</span><br><span class="line">	<span class="built_in">print1</span>(p1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//全局函数类外实现测试</span></span><br><span class="line">	person&lt;string, <span class="type">int</span> &gt;<span class="built_in">p2</span>(<span class="string">&quot;xiyang&quot;</span>, <span class="number">19</span>);</span><br><span class="line">	<span class="built_in">print2</span>(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="案例二：-通用的数组类"><a href="#案例二：-通用的数组类" class="headerlink" title="案例二： 通用的数组类"></a>案例二： 通用的数组类</h2><p><strong>问题描述</strong>：实现一个通用的数组类，要求如下：</p>
<ol>
<li>可以对内置数据类型以及自定义数据类型的数据进行存储</li>
<li>将数组中的数据存储到堆区</li>
<li>构造函数中可以传入数组的容量</li>
<li>提供对应的拷贝构造函数以及operator&#x3D;防止浅拷贝问题</li>
<li>提供尾插法和尾删法对数组中的数据进行增加和删除</li>
<li>可以通过下标的方式访问数组中的元素</li>
<li>可以获取数组中当前元素个数和数组的容量</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MyArray.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">int</span> capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;arr = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;capacity];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 拷贝构造——为了解决浅拷贝带来的问题</span></span><br><span class="line">	<span class="built_in">MyArray</span>(MyArray&amp; ma)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;capacity = ma.capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;size = ma.size;</span><br><span class="line">		<span class="keyword">this</span>-&gt;arr = <span class="keyword">new</span>	T[ma.capacity];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ma.size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;arr[i] = ma.arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// operator= ——解决浅拷贝带来的问题</span></span><br><span class="line">	MyArray&amp; <span class="keyword">operator</span>=(MyArray&amp; ma)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//赋值前有内容则需要清空</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;capacity != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;capacity = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;arr;</span><br><span class="line">			<span class="keyword">this</span>-&gt;arr = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;size = ma.size;</span><br><span class="line">		<span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;arr = <span class="keyword">new</span> T[ma.capacity];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ma.size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;arr[i] = ma.arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过下标访问数据</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>[ ](<span class="type">int</span> idex)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//越界</span></span><br><span class="line">		<span class="keyword">if</span> (idex&lt;<span class="number">0</span> || idex&gt;size)</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//强制退出</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;arr[idex];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PushBack</span><span class="params">(T val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//判断是否满了</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;capacity == <span class="keyword">this</span>-&gt;size)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;arr[<span class="keyword">this</span>-&gt;size] = val;</span><br><span class="line">		<span class="keyword">this</span>-&gt;size++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PopBack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//判断是否是空的</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;size == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;size--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取数组容量</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;capacity;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取数组大小</span></span><br><span class="line">	<span class="function"><span class="type">int</span>	<span class="title">GetSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">MyArray</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;arr != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;capacity = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;arr;</span><br><span class="line">			<span class="keyword">this</span>-&gt;arr = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* arr; <span class="comment">//指向数组</span></span><br><span class="line">	<span class="type">int</span> capacity; <span class="comment">//容量</span></span><br><span class="line">	<span class="type">int</span> size;  <span class="comment">//数组大小</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyArray.hpp&quot;</span></span></span><br><span class="line"><span class="comment">//测试内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printIntArray</span><span class="params">(MyArray&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">GetSize</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		array<span class="number">1.</span><span class="built_in">PushBack</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1打印输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printIntArray</span>(array1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1的大小：&quot;</span> &lt;&lt; array<span class="number">1.</span><span class="built_in">GetSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1的容量：&quot;</span> &lt;&lt; array<span class="number">1.</span><span class="built_in">GetCapacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125;</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPersonArray</span><span class="params">(MyArray&lt;Person&gt;&amp; personArr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; personArr.<span class="built_in">GetSize</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; personArr[i].name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; personArr[i].age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建数组</span></span><br><span class="line">	<span class="function">MyArray&lt;Person&gt; <span class="title">pArray</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;韩信&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;妲己&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;王昭君&quot;</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入数据</span></span><br><span class="line">	pArray.<span class="built_in">PushBack</span>(p1);</span><br><span class="line">	pArray.<span class="built_in">PushBack</span>(p2);</span><br><span class="line">	pArray.<span class="built_in">PushBack</span>(p3);</span><br><span class="line">	pArray.<span class="built_in">PushBack</span>(p4);</span><br><span class="line">	pArray.<span class="built_in">PushBack</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printPersonArray</span>(pArray);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pArray的大小：&quot;</span> &lt;&lt; pArray.<span class="built_in">GetSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pArray的容量：&quot;</span> &lt;&lt; pArray.<span class="built_in">GetCapacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、STL"><a href="#二、STL" class="headerlink" title="二、STL"></a>二、STL</h1><h2 id="2-1-STL的基础知识"><a href="#2-1-STL的基础知识" class="headerlink" title="2.1 STL的基础知识"></a>2.1 STL的基础知识</h2><p>​      <strong>定义</strong>：C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。</p>
<p>​      <strong>分类</strong>：广义上分为 ：① 容器(container) ② 算法(algorithm) ③ 迭代器(iterator)。其中容器和算法之间通过迭代器进行无缝连接。</p>
<p>​      <strong>六大组件</strong>：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</p>
<table>
<thead>
<tr>
<th>组件名字</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>容器</td>
<td>各种数据结构，如<code>vector</code>、<code>list</code>、<code>deque</code>、<code>set</code>、<code>map</code>等,用来存放数据</td>
</tr>
<tr>
<td>算法</td>
<td>各种常用的算法，如<code>sort</code>、<code>find</code>、<code>copy</code>、<code>for_each</code>等</td>
</tr>
<tr>
<td>迭代器</td>
<td>扮演了容器与算法之间的胶合剂</td>
</tr>
<tr>
<td>仿函数</td>
<td>行为类似函数，可作为算法的某种策略</td>
</tr>
<tr>
<td>适配器</td>
<td>一种用来修饰容器或者仿函数或迭代器接口的东西</td>
</tr>
<tr>
<td>空间配置器</td>
<td>负责空间的配置与管理</td>
</tr>
</tbody></table>
<h2 id="2-2-STL中的容器，算法，迭代器"><a href="#2-2-STL中的容器，算法，迭代器" class="headerlink" title="2.2 STL中的容器，算法，迭代器"></a>2.2 STL中的容器，算法，迭代器</h2><ol>
<li><strong>容器</strong>：置物之所也。<br> STL容器：将运用最广泛的一些数据结构实现出来，常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等。<br><strong>分类</strong>：<br>① 序列式容器: 强调值的排序，序列式容器中的每个元素均有固定的位置。<br>② 关联式容器: 二叉树结构，各元素之间没有严格的物理上的顺序关系。</li>
<li><strong>算法</strong>：问题之解法也。<br> 算法(Algorithms)：有限的步骤，解决逻辑或数学上的问题。<br><strong>分类</strong>：<br>① 质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等<br>② 非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</li>
<li><strong>迭代器</strong>：容器和算法之间粘合剂。<br> 提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。<br> 每个容器都有自己专属的迭代器。迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针。<br><strong>分类</strong>如下表：</li>
</ol>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>对数据的只读访问</td>
<td>只读，支持++、&#x3D;&#x3D;、！&#x3D;</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>读写操作，并能向前推进迭代器</td>
<td>读写，支持++、&#x3D;&#x3D;、！&#x3D;</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>读写操作，并能向前和向后操作</td>
<td>读写，支持++、–，</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;</td>
</tr>
</tbody></table>
<h3 id="2-2-1-用vector对容器算法迭代器再认识"><a href="#2-2-1-用vector对容器算法迭代器再认识" class="headerlink" title="2.2.1 用vector对容器算法迭代器再认识"></a>2.2.1 用vector对容器算法迭代器再认识</h3><p>STL中最常用的容器为<code>vector</code>，可以理解为数组。</p>
<h4 id="1-vector存放内置数据类型"><a href="#1-vector存放内置数据类型" class="headerlink" title="1. vector存放内置数据类型"></a>1. vector存放内置数据类型</h4><p>​      容器： <code>vector</code><br>​      算法： <code>for_each</code><br>​      迭代器：<code>vector&lt;int&gt;::iterator</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span><span class="comment">//vector容器的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span><span class="comment">//标准算法头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建一个int类型vector容器，相当于int数组</span></span><br><span class="line">	vector &lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="comment">//向容器插入数据</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">//通过迭代器访问容器中的数据</span></span><br><span class="line">	vector &lt;<span class="type">int</span>&gt;::iterator ItBegin = v.<span class="built_in">begin</span>();<span class="comment">//起始迭代器，指向容器中的第一个元素</span></span><br><span class="line">	vector &lt;<span class="type">int</span>&gt;::iterator ItEnd = v.<span class="built_in">end</span>();<span class="comment">//结束迭代器，指向容器中最后一个元素的下一个位置</span></span><br><span class="line">	<span class="comment">//vector 中：0 1 2 3</span></span><br><span class="line">	<span class="comment">//           |       |</span></span><br><span class="line">	<span class="comment">//         begin    end</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">//第一种遍历方式</span></span><br><span class="line">	<span class="keyword">while</span> (ItBegin != ItEnd)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *ItBegin;</span><br><span class="line">		ItBegin++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//第二种遍历方式(相当于整合第一种方式)</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span> &gt;::iterator begin = v.<span class="built_in">begin</span>(); begin != v.<span class="built_in">end</span>(); begin++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *begin;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//第三种遍历方式 </span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print);</span><br><span class="line">	<span class="comment">/* FUNCTION TEMPLATE for_each</span></span><br><span class="line"><span class="comment">	template &lt;class _InIt, class _Fn&gt;</span></span><br><span class="line"><span class="comment">	_CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) &#123; // perform function for each element [_First, _Last)</span></span><br><span class="line"><span class="comment">		_Adl_verify_range(_First, _Last);</span></span><br><span class="line"><span class="comment">		auto _UFirst = _Get_unwrapped(_First);</span></span><br><span class="line"><span class="comment">		const auto _ULast = _Get_unwrapped(_Last);</span></span><br><span class="line"><span class="comment">		for (; _UFirst != _ULast; ++_UFirst) &#123;</span></span><br><span class="line"><span class="comment">			_Func(*_UFirst);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		return _Func;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-vector存放自定义数据类型"><a href="#2-vector存放自定义数据类型" class="headerlink" title="2. vector存放自定义数据类型"></a>2. vector存放自定义数据类型</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vector存放自定义数据类型</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//person类</span></span><br><span class="line">	vector &lt;person&gt; v;</span><br><span class="line">	<span class="comment">//创建</span></span><br><span class="line">	<span class="function">person <span class="title">p1</span><span class="params">(<span class="string">&quot;a&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">person <span class="title">p2</span><span class="params">(<span class="string">&quot;b&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">person <span class="title">p3</span><span class="params">(<span class="string">&quot;c&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">person <span class="title">p4</span><span class="params">(<span class="string">&quot;d&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="comment">//向容器中添加数据</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	<span class="comment">//遍历</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; (*it).age &lt;&lt; endl;<span class="comment">//it-&gt;age</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; (*it).name &lt;&lt; endl;<span class="comment">//it-&gt;name</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针类</span></span><br><span class="line">	vector &lt;person*&gt; v1;</span><br><span class="line">	<span class="comment">//向容器中添加数据</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">	<span class="comment">//遍历</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;person*&gt;::iterator it = v<span class="number">1.</span><span class="built_in">begin</span>(); it != v<span class="number">1.</span><span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; (*it)-&gt;age &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; (*it)-&gt;name &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-vector容器嵌套容器"><a href="#3-vector容器嵌套容器" class="headerlink" title="3. vector容器嵌套容器"></a>3. vector容器嵌套容器</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vector容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//大容器</span></span><br><span class="line">	vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;  v;</span><br><span class="line">	<span class="comment">//小容器</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line">	<span class="comment">//小容器中添加数据</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i + <span class="number">2</span>);</span><br><span class="line">		v<span class="number">3.</span><span class="built_in">push_back</span>(i + <span class="number">3</span>);</span><br><span class="line">		v<span class="number">4.</span><span class="built_in">push_back</span>(i + <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将小容器的元素插入到大容器中</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v4);</span><br><span class="line">	<span class="comment">//遍历</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator vit = (*it).<span class="built_in">begin</span>(); vit != (*it).<span class="built_in">end</span>(); vit++) </span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-常用容器"><a href="#2-3-常用容器" class="headerlink" title="2.3 常用容器"></a>2.3 常用容器</h2><h3 id="2-3-1-string"><a href="#2-3-1-string" class="headerlink" title="2.3.1 string"></a>2.3.1 string</h3><h4 id="2-3-1-1-string基础知识"><a href="#2-3-1-1-string基础知识" class="headerlink" title="2.3.1.1 string基础知识"></a>2.3.1.1 string基础知识</h4><p>​      <strong>本质</strong>：<code>string</code>是C++风格的字符串，而<code>string</code>本质上是一个类。</p>
<p>🔵<strong>特点</strong>：<code>string</code>类内部封装了很多成员方法，例如：查找find，拷贝copy，删除delete 替换replace，插入insert。<br>🔴<strong>注意</strong>：<code>string</code>管理<code>char*</code>所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责。</p>
<h4 id="2-3-1-2-接口"><a href="#2-3-1-2-接口" class="headerlink" title="2.3.1.2 接口"></a>2.3.1.2 接口</h4><p>​      <strong>1. 构造函数原型</strong></p>
<p>​        ① <code>string()</code>:创建一个空的字符串<br>​        ② <code>string(const char* s)</code>：使用字符串s初始化<br>​        ③ <code>string(const string&amp; str)</code>:使用一个string对象初始化另一个string对象<br>​        ④ <code>string(int n, char c)</code>:使用n个字符c初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//string的构造函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span><span class="comment">//string头文件记得写</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1.默认构造 string()</span></span><br><span class="line">	string s1;</span><br><span class="line">	<span class="comment">//2.有参构造 string(const char* s);</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">	<span class="function">string <span class="title">s2</span><span class="params">(str)</span></span>;</span><br><span class="line">	<span class="comment">//3.拷贝构造 string(const string&amp; str);</span></span><br><span class="line">	<span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>;</span><br><span class="line">	<span class="comment">//4.特殊的一种构造 string(int n, char c);</span></span><br><span class="line">	<span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>2. 赋值操作</strong></p>
<p>​        ① <code>string&amp; operator=(char c)</code> :字符赋值给当前的字符串<br>​        ② <code>string&amp; operator=(const char* s)</code>：char*类型字符串 赋值给当前的字符串<br>​        ③ <code>string&amp; operator=(const string&amp; s)</code>:把字符串s赋给当前的字符串<br>​        ④ <code>string&amp; assign(const char *s)</code>:把字符串s赋给当前的字符串<br>​        ⑤ <code>string&amp; assign(const char *s, int n)</code>:把字符串s的前n个字符赋给当前的字符串<br>​        ⑥ <code>string&amp; assign(const string &amp;s)</code>:把字符串s赋给当前字符串<br>​        ⑦ <code>string&amp; assign(int n, char c)</code>:用n个字符c赋给当前字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//1.string&amp; operator=(char c)</span></span><br><span class="line">	string s1;</span><br><span class="line">	s1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	<span class="comment">//2.string&amp; operator=(const char* s)</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	string s2;</span><br><span class="line">	s2= str;</span><br><span class="line">	<span class="comment">//3.string&amp; operator=(const string&amp; s)</span></span><br><span class="line">	string s3;</span><br><span class="line">	s3 = s2;</span><br><span class="line">	<span class="comment">//4.string&amp; assign(const char* s)</span></span><br><span class="line">	string s4;</span><br><span class="line">	s<span class="number">4.</span><span class="built_in">assign</span>(str);</span><br><span class="line">	<span class="comment">//5.string&amp; assign(const char* s, int n)</span></span><br><span class="line">	string s5;</span><br><span class="line">	s<span class="number">5.</span><span class="built_in">assign</span>(str, <span class="number">3</span>);</span><br><span class="line">	<span class="comment">//6.string&amp; assign(const string&amp; s)</span></span><br><span class="line">	string s6;</span><br><span class="line">	s<span class="number">6.</span><span class="built_in">assign</span>(s2);</span><br><span class="line">	<span class="comment">//7.string&amp; assign(int n, char c)</span></span><br><span class="line">	string s7;</span><br><span class="line">	s<span class="number">7.</span><span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>3. 字符存取</strong></p>
<p>​        ①<code>char&amp; operator[](int n)</code>：通过[]方式取字符<br>​        ②<code>char&amp; at(int n)</code>： 通过at方法获取字符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	<span class="comment">//1.char&amp; operator[](int n)</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//2.char&amp; at(int n)</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符修改</span></span><br><span class="line">	str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">	str.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>4.字符串查找、替换</strong></p>
<p>​        ① <code>int find(const char c, int pos = 0) const</code> ：查找字符c第一次出现位置<br>​        ② <code>int find(const char* s, int pos = 0) const</code>：查找s第一次出现位置,从pos开始查找<br>​        ③ <code>int find(const char* s, int pos, int n) const</code>：从pos位置查找s的前n个字符第一次位置<br>​        ④ <code>int find(const string&amp; str, int pos = 0) const</code>：查找str第一次出现位置,从pos开始查找<br>​        ⑤ <code>int rfind(const char c, int pos = 0) const</code>:查找字符c最后一次出现位置<br>​        ⑥ <code>int rfind(const char* s, int pos = npos) const</code>：查找s最后一次出现位置,从pos开始查找<br>​        ⑦ <code>int rfind(const char* s, int pos, int n) const</code>:从pos查找s的前n个字符最后一次位置<br>​        ⑧ <code>int rfind(const string&amp; str, int pos = npos) const</code>:查找str最后一次位置,从pos开始查找<br>​        ⑨ <code>string&amp; replace(int pos, int n, const string&amp; str)</code>：替换从pos开始n个字符为字符串str<br>​        ⑩ <code>string&amp; replace(int pos, int n,const char* s)</code>：替换从pos开始的n个字符为字符串s</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	string s1 = <span class="string">&quot;hello!&quot;</span>;</span><br><span class="line"></span><br><span class="line">	string s2 = <span class="string">&quot;nihao,hello,haha&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.int find(const char c, int pos = 0) const;</span></span><br><span class="line">	<span class="type">int</span> ret = s<span class="number">2.f</span>ind(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//找到返回下标（从0开始），未找到返回-1</span></span><br><span class="line">	<span class="comment">//2.int find(const char* s, int pos = 0) const</span></span><br><span class="line">	ret = s<span class="number">2.f</span>ind(<span class="string">&quot;ha&quot;</span>);</span><br><span class="line">	<span class="comment">//3.int find(const char* s, int pos, int n) const</span></span><br><span class="line">	ret = s<span class="number">2.f</span>ind(<span class="string">&quot;ha&quot;</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">	<span class="comment">//4.int find(const string&amp; str, int pos = 0) const</span></span><br><span class="line">	ret = s<span class="number">2.f</span>ind(s1);</span><br><span class="line">	<span class="comment">//5.int rfind(const char c, int pos = 0) const</span></span><br><span class="line">	ret = s<span class="number">2.</span><span class="built_in">rfind</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	<span class="comment">//6.int rfind(const char* s, int pos = npos) const</span></span><br><span class="line">	ret = s<span class="number">2.</span><span class="built_in">rfind</span>(<span class="string">&quot;ha&quot;</span>, <span class="number">5</span>);</span><br><span class="line">	<span class="comment">//7.int rfind(const char* s, int pos, int n) const</span></span><br><span class="line">	ret = s<span class="number">2.</span><span class="built_in">rfind</span>(<span class="string">&quot;ha&quot;</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">	<span class="comment">//8.int rfind(const string&amp; str, int pos = npos) const</span></span><br><span class="line">	ret = s<span class="number">2.</span><span class="built_in">rfind</span>(s1);</span><br><span class="line">	<span class="comment">//9.string&amp; replace(int pos, int n,const char* s)</span></span><br><span class="line">	s<span class="number">2.</span><span class="built_in">replace</span>(<span class="number">0</span>,<span class="number">7</span>, s1);</span><br><span class="line">	<span class="comment">//10.string&amp; replace(int pos, int n, const string&amp; str)</span></span><br><span class="line">	s<span class="number">2.</span><span class="built_in">replace</span>(<span class="number">0</span>, <span class="number">7</span>, <span class="string">&quot;haha&quot;</span>);</span><br><span class="line"><span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>5. 插入和删除</strong><br>​        ① <code>string&amp; insert(int pos, const char* s)</code><br>​        ② <code>string&amp; insert(int pos, const string&amp; str)</code><br>​        ③ <code>string&amp; insert(int pos, int n, char c)</code>：在指定位置插入n个字符c<br>​        ④ <code>string&amp; erase(int pos, int n = npos)</code>：删除从Pos开始的n个字符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//字符串插入和删除</span></span><br><span class="line">	string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	str.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//从1号位置开始3个字符</span></span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>6. 字符串比较</strong><br>​        ① <code>int compare(const string &amp;s) const</code>:与字符串s按字符的ASCII码进行对比,&#x3D; 返回 0 &gt; 返回 1 &lt; 返回 -1<br>​        ② <code>int compare(const char *s) const</code>:同上</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">	<span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;nihao&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;nihaoa&quot;</span>)</span></span>;</span><br><span class="line">	<span class="comment">//1.int compare(const string &amp;s) const</span></span><br><span class="line">	<span class="type">int</span> ret=s<span class="number">1.</span><span class="built_in">compare</span>(str);</span><br><span class="line">	<span class="comment">//2.int compare(const char *s) const</span></span><br><span class="line">	ret = s<span class="number">1.</span><span class="built_in">compare</span>(s2);</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>​      但大小比较很有缺陷，ehllo和hello结果过是1小于2，ehllo和h还是1小于2，其实没啥用，基本只用于两字符串是否相等上面</p>
<p>​    <strong>7. 字符串拼接</strong></p>
<p>​        ① <code>string&amp; operator+=(char c)</code><br>​        ② <code>string&amp; operator+=(const char* s)</code><br>​        ③ <code>string&amp; operator=(const string&amp; s)</code><br>​        ④ <code>string&amp; append(const char *s)</code><br>​        ⑤ <code>string&amp; append(const char *s, int n)</code>:把字符串s的前n个字符连接到当前字符串结尾<br>​        ⑥ <code>string&amp; append (const string &amp;s)</code><br>​        ⑦ <code>string&amp; append(const string &amp;s, int pos, int n)</code>:字符串s中从pos开始的n个字符连接到字符串结尾</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	string s1 = <span class="string">&quot;hello!&quot;</span>;</span><br><span class="line">	string s2;</span><br><span class="line">	s2 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;haha&quot;</span>;</span><br><span class="line">	<span class="comment">//1.string&amp; operator+=(const char c)</span></span><br><span class="line">	string s3;</span><br><span class="line">	s3+= s2;</span><br><span class="line">	<span class="comment">//2.string&amp; operator+=(const char* str)</span></span><br><span class="line">	string s4;</span><br><span class="line">	s4 += str;</span><br><span class="line">	<span class="comment">//3.string&amp; operator+=(const string&amp; str)</span></span><br><span class="line">	string s5;</span><br><span class="line">	s5 += s1;</span><br><span class="line">	<span class="comment">//4.string&amp; append(const char* str)</span></span><br><span class="line">	string s6;</span><br><span class="line">	s<span class="number">6.</span><span class="built_in">append</span>(str);</span><br><span class="line">    <span class="comment">//5.string&amp; append(const char* s, int n)</span></span><br><span class="line">	string s7;</span><br><span class="line">	s<span class="number">7.</span><span class="built_in">append</span>(str, <span class="number">3</span>);</span><br><span class="line">	<span class="comment">//6.string&amp; append(const string&amp; s)</span></span><br><span class="line">	string s8;</span><br><span class="line">	s<span class="number">8.</span><span class="built_in">append</span>(s1);</span><br><span class="line">	<span class="comment">//7.string&amp; append(const string&amp; s, int pos, int n);</span></span><br><span class="line">	string s9;</span><br><span class="line">	s<span class="number">9.</span><span class="built_in">append</span>(s1, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>8. 子串</strong><br>​        ① <code>string substr(int pos = 0, int n = npos) const</code> ：返回由pos开始的n个字符组成的字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">	string subStr = str.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line">	<span class="type">int</span> pos = email.<span class="built_in">find</span>(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">	string username = email.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-vector"><a href="#2-3-2-vector" class="headerlink" title="2.3.2 vector"></a>2.3.2 vector</h3><h4 id="2-3-2-1-vector基础知识"><a href="#2-3-2-1-vector基础知识" class="headerlink" title="2.3.2.1 vector基础知识"></a>2.3.2.1 vector基础知识</h4><p>​      vector数据结构和数组非常相似，也称为单端数组。</p>
<p>🔵<strong>特点</strong>：<br>① <code>vector</code>可以动态扩展（不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间）。<br>② <code>vector</code>容器的迭代器是支持随机访问的迭代器。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/f9e57b223f2f4a5f9e1ed0ba489ffc03.png" alt="在这里插入图片描述"></p>
<h4 id="2-3-2-2-接口"><a href="#2-3-2-2-接口" class="headerlink" title="2.3.2.2 接口"></a>2.3.2.2 接口</h4><p>​      <strong>1. 构造函数原型</strong><br>​        ① <code>vector&lt;T&gt; v</code> :采用模板实现类实现，默认构造函数<br>​        ② <code>vector(v.begin(), v.end())</code>：将v[begin(), end())区间中的元素拷贝给本身<br>​        ③ <code>vector(n, elem)</code>:构造函数将n个elem拷贝给本身<br>​        ④ <code>vector(const vector &amp;vec)</code>:拷贝构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//1.vector&lt;T&gt; v</span></span><br><span class="line">	vector &lt;<span class="type">int</span> &gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.vector(v.begin(), v.end())</span></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v<span class="number">1.</span>begin(), v<span class="number">1.</span>end())</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.vector(n, elem)</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">v3</span>(<span class="number">10</span>, <span class="number">100</span>);<span class="comment">//10个100</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4.vector(const vector&amp; vec)</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">v4</span>(v1);</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>2. 赋值操作</strong><br>​        ① <code>vector&amp; operator=(const vector &amp;vec)</code> :重载等号操作符<br>​        ② <code>assign(beg, end)</code>：将[beg, end)区间中的数据拷贝赋值给本身<br>​        ③ <code>assign(n, elem)</code>:构将n个elem拷贝赋值给本身</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//1.vector&amp; operator=(const vector &amp;vec)</span></span><br><span class="line">	vector &lt;<span class="type">int</span>&gt;v2 = v1;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.assign(beg, end)</span></span><br><span class="line">	vector &lt;<span class="type">int</span>&gt;v3;</span><br><span class="line">	v<span class="number">3.</span><span class="built_in">assign</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.assign(n, elem)</span></span><br><span class="line">	vector &lt;<span class="type">int</span>&gt;v4;</span><br><span class="line">	v<span class="number">4.</span><span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>3. 数据存取</strong><br>​        ① <code>at(int idx)</code> :返回索引idx所指的数据<br>​        ② <code>operator[]</code>：返回索引idx所指的数据<br>​        ③ <code>front()</code>:返回容器中第一个数据元素<br>​        ④ <code>back()</code>:返回容器中最后一个数据元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//1.at(int idx)</span></span><br><span class="line">	cout &lt;&lt; v<span class="number">1.</span><span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.operator[]</span></span><br><span class="line">	cout &lt;&lt; v1[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.front()</span></span><br><span class="line">	cout &lt;&lt; v<span class="number">1.f</span>ront() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.back()</span></span><br><span class="line">	cout &lt;&lt; v<span class="number">1.</span><span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>4. 容量和大小</strong><br>​        ① <code>empty()</code> :判断容器是否为空<br>​        ② <code>capacity()</code>：容器的容量<br>​        ③ <code>size()</code>:返回容器中元素的个数<br>​        ④ <code>resize(int num)</code>:重新指定容器的长度为num。若容器变长，则以默认值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除。<br>​        ⑤ <code>resize(int num, elem)</code>:重新指定容器的长度为num。若容器变长，则以elem值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (v.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;vector is empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Not empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;The vector&#x27;s capacity is :&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;The vector&#x27;s size is :&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>5. 插入和删除</strong><br>​        ① <code>push_back(ele)</code> :尾部插入元素ele<br>​        ② <code>pop_back()</code>：删除最后一个元素<br>​        ③ <code>insert(const_iterator pos, ele)</code>:迭代器指向位置pos插入元素ele<br>​        ④ <code>insert(const_iterator pos, int count,ele)</code>:迭代器指向位置pos插入count个元素ele         ⑤ <code>erase(const_iterator pos)</code>:删除迭代器指向的元素<br>​        ⑥ <code>erase(const_iterator start, const_iterator end)</code>:删除迭代器从start到end之间的元素<br>​        ⑦ <code>clear()</code>:删除容器中所有元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it ;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector &lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>());</span><br><span class="line">	v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	v.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>6. 互换容器</strong><br>​        ① <code>swap(vec)</code>：将vec与本身的元素互换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it ;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">print</span>(v1);</span><br><span class="line">	<span class="built_in">print</span>(v2);</span><br><span class="line">	v<span class="number">2.</span><span class="built_in">swap</span>(v1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">print</span>(v1);</span><br><span class="line">	<span class="built_in">print</span>(v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🔴<strong>注意</strong>：<code>swap</code>有的收缩内存作用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swap的收缩内存作用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector &lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999999</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//收缩内存</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v); <span class="comment">//匿名对象，指针交换后，系统执行完这行代码后匿名对象指向空间立即释放，不会造成内存泄漏</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-3-deque"><a href="#2-3-3-deque" class="headerlink" title="2.3.3 deque"></a>2.3.3 deque</h3><h4 id="2-3-3-1-deque基础知识"><a href="#2-3-3-1-deque基础知识" class="headerlink" title="2.3.3.1 deque基础知识"></a>2.3.3.1 deque基础知识</h4><p>​      双端数组，可以对头端进行插入删除操作</p>
<p>与vector区别：</p>
<p>1.vector对于头部的插入删除的效率低，数据量越大，效率越低</p>
<p>2.deque相对而言，对头部的插入删除速度比vector快</p>
<p>3.vector访问元素时的速度会比deque快，这和两者的内部实现有关</p>
<p>🔵<strong>特点</strong>：<br>① <code>deque</code>对头部的插入删除速度比<code>vector</code>快<br>② <code>deque</code>容器的迭代器是支持随机访问的迭代器。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/4d32582a24844e0e9b32237fea4c53eb.png" alt="在这里插入图片描述"></p>
<p>内部工作原理<br><code>deque</code>中有一个中控器，维护每段缓冲区中的内容，缓冲区里面存放真实数据。</p>
<p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/f1a2c44283e64ce4ac3c93c7129bed08.png" alt="在这里插入图片描述"></p>
<p>deque容器的迭代器也是支持随机访问的</p>
<h4 id="2-3-3-2-接口"><a href="#2-3-3-2-接口" class="headerlink" title="2.3.3.2 接口"></a>2.3.3.2 接口</h4><p>​        ① <code>push_back(ele)</code> :尾部插入元素ele<br>​        ② <code>pop_back()</code>：删除最后一个元素<br>​        ③ <code>insert(const_iterator pos, ele)</code>:迭代器指向位置pos插入元素ele<br>​        ④ <code>insert(const_iterator pos, int count,ele)</code>:迭代器指向位置pos插入count个元素ele         ⑤ <code>erase(const_iterator pos)</code>:删除迭代器指向的元素<br>​        ⑥ <code>erase(const_iterator start, const_iterator end)</code>:删除迭代器从start到end之间的元素<br>​        ⑦ <code>clear()</code>:删除容器中所有元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数和赋值操作部分的基础内容，基本和vector没有什么区别</span></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printfde</span><span class="params">(deque&lt;<span class="type">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果要防止修改的话则需要一个只读的迭代器，即const_iterator和const deque&lt;int&gt;&amp; v</span></span><br><span class="line"><span class="comment">//只读迭代器就是加个const</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printfde</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.deque&lt;T&gt; deqT</span></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d<span class="number">1.</span><span class="built_in">push_front</span>(i);<span class="comment">//头插</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2.deque(beg, end)</span></span><br><span class="line">	<span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d2</span><span class="params">(d<span class="number">1.</span>begin(), d<span class="number">1.</span>end())</span></span>;</span><br><span class="line">	<span class="comment">//3.deque(n, elem)</span></span><br><span class="line">	<span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="comment">//4.deque(const deque &amp;deq)</span></span><br><span class="line">	<span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d4</span><span class="params">(d1)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="案例三：-评委打分"><a href="#案例三：-评委打分" class="headerlink" title="案例三： 评委打分"></a>案例三： 评委打分</h2><p><strong>案例描述</strong>：有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">double</span> score)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">double</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatPlayer</span><span class="params">(vector &lt;Person&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s1 = <span class="string">&quot;选手&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)<span class="comment">//5个选手</span></span><br><span class="line">	&#123;</span><br><span class="line">		string s2 = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">		s2 = s1 + s2[i];<span class="comment">//一个比较巧妙的办法，将选手 A两个字符串结合，作为类中的name</span></span><br><span class="line">		<span class="type">double</span> score = <span class="number">0.0</span>;<span class="comment">//设置初始分数为0，作为类中的score</span></span><br><span class="line">		<span class="function">Person <span class="title">p</span><span class="params">(s2, score)</span></span>;<span class="comment">//实例化对象</span></span><br><span class="line">		v.<span class="built_in">push_back</span>(p);<span class="comment">//将一个类放在vector容器中</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetScore</span><span class="params">(vector&lt;Person&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">double</span>&gt; d;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)<span class="comment">//ABCDE选手</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//评委随机打分</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)<span class="comment">//10个评委</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">double</span> x = <span class="built_in">rand</span>() % <span class="number">41</span> + <span class="number">60</span>;<span class="comment">//40-60</span></span><br><span class="line">			d.<span class="built_in">push_back</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//分数排序</span></span><br><span class="line">		<span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">		<span class="comment">//去掉最高分和最低分</span></span><br><span class="line">		d.<span class="built_in">pop_front</span>();</span><br><span class="line">		d.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="comment">//计算平均分</span></span><br><span class="line">		<span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (deque&lt;<span class="type">double</span>&gt;::iterator dit = d.<span class="built_in">begin</span>(); dit != d.<span class="built_in">end</span>(); dit++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum = sum + *dit;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">double</span> avg = sum / d.<span class="built_in">size</span>();</span><br><span class="line">		<span class="comment">//将平均分给类中的score</span></span><br><span class="line">		it-&gt;score = avg;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowScore</span><span class="params">(vector&lt;Person&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">		cout &lt;&lt; (*it).name &lt;&lt; endl &lt;&lt; <span class="string">&quot;平均分：&quot;</span> &lt;&lt; (*it).score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;<span class="comment">//选手容器</span></span><br><span class="line">	<span class="built_in">CreatPlayer</span>(v);</span><br><span class="line">	<span class="built_in">SetScore</span>(v);</span><br><span class="line">	<span class="built_in">ShowScore</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-4-stack"><a href="#2-3-4-stack" class="headerlink" title="2.3.4 stack"></a>2.3.4 stack</h3><h4 id="2-3-4-1-stack基础知识"><a href="#2-3-4-1-stack基础知识" class="headerlink" title="2.3.4.1 stack基础知识"></a>2.3.4.1 stack基础知识</h4><p>​      <strong>stack</strong>一种先进后出(<em>First In Last Out,FILO</em>)的数据结构，它只有一个出口。栈中进入数据称为 — 入栈 <code>push</code>，栈中弹出数据称为 — 出栈<code>pop</code></p>
<p>🔵<strong>特点</strong>：栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为。</p>
<h4 id="2-3-4-2-接口"><a href="#2-3-4-2-接口" class="headerlink" title="2.3.4.2 接口"></a>2.3.4.2 接口</h4><p>构造函数：<br>① <code>stack&lt;T&gt; stk</code> ：<code>stack</code>采用模板类实现， <code>stack</code>对象的默认构造形式<br>② <code>stack(const stack &amp;stk)</code>: 拷贝构造函数</p>
<p>赋值操作：<br><code>stack&amp; operator=(const stack &amp;stk)</code>: 重载等号操作符</p>
<p>数据存取：<br><code>push(elem)</code> : 向栈顶添加元素<br><code>pop()</code>: 从栈顶移除第一个元素<br><code>top()</code>: 返回栈顶元素</p>
<p>大小操作：<br><code>empty()</code>:判断堆栈是否为空<br><code>size()</code>:返回栈的大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="comment">//输出栈顶元素</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//弹出栈顶元素</span></span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-5-queue"><a href="#2-3-5-queue" class="headerlink" title="2.3.5 queue"></a>2.3.5 queue</h3><h4 id="2-3-5-1-queue基础知识"><a href="#2-3-5-1-queue基础知识" class="headerlink" title="2.3.5.1 queue基础知识"></a>2.3.5.1 queue基础知识</h4><p>​      <strong>queue</strong>是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口。队列容器允许从一端新增元素，从另一端移除元素。队列中进数据称为 — 入队<code>push</code>，队列中出数据称为 — 出队 <code>pop</code>。</p>
<p>🔵<strong>特点</strong>：队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为。</p>
<h4 id="2-3-5-2-接口"><a href="#2-3-5-2-接口" class="headerlink" title="2.3.5.2 接口"></a>2.3.5.2 接口</h4><p>构造函数：<br><code>queue&lt;T&gt; que</code>:<code>queue</code>采用模板类实现，<code>queue</code>对象的默认构造形式<br><code>queue(const queue &amp;que)</code> :拷贝构造函数</p>
<p>赋值操作：<br><code>queue&amp; operator=(const queue &amp;que)</code>:重载等号操作符</p>
<p>数据存取：<br><code>push(elem)</code>:往队尾添加元素<br><code>pop()</code>:从队头移除第一个元素<br><code>back()</code>:返回最后一个元素<br><code>front()</code>:返回第一个元素</p>
<p>大小操作：<br><code>empty()</code>:判断堆栈是否为空<br><code>size()</code>:返回栈的大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建队列</span></span><br><span class="line">	queue&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//准备数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">900</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;沙僧&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向队列中添加元素  入队操作</span></span><br><span class="line">	q.<span class="built_in">push</span>(p1);</span><br><span class="line">	q.<span class="built_in">push</span>(p2);</span><br><span class="line">	q.<span class="built_in">push</span>(p3);</span><br><span class="line">	q.<span class="built_in">push</span>(p4);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//队列不提供迭代器，更不支持随机访问	</span></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="comment">//输出队头元素</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_Name</span><br><span class="line">			&lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Name</span><br><span class="line">			&lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//弹出队头元素</span></span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-6-list"><a href="#2-3-6-list" class="headerlink" title="2.3.6 list"></a>2.3.6 list</h3><h4 id="2-3-6-1-list基础知识"><a href="#2-3-6-1-list基础知识" class="headerlink" title="2.3.6.1 list基础知识"></a>2.3.6.1 list基础知识</h4><p>​      <strong>链表</strong>（list）:是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p>
<p>​      链表的组成：链表由一系列结点组成<br>​      结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/f908953f70194cb799556e93f9d13b8b.png" alt="在这里插入图片描述"></p>
<p>🔵<strong>特点</strong>：<br>① 由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器。<br>② STL中的链表是一个双向循环链表。<br>③ 插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p>
<ul>
<li>list的优点：<br>① 采用动态存储分配，不会造成内存浪费和溢出<br>② 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
<li>list的缺点：<br>① 链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li>
</ul>
<h4 id="2-3-6-2-接口"><a href="#2-3-6-2-接口" class="headerlink" title="2.3.6.2 接口"></a>2.3.6.2 接口</h4><p>​      <strong>1. 构造函数原型</strong><br>​        ① <code>list&lt;T&gt; lst</code> :采用模板类实现,对象的默认构造形式<br>​        ② <code>list(beg,end)</code>：构造函数将[beg, end)区间中的元素拷贝给本身<br>​        ③ <code>list(n,elem)</code>:构造函数将n个elem拷贝给本身<br>​        ④ <code>list(const list &amp;lst)</code>:拷贝构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;<span class="built_in">L2</span>(L<span class="number">1.</span><span class="built_in">begin</span>(),L<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;<span class="built_in">L3</span>(L2);</span><br><span class="line">	<span class="built_in">printList</span>(L3);</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;<span class="built_in">L4</span>(<span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>2.赋值和交换</strong><br>​        ① <code>list&amp; operator=(const list &amp;lst)</code> :重载等号操作符<br>​        ② <code>assign(beg, end)</code>：将[beg, end)区间中的数据拷贝赋值给本身<br>​        ③ <code>assign(n, elem)</code>:构将n个elem拷贝赋值给本身<br>​        ④ <code>swap(lst)</code>:将lst与本身的元素互换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值和交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L2;</span><br><span class="line">	L2 = L1;</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L3;</span><br><span class="line">	L<span class="number">3.</span><span class="built_in">assign</span>(L<span class="number">2.</span><span class="built_in">begin</span>(), L<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L4;</span><br><span class="line">	L<span class="number">4.</span><span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L2;</span><br><span class="line">	L<span class="number">2.</span><span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	L<span class="number">1.</span><span class="built_in">swap</span>(L2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>3. 容量和大小</strong><br>​        ① <code>empty()</code> :判断容器是否为空<br>​        ② <code>size()</code>:返回容器中元素的个数<br>​        ③ <code>resize(int num)</code>:重新指定容器的长度为num。若容器变长，则以默认值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除。<br>​        ④ <code>resize(int num, elem)</code>:重新指定容器的长度为num。若容器变长，则以elem值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (L<span class="number">1.</span><span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重新指定大小</span></span><br><span class="line">	L<span class="number">1.</span><span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	L<span class="number">1.</span><span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>4. 数据存取</strong><br>​        ① <code>front()</code>:返回容器中第一个数据元素<br>​        ② <code>back()</code>:返回容器中最后一个数据元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一个元素为： &quot;</span> &lt;&lt; L<span class="number">1.f</span>ront() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L<span class="number">1.</span><span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//list容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;::iterator it = L<span class="number">1.</span><span class="built_in">begin</span>();</span><br><span class="line">	<span class="comment">//it = it + 1;//错误，不可以跳跃访问，即使是+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>5. 插入和删除</strong><br>​        ① <code>push_back(ele)</code> :尾部插入元素ele<br>​        ② <code>push_front(elem)</code>：开头插入元素ele<br>​        ③ <code>pop_front()</code>：从容器开头移除第一个元素<br>​        ④ <code>pop_back()</code>：删除容器中最后一个元素<br>​        ⑤ <code>insert(pos, ele)</code>:在pos位置插elem元素的拷贝，返回新数据的位置<br>​        ⑥ <code>insert(pos, int count,ele)</code>:在pos位置插入n个elem数据，无返回值<br>​        ⑦ <code>insert(pos,beg,end)</code>:在pos位置插入[beg,end)区间的数据，无返回值<br>​        ⑧ <code>erase(pos)</code>:删除pos位置的数据，返回下一个数据的位置<br>​        ⑨ <code>erase(start,end)</code>:删除[beg,end)区间的数据，返回下一个数据的位置<br>​        ⑩ <code>remove(elem)</code>:删除容器中所有与elem值匹配的元素<br>​        ⑩① <code>clear()</code>:删除容器中所有元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	<span class="comment">//头插</span></span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	L.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//头删</span></span><br><span class="line">	L.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;::iterator it = L.<span class="built_in">begin</span>();</span><br><span class="line">	L.<span class="built_in">insert</span>(++it, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	it = L.<span class="built_in">begin</span>();</span><br><span class="line">	L.<span class="built_in">erase</span>(++it);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//移除</span></span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">	L.<span class="built_in">remove</span>(<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">	L.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>6. 反转和排序</strong><br>​        ① <code>reverse()</code> :反转链表<br>​        ② <code>sort()</code>：链表排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(<span class="type">int</span> val1 , <span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转和排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">90</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">70</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//反转容器的元素</span></span><br><span class="line">	L.<span class="built_in">reverse</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//排序</span></span><br><span class="line">	L.<span class="built_in">sort</span>(); <span class="comment">//默认的排序规则 从小到大</span></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	L.<span class="built_in">sort</span>(myCompare); <span class="comment">//指定规则，从大到小</span></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-7-set-multiset"><a href="#2-3-7-set-multiset" class="headerlink" title="2.3.7 set&#x2F; multiset"></a>2.3.7 set&#x2F; multiset</h3><h4 id="2-3-7-1-set-multiset-基础知识"><a href="#2-3-7-1-set-multiset-基础知识" class="headerlink" title="2.3.7.1 set&#x2F; multiset 基础知识"></a>2.3.7.1 set&#x2F; multiset 基础知识</h4><p>​      <strong>set</strong>：所有元素都会在插入时自动被排序。<code>set/multiset</code>属于关联式容器，底层结构是用二叉树实现。</p>
<p>🔴<strong>注意</strong>：<code>set</code>和<code>multiset</code>区别：<br><code>set</code>不允许容器中有重复的元素，<code>multiset</code>允许容器中有重复的元素</p>
<h4 id="2-3-7-2-接口"><a href="#2-3-7-2-接口" class="headerlink" title="2.3.7.2 接口"></a>2.3.7.2 接口</h4><p>​      <strong>1. 构造函数原型和赋值</strong><br>​        ① <code>set&lt;T&gt; st</code> :采用模板实现类实现，默认构造函数<br>​        ② <code>set(const set &amp;st)</code>:拷贝构造函数<br>​        ③ <code>set&amp; operator=(const set &amp;st)</code>:重载等号操作符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造和赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;<span class="built_in">s2</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;s3;</span><br><span class="line">	s3 = s2;</span><br><span class="line">	<span class="built_in">printSet</span>(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>2. 大小和交换</strong><br>​        ① <code>empty()</code> :判断容器是否为空<br>​        ② <code>size()</code>:返回容器中元素的个数<br>​        ③ <code>swap(st)</code>:交换两个集合容器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s<span class="number">1.</span><span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1的大小为： &quot;</span> &lt;&lt; s<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">100</span>);</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">300</span>);</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">200</span>);</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">swap</span>(s2);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>3. 插入和删除</strong></p>
<p>​        ① <code>insert(elem)</code>:在容器中插入元素<br>​        ② <code>erase(pos)</code>:删除pos迭代器所指的元素，返回下一个元素的迭代器<br>​        ③ <code>erase(start,end)</code>:删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器<br>​        ④ <code>erase(elem)</code>:删除容器中值为elem的元素<br>​        ⑤ <code>clear()</code>:删除容器中所有元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	s<span class="number">1.</span><span class="built_in">erase</span>(s<span class="number">1.</span><span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	s<span class="number">1.</span><span class="built_in">erase</span>(<span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	<span class="comment">//s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">	s<span class="number">1.</span><span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>4. 查找和统计</strong></p>
<p>​        ① <code>find(key)</code>:查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end()<br>​        ② <code>count(key)</code>:统计key的元素个数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;::iterator pos = s<span class="number">1.f</span>ind(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos != s<span class="number">1.</span><span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//统计</span></span><br><span class="line">	<span class="type">int</span> num = s<span class="number">1.</span><span class="built_in">count</span>(<span class="number">30</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>5. set和multiset区别</strong></p>
<p>​        ① set不可以插入重复数据，而multiset可以<br>​        ② set插入数据的同时会返回插入结果，表示插入是否成功，multiset不会检测数据，因此可以插入重复数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set和multiset区别</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">	pair&lt;set&lt;<span class="type">int</span>&gt;::iterator, <span class="type">bool</span>&gt;  ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第一次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第二次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第二次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//multiset</span></span><br><span class="line">	multiset&lt;<span class="type">int</span>&gt; ms;</span><br><span class="line">	ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (multiset&lt;<span class="type">int</span>&gt;::iterator it = ms.<span class="built_in">begin</span>(); it != ms.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>6. pair对组创建</strong></p>
<p><strong>功能描述</strong>：成对出现的数据，利用对组可以返回两个数据</p>
<p>​        ① <code>pair&lt;type, type&gt; p ( value1, value2 )</code><br>​        ② <code>pair&lt;type, type&gt; p = make_pair( value1, value2 )</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对组创建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(string(<span class="string">&quot;Tom&quot;</span>), <span class="number">20</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt;  p.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	pair&lt;string, <span class="type">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p<span class="number">2.f</span>irst &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p<span class="number">2.</span>second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>7. 容器排序</strong></p>
<p>​        利用仿函数，可以改变排序规则</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例一：内置数据类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//默认从小到大</span></span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s<span class="number">1.</span><span class="built_in">begin</span>(); it != s<span class="number">1.</span><span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指定排序规则</span></span><br><span class="line">	set&lt;<span class="type">int</span>,MyCompare&gt; s2;</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>, MyCompare&gt;::iterator it = s<span class="number">2.</span><span class="built_in">begin</span>(); it != s<span class="number">2.</span><span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647</span></span><br><span class="line"><span class="comment">//示例二 set存放自定义数据类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">comparePerson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//按照年龄进行排序  降序</span></span><br><span class="line">		<span class="keyword">return</span> p<span class="number">1.</span>m_Age &gt; p<span class="number">2.</span>m_Age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;Person, comparePerson&gt; s;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">insert</span>(p1);</span><br><span class="line">	s.<span class="built_in">insert</span>(p2);</span><br><span class="line">	s.<span class="built_in">insert</span>(p3);</span><br><span class="line">	s.<span class="built_in">insert</span>(p4);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-8-map-multimap"><a href="#2-3-8-map-multimap" class="headerlink" title="2.3.8 map&#x2F; multimap"></a>2.3.8 map&#x2F; multimap</h3><h4 id="2-3-8-1-map-multimap基础知识"><a href="#2-3-8-1-map-multimap基础知识" class="headerlink" title="2.3.8.1 map&#x2F; multimap基础知识"></a>2.3.8.1 map&#x2F; multimap基础知识</h4><p>​      <strong>map</strong>中所有元素都是pair。pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值），所有元素都会根据元素的键值自动排序。map&#x2F;multimap属于关联式容器，底层结构是用二叉树实现。</p>
<p>🔴<strong>注意</strong>：map和multimap区别：<br>① map不允许容器中有重复key值元素<br>② multimap允许容器中有重复key值元素</p>
<ul>
<li>优点：<br>可以根据key值快速找到value值</li>
</ul>
<h4 id="2-3-8-2-接口"><a href="#2-3-8-2-接口" class="headerlink" title="2.3.8.2 接口"></a>2.3.8.2 接口</h4><p>​      <strong>1. 构造和赋值</strong><br>​        ① <code>map&lt;T1, T2&gt; mp</code> :采用模板实现类实现，默认构造函数<br>​        ② <code>map(const map &amp;mp)</code>:拷贝构造函数<br>​        ③ <code>map&amp; operator=(const map &amp;mp)</code>:重载等号操作符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;m; <span class="comment">//默认构造</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;<span class="built_in">m2</span>(m); <span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m3;</span><br><span class="line">	m3 = m2; <span class="comment">//赋值</span></span><br><span class="line">	<span class="built_in">printMap</span>(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>2. 大小和交换</strong><br>​        ① <code>size()</code> :返回容器中元素的数目<br>​        ② <code>empty()</code>:判断容器是否为空<br>​        ③ <code>swap(st)</code>:交换两个集合容器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m的大小为： &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m2;</span><br><span class="line">	m<span class="number">2.</span><span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">	m<span class="number">2.</span><span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">	m<span class="number">2.</span><span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	m.<span class="built_in">swap</span>(m2);</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>3. 插入和删除</strong></p>
<p>​        ① <code>insert(elem)</code>:在容器中插入元素<br>​        ② <code>erase(pos)</code>:删除pos迭代器所指的元素，返回下一个元素的迭代器<br>​        ③ <code>erase(start,end)</code>:删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器<br>​        ④ <code>erase(key)</code>:删除容器中值为key的元素<br>​        ⑤ <code>clear()</code>:删除容器中所有元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">	<span class="comment">//第一种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	<span class="comment">//第二种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	<span class="comment">//第三种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="comment">//第四种插入方式</span></span><br><span class="line">	m[<span class="number">4</span>] = <span class="number">40</span>; </span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	m.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>());</span><br><span class="line">	m.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>4. 查找和统计</strong></p>
<p>​        ① <code>find(key)</code>:查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end()<br>​        ② <code>count(key)</code>:统计key的元素个数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m; </span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator pos = m.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos != m.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//统计</span></span><br><span class="line">	<span class="type">int</span> num = m.<span class="built_in">count</span>(<span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435</span></span><br></pre></td></tr></table></figure>

<p>​      <strong>7. 容器排序</strong></p>
<p>​        利用仿函数，可以改变排序规则</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//默认从小到大排序</span></span><br><span class="line">	<span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="案例四：员工分组"><a href="#案例四：员工分组" class="headerlink" title="案例四：员工分组"></a>案例四：员工分组</h2><p><strong>案例描述</strong>：</p>
<ul>
<li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li>
<li>员工信息有: 姓名 工资组成；部门分为：策划、美术、研发</li>
<li>随机给10名员工分配部门和工资</li>
<li>通过multimap进行信息的插入 key(部门编号) value(员工)</li>
<li>分部门显示员工信息</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//部门的编号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEHUA 0   <span class="comment">//策划</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEISHU 1  <span class="comment">//美术</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YANFA 2   <span class="comment">//研发</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//员工类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Worker</span>(string name,<span class="type">int</span> salary)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;salary = salary;</span><br><span class="line">	&#125;</span><br><span class="line">	string name;<span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> salary;<span class="comment">//工资</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建员工</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatWorker</span><span class="params">(vector&lt;Worker&gt;&amp; w,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> salary;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		name= <span class="string">&quot;员工&quot;</span>;</span><br><span class="line">		<span class="type">char</span> temp = (<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span> + i);</span><br><span class="line">		name = name + temp;<span class="comment">//员工 ABCDEFG...</span></span><br><span class="line"></span><br><span class="line">		salary = <span class="built_in">rand</span>() % <span class="number">1000</span> + <span class="number">1000</span>;<span class="comment">//salary：1000-1999</span></span><br><span class="line">		<span class="function">Worker <span class="title">worker</span><span class="params">(name, salary)</span></span>;<span class="comment">//用name和salary实例化类</span></span><br><span class="line">		w.<span class="built_in">push_back</span>(worker);<span class="comment">//将实例化的类放入vector容器中</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClassifyWorker</span><span class="params">(multimap&lt;<span class="type">int</span>, Worker&gt;&amp; m, vector &lt;Worker&gt; &amp;w,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> id = <span class="built_in">rand</span>() % <span class="number">3</span>;<span class="comment">//0 1 2</span></span><br><span class="line">		m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(id, w.<span class="built_in">at</span>(i)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowWorkerByGourp</span><span class="params">(multimap&lt;<span class="type">int</span>, Worker&gt;&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;策划部门：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	multimap&lt;<span class="type">int</span>, Worker&gt;::iterator pos = m.<span class="built_in">find</span>(CEHUA);</span><br><span class="line">	<span class="type">int</span> count = m.<span class="built_in">count</span>(CEHUA); <span class="comment">// 统计具体人数</span></span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.salary &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;美术部门： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	pos = m.<span class="built_in">find</span>(MEISHU);</span><br><span class="line">	count = m.<span class="built_in">count</span>(MEISHU); <span class="comment">// 统计具体人数</span></span><br><span class="line">	index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.salary &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;研发部门： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	pos = m.<span class="built_in">find</span>(YANFA);</span><br><span class="line">	count = m.<span class="built_in">count</span>(YANFA); <span class="comment">// 统计具体人数</span></span><br><span class="line">	index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.salary &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));<span class="comment">//随机数种子，为了产生随机工资和部门编号</span></span><br><span class="line">	vector &lt;Worker&gt; w;              <span class="comment">//员工信息</span></span><br><span class="line">	multimap&lt;<span class="type">int</span>, Worker&gt; m;        <span class="comment">//部门编号 + 员工信息</span></span><br><span class="line">	<span class="type">int</span> number;                     <span class="comment">//员工数目</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;please input the number of employees:&quot;</span>;</span><br><span class="line">	cin &gt;&gt; number;</span><br><span class="line">	<span class="comment">//创建员工</span></span><br><span class="line">	<span class="built_in">CreatWorker</span>(w,number);</span><br><span class="line">	<span class="comment">//员工分部门</span></span><br><span class="line">	<span class="built_in">ClassifyWorker</span>(m,w, number);</span><br><span class="line">	<span class="comment">//按部门输出</span></span><br><span class="line">	<span class="built_in">ShowWorkerByGourp</span>(m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596</span></span><br></pre></td></tr></table></figure>

<h1 id="三、STL-函数对象"><a href="#三、STL-函数对象" class="headerlink" title="三、STL- 函数对象"></a>三、STL- 函数对象</h1><h2 id="3-1-函数对象"><a href="#3-1-函数对象" class="headerlink" title="3.1 函数对象"></a>3.1 函数对象</h2><h3 id="3-1-1-函数对象的基础知识"><a href="#3-1-1-函数对象的基础知识" class="headerlink" title="3.1.1 函数对象的基础知识"></a>3.1.1 函数对象的基础知识</h3><p>​       重载函数调用操作符的类，其对象常称为<strong>函数对象</strong>。<br>​       函数对象使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></p>
<h3 id="3-1-2-函数对象使用"><a href="#3-1-2-函数对象使用" class="headerlink" title="3.1.2 函数对象使用"></a>3.1.2 函数对象使用</h3><p>🔵<strong>特点</strong>：</p>
<ol>
<li>普通函数共性：可以有参数，返回值</li>
<li>仿函数特性：可以有自己的状态</li>
<li>函数对象可以作为参数传递</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyAdd</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="comment">//1.普通函数共性：可以有参数，返回值</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//2.仿函数特性：可以有自己的状态</span></span><br><span class="line">		count++;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//3.函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(MyAdd&amp; ma, <span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">ma</span>(a, b)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAdd ma;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">ma</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">ma</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; ma.count &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">test</span>(ma, <span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-谓词"><a href="#3-2-谓词" class="headerlink" title="3.2 谓词"></a>3.2 谓词</h2><h3 id="3-2-1-谓词的基础知识"><a href="#3-2-1-谓词的基础知识" class="headerlink" title="3.2.1 谓词的基础知识"></a>3.2.1 谓词的基础知识</h3><p>​      <strong>谓词</strong>：返回bool类型的仿函数<br>​      <strong>一元谓词</strong>：operator()接受一个参数<br>​      <strong>二元谓词</strong> ：operator()接受两个参数</p>
<h3 id="3-2-2-一元谓词"><a href="#3-2-2-一元谓词" class="headerlink" title="3.2.2 一元谓词"></a>3.2.2 一元谓词</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GreatFive</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>((<span class="built_in">rand</span>() % <span class="number">10</span>));<span class="comment">//随机放入0-9数字</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;v.<span class="built_in">at</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//找第一个大于5的数字</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; ::iterator it=<span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreatFive</span>());<span class="comment">//GreatFive 匿名函数对象</span></span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Not Find&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Find!&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233</span></span><br></pre></td></tr></table></figure>

<p><strong>find_if函数原型</strong>：<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/8655d53439fb43a2a73b8424cc32d230.png" alt="在这里插入图片描述"></p>
<h3 id="3-2-3-二元谓词"><a href="#3-2-3-二元谓词" class="headerlink" title="3.2.3 二元谓词"></a>3.2.3 二元谓词</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//两个参数——二元谓词</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="comment">//默认sort从小到大</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sort排序默认输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//从大到小</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sort排序从大到小输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-内建函数对象"><a href="#3-3-内建函数对象" class="headerlink" title="3.3 内建函数对象"></a>3.3 内建函数对象</h2><h3 id="3-3-1-内建函数对象意义"><a href="#3-3-1-内建函数对象意义" class="headerlink" title="3.3.1 内建函数对象意义"></a>3.3.1 内建函数对象意义</h3><p>​      <strong>概念</strong>：STL内建了一些函数对象。<br>​      <strong>分类</strong>: ①算术仿函数 ②关系仿函数 ③逻辑仿函数<br>​      <strong>用法</strong>: 和一般函数完全相同，但需要引入头文件 <code>#include&lt;functional&gt;</code></p>
<h3 id="3-3-2-算术仿函数"><a href="#3-3-2-算术仿函数" class="headerlink" title="3.3.2 算术仿函数"></a>3.3.2 算术仿函数</h3><p>​      <strong>作用</strong>：实现四则运算</p>
<p>​      <strong>仿函数原型</strong>：<br>​      <code>template&lt;class T&gt; T plus&lt;T&gt;</code>&#x2F;&#x2F;加法仿函数<br>​      <code>template&lt;class T&gt; T minus&lt;T&gt;</code> &#x2F;&#x2F;减法仿函数<br>​      <code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>&#x2F;&#x2F;乘法仿函数<br>​      <code>template&lt;class T&gt; T divides&lt;T&gt;</code> &#x2F;&#x2F;除法仿函数<br>​      <code>template&lt;class T&gt; T modulus&lt;T&gt;</code> &#x2F;&#x2F;取模仿函数<br>​      <code>template&lt;class T&gt; T negate&lt;T&gt;</code> &#x2F;&#x2F;取反仿函数</p>
<p>🔴<strong>注意</strong>： 其中<code>negate</code>是一元运算，其他都是二元运算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//取反</span></span><br><span class="line">	negate&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">n</span>(<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//相加</span></span><br><span class="line">	plus&lt;<span class="type">int</span>&gt;p;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">p</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test1</span>();</span><br><span class="line">	<span class="built_in">test2</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-3-关系仿函数"><a href="#3-3-3-关系仿函数" class="headerlink" title="3.3.3 关系仿函数"></a>3.3.3 关系仿函数</h3><p>​      <strong>仿函数原型</strong>：<br>​      <code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>&#x2F;&#x2F;等于<br>​      <code>template&lt;class T&gt; bool not_equal_to&lt;T&gt; emplate&lt;class T&gt; T minus&lt;T&gt;</code> &#x2F;&#x2F;不等于<br>​      <code>template&lt;class T&gt; bool greater&lt;T&gt;</code>&#x2F;&#x2F;大于<br>​      <code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code> &#x2F;&#x2F;大于等于<br>​      <code>template&lt;class T&gt; bool less&lt;T&gt;</code> &#x2F;&#x2F;小于<br>​      <code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code> &#x2F;&#x2F;小于等于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());     <span class="comment">//默认：升序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyComper</span>());  <span class="comment">//自定义：降序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">//与上面一条语句等价</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-4-逻辑仿函数"><a href="#3-3-4-逻辑仿函数" class="headerlink" title="3.3.4 逻辑仿函数"></a>3.3.4 逻辑仿函数</h3><p>​      <strong>仿函数原型</strong>：<br>​      <code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>&#x2F;&#x2F;逻辑与<br>​      <code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>&#x2F;&#x2F;逻辑或<br>​      <code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code> &#x2F;&#x2F;逻辑非</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">bool</span>&gt; v1;</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v<span class="number">1.</span><span class="built_in">begin</span>(); it != v<span class="number">1.</span><span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//将v的元素放在v1中而且元素取反</span></span><br><span class="line">	vector&lt;<span class="type">bool</span>&gt; v2;</span><br><span class="line">	v<span class="number">2.</span><span class="built_in">resize</span>(v<span class="number">1.</span><span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">transform</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), v<span class="number">2.</span><span class="built_in">begin</span>(), <span class="built_in">logical_not</span>&lt;<span class="type">bool</span>&gt;());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v<span class="number">2.</span><span class="built_in">begin</span>(); it != v<span class="number">2.</span><span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure>

<h1 id="四、STL-常用算法"><a href="#四、STL-常用算法" class="headerlink" title="四、STL- 常用算法"></a>四、STL- 常用算法</h1><h2 id="4-1-常用遍历算法"><a href="#4-1-常用遍历算法" class="headerlink" title="4.1 常用遍历算法"></a>4.1 常用遍历算法</h2><h3 id="4-1-1-for-each"><a href="#4-1-1-for-each" class="headerlink" title="4.1.1 for_each"></a>4.1.1 for_each</h3><p>​      <strong>函数原型</strong>：<br>​      <code>for_each(iterator beg, iterator end, _func);</code> &#x2F;&#x2F;遍历算法 遍历容器元素， beg 开始迭代器，end 结束迭代器， _func 函数或者函数对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print1</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Print1);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-2-transform"><a href="#4-1-2-transform" class="headerlink" title="4.1.2 transform"></a>4.1.2 transform</h3><p>​      <strong>函数原型</strong>：<br>​       <code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code> &#x2F;&#x2F;beg1 源容器开始迭代器，end1 源容器结束迭代器，beg2 目标容器开始迭代器，_func 函数或者函数对象</p>
<p> 目标容器需要提前开辟空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TransForm</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val<span class="number">+10</span>;<span class="comment">//原数据+10</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; TargetV; <span class="comment">//目标容器</span></span><br><span class="line">	TargetV.<span class="built_in">resize</span>(v.<span class="built_in">size</span>()); <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line">	<span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), TargetV.<span class="built_in">begin</span>(), <span class="built_in">TransForm</span>());</span><br><span class="line">	for_each(TargetV.<span class="built_in">begin</span>(), TargetV.<span class="built_in">end</span>(), print);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-常用查找算法"><a href="#4-2-常用查找算法" class="headerlink" title="4.2 常用查找算法"></a>4.2 常用查找算法</h2><p>​      <code>find</code> &#x2F;&#x2F;查找元素<br>​      <code>find_if</code> &#x2F;&#x2F;按条件查找元素<br>​      <code>adjacent_find</code> &#x2F;&#x2F;查找相邻重复元素<br>​      <code>binary_search</code> &#x2F;&#x2F;二分查找法<br>​      <code>count</code> &#x2F;&#x2F;统计元素个数<br>​      <code>count_if</code> &#x2F;&#x2F;按条件统计元素个数</p>
<h3 id="4-2-1-find"><a href="#4-2-1-find" class="headerlink" title="4.2.1 find"></a>4.2.1 find</h3><p>​      <strong>函数原型</strong>：<code>find(iterator beg, iterator end, value);</code><br>​      &#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<br>​      &#x2F;&#x2F; beg 开始迭代器<br>​      &#x2F;&#x2F; end 结束迭代器<br>​      &#x2F;&#x2F; value 查找的元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;name == p.name &amp;&amp; <span class="keyword">this</span>-&gt;age == p.age)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1.内置数据类型</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it1 = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">if</span> (it1 == v.<span class="built_in">end</span>())</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;NOT FIND!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;FIND&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//2.自定义数据类型</span></span><br><span class="line">	vector&lt;person&gt; p;</span><br><span class="line">	<span class="function">person <span class="title">p1</span><span class="params">(<span class="string">&quot;a&quot;</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function">person <span class="title">p2</span><span class="params">(<span class="string">&quot;b&quot;</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">person <span class="title">p3</span><span class="params">(<span class="string">&quot;c&quot;</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	p.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	p.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	vector&lt;person&gt;::iterator it2 = <span class="built_in">find</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), p2);</span><br><span class="line">	<span class="keyword">if</span> (it2 == p.<span class="built_in">end</span>())</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;NOT FIND!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;FIND&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-find-if"><a href="#4-2-2-find-if" class="headerlink" title="4.2.2 find_if"></a>4.2.2 find_if</h3><p>​      <strong>函数原型</strong>：<code>find_if(iterator beg, iterator end, _Pred);</code><br>​      &#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<br>​      &#x2F;&#x2F; beg 开始迭代器<br>​      &#x2F;&#x2F; end 结束迭代器<br>​      &#x2F;&#x2F; _Pred 函数或者谓词（返回bool类型的仿函数）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreaterFive</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater20</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater20</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-3-adjacent-find"><a href="#4-2-3-adjacent-find" class="headerlink" title="4.2.3 adjacent_find"></a>4.2.3 adjacent_find</h3><p>​      <strong>函数原型</strong>：<code>adjacent_find(iterator beg, iterator end);</code><br>​      &#x2F;&#x2F; 查找相邻重复元素,返回相邻元素的第一个位置的迭代器<br>​      &#x2F;&#x2F; beg 开始迭代器<br>​      &#x2F;&#x2F; end 结束迭代器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找相邻重复元素</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-4-binary-search"><a href="#4-2-4-binary-search" class="headerlink" title="4.2.4 binary_search"></a>4.2.4 binary_search</h3><p>​      <strong>函数原型</strong>：<code>bool binary_search(iterator beg, iterator end, value);</code><br>​      &#x2F;&#x2F; 查找指定的元素，查到 返回true 否则false<br>​      &#x2F;&#x2F; 注意: 在无序序列中不可用<br>​      &#x2F;&#x2F; beg 开始迭代器<br>​      &#x2F;&#x2F; end 结束迭代器<br>​      &#x2F;&#x2F; value 查找的元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//二分查找</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-5-count"><a href="#4-2-5-count" class="headerlink" title="4.2.5 count"></a>4.2.5 count</h3><p>​      <strong>函数原型</strong>：<code>count(iterator beg, iterator end, value);</code><br>​      &#x2F;&#x2F; 统计元素出现次数<br>​      &#x2F;&#x2F; beg 开始迭代器<br>​      &#x2F;&#x2F; end 结束迭代器<br>​      &#x2F;&#x2F; value 统计的元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>,<span class="number">35</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-6-count-if"><a href="#4-2-6-count-if" class="headerlink" title="4.2.6 count_if"></a>4.2.6 count_if</h3><p>​      <strong>函数原型</strong>：<code>count_if(iterator beg, iterator end, _Pred);</code><br>​      &#x2F;&#x2F; 按条件统计元素出现次数<br>​      &#x2F;&#x2F; beg 开始迭代器<br>​      &#x2F;&#x2F; end 结束迭代器<br>​      &#x2F;&#x2F; _Pred 谓词</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater4</span>());</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeLess35</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">AgeLess35</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182</span></span><br></pre></td></tr></table></figure>

<h2 id="4-3-常用排序算法"><a href="#4-3-常用排序算法" class="headerlink" title="4.3 常用排序算法"></a>4.3 常用排序算法</h2><p>​       <code>sort</code>&#x2F;&#x2F;对容器内元素进行排序<br>​      <code>random_shuffle</code> &#x2F;&#x2F;洗牌 指定范围内的元素随机调整次序<br>​      <code>merge</code> &#x2F;&#x2F; 容器元素合并，并存储到另一容器中<br>​      <code>reverse</code> &#x2F;&#x2F; 反转指定范围的元素</p>
<h3 id="4-3-1-sort"><a href="#4-3-1-sort" class="headerlink" title="4.3.1 sort"></a>4.3.1 sort</h3><p>​      <strong>函数原型</strong>：<code>sort(iterator beg, iterator end, _Pred);</code><br>​      &#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<br>​      &#x2F;&#x2F; beg 开始迭代器<br>​      &#x2F;&#x2F; end 结束迭代器<br>​      &#x2F;&#x2F; _Pred 谓词</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//sort默认从小到大排序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从大到小排序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-2-random-shuffle"><a href="#4-3-2-random-shuffle" class="headerlink" title="4.3.2 random_shuffle"></a>4.3.2 random_shuffle</h3><p>​      <strong>函数原型</strong>：<code>random_shuffle(iterator beg, iterator end);</code><br>​      &#x2F;&#x2F; 指定范围内的元素随机调整次序<br>​      &#x2F;&#x2F; beg 开始迭代器<br>​      &#x2F;&#x2F; end 结束迭代器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打乱顺序</span></span><br><span class="line">	<span class="built_in">random_shuffle</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-3-merge"><a href="#4-3-3-merge" class="headerlink" title="4.3.3 merge"></a>4.3.3 merge</h3><p>​      <strong>函数原型</strong>：<code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code><br>​      &#x2F;&#x2F; 容器元素合并，并存储到另一容器中</p>
<p>​      &#x2F;&#x2F; 注意: 两个容器必须是有序的</p>
<p>​      &#x2F;&#x2F; beg1 容器1开始迭代器<br>​      &#x2F;&#x2F; end1 容器1结束迭代器<br>​      &#x2F;&#x2F; beg2 容器2开始迭代器<br>​      &#x2F;&#x2F; end2 容器2结束迭代器<br>​      &#x2F;&#x2F; dest 目标容器开始迭代器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vtarget;</span><br><span class="line">	<span class="comment">//目标容器需要提前开辟空间</span></span><br><span class="line">	vtarget.<span class="built_in">resize</span>(v<span class="number">1.</span><span class="built_in">size</span>() + v<span class="number">2.</span><span class="built_in">size</span>());</span><br><span class="line">	<span class="comment">//合并  需要两个有序序列</span></span><br><span class="line">	<span class="built_in">merge</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), vtarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vtarget.<span class="built_in">begin</span>(), vtarget.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-4-reverse"><a href="#4-3-4-reverse" class="headerlink" title="4.3.4 reverse"></a>4.3.4 reverse</h3><p>​      <strong>函数原型</strong>：<code>reverse(iterator beg, iterator end);</code><br>​      &#x2F;&#x2F; 反转指定范围的元素<br>​      &#x2F;&#x2F; beg 开始迭代器<br>​      &#x2F;&#x2F; end 结束迭代器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940</span></span><br></pre></td></tr></table></figure>

<h2 id="4-4-常用拷贝和替换算法"><a href="#4-4-常用拷贝和替换算法" class="headerlink" title="4.4 常用拷贝和替换算法"></a>4.4 常用拷贝和替换算法</h2><p>​      <code>copy</code>&#x2F;&#x2F; 容器内指定范围的元素拷贝到另一容器中<br>​      <code>replace</code> &#x2F;&#x2F; 将容器内指定范围的旧元素修改为新元素<br>​      <code>replace_if</code> &#x2F;&#x2F; 容器内指定范围满足条件的元素替换为新元素<br>​      <code>swap</code> &#x2F;&#x2F; 互换两个容器的元素</p>
<h3 id="4-4-1-copy"><a href="#4-4-1-copy" class="headerlink" title="4.4.1 copy"></a>4.4.1 copy</h3><p>​      <strong>函数原型</strong>：<code>copy(iterator beg, iterator end, iterator dest);</code><br>​      &#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<br>​      &#x2F;&#x2F; beg 开始迭代器<br>​      &#x2F;&#x2F; end 结束迭代器<br>​      &#x2F;&#x2F; dest 目标起始迭代器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	v<span class="number">2.</span><span class="built_in">resize</span>(v<span class="number">1.</span><span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">copy</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), v<span class="number">2.</span><span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-2-replace"><a href="#4-4-2-replace" class="headerlink" title="4.4.2 replace"></a>4.4.2 replace</h3><p>​      <strong>函数原型</strong>：<code>replace(iterator beg, iterator end, oldvalue, newvalue);</code><br>​      &#x2F;&#x2F; 将区间内旧元素 替换成 新元素<br>​      &#x2F;&#x2F; beg 开始迭代器<br>​      &#x2F;&#x2F; end 结束迭代器<br>​      &#x2F;&#x2F; oldvalue 旧元素<br>​      &#x2F;&#x2F; newvalue 新元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器中的20 替换成 2000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>,<span class="number">2000</span>);</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-3-replace-if"><a href="#4-4-3-replace-if" class="headerlink" title="4.4.3 replace_if"></a>4.4.3 replace_if</h3><p>​      <strong>函数原型</strong>：<code>replace_if(iterator beg, iterator end, _pred, newvalue);</code><br>​      &#x2F;&#x2F; 按条件替换元素，满足条件的替换成指定元素<br>​      &#x2F;&#x2F; beg 开始迭代器<br>​      &#x2F;&#x2F; end 结束迭代器<br>​      &#x2F;&#x2F; _pred 谓词<br>​      &#x2F;&#x2F; newvalue 替换的新元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplaceGreater30</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ReplaceGreater30</span>(), <span class="number">3000</span>);</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-4-swap"><a href="#4-4-4-swap" class="headerlink" title="4.4.4 swap"></a>4.4.4 swap</h3><p>​      <strong>函数原型</strong>：<code>swap(container c1, container c2);</code><br>​      &#x2F;&#x2F; 互换两个容器的元素<br>​      &#x2F;&#x2F; c1容器1<br>​      &#x2F;&#x2F; c2容器2</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i<span class="number">+100</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">swap</span>(v1, v2);</span><br><span class="line">	for_each(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344</span></span><br></pre></td></tr></table></figure>

<h2 id="4-5-常用算术生成算法"><a href="#4-5-常用算术生成算法" class="headerlink" title="4.5 常用算术生成算法"></a>4.5 常用算术生成算法</h2><p>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></p>
<p>​      <code>accumulate</code>&#x2F;&#x2F; 计算容器元素累计总和<br>​      <code>fill</code>&#x2F;&#x2F; 向容器中添加元素</p>
<h3 id="4-5-1-accumulate"><a href="#4-5-1-accumulate" class="headerlink" title="4.5.1 accumulate"></a>4.5.1 accumulate</h3><p>​      <strong>函数原型</strong>：<code>accumulate(iterator beg, iterator end, value);</code><br>​      &#x2F;&#x2F; 计算容器元素累计总和<br>​      &#x2F;&#x2F; beg 开始迭代器<br>​      &#x2F;&#x2F; end 结束迭代器<br>​      &#x2F;&#x2F; value 起始值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> total = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>

<h3 id="4-5-2-fill"><a href="#4-5-2-fill" class="headerlink" title="4.5.2 fill"></a>4.5.2 fill</h3><p>​      <strong>函数原型</strong>：<code>fill(iterator beg, iterator end, value);</code><br>​      &#x2F;&#x2F; 向容器中填充元素<br>​      &#x2F;&#x2F; beg 开始迭代器<br>​      &#x2F;&#x2F; end 结束迭代器<br>​      &#x2F;&#x2F; value 填充的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="comment">//填充</span></span><br><span class="line">	<span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233</span></span><br></pre></td></tr></table></figure>

<h2 id="4-6-常用集合算法"><a href="#4-6-常用集合算法" class="headerlink" title="4.6 常用集合算法"></a>4.6 常用集合算法</h2><p>​      <code>set_intersection</code> &#x2F;&#x2F; 求两个容器的交集<br>​      <code>set_union</code>&#x2F;&#x2F; 求两个容器的并集<br>​      <code>set_difference</code>&#x2F;&#x2F; 求两个容器的差集</p>
<h3 id="4-6-1-set-intersection"><a href="#4-6-1-set-intersection" class="headerlink" title="4.6.1 set_intersection"></a>4.6.1 set_intersection</h3><p>​      <strong>函数原型</strong>：<code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code><br>​      &#x2F;&#x2F; 求两个集合的交集<br>​      &#x2F;&#x2F; 注意:两个集合必须是有序序列<br>​      &#x2F;&#x2F; beg1 容器1开始迭代器<br>​      &#x2F;&#x2F; end1 容器1结束迭代器<br>​      &#x2F;&#x2F; beg2 容器2开始迭代器<br>​      &#x2F;&#x2F; end2 容器2结束迭代器<br>​      &#x2F;&#x2F; dest 目标容器开始迭代器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i<span class="number">+5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(<span class="built_in">min</span>(v<span class="number">1.</span><span class="built_in">size</span>(), v<span class="number">2.</span><span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_intersection</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142</span></span><br></pre></td></tr></table></figure>

<h3 id="4-6-2-set-union"><a href="#4-6-2-set-union" class="headerlink" title="4.6.2 set_union"></a>4.6.2 set_union</h3><p>​      <strong>函数原型</strong>：<code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code><br>​      &#x2F;&#x2F; 求两个集合的并集<br>​      &#x2F;&#x2F; 注意:两个集合必须是有序序列<br>​      &#x2F;&#x2F; beg1 容器1开始迭代器<br>​      &#x2F;&#x2F; end1 容器1结束迭代器<br>​      &#x2F;&#x2F; beg2 容器2开始迭代器<br>​      &#x2F;&#x2F; end2 容器2结束迭代器<br>​      &#x2F;&#x2F; dest 目标容器开始迭代器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i<span class="number">+5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个容器的和给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(v<span class="number">1.</span><span class="built_in">size</span>() + v<span class="number">2.</span><span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_union</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041</span></span><br></pre></td></tr></table></figure>

<h3 id="4-6-3-set-difference"><a href="#4-6-3-set-difference" class="headerlink" title="4.6.3 set_difference"></a>4.6.3 set_difference</h3><p>​      <strong>函数原型</strong>：<code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code><br>​      &#x2F;&#x2F; 求两个集合的差集</p>
<p>​      &#x2F;&#x2F; 注意:两个集合必须是有序序列</p>
<p>​      &#x2F;&#x2F; beg1 容器1开始迭代器<br>​      &#x2F;&#x2F; end1 容器1结束迭代器<br>​      &#x2F;&#x2F; beg2 容器2开始迭代器<br>​      &#x2F;&#x2F; end2 容器2结束迭代器<br>​      &#x2F; dest 目标容器开始迭代器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i<span class="number">+5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>( <span class="built_in">max</span>(v<span class="number">1.</span><span class="built_in">size</span>() , v<span class="number">2.</span><span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_difference</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	itEnd = <span class="built_in">set_difference</span>(v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>完结散花🎉🎉🎉</p>
</blockquote>
<p>文章知识点与官方知识档案匹配，可进一步学习相关知识</p>
]]></content>
      <categories>
        <category>从零开始的C++の学习之路</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2025/03/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%20%20%E9%82%B1%E9%94%A1%E9%B9%8F%20%20%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="深度学习与神经网络-邱锡鹏-第一章学习笔记"><a href="#深度学习与神经网络-邱锡鹏-第一章学习笔记" class="headerlink" title="深度学习与神经网络 | 邱锡鹏 | 第一章学习笔记"></a>深度学习与神经网络 | 邱锡鹏 | 第一章学习笔记</h1><p>参考自下面这篇博客，笔者在此基础上写了写自己的理解，仅自己用来复习使用</p>
<p><a href="https://blog.csdn.net/wyll19980812/article/details/122063261">【学习笔记】《深度学习与神经网络》——邱锡鹏_神经网络与深度学习 邱锡鹏-CSDN博客</a></p>
<h2 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h2><p>人工智能的一个子领域<br>神经网络：一种以（人工)）<a href="https://so.csdn.net/so/search?q=%E7%A5%9E%E7%BB%8F%E5%85%83&spm=1001.2101.3001.7020">神经元</a>为基本单元的模型<br>深度学习：一类机器学习问题，主要解决<strong>贡献度分配</strong>问题</p>
<p>知识结构：<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/81f9fdc9443d6ae56765927e6bafc0cc.png" alt="在这里插入图片描述"><br>路线图：<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/63dcecc473e4ca3f5972eb6293fcbb60.png" alt="在这里插入图片描述"><br>顶会：<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/178afe9e08bac12bcaab9028ccc57ab5.png" alt="在这里插入图片描述"></p>
<h3 id="1-1-人工智能"><a href="#1-1-人工智能" class="headerlink" title="1.1 人工智能"></a>1.1 人工智能</h3><p>诞生：人工智能这个学科的诞生有着明确的标志性事件，就是1956年的达特茅斯(Dartmouth)会议。在这次会议上，“人工智能” 被提出并作为木研究领域的名称。</p>
<p>人工智能&#x3D;计算机控制+智能行为；</p>
<p>人工智能就是要让机器的行为看起来就像是人所表现出的智能行为一样。 ——John McCarthy ( 1927-2011)</p>
<p>因为要使得计算机能通过图灵测试，计算机必须具备理解语言、学习、记忆、推理、决策等能力 &#x3D;&gt;<br>研究领域：</p>
<ol>
<li>机器感知(计算机视觉、语音信息处理、模式识别)</li>
<li>学习(机器学习、强化学习)</li>
<li>语言（自然语言处理)</li>
<li>记忆（知识表示)</li>
<li>决策（规划、数据挖掘)</li>
</ol>
<p>发展时间轴：<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/e81abe6a05731d990c5af0820b5766a3.png" alt="在这里插入图片描述"></p>
<h3 id="1-2-如何开发人工智能系统"><a href="#1-2-如何开发人工智能系统" class="headerlink" title="1.2 如何开发人工智能系统"></a>1.2 如何开发人工智能系统</h3><p>很难实现一个程序把这些规则给写下来，比如语音的识别，数字的识别； &#x3D;&gt; 机器学习：机器自己总结规则（函数）<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/8c3c9b1e138c0f1dc3a28b045d3a53c6.png" alt="在这里插入图片描述"><br>怎么构建这个函数？就是机器学习要解决的事；</p>
<p>用一个根据芒果图片来判断芒果是否甜的模型举例机器学习步骤：<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/035119537851ac6a0c8ab4a55183eadb.png" alt="在这里插入图片描述"><br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/b0138c9c7248ee99e7f3a101302dae36.png" alt="在这里插入图片描述"></p>
<h3 id="1-3-表示学习"><a href="#1-3-表示学习" class="headerlink" title="1.3 表示学习"></a>1.3 表示学习</h3><p>当我们用机器学习来解决一些模式识别任务时，一般的流程包含以下几个步骤：<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/9de712f15be24b8f4399907b256ee84e.png" alt="在这里插入图片描述"></p>
<ol>
<li>数据预处理：剔除原始数据中的冗余、缺失、异常等无效数据；</li>
<li>特征提取：提取有效特征；</li>
<li>特征转换：剔除冗余特征、考虑特征间的相关性、对特征进行组合等特征转换操作；</li>
<li>预测：建立 f(x) -&gt; y 的模型；</li>
</ol>
<blockquote>
<p>语义鸿沟：人工智能挑战之一，即对文本、图像的理解无法从字符串或者图像的底层特征直接获取；</p>
</blockquote>
<p>比如根据一些底层的像素点就能判断这个图像是不是猫啊狗啊，这是挺难的；</p>
<p>Q：什么是好的数据表示？<br>一个好的数据表示一般有以下优点：</p>
<ol>
<li>具有很强的学习能力；</li>
<li>使后续的学习任务变得简单；</li>
<li>具有一般性，是任务或者领域独立的；</li>
</ol>
<p>数据表示是机器学习的核心问题；</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/1200d9c5823dc5ee846cce88bb161ef6.png" alt="在这里插入图片描述"><br>局部表示，1维表示一个语义；分布式表示，n维组合表示一个语义；<br>对于分布式表示：K维非零参数能够表示2^k个语义（假设一个维度分左右，即表示两个语义)；而局部表示中，K维只能表示K个语义。</p>
<p>这个2^k的意思是：每一个维度表示两个语意，我就以大于0或者小于0为例，x&gt;0,x&lt;0,y&gt;0,y&lt;0，就是二维的那四个象限，就是2^2&#x3D;4，有4个语意，当然我这里只是举例子拿大于0或者小于0，实际大于1小于1也行，只要实现老师说的2分就行。</p>
<p>以颜色为例：<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/359a085e7d319d029377aee17138ecd3.png" alt="在这里插入图片描述"><br>分布式表示，3个维度能够表示完所有颜色，而如果用局部表示的话则每个颜色需要一个维度，1千种颜色就需要1千个颜色；说明分布式表示的表示能力很强，但解释能力劣于局部表示；分布式表示对于颜色间的对比、相似等操作也能提供很大的便利；<br>Q：照这么说，分布式表示岂不是可以表示无穷种颜色，还需要3个维度干嘛？？？</p>
<p>嵌入：<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/ce2ec4598e2f574d9e4f7061642a5dc2.png" alt="在这里插入图片描述"><br>比如这个词嵌入：<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/5f955a327936b22cf3e90583a00dd326.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>表示学习：如何自动从数据中学习好的表示</p>
</blockquote>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/1d30a97dd83abceb1b64a715e2d046c1.png" alt="在这里插入图片描述"><br>传统的特征提取 VS 表示学习：<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/240c925665735f40dfea8c8149214f95.png" alt="在这里插入图片描述"><br>特征提取有明确的任务或目标，但完成这个任务或目标而提取的特征并不一定有益于后面的分析，而表示学习学习得是有用的特征，有益于右面的分析，但难点在于没有明确地目标，需要后面不断的反馈回来；</p>
<h3 id="1-4-深度学习"><a href="#1-4-深度学习" class="headerlink" title="1.4 深度学习"></a>1.4 深度学习</h3><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/9b1432098d9a7bf241b49b32e77bb520.png" alt="在这里插入图片描述"><br>深度学习 &#x3D; 表示学习 + 决策（预测）学习；</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/b84d5d055cb9fae154407c16355bd937.png" alt="在这里插入图片描述"><br>Q：什么叫贡献度分配问题？<br>是底层特征、中层特征还是高层特征对预测的结果影响较大，即当预测了一个较差的结果，我需要知道这主要是因为底层到中层没处理好还是中层到高层没处理好；拿下象棋举例子，我这一下下在这，我怎么知道这是好还是坏，只能通过最后我赢没赢来反馈反推前面哪一步没下好，这就需要大量的练习经验；</p>
<p>Q：怎么解决贡献度分配问题？<br>神经网络；</p>
<p>一个图像分类的深度学习模型：<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/8424f0481ac000f415c3565a266d697b.png" alt="在这里插入图片描述"><br>深度学习的数学描述：<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/c91b54f77f581e1138124b106a22c1bb.png" alt="在这里插入图片描述"></p>
<p>我的理解是f(x)是一次预测的结果，g(f(x))就是用第一次预测的结果再次进行学习然后预测，之后就重复这个过程</p>
<p>如果F(x)是线性函数，那么这个就没意义了，因为多个线性函数嵌套依旧还是线性函数，没有能力的提升；</p>
<h3 id="1-5-神经网络"><a href="#1-5-神经网络" class="headerlink" title="1.5 神经网络"></a>1.5 神经网络</h3><p>Q：神经网络如何学习？</p>
<blockquote>
<p>赫布法则（Hebb Rule）：“当神经元A的一个轴突和神经元B很近，足以对它产生影响，并且持续地、重复地参与了对神经元B的兴奋，那么在这两个神经元或其中之一会发生某种生长过程或新陈代谢变化，以致于神经元A作为能使神经元B兴奋的细胞之一，它的效能加强了。”</p>
</blockquote>
<ol>
<li>人脑有两种记忆：长期记忆和短期记忆。短期记忆持续时间不超过一分钟。如果一个经验重复足够的次数，此经验就可储存在长期记忆中。</li>
<li>短期记忆转化为长期记忆的过程就称为凝固作用。</li>
<li>人脑中的海马区为大脑结构凝固作用的核心区域。</li>
</ol>
<p>人工神经元：<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/d365777fcc45d84e62b3ec767b61b8e7.png" alt="在这里插入图片描述"></p>
<p>人工神经网络主要由大量的神经元以及它们之间的有向连接构成。因此考虑三方面︰</p>
<ol>
<li>神经元的激活规则：那个激活函数，到底是怎么激活的，神经元输入到输出之间的映射关系，一般为非线性函数；</li>
<li>网络的拓扑结构：不同神经元是怎么连接的；</li>
<li>学习算法：通过训练数据来学习神经网络的参数：梯度下降，反馈；</li>
</ol>
<p>人工神经网络由神经元模型构成，这种由许多神经元组成的信息处理网络具有并行分布结构。<br>虽然这里将神经网络结构大体上分为三种类型，但是大多数网络都是<strong>复合型结构</strong>，即一个神经网络中包括多种网络结构<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/2021246ab71a4471258dc36fcf3c3495.png" alt="在这里插入图片描述"><br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/38d0b2885bba7550f5b5f8d796287c3e.png" alt="在这里插入图片描述"><br>Q：神经网络如何解决<strong>贡献度分配</strong>问题？<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/2c6d069488af8c85ea914921602ffc27.png" alt="在这里插入图片描述"><br>一个点的斜率越大，说明此处 x 的变化对 y 的影响越大，偏导数的概念，那么就知道在哪个地方调参数能够很大程度上影响输出</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>pycharm+anaconda创建项目</title>
    <url>/2024/12/28/%E5%AD%A6%E6%A0%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/pycharm+anaconda%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="pycharm-anaconda创建项目"><a href="#pycharm-anaconda创建项目" class="headerlink" title="pycharm+anaconda创建项目"></a>pycharm+anaconda创建项目</h1><p><code>安装：</code></p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/144791667?spm=1001.2014.3001.5502">Windows下Python+PyCharm的安装步骤及PyCharm的使用-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/m0_74795952/article/details/144792895?spm=1001.2014.3001.5502">详细Anaconda安装+配置+环境创建教程-CSDN博客</a></p>
<p><code>创建项目：</code></p>
<p>开始尝试新建一个项目吧！<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/f6c9f4bb15144e1d2a7a74d63f45e2f6.png" alt="在这里插入图片描述"><br>选择好项目建设的文件夹<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/c097394adcb449b58b9595fce975811a.png" alt="在这里插入图片描述"><br>我的项目命名为：pythontset，选择自定义环境-select existing(已存在环境)，类型可选择conda(这就是前边已经配置好的anaconda环境)，点击创建。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/30b8f60ecc0e9fce5c693580536fd5a0.png" alt="在这里插入图片描述"><br>这里我的test项目就已经创建完成了<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/bc59e6f28552da9f59edcd9f592c746b.png" alt="在这里插入图片描述"><br>输入<strong>print(“hello world”)</strong>， 运行一下试试看！<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/9529197b66b20e8007d3863f5023e002.png" alt="在这里插入图片描述"></p>
<p>成功。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/f56b58e80b05a9ad78bb57d4624d26af.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下Python+PyCharm的安装步骤及PyCharm的使用</title>
    <url>/2024/12/28/%E5%AD%A6%E6%A0%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Windows%E4%B8%8BPython+PyCharm%E7%9A%84%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4%E5%8F%8APyCharm%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Windows下Python-PyCharm的安装步骤及PyCharm的使用"><a href="#Windows下Python-PyCharm的安装步骤及PyCharm的使用" class="headerlink" title="Windows下Python+PyCharm的安装步骤及PyCharm的使用"></a>Windows下Python+PyCharm的安装步骤及PyCharm的使用</h1><h2 id="一、Python的安装"><a href="#一、Python的安装" class="headerlink" title="一、Python的安装"></a>一、Python的安装</h2><h3 id="（1）环境准备"><a href="#（1）环境准备" class="headerlink" title="（1）环境准备"></a>（1）环境准备</h3><p>python是一门跨平台的语言，如Windows、Linux、MacOS等平台都能完美兼容，以下只对Windows平台安装做详细介绍。</p>
<blockquote>
<p>Windows PC</p>
<p>python3.6.4</p>
<p>python官方下载：<a href="https://www.python.org/downloads/windows/">Python Releases for Windows | Python.org</a>，可根据自己需要下载版本。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/2f0ccbf338c52d8e2d8e079581cb5631.png" alt="img"></p>
<p> 我下载的是python3.6.4，比较老的一个版本了，选择<code>Download Windows x86-64 executable installer</code>，下载64位的：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/3d9e0421b80dae4736d7734d43906b88.png" alt="img"></p>
<p> <strong>注意：</strong>“x86”是指32位的操作系统，“x86-64”是指64位的操作系统。</p>
</blockquote>
<h3 id="（2）Python安装"><a href="#（2）Python安装" class="headerlink" title="（2）Python安装"></a>（2）Python安装</h3><blockquote>
<p>python安装非常简单，双击下载好的安装包，进入选择安装方式</p>
<p>第一种：Install Now 立即安装，即采用默认安装方式，不能自行指定安装的路径。</p>
<p>第二种：Customize installation 自定义安装，可以自己选择安装的路径（建议自定义安装）。</p>
<p>选择第二种，自定义安装，把最底下<code>Add Python 3.6 to PATH</code>打上勾，否则需要手动添加环境变量</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/5b77522bb3842d7a3f9fb4e7dbe71323.png" alt="img"></p>
<p> 下一步：默认把所有的勾选上即可</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/af58e740837b024b6c08ed4383db7240.png" alt="img"></p>
<p> 下一步：修改安装路径，建议别安装在C盘。如果没有联网，请不要勾选第六项</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/b9d6b7269407b6ab69b9d4a6b039cb0f.png" alt="img"></p>
<p> 下一步：安装完成，点击Close关闭即可</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/098dd46c89d7d2dc04051e93c5353afe.png" alt="img"></p>
<p> 安装完成之后，使用win+R键输入cmd进入DOS界面，输入<code>python</code>验证，如下图所示即安装成功，继续输入exit()退出即可</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/acb45bd29b37a331b9c094d0590ffa4b.png" alt="img"></p>
<p> <strong>补充：</strong></p>
<p>如果在控制台输入<code>python</code>命令后，显示找不到命令或者不是内部命令等情况，大部分的原因是因为在第一步时没有勾选上<code>Add Python 3.6 to PATH</code>，这个时候我们需要手动的添加环境变量：</p>
<p>右键单击桌面 我的电脑&#x2F;此电脑–&gt;属性–&gt;找到高级系统设置–&gt;环境变量–&gt;下面的系统变量–&gt;找到 Path</p>
<p>添加python安装的路径和Scripts即可（根据自己安装的路径添加）</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/fbf8cfebe158b38d7c5fd955606dd9f7.png" alt="img"></p>
<p> 确定之后，重新打开控制台输入python查看是否有版本信息等</p>
</blockquote>
<h3 id="（3）pip组件的安装"><a href="#（3）pip组件的安装" class="headerlink" title="（3）pip组件的安装"></a>（3）pip组件的安装</h3><p>pip组件是一个现代通用的Python包管理工具，其提供了对Python包的查找、下载、安装及卸载等功能。一种通过在线升级安装，另一种直接官网下载后解压安装，下载地址：<a href="https://pypi.org/project/pip/#files">pip · PyPI</a>，点击下载最新版的<code>pip-21.2.4-py3-none-any.whl</code>即可，下载后解压，在解压后的目录下命令行中输入命令<code>python setup.py install</code></p>
<blockquote>
<p>在线升级安装：</p>
<p>首先查看是否安装pip组件： pip list</p>
<p>如果出现以下提示，则输入： python -m pip install –upgrade pip 进行在线升级</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/e52310f9a4f0be7bdcfff6cda716f149.png" alt="img"></p>
<p> 输入命令回车后自动下载最新版的pip，再重新输入： pip list 查看pip版本信息即可</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/54a6c18425ed40f63bcc4cccb321930d.png" alt="img"></p>
</blockquote>
<h2 id="二、PyCharm的安装"><a href="#二、PyCharm的安装" class="headerlink" title="二、PyCharm的安装"></a>二、PyCharm的安装</h2><h3 id="（1）环境准备-1"><a href="#（1）环境准备-1" class="headerlink" title="（1）环境准备"></a>（1）环境准备</h3><blockquote>
<p>PyCharm是一款非常好用的Python IDE，由JetBrains开发而成。</p>
<p>官方下载：<a href="https://www.jetbrains.com/pycharm/download/#section=windows">Download PyCharm: Python IDE for Professional Developers by JetBrains</a></p>
<p>我下载的是pycharm-professional-2021.2.2.exe（专业版）：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/ec98cabe6db1b03ef97052c132222e2a.png" alt="img"></p>
<p> PyCharm针对每个平台都有<code>Professional</code>和<code>Community</code>两个版本，自己可根据自己的需要进行选择。</p>
<p>Professional：专业版（建议选择专业版），功能强大，属于收费版。</p>
<p>Community：社区版，只支持Python开发，开源、免费，用作学习也够用。</p>
</blockquote>
<h3 id="（2）PyCharm的安装"><a href="#（2）PyCharm的安装" class="headerlink" title="（2）PyCharm的安装"></a>（2）PyCharm的安装</h3><blockquote>
<p>PyCharm的安装通用非常简单，双击进行下一步即可</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/3fb87dd678398d8b8e708cd159a40ddd.png" alt="img"></p>
<p> 下一步：修改安装路径，建议别放在C盘。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/4564170bad60515499b2764e6d3c707a.png" alt="img"></p>
<p> 下一步：可以都勾选上</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/b18d1d2564fe2419eb2bf669a1aeea7a.png" alt="img"></p>
<p> 下一步：直接点击<code>Install</code>安装即可</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/0c51b93a6f8ceec46aebd4d7b43bf6b9.png" alt="img"></p>
<p> 安装完成：点击<code>I want to manually reboot later</code>稍后重启系统</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/d6e64f9662d799ac5298c2e7c4e2e5bf.png" alt="img"></p>
</blockquote>
<h2 id="三、PyCharm的使用（含快捷键）"><a href="#三、PyCharm的使用（含快捷键）" class="headerlink" title="三、PyCharm的使用（含快捷键）"></a>三、PyCharm的使用（含快捷键）</h2><h3 id="（1）PyCharm的一些常用设置"><a href="#（1）PyCharm的一些常用设置" class="headerlink" title="（1）PyCharm的一些常用设置"></a>（1）PyCharm的一些常用设置</h3><ul>
<li><strong>修改主题</strong></li>
</ul>
<blockquote>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/6cf65464af34ab42ace247ab7f4cf551.png" alt="img"></p>
</blockquote>
<ul>
<li><strong>设置字体</strong></li>
</ul>
<blockquote>
<p><code>进入Settings</code>界面，在<code>Editor-&gt;Font</code>中修改字体及大小</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/54d4e1d1d52e7142ecd907666d804135.png" alt="img"></p>
<p> 默认使用<code>JetBrains Mono</code>，也比较好用。</p>
</blockquote>
<ul>
<li><strong>代码模板</strong></li>
</ul>
<blockquote>
<p>在<code>File - &gt; Settings</code>下，找到 <code>Editor - &gt; File and Code Templates</code></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/0e67b016e8e0569649fbaa2cb35b4d24.png" alt="img"></p>
<p> 看下效果：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/4f493845694210f1c957f2146b46f451.png" alt="img"></p>
</blockquote>
<ul>
<li><strong>解释器配置</strong></li>
</ul>
<blockquote>
<p>执行Python代码必须要用到解释器，也就是用到的python版本。</p>
<p>可以在<code>Fiel -&gt; settings</code>中的 <code>Project 项目名 - &gt; Project Interpreter</code>中进行设置，如下图</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/0daf8e33a814968a620032c99c1a485c.png" alt="img"></p>
<p> **注：**如果安装多个版本，就可以在这里进行选择</p>
</blockquote>
<ul>
<li>python文件默认编码</li>
</ul>
<blockquote>
<p>可以在File -&gt; Editor -&gt; File Encodings -&gt; Global Encoding和Project Encoding选择需要的字符编码。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/6727a0122e35583ea66bfa1b7d5b03ba.png" alt="img"></p>
<p> **注：**通常会使用UTF-8编码</p>
</blockquote>
<h3 id="（2）PyCharm快捷键的使用"><a href="#（2）PyCharm快捷键的使用" class="headerlink" title="（2）PyCharm快捷键的使用"></a>（2）PyCharm快捷键的使用</h3><blockquote>
<p>常用的几个快捷键：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">折叠</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Ctrl -: 折叠当前代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Ctrl +: 展开当前代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Ctrl Shift -: 折叠所有代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Ctrl Shift +: 展开所有代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">移动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Shift+Enter: 在行中间执行时，智能跳到下一行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Ctrl+Alt+Enter: 向上插入一行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注释</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Ctrl /: 注释、取消注释行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">编辑</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Ctrl + D: 未选中时，复制当前行到下一行，选中时复制粘贴选中部分。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">删除</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Ctrl + Y: 删除当前行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Ctrl + Q: 查看文档</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">缩进</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Shift + Tab: 反向退格</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">替换</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Ctrl + r: 替换</span><br></pre></td></tr></table></figure></blockquote>
<h2 id="四、编写第一个Python程序"><a href="#四、编写第一个Python程序" class="headerlink" title="四、编写第一个Python程序"></a>四、编写第一个Python程序</h2><p>New Project –&gt; 创建一个新的项目</p>
<p>右键单击项目名 –&gt; new –&gt; python file –&gt; 输入hello      即可创建一个hello.py文件</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/39a2f965940db908fa03c82bcf943741.png" alt="img"></p>
<p> 编写如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 这是第一个python程序</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/b01a8112054d5fc62122daf6e0bcfaf6.png" alt="img"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Wireshark网络分析就这么简单：从一道面试题说起</title>
    <url>/2024/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B0%B1%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95%EF%BC%9A%E4%BB%8E%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%B4%E8%B5%B7/</url>
    <content><![CDATA[<h1 id="Wireshark网络分析就这么简单：从一道面试题说起"><a href="#Wireshark网络分析就这么简单：从一道面试题说起" class="headerlink" title="Wireshark网络分析就这么简单：从一道面试题说起"></a>Wireshark网络分析就这么简单：从一道面试题说起</h1><h2 id="1-实验环境配置"><a href="#1-实验环境配置" class="headerlink" title="1.实验环境配置"></a>1.实验环境配置</h2><p>注：ensp在BpingA时，A发出的回复报文是通过网关发送而不是直接发送的，本书中显示的是直接发送的，大家可以改用两台真正的虚拟机进行实验，除了这点外，其余的没有啥问题可以凑活看看</p>
<p>实验环境：华为ENSP，抓包工具Wireshark</p>
<p>ENSP学习网址（想看看一下）</p>
<p><a href="https://www.bilibili.com/video/BV1eQ4y1X78v?p=1&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">同网段与网关之间通信_哔哩哔哩_bilibili</a></p>
<p>实验配置：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240527171326803.png" alt="image-20240527171326803"></p>
<p>A主机mac：1056（为了方便只看后四位，后面也是如此表示）</p>
<p>B主机mac：20D8</p>
<p>网关mac：3d18</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">网关配置语句</span><br><span class="line"></span><br><span class="line">sys</span><br><span class="line">int vlan1</span><br><span class="line">ip add <span class="number">192</span>.<span class="number">168</span>.<span class="number">26</span>.<span class="number">2</span></span><br><span class="line"></span><br><span class="line">这时可以尝试一下 <span class="built_in">ping</span> A和B看看通不通</span><br></pre></td></tr></table></figure>

<h2 id="2-理论分析"><a href="#2-理论分析" class="headerlink" title="2.理论分析"></a>2.理论分析</h2><h3 id="A-ping-B"><a href="#A-ping-B" class="headerlink" title="A ping B"></a>A ping B</h3><ul>
<li><p><input disabled="" type="checkbox"> 
A根据自己的子网掩码判断B是否和自己属于同一子网，用自己的子网掩码与B主机的IP地址做&amp;运算，计算出B主机的网段也是192.168.26.0&#x2F;24，所以在A看来B和A属于同一网段</p>
</li>
<li><p><input disabled="" type="checkbox"> 
A在VLAN发送ARP广播询问B的Mac地址</p>
</li>
<li><p><input disabled="" type="checkbox"> 
B主机由于和A主机处于同一个交换机的同一个VLAN，所以B主机会收到A发送的ARP广播，无论B如何配置其子网掩码或路由表</p>
</li>
<li><p><input disabled="" type="checkbox"> 
那B主机会这么处理：<strong>B主机并不会再去判断A主机是否于它处于同一个网段</strong>，而直接进行ARP的单播回复，将自己的MAC地址告诉A</p>
</li>
<li><p><input disabled="" type="checkbox"> 
只要VLAN的二层转发功能正常A就可以收到B的ARP回复，从而得知了B的Mac地址</p>
</li>
<li><p><input disabled="" type="checkbox"> 
A开始构建ICMP报文并发送给B<br>源IP：192.168.26.129  目标IP：192.168.26.3<br>源Mac：1056 目标Mac：20d8</p>
</li>
<li><p><input disabled="" type="checkbox"> 
B收到A的ICMP报文，判断A是否与B处于同一网段</p>
</li>
<li><p><input disabled="" type="checkbox"> 
B通过自己的子网掩码判断出自己的网段是192.168.26.0&#x2F;27，然后通过自己的子网掩码判断A主机的网段为192.168.26.128&#x2F;27，于是B主机认为A主机和它并不处于同一个网段</p>
</li>
<li><p><input disabled="" type="checkbox"> 
B发送ARP广播询问网关的Mac地址</p>
</li>
<li><p><input disabled="" type="checkbox"> 
网关回复给B，B得知了网关的Mac地址，开始构建ICMP报文<br>源IP：192.168.26.3  目标IP：192.168.26.129<br>源Mac：20d8 目标Mac：3d18</p>
</li>
<li><p><input disabled="" type="checkbox"> 
B发送给网关，网关转发给A，自此完成了一次ping通信操作</p>
</li>
</ul>
<h3 id="B-ping-A"><a href="#B-ping-A" class="headerlink" title="B ping A"></a>B ping A</h3><ul>
<li><p><input disabled="" type="checkbox"> 
B判断A是否是同一子网，用自己的子网掩码进行运算，发现不是同一子网</p>
</li>
<li><p><input disabled="" type="checkbox"> 
B使用ARP广播询问网关的的Mac地址，网关回复B它的Mac地址</p>
</li>
<li><p><input disabled="" type="checkbox"> 
B构建ICMP报文<br>源IP是192.168.26.3，目标IP是192.168.26.129<br>源MAC是20d8 目标MAC是网关的MAC</p>
</li>
<li><p><input disabled="" type="checkbox"> 
B发送ICMP报文给网关，网关发送给A</p>
</li>
<li><p><input disabled="" type="checkbox"> 
A判断B和A是否是同一子网，用自己的子网掩码进行运算，发现是同一子网</p>
</li>
<li><p><input disabled="" type="checkbox"> 
A发ARP广播询问B的Mac地址</p>
</li>
<li><p><input disabled="" type="checkbox"> 
B直接回复A它的Mac地址，不会判断是否在同一子网</p>
</li>
<li><p><input disabled="" type="checkbox"> 
A构建回复ICMP报文直接发送给B<br>源IP是192.168.26.129 目标IP是192.168.26.3<br>源MAC是1056，目标MAC是20d8</p>
</li>
</ul>
<h2 id="3-抓包分析"><a href="#3-抓包分析" class="headerlink" title="3.抓包分析"></a>3.抓包分析</h2><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240527160021667.png" alt="image-20240527160021667"></p>
<p>右键点击选择开始抓包就可以看A的包</p>
<h3 id="A-ping-B-1"><a href="#A-ping-B-1" class="headerlink" title="A ping B"></a>A ping B</h3><h4 id="A主机的包"><a href="#A主机的包" class="headerlink" title="A主机的包"></a>A主机的包</h4><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240527182019461.png" alt="image-20240527182019461"></p>
<ol>
<li>两个ARP，A询问B的Mac，B给A进行单播回复</li>
<li>A构建ICMP报文并发送给B</li>
<li>B询问网关Mac</li>
<li>前一条ICMP超时然后重新发送</li>
<li>网关询问A主机的Mac，A回复（如果前面网关已经ping过A的话就不会有这个情况）</li>
<li>后续就是正常的重复内容</li>
</ol>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240527161237986.png" alt="image-20240527161237986"></p>
<p>B给A的ARP回复报文，源Mac就是B而不是网关，应该是走的二层交换机</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240527160535195.png" alt="image-20240527160535195"></p>
<p>这是B给A的ping回复报文，源Mac地址是网关而不是B</p>
<h4 id="B主机的包"><a href="#B主机的包" class="headerlink" title="B主机的包"></a>B主机的包</h4><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240527160750968.png" alt="image-20240527160750968"></p>
<ol>
<li>A问B的Mac，B给回复</li>
<li>收到A的ICMP，判断是否一个子网</li>
<li>不是一个子网，ARP问网关，网关回复</li>
<li>多的ICMP请求报文都是超时重发的</li>
<li>B发给网关网关发给A</li>
</ol>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240527161105833.png" alt="image-20240527161105833"></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240527161118428.png" alt="image-20240527161118428"></p>
<p>可以看到目标Mac是网关而不是A</p>
<h3 id="B-ping-A-1"><a href="#B-ping-A-1" class="headerlink" title="B ping A"></a>B ping A</h3><h4 id="B主机包"><a href="#B主机包" class="headerlink" title="B主机包"></a>B主机包</h4><p>黑色的不必理会，是正常的网络流量，不是错误</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240527182059384.png" alt="image-20240527182059384"></p>
<ol>
<li>B广播问网关的地址，网关回复</li>
<li>B封装ICMP报文</li>
<li>网关问A的Mac地址</li>
<li>B收到A的回复ICMP报文</li>
</ol>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240527172342767.png" alt="image-20240527172342767"></p>
<p>这是19条，B封装的ICMP报文，可以看到，先发给网关，网关进行转发</p>
<ul>
<li>源IP是192.168.26.3，目标IP是192.168.26.129</li>
<li>源MAC是00:bb:bb:bb:bb:bb 目标MAC是网关的MAC</li>
</ul>
<h4 id="A主机包"><a href="#A主机包" class="headerlink" title="A主机包"></a>A主机包</h4><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240527172149130.png" alt="image-20240527172149130"></p>
<ol>
<li>网关问A主机A的Mac，A主机给网关回复</li>
<li>A从网关收到B的ICMP报文，构建回复报文</li>
<li>A直接将回复报文发送给B，不经过网关</li>
</ol>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240527173320942.png" alt="image-20240527173320942"></p>
<p>第19条可以看到，ICMP请求报文由网关转发给A</p>
<h2 id="3-关键点总结"><a href="#3-关键点总结" class="headerlink" title="3.关键点总结"></a>3.关键点总结</h2><p>1.B ping A的过程是B交给网关，网关交给A，A直接回复给B </p>
<p>2.ARP回复时不会进行是否在同一子网的判断</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习实践：配置主机通过DHCP获取IP并通过域名访问web服务器</title>
    <url>/2024/06/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%EF%BC%9A%E9%85%8D%E7%BD%AE%E4%B8%BB%E6%9C%BA%E9%80%9A%E8%BF%87DHCP%E8%8E%B7%E5%8F%96IP%E5%B9%B6%E9%80%9A%E8%BF%87%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AEweb%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="计算机网络学习实践：配置主机通过DHCP获取IP并通过域名访问web服务器"><a href="#计算机网络学习实践：配置主机通过DHCP获取IP并通过域名访问web服务器" class="headerlink" title="计算机网络学习实践：配置主机通过DHCP获取IP并通过域名访问web服务器"></a>计算机网络学习实践：配置主机通过DHCP获取IP并通过域名访问web服务器</h1><p>点一点就能配置，不需要输入命令</p>
<h2 id="1-实验准备"><a href="#1-实验准备" class="headerlink" title="1.实验准备"></a>1.实验准备</h2><p><code>实验环境：</code>思科的模拟器</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240601175822178.png" alt="image-20240601175822178"></p>
<p><code>实验设备：</code></p>
<p>3个服务器，1个二层交换机（不是三层的），2个PC机，1个路由器</p>
<p><code>2个网段 </code></p>
<p>192.168.1.0     255.255.255.0 （web服务器所在网段）</p>
<p>192.168.0.0     255.255.255.0（其余所有设备）</p>
<p><code>DNS服务器</code></p>
<p>192.168.0.253  255.255.255.0</p>
<p>默认网关192.168.0.254</p>
<p><code>web服务器</code></p>
<p>192.168.1.1  255.255.255.0</p>
<p>默认网关192.168.1.254</p>
<p><code>DHCP服务器</code></p>
<p>192.168.0.252  255.255.255.0</p>
<p>默认网关192.168.0.254</p>
<p>2个PC机无需任何配置</p>
<h2 id="2-web服务器配置"><a href="#2-web服务器配置" class="headerlink" title="2.web服务器配置"></a>2.web服务器配置</h2><p>点击desktop-&gt;IP，做如下配置</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240601180205620.png" alt="image-20240601180205620"></p>
<h2 id="3-路由器配置"><a href="#3-路由器配置" class="headerlink" title="3.路由器配置"></a>3.路由器配置</h2><p>以往都是命令，这次通过图形化界面来进行</p>
<p><code>点击config-&gt;对应接口如FE0/0</code>，输入对应的IP和子网掩码，最后点击最上面的ON打开该链路</p>
<p>FE0&#x2F;0对应配置</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240601180357760.png" alt="image-20240601180357760"></p>
<p>FE1&#x2F;0对应配置</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240601180440532.png" alt="image-20240601180440532"></p>
<h2 id="4-DNS服务器配置"><a href="#4-DNS服务器配置" class="headerlink" title="4.DNS服务器配置"></a>4.DNS服务器配置</h2><p><code>1.静态配置IP</code></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240601180515577.png" alt="image-20240601180515577"></p>
<p><code>2.添加域名对应IP</code></p>
<p><code>service-&gt;DNS</code></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240601180610443.png" alt="image-20240601180610443"></p>
<p>输入web服务器网址对应域名</p>
<h2 id="5-DHCP服务器配置"><a href="#5-DHCP服务器配置" class="headerlink" title="5.DHCP服务器配置"></a>5.DHCP服务器配置</h2><p><code>1.静态IP</code></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240601180711905.png" alt="image-20240601180711905"></p>
<p><code>2.DHCP分配范围</code></p>
<p><code>service-&gt;DHCP</code></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240601180746684.png" alt="image-20240601180746684"></p>
<p>要记得写DNS服务器的IP地址，服务器不要忘记点ON开启服务</p>
<h2 id="6-PC通过DHCP获取IP"><a href="#6-PC通过DHCP获取IP" class="headerlink" title="6.PC通过DHCP获取IP"></a>6.PC通过DHCP获取IP</h2><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240601180909477.png" alt="image-20240601180909477"></p>
<p>点击<code>IP-&gt;DHCP</code>，即可获取IP</p>
<h2 id="7-发送web请求"><a href="#7-发送web请求" class="headerlink" title="7.发送web请求"></a>7.发送web请求</h2><p>点击<code>Desktop-&gt;Web Browser</code></p>
<p>在URL出输入<code>www.baidu.com</code>（web服务器域名）</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240601181116241.png" alt="image-20240601181116241"></p>
<p>出现此图说明配置成功</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习实践：DHCP跨网段动态分配IP</title>
    <url>/2024/06/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%EF%BC%9ADHCP%E8%B7%A8%E7%BD%91%E6%AE%B5%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8DIP/</url>
    <content><![CDATA[<h1 id="计算机网络学习实践：DHCP跨网段动态分配IP"><a href="#计算机网络学习实践：DHCP跨网段动态分配IP" class="headerlink" title="计算机网络学习实践：DHCP跨网段动态分配IP"></a>计算机网络学习实践：DHCP跨网段动态分配IP</h1><h2 id="1-实验准备"><a href="#1-实验准备" class="headerlink" title="1.实验准备"></a>1.实验准备</h2><p><code>实验环境：</code>思科的模拟器</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240601162112163.png" alt="image-20240601162112163"></p>
<p><code>实验设备：</code></p>
<p>1个服务器，2个二层交换机（不是三层的），4个PC机，1个路由器</p>
<p><code>三个网段 </code></p>
<p>192.168.1.0     255.255.255.0 （PC0,2所在网段）</p>
<p>192.168.2.0     255.255.255.0（PC1,3网段）</p>
<p>192.168.0.0     255.255.255.0（DHCP服务器所在网段）</p>
<p><code>DHCP服务器</code></p>
<p>192.168.0.2 255.255.255.0</p>
<p>默认网关192.168.0.1</p>
<p>4个PC机无需任何配置</p>
<h2 id="2-路由器配置"><a href="#2-路由器配置" class="headerlink" title="2.路由器配置"></a>2.路由器配置</h2><p>0，1， 7这些接口都是自己选的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">en</span><br><span class="line">config t</span><br><span class="line">interface fastEthernet 0/0</span><br><span class="line">ip address 192.168.1.1 255.255.255.0 #PC0,2的网关</span><br><span class="line">ip helper-address 192.168.0.2  #DHCP服务器的IP</span><br><span class="line">exit</span><br><span class="line">interface fastEthernet 1/0</span><br><span class="line">ip address 192.168.2.1 255.255.255.0 #PC1,3的网关</span><br><span class="line">ip helper-address 192.168.0.2  #DHCP服务器的IP</span><br><span class="line">exit</span><br><span class="line">interface fastEthernet 7/0 </span><br><span class="line">ip address 192.168.2.1 255.255.255.0 #DHCP服务器所在网关</span><br></pre></td></tr></table></figure>

<p>如果只有两个FE接口，如下图所示将其拖入即可</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-06-01%20163257.png" alt="屏幕截图 2024-06-01 163257"></p>
<h2 id="3-DHCP服务器配置"><a href="#3-DHCP服务器配置" class="headerlink" title="3.DHCP服务器配置"></a>3.DHCP服务器配置</h2><h3 id="3-1-服务器本身IP地址和默认网关"><a href="#3-1-服务器本身IP地址和默认网关" class="headerlink" title="3.1 服务器本身IP地址和默认网关"></a>3.1 服务器本身IP地址和默认网关</h3><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240601162030687.png" alt="image-20240601162030687"></p>
<h3 id="3-2-分配IP地址范围"><a href="#3-2-分配IP地址范围" class="headerlink" title="3.2 分配IP地址范围"></a>3.2 分配IP地址范围</h3><p><code>1.选中DHCP服务器</code></p>
<p><code>2.输入对应范围的默认网关，DNS服务器，子网掩码，开始分配的IP地址，可以分配的IP的数量</code></p>
<p>如下是第一个网段的IP分配</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240601154711722.png" alt="image-20240601154711722"></p>
<p>按照图中配置好后，点击Save进行保存，它的pool name能不修改就别修改</p>
<p>如下是第二个网段的IP分配，配置好后点击Add，添加第二条记录</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240601154829691.png" alt="image-20240601154829691"></p>
<h2 id="4-路由器再配置"><a href="#4-路由器再配置" class="headerlink" title="4.路由器再配置"></a>4.路由器再配置</h2><p>在路由器对应的接口已经配置过了，这里再提只是想要说明这一点的重要性，不设置这条语句不会进行IP分配</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip helper-address 192.168.0.2  #DHCP服务器的IP</span><br></pre></td></tr></table></figure>

<h2 id="5-观察结果"><a href="#5-观察结果" class="headerlink" title="5.观察结果"></a>5.观察结果</h2><p>打开PC机，点击DHCP，会进行自动IP分配</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240601164523842.png" alt="image-20240601164523842"></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240601164622199.png" alt="image-20240601164622199"></p>
<p>可以看到，PC0和PC2的分配的IP是按照顺序且都是我们在DHCP服务器里面设置好的</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240601164553933.png" alt="image-20240601164553933"></p>
<p>再对PC1,3做同样的操作后，这几者就可以相互ping通了</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习实践：模拟静态路由&amp;&amp;RIP动态路由&amp;&amp;OSPF协议</title>
    <url>/2024/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%EF%BC%9A%E6%A8%A1%E6%8B%9F%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1&amp;&amp;RIP%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1&amp;&amp;OSPF%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="计算机网络学习实践：模拟静态路由-RIP动态路由-OSPF协议"><a href="#计算机网络学习实践：模拟静态路由-RIP动态路由-OSPF协议" class="headerlink" title="计算机网络学习实践：模拟静态路由&amp;&amp;RIP动态路由&amp;&amp;OSPF协议"></a>计算机网络学习实践：模拟静态路由&amp;&amp;RIP动态路由&amp;&amp;OSPF协议</h1><h2 id="一、模拟静态路由"><a href="#一、模拟静态路由" class="headerlink" title="一、模拟静态路由"></a>一、模拟静态路由</h2><p><a href="https://www.bilibili.com/video/BV1Qr4y1N7cH?p=84&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">084第4章 网络层–添加静态路由_哔哩哔哩_bilibili</a></p>
<h3 id="1-实验准备"><a href="#1-实验准备" class="headerlink" title="1.实验准备"></a>1.实验准备</h3><p><code>实验环境：</code>思科的模拟器</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240529203026881.png" alt="image-20240529203026881"></p>
<p><code>实验设备：</code></p>
<p>两个路由器，两个二层交换机（不是三层的），两个PC机</p>
<p><code>三个网段 </code></p>
<p>192.168.0.0     255.255.255.0 （PC0所在网段）</p>
<p>172.16.0.0     255.255.255.0（两路由器之间）</p>
<p>104.16.0.0     255.255.255.0（PC1所在网段）</p>
<p><code>PC0：</code></p>
<p>192.168.0.2     255.255.255.0    默认网关：192.168.0.1</p>
<p><code>PC1：</code></p>
<p>104.16.0.2     255.255.255.0    默认网关：104.16.0.1</p>
<p>直接将两个交换机分别和自己网段的PC机和路由器通过以太网线连接（图书第三个黑色的线），路由器之间用广域网线连接（红色闪电，带时钟的要自己配置带宽）</p>
<h3 id="2-两路由器相关配置"><a href="#2-两路由器相关配置" class="headerlink" title="2.两路由器相关配置"></a>2.两路由器相关配置</h3><p><code>Router1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">en</span><br><span class="line">config t</span><br><span class="line">interface fastEthernet 0/0    #和你自己选的接口相关，这个是PC0的网关</span><br><span class="line">ip address 192.168.0.1 255.255.255.0       #设置PC0的网关</span><br><span class="line">exit</span><br><span class="line">interface serial 2/0 		#设置两路由器之间的网段</span><br><span class="line">ip address 172.16.0.1 255.255.255.0</span><br></pre></td></tr></table></figure>

<p><code>Router2</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">en</span><br><span class="line">config t</span><br><span class="line">interface fastEthernet 0/0    #和你自己选的接口相关，这个是PC1的网关</span><br><span class="line">ip address 104.16.0.1 255.255.255.0       #设置PC1的网关</span><br><span class="line">exit</span><br><span class="line">interface serial 3/0 		#设置两路由器之间的网段</span><br><span class="line">ip address 172.16.0.2 255.255.255.0</span><br></pre></td></tr></table></figure>

<h3 id="3-现象观察"><a href="#3-现象观察" class="headerlink" title="3.现象观察"></a>3.现象观察</h3><p>此时可以用PC0 ping，发现可以ping通的有自己的网关和Router1的172.16.0.1接口，172.16.0.2ping不通，104网段就更不用说了，PC1那边也是类似</p>
<p>其实是PC1发出的数据包经过Router1到达了172.16.0.2但是172.16.0.2找不到192的网段</p>
<p>所以没办法回复ping的ICMP报文，导致ping不通，172.16.0.2pingPC0也不通（可以通过使用wireshark抓包发现这个原因）</p>
<p>这时可以发现路由器两个相连网段只能说数据能到达，并不能通信，除非是同一网段</p>
<h3 id="4-配置路由器静态路由"><a href="#4-配置路由器静态路由" class="headerlink" title="4.配置路由器静态路由"></a>4.配置路由器静态路由</h3><p>对于Router2来说，它在回复PC0的ICMP请求报文的时候会发现自己的路由表里面没有到达192.168.0.0网段的选项，所以会找不到发送地点，这时就需要配置静态路由</p>
<p><code>Router2</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config t</span><br><span class="line">ip route 192.168.0.0 255.255.255.0 172.16.0.1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">    目的网段的网络地址   目的网段掩码   对于Router1来说，要去目的网段的下一跳是那个IP地址即Router1的右边的接口地址</span></span><br></pre></td></tr></table></figure>

<p>配置好之后，可以使用<code>show ip route</code>进行查看</p>
<p>如下图所示</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240529210213372.png" alt="image-20240529210213372"></p>
<p>会发现PC0已经可以ping通172.16.0.1了</p>
<p>如果不通的话尝试输入shut和no shut，关闭然后打开</p>
<p>但是ping104网段仍旧不通，这是因为路由器1在接受到PC0的ICMP报文后，找不到104网段在哪里</p>
<p><code>Router1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config t</span><br><span class="line">ip route 104.16.0.0 255.255.255.0 172.16.0.2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">    目的网段的网络地址   目的网段掩码   对于Router1来说，要去目的网段的下一跳是那个IP地址即Router2的左边的接口地址</span></span><br></pre></td></tr></table></figure>

<p>都配置好之后，PC0和PC1即可相互通信</p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>静态路由确实感觉人工处理起来会很麻烦</p>
<p>路由器相连的两个网段只有是一个子网的情况下才能通信，否则不能</p>
<h2 id="二、模拟动态路由RIP协议"><a href="#二、模拟动态路由RIP协议" class="headerlink" title="二、模拟动态路由RIP协议"></a>二、模拟动态路由RIP协议</h2><h3 id="1-实验准备-1"><a href="#1-实验准备-1" class="headerlink" title="1.实验准备"></a>1.实验准备</h3><p><code>实验环境：</code>华为模拟器ENSP</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240529233440883.png" alt="image-20240529233440883"></p>
<p><code>实验设备：</code></p>
<p>3个路由器，3个二层交换机（不是三层的），3个PC机</p>
<p><code>5个网段 </code></p>
<p>192.168.1.0     255.255.255.0 （PC1所在网段）</p>
<p>192.168.2.0     255.255.255.0 （PC2所在网段）</p>
<p>192.168.3.0     255.255.255.0 （PC3所在网段）</p>
<p>172.0.0.0     255.255.255.0（AR4和AR5之间）</p>
<p>176.0.0.0     255.255.255.0（AR5和AR6之间）</p>
<p><code>PC1：</code></p>
<p>192.168.1.2     255.255.255.0    默认网关：192.168.1.1</p>
<p><code>PC2：</code></p>
<p>192.168.2.2     255.255.255.0    默认网关：192.168.2.1</p>
<p><code>PC3：</code></p>
<p>192.168.3.2     255.255.255.0    默认网关：192.168.3.1</p>
<p>直接将两个交换机分别和自己网段的PC机和路由器通过以太网线连接（图书第三个黑色的线），路由器之间用广域网线连接（红色闪电，带时钟的要自己配置带宽）</p>
<h3 id="2-三个路由器相关配置"><a href="#2-三个路由器相关配置" class="headerlink" title="2.三个路由器相关配置"></a>2.三个路由器相关配置</h3><p>注意：接口看你自己的ENSP上显示的什么就按照哪个选</p>
<p><code>AR4</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sys</span><br><span class="line">int GigabitEthernet 0/0/0    #这个是PC1的网关</span><br><span class="line">ip address 192.168.0.1 255.255.255.0       #设置PC1的网关</span><br><span class="line">q #退出选择另一接口</span><br><span class="line">int GigabitEthernet 0/0/1 		#设置AR4和AR5路由器之间的网段</span><br><span class="line">ip address 172.0.0.1 255.255.255.0</span><br></pre></td></tr></table></figure>

<p><code>AR5</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sys</span><br><span class="line">int GigabitEthernet 0/0/0    #设置AR4和AR5路由器之间的网段</span><br><span class="line">ip address 172.0.0.2 255.255.255.0      </span><br><span class="line">q #退出选择另一接口</span><br><span class="line">int GigabitEthernet 0/0/1    #这个是PC2的网关</span><br><span class="line">ip address 192.168.1.1 255.255.255.0       #设置PC2的网关</span><br><span class="line">q #退出选择另一接口</span><br><span class="line">int GigabitEthernet 0/0/2 		#设置AR5和AR6路由器之间的网段</span><br><span class="line">ip address 176.0.0.1 255.255.255.0</span><br></pre></td></tr></table></figure>

<p><code>AR6</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sys</span><br><span class="line">int GigabitEthernet 0/0/0    #这个是PC3的网关</span><br><span class="line">ip address 192.168.3.1 255.255.255.0       #设置PC3的网关</span><br><span class="line">q #退出选择另一接口</span><br><span class="line">int GigabitEthernet 0/0/1 		#设置AR5和AR6路由器之间的网段</span><br><span class="line">ip address 176.0.0.2 255.255.255.0</span><br></pre></td></tr></table></figure>

<p>此时，三个PC机都可以ping通自己的网关，两个相邻路由器可以相互ping通，就算配置完成</p>
<h3 id="3-RIP配置"><a href="#3-RIP配置" class="headerlink" title="3.RIP配置"></a>3.RIP配置</h3><p><code>配置方法：</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意要在[AR4]情况下，不是&lt;AR4&gt;或者某个具体接口</span></span><br><span class="line">rip</span><br><span class="line"></span><br><span class="line">network + 路由器所有直连网段的网络地址 #不需要子网掩码</span><br></pre></td></tr></table></figure>

<p><code>AR4</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rip</span><br><span class="line"></span><br><span class="line">network 192.168.1.0</span><br><span class="line">network 172.0.0.0</span><br></pre></td></tr></table></figure>

<p><code>AR5</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rip</span><br><span class="line"></span><br><span class="line">network 192.168.2.0</span><br><span class="line">network 172.0.0.0</span><br><span class="line">network 176.0.0.0</span><br></pre></td></tr></table></figure>

<p><code>AR4</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rip</span><br><span class="line"></span><br><span class="line">network 192.168.3.0</span><br><span class="line">network 176.0.0.1</span><br></pre></td></tr></table></figure>

<h3 id="4-查看结果"><a href="#4-查看结果" class="headerlink" title="4.查看结果"></a>4.查看结果</h3><h4 id="查看路由表"><a href="#查看路由表" class="headerlink" title="查看路由表"></a>查看路由表</h4><p>输入命令</p>
<p><code>dis ip routing-table</code></p>
<p>这是配置完成的Router1（AR4）的路由表信息，可以看到有3个RIP协议，通向了与AR4不直接相连的三个子网，表明配置成功</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240529233706029.png" alt="image-20240529233706029"></p>
<p>在AR5和AR6中也能看到类似的</p>
<h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>PC1 ping PC2和PC3均可成功，三者之间可以互相通信，实验完成</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240529234250374.png" alt="image-20240529234250374"></p>
<h3 id="5-可能出现的问题"><a href="#5-可能出现的问题" class="headerlink" title="5.可能出现的问题"></a>5.可能出现的问题</h3><p>在实验中如果出现了这个错误，是因为网段选的不太好</p>
<p>The network address is invalid, and the specified address must be major-n et address without any subnets.</p>
<p>这个错误提示意味着网络地址无效,并且指定的地址必须是没有子网的主网络地址。这个错误通常出现在配</p>
<p>置动态路由协议RIP时,当指定的网络地址不符合要求时会出现。在这种情况下,网络地址必须是没有子网的主网</p>
<p>络地址,不能包含任何子网。</p>
<ol>
<li>“地址必须是没有子网的主网络地址”的解释<ul>
<li>这一表述意味着所需的IP地址应该是一个没有进一步划分子网的主网络地址。换句话说，该地址应该只包含一个网络号和主机号，而没有额外的子网网络号和子网主机号。</li>
<li>在实际应用中，这通常意味着IP地址和子网掩码的组合应该使得IP地址的前部分完全代表网络号，而后部分完全代表主机号，没有额外的子网划分。</li>
</ul>
</li>
<li>示例<ul>
<li>假设一个网络的IP地址范围是192.168.1.0到192.168.1.255，子网掩码是255.255.255.0。这个范围内的所有IP地址都可以被认为是“没有子网的主网络地址”，因为它们没有进一步划分子网。</li>
<li>如果该网络使用子网掩码255.255.255.192进行划分，那么它将被分为四个子网，每个子网有不同的网络地址和主机地址范围。在这种情况下，只有这四个子网的网络地址（例如192.168.1.0、192.168.1.64、192.168.1.128和192.168.1.192）才是“没有子网的主网络地址”（在子网划分的层面上），而其他的IP地址则属于这些子网中的主机地址。</li>
</ul>
</li>
</ol>
<p>可以重新选别的符合条件的网段</p>
<h2 id="三、模拟动态路由OSPF协议"><a href="#三、模拟动态路由OSPF协议" class="headerlink" title="三、模拟动态路由OSPF协议"></a>三、模拟动态路由OSPF协议</h2><h3 id="1-实验准备-2"><a href="#1-实验准备-2" class="headerlink" title="1.实验准备"></a>1.实验准备</h3><p><code>实验环境：</code>思科的模拟器</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240530115941573.png" alt="image-20240530115941573"></p>
<p><code>实验设备：</code></p>
<p>5个路由器，3个二层交换机（不是三层的），3个PC机</p>
<p><code>8个网段 </code></p>
<p>172.16.0.0 255.255.0.0 （PC0所在网段）</p>
<p>172.17.0.0 255.255.0.0 （PC1所在网段）</p>
<p>172.18.0.0 255.255.0.0 （PC2所在网段）</p>
<p>192.168.1.0 255.255.255.0 （R2和R0）</p>
<p>192.168.2.0 255.255.255.0  （R1和R0）</p>
<p>192.168.3.0 255.255.255.0 （R1和R4）</p>
<p>192.168.4.0 255.255.255.0 （R3和R0）</p>
<p>192.168.5.0 255.255.255.0 （R3和R4）</p>
<p><code>PC0：</code></p>
<p>172.16.0.2  255.255.0.0   默认网关：172.16.0.1</p>
<p><code>PC1：</code></p>
<p>172.17.0.2  255.255.0.0   默认网关：172.17.0.1</p>
<p><code>PC2：</code></p>
<p>172.18.0.2  255.255.0.0   默认网关：172.18.0.1</p>
<p>直接将两个交换机分别和自己网段的PC机和路由器通过以太网线连接（图书第三个黑色的线），路由器之间用广域网线连接（红色闪电，带时钟的要自己配置带宽）</p>
<p>如果Serial接口不够的话要去自己加接口，如图所示<img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-05-30%20105437.png" alt="屏幕截图 2024-05-30 105437"></p>
<h3 id="2-五个路由器相关配置"><a href="#2-五个路由器相关配置" class="headerlink" title="2.五个路由器相关配置"></a>2.五个路由器相关配置</h3><p><code>no sh</code> </p>
<p>使用该命令确保是打开状态不然IP地址加不上，就是图中必须全是绿点</p>
<p><code>Router2</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">en</span><br><span class="line">config t</span><br><span class="line">interface fastEthernet 0/0    #和你自己选的接口相关，这个是PC0的网关</span><br><span class="line">no sh #确保是打开状态不然IP地址加不上</span><br><span class="line">ip address 172.16.0.1 255.255.0.0       #设置PC0的网关</span><br><span class="line">exit</span><br><span class="line">interface serial 2/0 		#设置两路由器之间的网段 2和0</span><br><span class="line">no sh #确保是打开状态不然IP地址加不上</span><br><span class="line">ip address 192.168.1.1 255.255.255.0</span><br></pre></td></tr></table></figure>

<p><code>Router3</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">en</span><br><span class="line">config t</span><br><span class="line">interface fastEthernet 0/0    #和你自己选的接口相关，这个是PC0的网关</span><br><span class="line">ip address 172.17.0.1 255.255.0.0       #设置PC0的网关</span><br><span class="line">exit</span><br><span class="line">interface serial 2/0 		#设置两路由器之间的网段 3和0</span><br><span class="line">ip address 192.168.4.2 255.255.255.0</span><br><span class="line">exit</span><br><span class="line">interface serial 3/0 		#设置两路由器之间的网段 3和4</span><br><span class="line">ip address 192.168.5.1 255.255.255.0</span><br></pre></td></tr></table></figure>

<p><code>Router4</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">en</span><br><span class="line">config t</span><br><span class="line">interface fastEthernet 0/0    #和你自己选的接口相关，这个是PC0的网关</span><br><span class="line">ip address 172.18.0.1 255.255.0.0       #设置PC0的网关</span><br><span class="line">exit</span><br><span class="line">interface serial 2/0 		#设置两路由器之间的网段 3和4</span><br><span class="line">ip address 192.168.5.2 255.255.255.0</span><br><span class="line">exit</span><br><span class="line">interface serial 3/0 		#设置两路由器之间的网段 1和4</span><br><span class="line">ip address 192.168.3.2 255.255.255.0</span><br></pre></td></tr></table></figure>

<p><code>Router0</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">en</span><br><span class="line">config t</span><br><span class="line">interface serial 3/0 		#设置两路由器之间的网段 2和0</span><br><span class="line">ip address 192.168.1.2 255.255.255.0</span><br><span class="line">exit</span><br><span class="line">interface serial 6/0 		#设置两路由器之间的网段 3和0</span><br><span class="line">ip address 192.168.4.1 255.255.255.0</span><br><span class="line">exit</span><br><span class="line">interface serial 2/0 		#设置两路由器之间的网段 1和0</span><br><span class="line">ip address 192.168.2.1 255.255.255.0</span><br></pre></td></tr></table></figure>

<p><code>Router1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">en</span><br><span class="line">config t</span><br><span class="line">interface serial 3/0 		#设置两路由器之间的网段 1和0</span><br><span class="line">ip address 192.168.2.2 255.255.255.0</span><br><span class="line">exit</span><br><span class="line">interface serial 2/0 		#设置两路由器之间的网段 1和4</span><br><span class="line">ip address 192.168.3.1 255.255.255.0</span><br></pre></td></tr></table></figure>

<p>相邻路由器之间可以ping通，网关和PC可以ping通才算配置完成</p>
<h3 id="3-OSPF配置"><a href="#3-OSPF配置" class="headerlink" title="3.OSPF配置"></a>3.OSPF配置</h3><p>关键部分</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">指定ospf协议 1代表进程号</span></span><br><span class="line">router ospf 1 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">        路由器直连网段    子网掩码的反码   自治区域</span> </span><br><span class="line">network   172.16.0.0    0.0.255.255      area 0</span><br></pre></td></tr></table></figure>

<p><code>R2</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config t</span><br><span class="line">router ospf 1</span><br><span class="line">network 172.16.0.0 0.0.255.255 area 0</span><br><span class="line">network 192.168.1.0 0.0.0.255 area 0</span><br></pre></td></tr></table></figure>

<p><code>R0</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config t</span><br><span class="line">router ospf 1</span><br><span class="line">network 192.168.1.0 0.0.0.255 area 0</span><br><span class="line">network 192.168.2.0 0.0.0.255 area 0</span><br><span class="line">network 192.168.4.0 0.0.0.255 area 0</span><br></pre></td></tr></table></figure>

<p><code>R1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config t</span><br><span class="line">router ospf 1</span><br><span class="line">network 192.168.2.0 0.0.0.255 area 0</span><br><span class="line">network 192.168.3.0 0.0.0.255 area 0</span><br></pre></td></tr></table></figure>

<p><code>R4</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config t</span><br><span class="line">router ospf 1</span><br><span class="line">network 172.18.0.0 0.0.255.255 area 0</span><br><span class="line">network 192.168.3.0 0.0.0.255 area 0</span><br><span class="line">network 192.168.5.0 0.0.0.255 area 0</span><br></pre></td></tr></table></figure>

<p><code>R3</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config t</span><br><span class="line">router ospf 1</span><br><span class="line">network 172.17.0.0 0.0.255.255 area 0</span><br><span class="line">network 192.168.4.0 0.0.0.255 area 0</span><br><span class="line">network 192.168.5.0 0.0.0.255 area 0</span><br></pre></td></tr></table></figure>

<h3 id="4-查看结果-1"><a href="#4-查看结果-1" class="headerlink" title="4.查看结果"></a>4.查看结果</h3><h4 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h4><p>在R2上使用<code>show ip route</code>得到如下结果算OSPF配置完成</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240530122908779.png" alt="image-20240530122908779"></p>
<p>一共有8个网段，全部学习到了</p>
<p>其实 O代表OSPF协议，110是管理距离，代表优先级，这个值越小越好</p>
<p>RIP协议是120，，静态路由是1，OSPF比RIP更可信，静态路由最可信</p>
<p>129,193这些是度量值，算出来的</p>
<h4 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h4><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240530123629574.png" alt="image-20240530123629574"></p>
<p>说明 PC0 ping 1&amp;&amp;2 都是通的</p>
<h4 id="tracert"><a href="#tracert" class="headerlink" title="tracert"></a>tracert</h4><p>跟踪 0 ping 1 过程</p>
<p>走的是 R2 R0 R3这条路</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240530123955143.png" alt="image-20240530123955143"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>IP，网络地址，主机地址，网络号，子网号，主机号定义、相互关系及其计算</title>
    <url>/2024/05/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%EF%BC%8C%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%EF%BC%8C%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%BD%91%E7%BB%9C%E5%8F%B7%EF%BC%8C%E5%AD%90%E7%BD%91%E5%8F%B7%EF%BC%8C%E4%B8%BB%E6%9C%BA%E5%8F%B7%E5%AE%9A%E4%B9%89%E3%80%81%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB%E5%8F%8A%E5%85%B6%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="IP，网络地址，主机地址，网络号，子网号，主机号定义、相互关系及其计算"><a href="#IP，网络地址，主机地址，网络号，子网号，主机号定义、相互关系及其计算" class="headerlink" title="IP，网络地址，主机地址，网络号，子网号，主机号定义、相互关系及其计算"></a>IP，网络地址，主机地址，网络号，子网号，主机号定义、相互关系及其计算</h1><h3 id="1-IP定义"><a href="#1-IP定义" class="headerlink" title="1.IP定义"></a>1.IP定义</h3><p>IP地址由32个bit组成</p>
<p>每隔8位作为一个整体，得到IP地址</p>
<p>例如192.168.129.10</p>
<h3 id="2-IP，网络地址，主机地址，网络号，子网号，主机号的关系"><a href="#2-IP，网络地址，主机地址，网络号，子网号，主机号的关系" class="headerlink" title="2.IP，网络地址，主机地址，网络号，子网号，主机号的关系"></a>2.IP，网络地址，主机地址，网络号，子网号，主机号的关系</h3><p>网络地址通常指的是标识一个特定网络的IP地址。在子网划分的情况下，网络地址通常是<strong>子网掩码与子网中第一个可用IP地址的按位与运算结果</strong>。这个地址在子网中通常是不可分配给主机的，因为它代表了整个子网。</p>
<p>IP地址由网络号和主机号组成。在没有划分子网的情况下，IP地址的前半部分代表网络号，后半部分代表主机号。但是，当网络被划分子网后，IP地址的组成变为网络号、子网网络号和子网主机号。</p>
<p>IP&#x3D;网络地址+主机地址</p>
<p>IP&#x3D;网络号+主机号</p>
<p>划分子网后</p>
<p>IP地址组成变为网络号，子网网络号，子网主机号</p>
<p>经常看到<code>IP/数字</code>的样式，例如192.168.129.10&#x2F;24</p>
<p>这是说明</p>
<ol>
<li>IP的32位的子网掩码的前24位都是1，其余都是0</li>
<li>IP的前24位为网络地址也为网络号，剩余的8位是主机号</li>
</ol>
<h3 id="3-子网号的定义和子网划分"><a href="#3-子网号的定义和子网划分" class="headerlink" title="3.子网号的定义和子网划分"></a>3.子网号的定义和子网划分</h3><p>例如IP地址<code>195.169.20.50</code>和子网掩码<code>255.255.255.224</code>所代表的子网进一步划分子网，我们可以按照以下步骤计算新的子网号：</p>
<ol>
<li>理解当前子网<ul>
<li>当前子网掩码<code>255.255.255.224</code>转换为二进制是<code>11111111.11111111.11111111.11100000</code>，这意味着前27位是网络部分（包括子网部分），后5位是主机部分。</li>
<li>当前子网可以容纳的主机数量是2^5 - 2 &#x3D; 30台（减去网络地址和广播地址）。</li>
</ul>
</li>
<li>确定进一步划分的子网数<ul>
<li>假设我们想要将当前子网划分为4个子网。这意味着我们需要从当前的主机部分中借用2位来作为新的子网部分。</li>
<li>借用2位后，新的子网掩码将是<code>255.255.255.240</code>（二进制为<code>11111111.11111111.11111111.11110000</code>），前29位是网络部分（包括子网部分），后3位是主机部分。</li>
</ul>
</li>
<li>计算新的子网号<ul>
<li>新的子网号将基于原始的网络号（或称为“超级网”的网络号）和新的子网部分。</li>
<li>由于原始网络号是<code>195.169.20.32</code>（二进制为<code>11000011.10101001.00010100.00100000</code>），当我们从主机部分借用2位作为新的子网部分时，可以得到4个不同的子网号。</li>
</ul>
</li>
<li>列出新的子网号<ul>
<li>对于每个新的子网，我们将原始网络号的主机部分的前两位设置为00、01、10或11，以表示4个不同的子网。</li>
<li><strong>子网1</strong>：<code>195.169.20.32</code>（二进制<code>...000000</code>，即不变）</li>
<li><strong>子网2</strong>：<code>195.169.20.48</code>（二进制<code>...010000</code>）</li>
<li><strong>子网3</strong>：<code>195.169.20.64</code>（二进制<code>...100000</code>）</li>
<li><strong>子网4</strong>：<code>195.169.20.80</code>（二进制<code>...110000</code>）</li>
</ul>
</li>
<li>验证和归纳<ul>
<li>每个新的子网现在都有一个新的子网掩码<code>255.255.255.240</code>，并且每个子网可以容纳的主机数量是2^3 - 2 &#x3D; 6台（减去网络地址和广播地址）。</li>
<li>当我们从主机部分借用位来创建新的子网时，每个新的子网中的可用主机数量会<strong>减少</strong>（广播地址和网络地址），但我们可以获得更多的子网。</li>
</ul>
</li>
</ol>
<h3 id="4-IP常见计算"><a href="#4-IP常见计算" class="headerlink" title="4.IP常见计算"></a>4.IP常见计算</h3><h5 id="1、网络号"><a href="#1、网络号" class="headerlink" title="1、网络号"></a>1、网络号</h5><p>公式：将IP地址的二进制和子网掩码的二进制进行“&amp;”（and）运算，得到的结果就是网络号。“&amp;运算”的规则是1&amp;1&#x3D;1，0&amp;1&#x3D;0，1&amp;0&#x3D;0,0&amp;0&#x3D;0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ip:        <span class="number">10101100.00011111</span><span class="number">.10000000</span><span class="number">.11111111</span>  </span><br><span class="line"></span><br><span class="line">子网掩码:　　<span class="number">11111111.11111111</span><span class="number">.11000000</span><span class="number">.00000000</span></span><br><span class="line">----------------------------------------------------</span><br><span class="line">网络号:     <span class="number">10101100.00011111</span><span class="number">.10000000</span><span class="number">.00000000</span>   &amp;　</span><br><span class="line">网络号点分法表示: <span class="number">172.31</span><span class="number">.128</span><span class="number">.0</span>   </span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<h5 id="2、主机号"><a href="#2、主机号" class="headerlink" title="2、主机号"></a>2、主机号</h5><p>公式：用IP地址的二进制和（子网掩码的二进制的反码）进行“&amp;”运算，得到的结果就是主机号。反码就是将原本是0的变为1，原本是1的变为0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ip:           <span class="number">10101100.00011111</span><span class="number">.10000000</span><span class="number">.11111111</span>  </span><br><span class="line"></span><br><span class="line">子网掩码取反:　　<span class="number">00000000.00000000</span><span class="number">.00111111</span><span class="number">.11111111</span></span><br><span class="line">----------------------------------------------------</span><br><span class="line">主机号:        <span class="number">00000000.00000000</span><span class="number">.00000000</span><span class="number">.11111111</span>   &amp;　</span><br><span class="line">主机号点分法表示: <span class="number">0.0</span><span class="number">.0</span><span class="number">.255</span> </span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<h5 id="3、广播地址"><a href="#3、广播地址" class="headerlink" title="3、广播地址"></a>3、广播地址</h5><p>公式：在得到网络号的基础上，将网络号右边的表示IP地址的主机部分的二进制位全部填上1，再将得到的二进制数转换为十进制数就可以得到广播地址。因为本题中子网掩码是11111111.11111111.11000000.00000000， 0有14个，主机位是14，我们将网络号172.31.128.0，转换为二进制是 10101100.00011111.10000000.00000000，从右边数起，将14个0全部替换为1， 即：10101100.00011111.10111111.11111111，这就是这个子网的广播地址的二进制表示法。将这个二进制广播地址转换为十进制就是<br>172.31.191.255</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">网络号:     <span class="number">10101100.00011111</span><span class="number">.10000000</span><span class="number">.00000000</span></span><br><span class="line"></span><br><span class="line">子网掩码:　　<span class="number">11111111.11111111</span><span class="number">.11000000</span><span class="number">.00000000</span></span><br><span class="line">----------------------------------------------------</span><br><span class="line">广播地址:   <span class="number">10101100.00011111</span><span class="number">.10111111</span><span class="number">.11111111</span>   网络号从右向左<span class="number">0</span>填为<span class="number">1</span>，个数为掩码中的<span class="number">0</span></span><br><span class="line">广播地址点分法表示: <span class="number">172.31</span><span class="number">.191</span><span class="number">.255</span></span><br></pre></td></tr></table></figure>

<h5 id="4、可用IP地址范围"><a href="#4、可用IP地址范围" class="headerlink" title="4、可用IP地址范围"></a>4、可用IP地址范围</h5><p>因为网络号是172.31.128.0，广播地址是172.31.191.255，所以子网中可用的IP地址范围就是从网络号+1 ~广播地址-1，所以子网中的可用IP地址范围就是从<strong>172.31.128.1-172.31.191.254</strong>。</p>
<h5 id="5、子网数目"><a href="#5、子网数目" class="headerlink" title="5、子网数目"></a>5、子网数目</h5><p>首先将&#x2F;18换成为我们习惯的表示法:11111111.11111111.11000000.000000转为十进制就是255.255.192.0，可以看到这个掩码的左边两节和B类默认掩码是一致的，所以这个掩码是在B类默认掩码的范围内，意味着我们将对B类大网进行子网划分。B类掩码默类是用16位(16个0)来表示可分配的IP 地址，这里的掩码在B类默认掩码的基础上多出了两个表示网络号的1，也就是向主机位借了两个1这就是说是将B类大网划分为2的2次方个子网(2^n,n表示所借1的个数)，所以最终的子网数目是4</p>
<h5 id="6、如何根据IP和子网掩码判断两个IP是否属于同一子网"><a href="#6、如何根据IP和子网掩码判断两个IP是否属于同一子网" class="headerlink" title="6、如何根据IP和子网掩码判断两个IP是否属于同一子网"></a>6、如何根据IP和子网掩码判断两个IP是否属于同一子网</h5><ol>
<li><strong>获取设备的IP地址和子网掩码</strong>：首先，我们需要知道两个设备的IP地址和它们各自的子网掩码。</li>
<li><strong>转换为二进制表示</strong>：将两个IP地址和它们的子网掩码都转换为二进制形式。</li>
<li><strong>执行按位与操作</strong>：将每个IP地址与其对应的子网掩码进行按位与操作。按位与运算的规则是：两个相应位都为1时，结果为1；否则为0。</li>
<li><strong>比较结果</strong>：如果两个设备的按位与结果相同，则它们属于同一子网。</li>
</ol>
<h5 id="7、如何通过IP和子网掩码确定这个IP所属于的子网的寻址范围"><a href="#7、如何通过IP和子网掩码确定这个IP所属于的子网的寻址范围" class="headerlink" title="7、如何通过IP和子网掩码确定这个IP所属于的子网的寻址范围"></a>7、如何通过IP和子网掩码确定这个IP所属于的子网的寻址范围</h5><ol>
<li><strong>确定子网地址</strong>：将IP地址和子网掩码进行按位与操作，得到的结果就是子网地址。子网地址是子网中所有IP地址的公共部分。</li>
<li><strong>计算子网内主机数量</strong>：子网掩码中的0位代表主机位。通过计算子网掩码中0的位数，可以确定子网内可以分配的主机数量（注意要减去网络地址和广播地址）。</li>
<li><strong>确定子网范围</strong>：基于子网地址和子网内主机数量，可以确定子网的IP范围。通常，子网范围的起始地址是子网地址，结束地址是子网地址加上子网内主机数量减1（因为要减去广播地址）。</li>
</ol>
<p>以IP地址192.168.210.181和子网掩码255.255.224.0为例：</p>
<ul>
<li><strong>确定子网地址</strong>：将IP地址和子网掩码转换为二进制并执行按位与操作，得到子网地址192.168.192.0。</li>
<li><strong>计算子网内主机数量</strong>：子网掩码中有9位是0（即2^9&#x3D;512），但由于要减去网络地址和广播地址，所以实际可用主机数为510。</li>
<li><strong>确定子网范围</strong>：子网范围是192.168.192.0到192.168.223.255。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络实践：模拟PPP协议&amp;&amp;验证虚拟局域网（VLAN）</title>
    <url>/2024/05/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%EF%BC%9A%E6%A8%A1%E6%8B%9FPPP%E5%8D%8F%E8%AE%AE&amp;&amp;%E9%AA%8C%E8%AF%81%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91%EF%BC%88VLAN%EF%BC%89/</url>
    <content><![CDATA[<h1 id="计算机网络实践：模拟PPP协议-验证虚拟局域网（VLAN）"><a href="#计算机网络实践：模拟PPP协议-验证虚拟局域网（VLAN）" class="headerlink" title="计算机网络实践：模拟PPP协议&amp;&amp;验证虚拟局域网（VLAN）"></a>计算机网络实践：模拟PPP协议&amp;&amp;验证虚拟局域网（VLAN）</h1><h2 id="一、模拟PPP协议"><a href="#一、模拟PPP协议" class="headerlink" title="一、模拟PPP协议"></a>一、模拟PPP协议</h2><p>实验环境：思科模拟器</p>
<p>FastEthernet是以太网接口，serial是广域网接口，连的线也不同</p>
<p>主要用到的就是RouterA和RouterB</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240529114849346.png" alt="image-20240529114849346"></p>
<p>路由器连接注意：</p>
<p>一台路由器的serial 2&#x2F;0连接另外一台的 serial 3&#x2F;0，这台的2&#x2F;0去连接下一台的3&#x2F;0，交错开来</p>
<h2 id="1-配置路由器接口IP地址："><a href="#1-配置路由器接口IP地址：" class="headerlink" title="1.配置路由器接口IP地址："></a>1.配置路由器接口IP地址：</h2><p>Router0（RouterA）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">en</span><br><span class="line">configure t     //进入特权模式</span><br><span class="line">hostname RouterA //重命名 配置身份验证的时候用</span><br><span class="line">interface serial 2/0</span><br><span class="line">clock rate 64000   //时钟频率 设置带宽，控制网速的</span><br><span class="line">ip address 172.16.1.1 255.255.255.0</span><br><span class="line">no shutdown</span><br></pre></td></tr></table></figure>

<p>Router1（RouterB）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">en</span><br><span class="line">configure t     //进入特权模式</span><br><span class="line">interface serial 2/0</span><br><span class="line">clock rate 64000   //时钟频率 设置带宽，控制网速的</span><br><span class="line">ip address 172.16.1.1 255.255.255.0</span><br><span class="line">no shutdown</span><br></pre></td></tr></table></figure>

<h2 id="2-检查是否通信"><a href="#2-检查是否通信" class="headerlink" title="2.检查是否通信"></a>2.检查是否通信</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Router1 ping 172.16.1.1</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240529110909866.png" alt="image-20240529110909866"></p>
<p>如图所示则为成功</p>
<h2 id="3-广域网封装"><a href="#3-广域网封装" class="headerlink" title="3.广域网封装"></a>3.广域网封装</h2><p>使得HDLC改为PPP协议</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show interface serial 2/0   查看当前接口协议</span><br></pre></td></tr></table></figure>

<p>下面第五行的Encapsulation 就是使用的协议</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config t</span><br><span class="line">interface serial 2/0</span><br><span class="line">encapsulation ?   //查看协议</span><br><span class="line">encapsulation ppp//选择PPP</span><br></pre></td></tr></table></figure>

<p>注意：两个相连的路由器要用相同的协议，要用PPP都用PPP</p>
<p>改完协议要让两个路由器还是可以ping通才行</p>
<h2 id="4-PPP协议的身份验证功能"><a href="#4-PPP协议的身份验证功能" class="headerlink" title="4.PPP协议的身份验证功能"></a>4.PPP协议的身份验证功能</h2><p><code>秘钥：darling</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//RouterA</span><br><span class="line">config t</span><br><span class="line">username RouterB password darling //A和B的共享密钥</span><br><span class="line">interface serial 2/0</span><br><span class="line">ppp authentication chap //设置身份验证方式为chap</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//RouterB</span><br><span class="line">config t</span><br><span class="line">username RouterA password darling //A和B的共享密钥</span><br><span class="line">interface serial 3/0</span><br><span class="line">ppp authentication chap //设置身份验证方式为chap</span><br></pre></td></tr></table></figure>

<p>此时两者还可以ping通</p>
<p>将B的密钥修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">no username RouterA password darling</span><br><span class="line">username RouterA password dddd</span><br><span class="line">interface serial 3/0</span><br><span class="line">sh//关闭</span><br><span class="line">no sh//开启</span><br></pre></td></tr></table></figure>

<p>此时发现两者就ping不通了，就是密钥对不上</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240529114955346.png" alt="image-20240529114955346"></p>
<p>时不时出现的这句话表达的意思就是连接可以不可以连接上，up就是可以，down就是不行</p>
<h2 id="二、验证虚拟局域网（VLAN）"><a href="#二、验证虚拟局域网（VLAN）" class="headerlink" title="二、验证虚拟局域网（VLAN）"></a>二、验证虚拟局域网（VLAN）</h2><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240529124555555.png" alt="image-20240529124555555"></p>
<h2 id="1-实验环境："><a href="#1-实验环境：" class="headerlink" title="1.实验环境："></a>1.实验环境：</h2><p>交换机：</p>
<p>1接口 PC0</p>
<p>2接口 PC1</p>
<p>13接口 PC2</p>
<p>14接口 PC3</p>
<p>PC 0：192.168.1.2   255.255.255.0</p>
<p>PC 1：192.168.1.3   255.255.255.0</p>
<p>PC 2：192.168.1.4   255.255.255.0</p>
<p>PC 3：192.168.1.5   255.255.255.0</p>
<p>此时全都可以相互ping通，因为交换机默认24个接口全都是一个VLAN</p>
<p>现在将1-12接口和13-24接口划分为两个VLAN，即PC0和1是一个VLAN，2和3是一个VLAN</p>
<h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>证明即使在一个网段，不同的VLAN的主机也不能相互通信</p>
<h2 id="2-交换机分成两个VLAN配置"><a href="#2-交换机分成两个VLAN配置" class="headerlink" title="2.交换机分成两个VLAN配置"></a>2.交换机分成两个VLAN配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">en</span><br><span class="line">config t</span><br><span class="line">vlan 2 //创建vlan2</span><br><span class="line">ctrl+z //退出</span><br><span class="line">config t</span><br><span class="line">interface range fastEthernet 0/13-24</span><br><span class="line">?</span><br><span class="line">switchport access vlan 2</span><br><span class="line"></span><br><span class="line">show vlan//查看</span><br></pre></td></tr></table></figure>

<p><code>PC0 ping PC1 &amp;&amp; PC2</code></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20240529125744093.png" alt="image-20240529125744093"></p>
<p>可以看到PC0和PC1可以通信，PC0和PC2不能通信</p>
<p>即验证了两个VLAN中即使是同网段也不能通信</p>
<p>&#x2F;&#x2F;本来想上源文件，发现放上以后竟然只有VIP才能看。。。遂放弃</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>修改成清华镜像源解决Anaconda报The channel is not accessible源通道不可用问题</title>
    <url>/2024/12/28/%E5%AD%A6%E6%A0%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E4%BF%AE%E6%94%B9%E6%88%90%E6%B8%85%E5%8D%8E%E9%95%9C%E5%83%8F%E6%BA%90%E8%A7%A3%E5%86%B3Anaconda%E6%8A%A5The%20channel%20is%20not%20accessible%E6%BA%90%E9%80%9A%E9%81%93%E4%B8%8D%E5%8F%AF%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="修改成清华镜像源解决Anaconda报The-channel-is-not-accessible源通道不可用问题"><a href="#修改成清华镜像源解决Anaconda报The-channel-is-not-accessible源通道不可用问题" class="headerlink" title="修改成清华镜像源解决Anaconda报The channel is not accessible源通道不可用问题"></a>修改成清华镜像源解决Anaconda报The channel is not accessible源通道不可用问题</h1><p>最近在通过pycharm开发python程序，引用anaconda环境建立<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83&spm=1001.2101.3001.7020">虚拟环境</a>时报错，报UnavailableInvalidChannel: The channel is not accessible or is invalid.应该是镜像源访问通道无法访问或无效。现将解决办法记录如下：</p>
<h2 id="环境说明："><a href="#环境说明：" class="headerlink" title="环境说明："></a>环境说明：</h2><p>操作系统：win10<br>安装有anaconda 4.10.3<br>pycharm2021.2</p>
<h2 id="报错现象："><a href="#报错现象：" class="headerlink" title="报错现象："></a>报错现象：</h2><p>在pycharm中新建python项目，引用anaconda建立虚拟环境时报错<br>报“UnavailableInvalidChannel: The channel is not accessible or is invalid.”<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/5d1d36b52467d70057624fb4ce4cb881.png" alt="建立虚拟环境报错"></p>
<p>或者执行命令遇到这种情况</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241228184438449.png" alt="image-20241228184438449"></p>
<h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><h3 id="1、找到anaconda的源配置文件"><a href="#1、找到anaconda的源配置文件" class="headerlink" title="1、找到anaconda的源配置文件"></a>1、找到anaconda的源配置文件</h3><p><strong>配置文件.condar.c一般都在c&#x2F;user&#x2F;用户名这个目录里面</strong></p>
<p>根据报错的建议提示：</p>
<blockquote>
<p>You will need to ajust your conda configuration to proceed.<br>Use ‘cona config –show channels’ to view your configuration’s current state,<br>and use ‘conda config –show-sources’ to view config file location.</p>
</blockquote>
<p>意思是建议你需要调整conda的配置来处理，可以通过<code>cona config --show channels</code>命令来查看你当前的配置状态，可以用<code>conda config --show-sources</code>看查看本地的配置文件。<br>根据这个建议，打开anaconda的命令行控制台。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/8eaf327208a326db79614cd62661c4d5.png" alt="Anaconda Powershell"></p>
<p>敲入“conda config –show-sources”命令，显示当前的通道为<a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> 报错就是说这个通道无法访问或无效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS C:\Users\xiejava&gt; conda config --show channels</span><br><span class="line">channels:</span><br><span class="line">  - https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>通过“conda config –show-sources” 查看配置文件的路径。配置文件为用户目录下的<code>.condarc</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS C:\Users\xiejava&gt; conda config --show-sources</span><br><span class="line">==&gt; C:\Users\xiejava\.condarc &lt;==</span><br><span class="line">channels:</span><br><span class="line">  - https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">show_channel_urls: True</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/8c5d2cd54069bc8a923d0d1d963b496f.png" alt="在这里插入图片描述"></p>
<h3 id="2、修改为清华的镜像源"><a href="#2、修改为清华的镜像源" class="headerlink" title="2、修改为清华的镜像源"></a>2、修改为清华的镜像源</h3><p>将找到的.condarc文件打开。<br>拷贝以下清华的镜像源到该文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line">custom_channels:</span><br><span class="line">  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">default_channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span><br><span class="line">show_channel_urls: True</span><br></pre></td></tr></table></figure>

<p>然后再次运行<code>conda config --show-sources</code>，确认配置文件内容已经修改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS C:\Users\xiejava&gt; conda config --show-sources</span><br><span class="line">==&gt; C:\Users\xiejava\.condarc &lt;==</span><br><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line">custom_channels:</span><br><span class="line">  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">default_channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span><br><span class="line">show_channel_urls: True</span><br></pre></td></tr></table></figure>

<p><strong>修改后的condarc</strong></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241228184659429.png" alt="image-20241228184659429"></p>
<h3 id="3、验证"><a href="#3、验证" class="headerlink" title="3、验证"></a>3、验证</h3><p>再打开pycharm引用Conda Enviroment新建新的虚拟环境。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/16d66fb4bedda5e72e366f84a8584d5d.png" alt="新建新的虚拟环境"><br>这时不报错可以正常创建Conda虚拟环境了。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/0859ffc1569c2fe6e4211f72c8a4f548.png" alt="创建Conda Environment"></p>
<p>使用命令行也可以创建了</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241228184604467.png" alt="image-20241228184604467"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>泰坦尼克号生存的预测任务</title>
    <url>/2024/12/30/%E5%AD%A6%E6%A0%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E7%94%9F%E5%AD%98%E7%9A%84%E9%A2%84%E6%B5%8B%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="泰坦尼克号生存的预测任务"><a href="#泰坦尼克号生存的预测任务" class="headerlink" title="泰坦尼克号生存的预测任务"></a>泰坦尼克号生存的预测任务</h1><p>学校作业，我来水一水</p>
<p>环境：pycharm+anaconda虚拟环境</p>
<h2 id="0-环境搭建参考："><a href="#0-环境搭建参考：" class="headerlink" title="0.环境搭建参考："></a>0.环境搭建参考：</h2><p><a href="https://blog.csdn.net/m0_74795952/category_12866393.html?spm=1001.2014.3001.5482">学校机器学习_为了前进而后退，为了走直路而走弯路的博客-CSDN博客</a></p>
<h2 id="1-目的与要求"><a href="#1-目的与要求" class="headerlink" title="1 目的与要求"></a>1 目的与要求</h2><p>（1）目的： 本任务旨在使用机器学习算法预测泰坦尼克号乘客的生存情况。根据乘客的个人信息（如年龄、性别、船舱等级等），使用合适的模型来判断该乘客是否在事故中幸存。模型将对给定的测试集进行预测，并生成预测结果。<br>（2）采用不同的机器学习算法进行建模（如：决策树、朴素贝叶斯、支持向量机）。<br>对模型的性能进行评估，计算准确率。<br>对比不同模型的准确率，通过可视化手段展示结果（如准确率折线图、混淆矩阵等）。<br>输出每个模型的可视化结果并保存（如决策树的图示、特征重要性等）。</p>
<h2 id="2-任务背景"><a href="#2-任务背景" class="headerlink" title="2 任务背景"></a>2 任务背景</h2><p>泰坦尼克号（RMS Titanic）是世界历史上最著名的沉船之一，1912年4月15日沉没。在事故中，约有1500多人失去了生命。根据该事件的相关数据集（包含乘客的个人信息及生死状态），我们可以构建模型预测乘客的生存概率。数据集包含的特征有：乘客的年龄、性别、船舱等级、票价、家庭成员数量等。</p>
<h2 id="3-任务简介"><a href="#3-任务简介" class="headerlink" title="3 任务简介"></a>3 任务简介</h2><p><strong>数据集介绍：</strong><br>训练集（mytrain.csv）：包含泰坦尼克号乘客的个人信息及其是否生还的标签（Survived）。这个数据集将用于训练模型。<br>测试集（mytest.csv）：包含泰坦尼克号乘客的个人信息。这个数据集将用于模型预测，预测结果与 mygender.csv 中的标签进行比较。</p>
<p>**目标：**构建机器学习模型，预测乘客在事故中是否生还（分类任务）。<br>数据预处理：</p>
<p>**处理缺失值：**填充年龄的缺失值为平均值，填充 Embarked 的缺失值为众数，填充 Fare 的缺失值为均值。</p>
<p>特征工程：将性别特征（Sex）从字符型转化为数值型（男为0，女为1）。</p>
<p>任务目标：通过不同的机器学习算法（如决策树、朴素贝叶斯、支持向量机），对乘客生还与否进行预测，并比较其准确率。</p>
<p><strong>可视化图表</strong></p>
<p>准确率对比折线图：<br>比较三种模型（决策树、朴素贝叶斯、SVM）的准确率。<br>保存为 model_comparison_accuracy.png。<br>决策树的图示：<br>生成决策树的结构图，并保存为 decision_tree.png。<br>混淆矩阵图：<br>为每个模型生成并保存混淆矩阵图，分别为<br>decision_tree_confusion_matrix.png,naive_bayes_confusion_matrix.png, svm_confusion_matrix.png。</p>
<h2 id="4-模型介绍"><a href="#4-模型介绍" class="headerlink" title="4 模型介绍"></a>4 模型介绍</h2><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241230195502739.png" alt="image-20241230195502739"></p>
<h3 id="1-决策树（Decision-Tree）"><a href="#1-决策树（Decision-Tree）" class="headerlink" title="1.决策树（Decision Tree）"></a>1.决策树（Decision Tree）</h3><p>简介：决策树是一种树形结构的模型，适用于分类和回归任务。它通过一系列的决策规则将数据划分为不同的类别，直到满足某种停止条件。决策树模型易于理解和解释。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">关键代码：</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier, plot_tree</span><br><span class="line"></span><br><span class="line">决策树模型训练</span><br><span class="line"></span><br><span class="line">dt_model = DecisionTreeClassifier(random_state=<span class="number">42</span>)</span><br><span class="line">dt_model.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">预测</span><br><span class="line"></span><br><span class="line">dt_y_pred = dt_model.predict(X_test)</span><br><span class="line"></span><br><span class="line">绘制决策树图</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line">plot_tree(dt_model, feature_names=features, class_names=[<span class="string">&#x27;Not Survived&#x27;</span>, <span class="string">&#x27;Survived&#x27;</span>], filled=<span class="literal">True</span>, rounded=<span class="literal">True</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Decision Tree Visualization&quot;</span>)</span><br><span class="line">plt.savefig(<span class="string">&#x27;decision_tree.png&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>**模型评估：**通过 accuracy_score 计算准确率，比较实际与预测结果。</p>
<p>结果：<br><strong>准确率：0.8014</strong><br>Decision Tree_confusion_matrix.png</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/wps80.jpg" alt="img"></p>
<p>decision_tree.png<img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/wps71.jpg" alt="img"></p>
<p>feature_importance.png</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/wps62.jpg" alt="img"></p>
<h3 id="2-朴素贝叶斯（Naive-Bayes）"><a href="#2-朴素贝叶斯（Naive-Bayes）" class="headerlink" title="2.朴素贝叶斯（Naive Bayes）"></a>2.朴素贝叶斯（Naive Bayes）</h3><p>简介：朴素贝叶斯是一种基于贝叶斯定理的分类算法，适用于特征之间独立性假设成立的场景。它通过计算各类别的条件概率，选择概率最大的类别作为预测结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">关键代码：</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"></span><br><span class="line">朴素贝叶斯模型训练</span><br><span class="line"></span><br><span class="line">nb_model = GaussianNB()</span><br><span class="line">nb_model.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">预测</span><br><span class="line"></span><br><span class="line">nb_y_pred = nb_model.predict(X_test)</span><br><span class="line">模型评估：同样使用 accuracy_score 来评估朴素贝叶斯模型的准确率。</span><br></pre></td></tr></table></figure>

<p>结果：<br>准确率：0.9306<br>Naïve Bayes_confusion_matrix.png</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/wps44.jpg" alt="img"></p>
<h3 id="3-支持向量机（Support-Vector-Machine-SVM）"><a href="#3-支持向量机（Support-Vector-Machine-SVM）" class="headerlink" title="3.支持向量机（Support Vector Machine, SVM）"></a>3.支持向量机（Support Vector Machine, SVM）</h3><p>简介：支持向量机是一种基于最大间隔原则的分类模型，主要用于二分类问题。SVM通过构造一个超平面来实现分类，使得不同类别的数据点距离超平面尽可能远。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">关键代码：</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"></span><br><span class="line">支持向量机模型训练</span><br><span class="line"></span><br><span class="line">svm_model = SVC(random_state=<span class="number">42</span>)</span><br><span class="line">svm_model.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">预测</span><br><span class="line"></span><br><span class="line">svm_y_pred = svm_model.predict(X_test)</span><br></pre></td></tr></table></figure>

<p>模型评估：使用 accuracy_score 来评估SVM模型的准确率。<br>混淆矩阵： 对于每个模型，生成混淆矩阵，评估模型的精确度、召回率等。<br>准确率对比折线图： 通过 seaborn 和 matplotlib 绘制不同模型的准确率对比折线图，方便比较各算法的性能。</p>
<p><strong>代码示例：</strong></p>
<p>绘制模型准确率折线图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accuracies = [dt_accuracy, nb_accuracy, svm_accuracy]</span><br><span class="line">models = [&#x27;Decision Tree&#x27;, &#x27;Naive Bayes&#x27;, &#x27;SVM&#x27;]</span><br><span class="line">sns.lineplot(x=models, y=accuracies, marker=&#x27;o&#x27;)</span><br><span class="line">plt.title(&#x27;Model Comparison: Accuracy of Decision Tree, Naive Bayes, and SVM&#x27;)</span><br><span class="line">plt.ylabel(&#x27;Accuracy&#x27;)</span><br><span class="line">plt.savefig(&#x27;model_comparison_accuracy.png&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong><br>准确率：0.6531<br>SVM_confusion_matrix.png</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/wps32.jpg" alt="img"></p>
<p><strong>完整代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入需要的库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier, plot_tree</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score, confusion_matrix</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"></span><br><span class="line"><span class="comment">#加载数据</span></span><br><span class="line"></span><br><span class="line">train_df = pd.read_csv(<span class="string">&#x27;mytrain.csv&#x27;</span>)</span><br><span class="line">test_df = pd.read_csv(<span class="string">&#x27;mytest.csv&#x27;</span>)</span><br><span class="line">gender_df = pd.read_csv(<span class="string">&#x27;mygender.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#数据预处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#填充缺失值，删除无关列</span></span><br><span class="line"></span><br><span class="line">train_df.fillna(&#123;<span class="string">&#x27;Age&#x27;</span>: train_df[<span class="string">&#x27;Age&#x27;</span>].mean(), <span class="string">&#x27;Embarked&#x27;</span>: train_df[<span class="string">&#x27;Embarked&#x27;</span>].mode()[<span class="number">0</span>]&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line">test_df.fillna(&#123;<span class="string">&#x27;Age&#x27;</span>: test_df[<span class="string">&#x27;Age&#x27;</span>].mean(), <span class="string">&#x27;Fare&#x27;</span>: test_df[<span class="string">&#x27;Fare&#x27;</span>].mean()&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#转换性别列为数字（男=0，女=1）</span></span><br><span class="line"></span><br><span class="line">label_encoder = LabelEncoder()</span><br><span class="line">train_df[<span class="string">&#x27;Sex&#x27;</span>] = label_encoder.fit_transform(train_df[<span class="string">&#x27;Sex&#x27;</span>])</span><br><span class="line">test_df[<span class="string">&#x27;Sex&#x27;</span>] = label_encoder.transform(test_df[<span class="string">&#x27;Sex&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#特征选择 - 这里只选择了一些简单的特征</span></span><br><span class="line"></span><br><span class="line">features = [<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;Sex&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;SibSp&#x27;</span>, <span class="string">&#x27;Parch&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>]</span><br><span class="line">X_train = train_df[features]</span><br><span class="line">y_train = train_df[<span class="string">&#x27;Survived&#x27;</span>]</span><br><span class="line">X_test = test_df[features]</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建保存结果的文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_folder</span>(<span class="params">folder_name</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(folder_name):</span><br><span class="line">        os.makedirs(folder_name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化准确率对比列表</span></span><br><span class="line"></span><br><span class="line">accuracies = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#决策树模型</span></span><br><span class="line"></span><br><span class="line">dt_model = DecisionTreeClassifier(random_state=<span class="number">42</span>)</span><br><span class="line">dt_model.fit(X_train, y_train)</span><br><span class="line">dt_y_pred = dt_model.predict(X_test)</span><br><span class="line">dt_accuracy = accuracy_score(gender_df[<span class="string">&#x27;Survived&#x27;</span>], dt_y_pred)</span><br><span class="line">accuracies.append(dt_accuracy)</span><br><span class="line"></span><br><span class="line"><span class="comment">#朴素贝叶斯模型</span></span><br><span class="line"></span><br><span class="line">nb_model = GaussianNB()</span><br><span class="line">nb_model.fit(X_train, y_train)</span><br><span class="line">nb_y_pred = nb_model.predict(X_test)</span><br><span class="line">nb_accuracy = accuracy_score(gender_df[<span class="string">&#x27;Survived&#x27;</span>], nb_y_pred)</span><br><span class="line">accuracies.append(nb_accuracy)</span><br><span class="line"></span><br><span class="line"><span class="comment">#支持向量机模型</span></span><br><span class="line"></span><br><span class="line">svm_model = SVC(random_state=<span class="number">42</span>)</span><br><span class="line">svm_model.fit(X_train, y_train)</span><br><span class="line">svm_y_pred = svm_model.predict(X_test)</span><br><span class="line">svm_accuracy = accuracy_score(gender_df[<span class="string">&#x27;Survived&#x27;</span>], svm_y_pred)</span><br><span class="line">accuracies.append(svm_accuracy)</span><br><span class="line"></span><br><span class="line"><span class="comment">#可视化决策树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visualize_decision_tree</span>(<span class="params">model, folder_name</span>):</span><br><span class="line">    plt.figure(figsize=(<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line">    plot_tree(model, feature_names=features, class_names=[<span class="string">&#x27;Not Survived&#x27;</span>, <span class="string">&#x27;Survived&#x27;</span>], filled=<span class="literal">True</span>, rounded=<span class="literal">True</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;Decision Tree Visualization&quot;</span>)</span><br><span class="line">    plt.savefig(os.path.join(folder_name, <span class="string">&quot;decision_tree.png&quot;</span>))</span><br><span class="line">    plt.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#可视化混淆矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visualize_confusion_matrix</span>(<span class="params">y_true, y_pred, folder_name, model_name</span>):</span><br><span class="line">    conf_matrix = confusion_matrix(y_true, y_pred)</span><br><span class="line">    plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line">    sns.heatmap(conf_matrix, annot=<span class="literal">True</span>, fmt=<span class="string">&#x27;d&#x27;</span>, cmap=<span class="string">&#x27;Blues&#x27;</span>, xticklabels=[<span class="string">&#x27;Not Survived&#x27;</span>, <span class="string">&#x27;Survived&#x27;</span>], yticklabels=[<span class="string">&#x27;Not Survived&#x27;</span>, <span class="string">&#x27;Survived&#x27;</span>])</span><br><span class="line">    plt.title(<span class="string">f&#x27;<span class="subst">&#123;model_name&#125;</span> Confusion Matrix&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Actual&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Predicted&#x27;</span>)</span><br><span class="line">    plt.savefig(os.path.join(folder_name, <span class="string">f&quot;<span class="subst">&#123;model_name&#125;</span>_confusion_matrix.png&quot;</span>))</span><br><span class="line">    plt.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#可视化特征重要性（仅限决策树）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visualize_feature_importance</span>(<span class="params">model, folder_name</span>):</span><br><span class="line">    feature_importances = model.feature_importances_</span><br><span class="line">    sns.barplot(x=features, y=feature_importances)</span><br><span class="line">    plt.title(<span class="string">&#x27;Feature Importances - Decision Tree&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Importance&#x27;</span>)</span><br><span class="line">    plt.savefig(os.path.join(folder_name, <span class="string">&quot;feature_importance.png&quot;</span>))</span><br><span class="line">    plt.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存决策树结果</span></span><br><span class="line"></span><br><span class="line">dt_folder = <span class="string">&#x27;decision_tree_results&#x27;</span></span><br><span class="line">create_folder(dt_folder)</span><br><span class="line">visualize_decision_tree(dt_model, dt_folder)</span><br><span class="line">visualize_confusion_matrix(gender_df[<span class="string">&#x27;Survived&#x27;</span>], dt_y_pred, dt_folder, <span class="string">&#x27;Decision Tree&#x27;</span>)</span><br><span class="line">visualize_feature_importance(dt_model, dt_folder)</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存朴素贝叶斯结果</span></span><br><span class="line"></span><br><span class="line">nb_folder = <span class="string">&#x27;naive_bayes_results&#x27;</span></span><br><span class="line">create_folder(nb_folder)</span><br><span class="line">visualize_confusion_matrix(gender_df[<span class="string">&#x27;Survived&#x27;</span>], nb_y_pred, nb_folder, <span class="string">&#x27;Naive Bayes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存支持向量机结果</span></span><br><span class="line"></span><br><span class="line">svm_folder = <span class="string">&#x27;svm_results&#x27;</span></span><br><span class="line">create_folder(svm_folder)</span><br><span class="line">visualize_confusion_matrix(gender_df[<span class="string">&#x27;Survived&#x27;</span>], svm_y_pred, svm_folder, <span class="string">&#x27;SVM&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#绘制三种模型准确率的折线图</span></span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">models = [<span class="string">&#x27;Decision Tree&#x27;</span>, <span class="string">&#x27;Naive Bayes&#x27;</span>, <span class="string">&#x27;SVM&#x27;</span>]</span><br><span class="line">sns.lineplot(x=models, y=accuracies, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Model Comparison: Accuracy of Decision Tree, Naive Bayes, and SVM&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Accuracy&#x27;</span>)</span><br><span class="line">plt.savefig(<span class="string">&#x27;model_comparison_accuracy.png&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出各模型准确率</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Decision Tree Accuracy: <span class="subst">&#123;dt_accuracy:<span class="number">.4</span>f&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Naive Bayes Accuracy: <span class="subst">&#123;nb_accuracy:<span class="number">.4</span>f&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;SVM Accuracy: <span class="subst">&#123;svm_accuracy:<span class="number">.4</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>三种算法对比折线图：<br>Model_comparison_accuract.png</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/wps24.jpg" alt="img"></p>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5 结论"></a>5 结论</h2><p>总结： 通过本次任务，我使用了三种不同的机器学习算法：决策树、朴素贝叶斯和支持向量机，来预测泰坦尼克号乘客的生还与否。每个算法都进行了训练并生成了相应的预测结果。通过对比准确率，我发现不同模型在本任务中的表现有所不同。<br>收获：<br>学会了如何进行数据预处理，如处理缺失值、转换类别特征等。<br>掌握了多种常用分类算法的使用，包括决策树、朴素贝叶斯和支持向量机，并能够对其进行评估。<br>学会了如何使用混淆矩阵和准确率等评估指标来评价模型的表现。<br>通过可视化，能够更清晰地理解模型的预测结果以及不同模型之间的差异。</p>
<h2 id="6-训练集测试集代码链接"><a href="#6-训练集测试集代码链接" class="headerlink" title="6.训练集测试集代码链接"></a>6.训练集测试集代码链接</h2><p>我就直接把整个项目的都放在这了</p>
<p>通过网盘分享的文件：PythonProject<br>链接: <a href="https://pan.baidu.com/s/1VXbp32N29owHKvdf7F0eoA">https://pan.baidu.com/s/1VXbp32N29owHKvdf7F0eoA</a> 提取码: zp5u</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>详细Anaconda安装+配置+环境创建教程</title>
    <url>/2024/12/28/%E5%AD%A6%E6%A0%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%AF%A6%E7%BB%86Anaconda%E5%AE%89%E8%A3%85+%E9%85%8D%E7%BD%AE+%E7%8E%AF%E5%A2%83%E5%88%9B%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="详细Anaconda安装-配置-环境创建教程"><a href="#详细Anaconda安装-配置-环境创建教程" class="headerlink" title="详细Anaconda安装+配置+环境创建教程"></a>详细Anaconda安装+配置+环境创建教程</h1><h3 id="一、Anaconda简介"><a href="#一、Anaconda简介" class="headerlink" title="一、Anaconda简介"></a>一、Anaconda简介</h3><p>Anaconda 是一个开源的 Python 和 [R 语言](<a href="https://so.csdn.net/so/search?q=R">https://so.csdn.net/so/search?q=R</a> 语言&amp;spm&#x3D;1001.2101.3001.7020)的发行版本，主要用于数据科学、机器学习和科学计算。它包含了大量的科学计算库和工具，并且提供了一个方便的环境管理工具，使得用户可以<strong>轻松地创建、管理和切换不同的 Python 环境。</strong>（我使用的原因是可以方便的切换python环境，每个环境包与包的版本不冲突，以及可以很方便的导入与导出包，最主要的原因是我的科研需要使用Deeplabcut,用anaconda比较方便）</p>
<h4 id="Anaconda-的主要特点"><a href="#Anaconda-的主要特点" class="headerlink" title="Anaconda 的主要特点"></a>Anaconda 的主要特点</h4><ol>
<li><p><strong>包管理</strong>：</p>
<ul>
<li>Anaconda 使用 <code>conda</code> 作为包管理工具，可以方便地安装、更新和删除 Python 包。</li>
<li>支持多种操作系统和平台（Windows、macOS、Linux）。</li>
</ul>
</li>
<li><p><strong>环境管理</strong>：</p>
<ul>
<li><p>Anaconda 允许用户创建独立的 Python 环境，每个环境可以有不同的 Python 版本和包依赖。</p>
</li>
<li><p>使用 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">env</span></span><br></pre></td></tr></table></figure>

<p> 命令可以轻松创建、激活、删除和管理环境。</p>
</li>
</ul>
</li>
<li><p><strong>集成开发环境（IDE）</strong>：</p>
<ul>
<li>Anaconda 提供了 Jupyter Notebook 和 JupyterLab，这些工具非常适合数据分析和可视化。</li>
<li>还集成了 Spyder，一个专门为科学计算设计的 IDE。</li>
</ul>
</li>
<li><p><strong>预装包</strong>：</p>
<ul>
<li>Anaconda 发行版预装了大量的科学计算库，如 NumPy、Pandas、Matplotlib、SciPy、Scikit-learn 等。</li>
<li>还包括一些常用的<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%B7%A5%E5%85%B7&spm=1001.2101.3001.7020">数据科学工具</a>，如 TensorFlow、PyTorch 等。</li>
</ul>
</li>
<li><p><strong>社区支持</strong>：</p>
<ul>
<li>Anaconda 有一个活跃的社区，用户可以在社区中获取帮助、分享经验和学习资源。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="二、Anaconda-的下载"><a href="#二、Anaconda-的下载" class="headerlink" title="二、Anaconda 的下载"></a>二、Anaconda 的下载</h3><p><strong>下载方式</strong>有两种：</p>
<h4 id="1、在anaconda的官网上进行安装（国内网络的问题，下载速度很慢，不推荐）"><a href="#1、在anaconda的官网上进行安装（国内网络的问题，下载速度很慢，不推荐）" class="headerlink" title="1、在anaconda的官网上进行安装（国内网络的问题，下载速度很慢，不推荐）"></a>1、在anaconda的官网上进行安装（国内网络的问题，下载速度很慢，不推荐）</h4><p><a href="https://www.anaconda.com/download/success">Anaconda官网</a></p>
<p>Anaconda可以在Windows、MacOS、Linux系统平台中安装和使用，下载的时候找到对应的点击即可。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/6292eac48de64655881f42e2012a2757.png" alt="img"><strong>选择对应的系统下载即可</strong></p>
<h4 id="2、使用清华镜像源下载（下载速度快，推荐）"><a href="#2、使用清华镜像源下载（下载速度快，推荐）" class="headerlink" title="2、使用清华镜像源下载（下载速度快，推荐）"></a>2、使用清华镜像源下载（下载速度快，推荐）</h4><p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/?C=M&O=D">Anaconda清华镜像源下载</a></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/a486177a66614bd982ce02fbd159b6dc.png" alt="img"><strong>选择对应的系统和版本进行下载</strong></p>
<p>我的电脑是windows系统，我这里选择下载最新版本的Anaconda3-2024.06-1-windows-x86_64.exe   下载完成我们就可以得到一个exe文件。</p>
<h3 id="三、Anaconda-的安装"><a href="#三、Anaconda-的安装" class="headerlink" title="三、Anaconda 的安装"></a>三、Anaconda 的安装</h3><p>下载完成后，只需要一步一步按照提示安装即可，以下说明安装过程中需要特别<strong>注意的步骤</strong></p>
<p><strong>Step1:直接点击next</strong></p>
<p> <img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/7f583f0a0b94426d9804405b468e2b48.png" alt="img"></p>
<p> <strong>Step2:点击 I Agree</strong></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/356a152fcc0d435fa22e470d76452365.png" alt="img"></p>
<p> <strong>Step3:选择 ALL users（选择仅个人的话，后面使用可能会报错）,然后点击next</strong></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/0a228d7fcc134a2fb47ff05b0d58de08.png" alt="img"></p>
<p> <strong>Step4:选择anaconda的安装位置</strong></p>
<blockquote>
<p>**🔔**<strong>Tips:</strong> <strong>这里建议修改为其他盘,要不然下载的包和创建的环境都在C盘，占用空间，我这里修为为F盘（专门安装软件的盘），后面介绍如何把创建的环境和下载的包都装在自己想装的盘里。</strong></p>
</blockquote>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/140fb19a20fe40de82247796daff1401.png" alt="img"></p>
<p> <strong>Step5:这里把三个勾全部打上，然后点击Install,anaconda开始安装</strong></p>
<blockquote>
<ul>
<li>🔒创建开始菜单</li>
<li>🔒base环境以python3.12创建</li>
<li>🔒清除包缓存</li>
</ul>
</blockquote>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/6378e4908ea04dfb8ec57fcdbb169b1d.png" alt="img"></p>
<p> <strong>Step6:安装进行中，等待即可，这一步取决于电脑的性能。</strong></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/454be702d3d0497b89819503d70d8775.png" alt="img"></p>
<p><strong>Step6:</strong> 点击【Next】——再次点击【Next】</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/700b8baba5e44e4ba5bdff667e792a4f.png" alt="img"></p>
<p> <strong>Step7：接着来到最后一步，两个勾取消，不要框选。点击【Finish】</strong></p>
<blockquote>
<p><strong>📍到这里anaconda的安装基本完成，接下来要对anaconda进行一些配置</strong></p>
</blockquote>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/39bceeb539c048b3a3a0901a105621fa.png" alt="img"></p>
<h3 id="四、anaconda的基本配置"><a href="#四、anaconda的基本配置" class="headerlink" title="四、anaconda的基本配置"></a>四、anaconda的基本配置</h3><h4 id="1、环境变量的配置"><a href="#1、环境变量的配置" class="headerlink" title="1、环境变量的配置"></a>1、环境变量的配置</h4><blockquote>
<p>电脑设置搜索栏搜索高级系统设置</p>
</blockquote>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/162c061d2e0a44348367bc93306cc9fd.png" alt="img"></p>
<blockquote>
<p> 选择环境变量</p>
</blockquote>
<p> <img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/d6a3a8b4f7994299b97082a74375f445.png" alt="img"></p>
<blockquote>
<p> 系统变量选择path，双击进入</p>
</blockquote>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/f12f41182bec405bb067aff2ec358c06.png" alt="img"></p>
<blockquote>
<p> 新建环境变量****【根据自己安装的盘，选择对应的盘】****</p>
<p>D:\anaconda3<br>D:\anaconda3\Scripts<br>D:\anaconda3\Library\bin<br>D:\anaconda3\Library\mingw-w64\bin</p>
</blockquote>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/38b244a15d3a45649d2e4df2a51f9efe.png" alt="img"></p>
<blockquote>
<p>在windows菜单栏搜索Anaconda,打开anaconda prompt </p>
</blockquote>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/e706f1778c5345b49e5206758268b821.png" alt="img"></p>
<p>输入这行代码，查看版本号，检查是否成功安装</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">conda <span class="comment">--version</span></span><br></pre></td></tr></table></figure>

<p> <img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/b9331178a8a64292a6503023a8f415b5.png" alt="img"></p>
<p>成功安装会显示Anaconda的版本号，这里anaconda就安装完成了，但是并没有结束，因为还涉及到环境和包的下载，这里默认是下载在C盘的，我们需要更改下载的位置，以免占C盘系统盘内存；最后再添加镜像源方便下载环境的包（网速更快） </p>
<h3 id="五、Anaconda默认环境保存路径和下载源修改"><a href="#五、Anaconda默认环境保存路径和下载源修改" class="headerlink" title="五、Anaconda默认环境保存路径和下载源修改"></a>五、Anaconda默认环境保存路径和下载源修改</h3><p>因为更改环境保存路径和更改下载源都可以在.condarc文件中修改，这里一次性配置完</p>
<blockquote>
<p> 打开上面的anaconda prompt命令窗口，输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda info</span><br></pre></td></tr></table></figure></blockquote>
<p> 没有修改的conda的pkgs和envs均保存在C盘，为了不占用系统盘的空间，我们需要修改保存的位置</p>
<p> <img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/951831dd12d642ddbee6a55dc7fc38ba.png" alt="img"></p>
<blockquote>
<p> 在C盘-用户-用户名，找到.condarc,如果找不到打开anaconda prompt输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --<span class="built_in">set</span> show_channel_urls <span class="built_in">yes</span></span><br></pre></td></tr></table></figure></blockquote>
<p> 即可找到，用记事本打开<img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/12a89dda80394dcb8811d30c07b5b0ff.png" alt="img"></p>
<blockquote>
<p> 删除其他的，输入以下指令【注意修改为自己想要安装的盘，我这里修改为F盘】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">envs_dirs:</span><br><span class="line">  - F:\Anaconda3\envs</span><br><span class="line">pkgs_dirs:</span><br><span class="line">  - F:\Anaconda3\pkgs</span><br></pre></td></tr></table></figure></blockquote>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/e030682e571042b98375113299c5df5a.png" alt="img"></p>
<blockquote>
<p> CTRL + S保存</p>
</blockquote>
<blockquote>
<p> conda镜像源的配置，因为conda很多下载的东西在国外，默认的下载速度往往会很慢，这里建议修改为清华的镜像源，打开anaconda prompt，输入以下指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加清华源</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line"> </span><br><span class="line"># 添加阿里云镜像源</span><br><span class="line">conda config --add channels https://mirrors.aliyun.com/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.aliyun.com/anaconda/pkgs/main/</span><br><span class="line"> </span><br><span class="line"># 添加中科大源</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># （可选）设置搜索时显示通道地址</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure></blockquote>
<blockquote>
<p>最后我们验证一下上面的内容是否成功配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda info</span><br></pre></td></tr></table></figure></blockquote>
<blockquote>
<p> 首先pkgs和envs都修改为F盘了</p>
</blockquote>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/7d29733c23a14627ab108fa45b589774.png" alt="img"></p>
<p>其次我们看镜像源也成功配置</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/fae2804f68204487a43840063728764e.png" alt="img"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2024/10/21/redis%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><h2 id="一-初始Redis"><a href="#一-初始Redis" class="headerlink" title="一.初始Redis"></a>一.初始Redis</h2><h3 id="1-1SQL-和-NoSql的区别"><a href="#1-1SQL-和-NoSql的区别" class="headerlink" title="1.1SQL 和 NoSql的区别"></a>1.1SQL 和 NoSql的区别</h3><h4 id="1-1-1结构化和非结构化"><a href="#1-1-1结构化和非结构化" class="headerlink" title="1.1.1结构化和非结构化"></a>1.1.1结构化和非结构化</h4><blockquote>
<p><strong>(1) SQL关系性数据库</strong></p>
<p> <strong>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名、字段数据类型、字段约束等等信息，插入的数据必须遵守这些约束</strong></p>
<p><strong><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/b8cd9ab419e6397db101ba53aab2ebad.png" alt="image-20221108150421251"></strong></p>
<p><strong>(2) NoSql数据库</strong></p>
<p><strong>NoSql对数据库格式没有严格约束，往往形式松散，自由。</strong></p>
<p><strong>可以是key-value,可以是文档，或者图格式</strong></p>
<p><strong><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/402ec64c64b2c754969e260970348105.png" alt="image-20221108150842073"></strong></p>
<p><strong><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/57f3717cc51e15946248c8c5d8eb56be.png" alt="image-20221108150759880"></strong></p>
<p><strong><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/16bf83550bc1fa7a14f1b39e482989ae.png" alt="image-20221108150824222"></strong></p>
</blockquote>
<h4 id="1-1-2关联和非关联"><a href="#1-1-2关联和非关联" class="headerlink" title="1.1.2关联和非关联"></a>1.1.2关联和非关联</h4><blockquote>
<p><strong>(1) 关系型数据库</strong></p>
<p><strong><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/789b285ff31c7b5276f0477d08b14010.png" alt="image-20221108151050108"></strong></p>
<p><strong>(2) 非关系型数据库</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  name<span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  orders<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	 id<span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;荣耀6&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">4999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	 id<span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;小米11&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">3999</span></span><br><span class="line">      </span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></blockquote>
<h4 id="1-1-3查询方式"><a href="#1-1-3查询方式" class="headerlink" title="1.1.3查询方式"></a>1.1.3查询方式</h4><p><strong><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/1a6a6e85d8ff16d7da216ede02ea16f6.png" alt="image-20221108151404130"></strong></p>
<h4 id="1-1-4-事务"><a href="#1-1-4-事务" class="headerlink" title="1.1.4 事务"></a>1.1.4 事务</h4><p><strong>传统关系型数据库能满足事务ACID的原则 ，而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。</strong></p>
<h4 id="1-1-5总结"><a href="#1-1-5总结" class="headerlink" title="1.1.5总结"></a>1.1.5总结</h4><p><strong><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/a28d237e5cd7ae17a7932567698438d5.png" alt="image-20221108154744967"></strong></p>
<h3 id="1-2-认识Redis"><a href="#1-2-认识Redis" class="headerlink" title="1.2 认识Redis"></a>1.2 认识Redis</h3><p><strong>特征：</strong></p>
<ul>
<li><strong>键值（key-value）型，value支持多种不同数据结构，功能丰富</strong></li>
<li><strong>单线程，每个命令具备原子性</strong></li>
<li><strong>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</strong></li>
<li><strong>支持数据持久化(定期将内存搬运到磁盘)</strong></li>
<li><strong>支持主从集群、分片集群（数据拆分）</strong>（可以做读写分离，大大提高效率）</li>
<li><strong>支持多语言客户端</strong></li>
</ul>
<p><strong>Redis的官方网站地址：<a href="https://redis.io/">Redis</a><a href="https://redis.io/">Redis</a> <a href="https://redis.io/">Redis</a></strong></p>
<h3 id="1-3-Redis安装启动"><a href="#1-3-Redis安装启动" class="headerlink" title="1.3 Redis安装启动"></a>1.3 Redis安装启动</h3><p><strong>Redis是基于C编写，所以需要先安装Redis所需的gcc依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y gcc </span><br></pre></td></tr></table></figure>

<p><strong>如果有了就跳过</strong></p>
<p><strong>安装包上传到usr&#x2F;local&#x2F;src</strong></p>
<p><strong><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/043889f660657c21ebd7ee3168d64830.png" alt="image-20221109102716711"></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf redis-6.2.6.tar.gz </span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong>cd到redis的目录：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd redis-6.2.6/</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong>编译和运行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h4 id="默认启动："><a href="#默认启动：" class="headerlink" title="默认启动："></a>默认启动：</h4><p><strong>需要一直挂着页面</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>

<h4 id="后台启动："><a href="#后台启动：" class="headerlink" title="后台启动："></a>后台启动：</h4><p><strong>前提是必须修改配置文件(&#x2F;usr&#x2F;local&#x2F;src&#x2F;redis-6.2.6&#x2F;redis.conf)</strong></p>
<p><strong>(1) 先备份一份</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp redis.conf redis.conf.bak</span><br></pre></td></tr></table></figure>

<p><strong>(2) 修改</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi redis.conf</span><br></pre></td></tr></table></figure>

<p><strong>eg:修改密码为1234</strong></p>
<p><strong><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/1527463cb0ac80564df17ed9516bb1fa.png" alt="image-20221109111623471"></strong></p>
<p><strong>(3) 运行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/src/redis-6.2.6</span><br><span class="line">redis-server redis.conf</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p><strong>(4) 查看是否启动</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/17be3b48958911355b14acd5305dafe9.png" alt="image-20221109111925399"></strong></p>
<p><strong>(5) 停止redis -9:强制但是不安全</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -9 进程号</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h4 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h4><p><strong>(1) 新建系统服务文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong>内容：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">1234567891011</span><br></pre></td></tr></table></figure>

<p><strong>(2) 重新加载系统服务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong>(3)启动</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start redis</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong>(4)查看状态</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status redis</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/fc132c8c167eea60ab5c7f46f92a9903.png" alt="image-20221109113222600"></strong></p>
<p><strong>(5) 设置开机自启</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable redis</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/63944ec7da77ca47f11758f70fa2cdda.png" alt="image-20221109113355471"></strong></p>
<h3 id="1-4-Redis客户端"><a href="#1-4-Redis客户端" class="headerlink" title="1.4 Redis客户端"></a>1.4 Redis客户端</h3><p><strong>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</strong></p>
<ul>
<li><strong>命令行客户端</strong></li>
<li><strong>图形化桌面客户端</strong></li>
<li><strong>编程客户端</strong></li>
</ul>
<h5 id="1-4-1-Redis命令行客户端"><a href="#1-4-1-Redis命令行客户端" class="headerlink" title="1.4.1.Redis命令行客户端"></a>1.4.1.Redis命令行客户端</h5><p><strong>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure>

<p>redis-cli -h 192.168.200.131 -p 6379 -a 1234</p>
<p><strong>其中常见的options有：</strong></p>
<ul>
<li><strong><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</strong></li>
<li><strong><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</strong></li>
<li><strong><code>-a 123321</code>：指定redis的访问密码</strong></li>
</ul>
<p><strong>其中的commonds就是Redis的操作命令，例如：</strong></p>
<ul>
<li><strong><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></strong></li>
</ul>
<p><strong>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</strong></p>
<p><strong><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/8061fdd368255e1d727f37de06b2e1d6.png" alt="image-20221109130629001"></strong></p>
<p><strong>也可以先不写密码，后面来补充！</strong></p>
<p><strong><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/ef6ae4301d700e5ce9c69ff3ba569323.png" alt="image-20221109130833848"></strong></p>
<h5 id="1-4-2-图形化桌面客户端"><a href="#1-4-2-图形化桌面客户端" class="headerlink" title="1.4.2.图形化桌面客户端"></a>1.4.2.图形化桌面客户端</h5><p><strong>GitHub上的大神编写了Redis的图形化桌面客户端，地址：<a href="https://github.com/uglide/RedisDesktopManager">https://github.com/uglide/RedisDesktopManager</a></strong></p>
<p><strong>不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。</strong></p>
<p><strong>在下面这个仓库可以找到安装包：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></strong></p>
<p><strong>resp.exe</strong></p>
<p><strong><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/3c4fc4ed400a07f6356043aa855f5d95.png" alt="image-20221109141759074"></strong></p>
<p><strong><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/4f0280685a8ad88c1d2c5d2cdd2d4b5b.png" alt="image-20221109142107511"></strong></p>
<h2 id="二-Redis命令"><a href="#二-Redis命令" class="headerlink" title="二.Redis命令"></a>二.Redis命令</h2><h3 id="0-通用命令"><a href="#0-通用命令" class="headerlink" title="0.通用命令"></a>0.通用命令</h3><p><code>help @generic </code>查看所有的通用命令</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241021105219427.png" alt="image-20241021105219427"></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241021105335724.png" alt="image-20241021105335724"></p>
<p>生产过程中不建议用keys是因为它是单线程的，而这个行为是耗时的，会被阻塞很久耽误事情。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">centos7_01_192.168.120.90:0&gt;mset k1 v1 k2 v2 k3 v3 </span><br><span class="line">&quot;OK&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;keys *</span><br><span class="line">1) &quot;k2&quot;</span><br><span class="line">2) &quot;k1&quot;</span><br><span class="line">3) &quot;k3&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用del</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;del k1 k2 k3 k4</span><br><span class="line">&quot;3&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;keys *</span><br><span class="line"></span><br><span class="line">centos7_01_192.168.120.90:0&gt;mset name v1</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;keys *</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用exists</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;exists name</span><br><span class="line">&quot;1&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;exists age</span><br><span class="line">&quot;0&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用expire和ttl</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;expire name 20</span><br><span class="line">&quot;1&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;TTL name</span><br><span class="line">&quot;15&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;TTL name</span><br><span class="line">&quot;14&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;TTL name</span><br><span class="line">&quot;9&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;TTL name</span><br><span class="line">&quot;4&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;TTL name</span><br><span class="line">&quot;2&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;TTL name</span><br><span class="line">&quot;1&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;TTL name</span><br><span class="line">&quot;0&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;TTL name</span><br><span class="line">&quot;-2&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;TTL name</span><br><span class="line">&quot;-2&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;TTL name</span><br><span class="line">&quot;-2&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;TTL name</span><br><span class="line">&quot;-2&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;TTL name</span><br><span class="line">&quot;-2&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-2表示已经被删了</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;keys * </span><br><span class="line"></span><br><span class="line">centos7_01_192.168.120.90:0&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">没有用expire设置有效期，那么-1表示的是永久有效</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;set name Kevin</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;ttl name</span><br><span class="line">&quot;-1&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;</span><br></pre></td></tr></table></figure>

<p><strong>expire设置存活周期，ttl查看剩余时间，不设置expire的话ttl为-1</strong></p>
<h3 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h3><p><strong><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/92350a2f2ef0117cae67b4307fe1d2f3.png" alt="image-20221109150526290"></strong></p>
<p><strong><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/1741180311023ccfd61d03f0b9111258.png" alt="image-20221109150730084"></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">set</span> 单个添加 值会被覆盖，所以是修改</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;set name Rose</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;get name</span><br><span class="line">&quot;Rose&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;set name Jack</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;get name</span><br><span class="line">&quot;Jack&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">mset 批量添加</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;MSET k1 v1 k2 v2 k3 v3</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;keys *</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;k2&quot;</span><br><span class="line">3) &quot;k1&quot;</span><br><span class="line">4) &quot;k3&quot;</span><br><span class="line"></span><br><span class="line">centos7_01_192.168.120.90:0&gt;MGET name k1 k2 k3</span><br><span class="line">1) &quot;Jack&quot;</span><br><span class="line">2) &quot;v1&quot;</span><br><span class="line">3) &quot;v2&quot;</span><br><span class="line">4) &quot;v3&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">INCR</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;set age 18</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;keys *</span><br><span class="line">1) &quot;k1&quot;</span><br><span class="line">2) &quot;k2&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;k3&quot;</span><br><span class="line">5) &quot;name&quot;</span><br><span class="line"></span><br><span class="line">centos7_01_192.168.120.90:0&gt;INCR age</span><br><span class="line">&quot;19&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;get age</span><br><span class="line">&quot;19&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;INCR age</span><br><span class="line">&quot;20&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;get age</span><br><span class="line">&quot;20&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">INCRBY 设置每次增长多少</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置为负数就是自减了</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;INCRBY age 2</span><br><span class="line">&quot;22&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;INCRBY age 2</span><br><span class="line">&quot;24&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;INCRBY age 2</span><br><span class="line">&quot;26&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;get age</span><br><span class="line">&quot;26&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;INCRBY age -3</span><br><span class="line">&quot;23&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;INCRBY age -3</span><br><span class="line">&quot;20&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;get age</span><br><span class="line">&quot;20&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">setnx</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;setnx name lli</span><br><span class="line">&quot;0&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;get name</span><br><span class="line">&quot;Jack&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;setnx name1 kevin</span><br><span class="line">&quot;1&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;get name</span><br><span class="line">&quot;Jack&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;get name1</span><br><span class="line">&quot;kevin&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">set</span>和nx是组合的，可以分开可以合起来</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;set name lucy nx</span><br><span class="line">null</span><br><span class="line">centos7_01_192.168.120.90:0&gt;get name</span><br><span class="line">&quot;Jack&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">setex <span class="built_in">set</span>和expire的组合 添加并设置有效期</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;setex name 10 jack</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;ttl name</span><br><span class="line">&quot;6&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;ttl name</span><br><span class="line">&quot;3&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;ttl name</span><br><span class="line">&quot;2&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;ttl name</span><br><span class="line">&quot;1&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;ttl name</span><br><span class="line">&quot;0&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;ttl name</span><br><span class="line">&quot;-2&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;get name</span><br><span class="line">null</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">set</span>和ex分开的</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;set name Jack ex 10</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;get name</span><br><span class="line">&quot;Jack&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;ttl name</span><br><span class="line">&quot;4&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;ttl name</span><br><span class="line">&quot;3&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;ttl name</span><br><span class="line">&quot;-2&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;get name</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<h3 id="2-Key的层级格式"><a href="#2-Key的层级格式" class="headerlink" title="2.Key的层级格式"></a>2.Key的层级格式</h3><p>推荐用：</p>
<p><code>项目名:业务名:类型:id</code></p>
<p>这种形式去存储</p>
<p><strong><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/cb0081614ce3ab4361bd1f290490dd55.png" alt="image-20221109152434329"></strong></p>
<p><strong>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">centos7_01_192.168.120.90:0&gt;set heima:user:1 &#x27;&#123;&quot;id&quot;:1,&quot;name&quot;: &quot;Jack&quot;,&quot;age&quot;: 21&#125;&#x27;</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;set heima:user:2 &#x27;&#123;&quot;id&quot;:2,&quot;name&quot;: &quot;Rose&quot;,&quot;age&quot;: 20&#125;&#x27;</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;set heima:product:1 &#x27;&#123;&quot;id&quot;:1, &quot;name&quot;: &quot;小米11&quot;, &quot;price&quot;: 4999&#125;&#x27;</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;set heima:product:2 &#x27;&#123;&quot;id&quot;:2, &quot;name&quot;: &quot;iphone&quot;, &quot;price&quot;: 9809&#125;&#x27;</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;keys *</span><br><span class="line">1) &quot;heima:product:2&quot;</span><br><span class="line">2) &quot;age&quot;</span><br><span class="line">3) &quot;k2&quot;</span><br><span class="line">4) &quot;k1&quot;</span><br><span class="line">5) &quot;heima:product:1&quot;</span><br><span class="line">6) &quot;heima:user:2&quot;</span><br><span class="line">7) &quot;k3&quot;</span><br><span class="line">8) &quot;name1&quot;</span><br><span class="line">9) &quot;heima:user:1&quot;</span><br></pre></td></tr></table></figure>

<p><strong>一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于这样的结构，更加方便Redis获取数据，避免了名字冲突</strong></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241021113335832.png" alt="image-20241021113335832"></p>
<h3 id="3-Hash"><a href="#3-Hash" class="headerlink" title="3.Hash"></a>3.Hash</h3><p><strong>本身Redis就是一个key-value的结构，而hash的value还是一个key-value的结构</strong></p>
<p><strong><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/28b195ee5a093c2b6b787c992914d6da.png" alt="image-20221109155158922"></strong></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/90d6649c25d08cb629883f5aa997c523.png" alt="image-20221109155235999"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HSET 用法和<span class="built_in">set</span>一样的，和string不同的是不止要给key还要给field</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;HSET heima:user:3 name Lucy</span><br><span class="line">&quot;1&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;HSET heima:user:3 age 21</span><br><span class="line">&quot;1&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;HSET heima:user:3 age 17</span><br><span class="line">&quot;0&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241021184809896.png" alt="image-20241021184809896"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HMSET</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;HMSET heima:user:4 name hanmeimei</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;HMSET hiema:user:4 name lilei age 20 sex man</span><br><span class="line">&quot;OK&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HMGET</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;HMGET hiema:user:4 name age sex</span><br><span class="line">1) &quot;lilei&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;man&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HGETALL</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;HGETALL hiema:user:4</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;lilei&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">5) &quot;sex&quot;</span><br><span class="line">6) &quot;man&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HKEYS HVALS</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;HKEYS hiema:user:4</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;age&quot;</span><br><span class="line">3) &quot;sex&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;HVALS hiema:user:4</span><br><span class="line">1) &quot;lilei&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;man&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HINCRBY</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;HINCRBY hiema:user:4 age 2</span><br><span class="line">&quot;22&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HSET和nx 原来有的改不了，原来没的创建</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;HSETNX hiema:user:4 sex women</span><br><span class="line">&quot;0&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;HSETNX hiema:user:3 sex women</span><br><span class="line">&quot;1&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;HGETALL hiema:user:3</span><br><span class="line">1) &quot;sex&quot;</span><br><span class="line">2) &quot;women&quot;</span><br></pre></td></tr></table></figure>

<h3 id="4-List"><a href="#4-List" class="headerlink" title="4.List"></a>4.List</h3><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/c166c8176269525213a1231b783d243f.png" alt="image-20221109162502511"></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/4dc4ab59fee2212e018a87223182d4a5.png" alt="image-20221109163700818"></p>
<p>BLPOP 是阻塞等待，当前进程阻塞，等待另外一个进程输入结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">LPUSH</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;LPUSH users 1 2 3</span><br><span class="line">&quot;3&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">RPUSH</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;RPUSH users 456</span><br><span class="line">&quot;4&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;RPUSH users 4 5 6</span><br><span class="line">&quot;7&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">LPOP 直接移除</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;LPOP users 1</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">RPOP</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;RPOP users 1</span><br><span class="line">1) &quot;6&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">LRANGE</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;LRANGE users 1 2</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;456&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">BLPOP 有的话弹出，没有的话等待指定时间，这里是100秒</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;BLPOP user2 100</span><br><span class="line">1) &quot;user2&quot;</span><br><span class="line">2) &quot;Jack&quot;</span><br></pre></td></tr></table></figure>

<h3 id="5-Set"><a href="#5-Set" class="headerlink" title="5.Set"></a>5.Set</h3><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/bc3482b41c3b887f2f58033b7e10bcff.png" alt="image-20221109164228655"></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241021194250280.png" alt="image-20241021194250280"></p>
<p>单个集合的操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SADD添加</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;SADD s1 a b c</span><br><span class="line">&quot;3&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SMEMBERS 查看所有</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;SMEMBERS s1</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SREM 删除</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;SREM s1 a</span><br><span class="line">&quot;1&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SISMEMBER 是否存在</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;SISMEMBER s1 a</span><br><span class="line">&quot;0&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;SISMEMBER s1 b</span><br><span class="line">&quot;1&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SCARD 计数</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;SCARD s1</span><br><span class="line">&quot;2&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/cd7cf6a68fc1117c876d98174148e15b.png" alt="image-20221109165305468"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">centos7_01_192.168.120.90:0&gt;sadd zs lisi wangwu zhaoliu</span><br><span class="line">&quot;3&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;sadd ls wangwu mazi ergou</span><br><span class="line">&quot;3&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;sinter zs ls</span><br><span class="line">1) &quot;wangwu&quot;</span><br><span class="line"></span><br><span class="line">centos7_01_192.168.120.90:0&gt;sdiff zs ls</span><br><span class="line">1) &quot;lisi&quot;</span><br><span class="line">2) &quot;zhaoliu&quot;</span><br><span class="line"></span><br><span class="line">centos7_01_192.168.120.90:0&gt;sunion zs ls</span><br><span class="line">1) &quot;wangwu&quot;</span><br><span class="line">2) &quot;ergou&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">4) &quot;zhaoliu&quot;</span><br><span class="line">5) &quot;mazi&quot;</span><br><span class="line"></span><br><span class="line">centos7_01_192.168.120.90:0&gt;sismember zs lisi</span><br><span class="line">&quot;1&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;sismember ls zhangsan</span><br><span class="line">&quot;0&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;sismember ls zhangsan</span><br><span class="line">&quot;0&quot;</span><br><span class="line">centos7_01_192.168.120.90:0&gt;srem zs lisi</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure>

<h3 id="6-SortedSet"><a href="#6-SortedSet" class="headerlink" title="6.SortedSet"></a>6.SortedSet</h3><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/a442f434dc3a0b0732d7a05d00041986.png" alt="image-20221109165841177"></p>
<p><strong>每个元素都带上分数，所以才能实现排序</strong></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241021195555459.png" alt="image-20241021195555459"></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/c30d7972a3db6e21adab62189c3c353e.png" alt="image-20221109170635790"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ZADD 添加</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;zadd stus 85 jack 89 Lucy 82 Rose 95 Tom 78 Jerry 92 Amy 76 Miles</span><br><span class="line">&quot;7&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ZREM 删除</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;zrem stus Tom</span><br><span class="line">&quot;1&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ZSCORE</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;zscore stus Amy</span><br><span class="line">&quot;92&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ZRANK 这个是从0开始数的排名 升序</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;zrank stus Rose</span><br><span class="line">&quot;2&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ZREVRANK 降序</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;zrevrank stus Rose</span><br><span class="line">&quot;3&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ZCOUNT 0-80分</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;zcount stus 0 80</span><br><span class="line">&quot;2&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ZINCRBY 自增，一个加分操作</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;zincrby stus 2 Amy</span><br><span class="line">&quot;94&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这是后三名，因为原来的是按照成绩升序排的</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;zrange stus 0 2</span><br><span class="line">1) &quot;Miles&quot;</span><br><span class="line">2) &quot;Jerry&quot;</span><br><span class="line">3) &quot;Rose&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这是前三名</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;zrevrange stus 0 2</span><br><span class="line">1) &quot;Amy&quot;</span><br><span class="line">2) &quot;Lucy&quot;</span><br><span class="line">3) &quot;jack&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">80以下的人</span></span><br><span class="line">centos7_01_192.168.120.90:0&gt;zrangebyscore stus 0 80</span><br><span class="line">1) &quot;Miles&quot;</span><br><span class="line">2) &quot;Jerry&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Bulk Rename Utility（BRU）——大批量重命名实用程序</title>
    <url>/2025/03/22/%E5%B7%A5%E5%85%B7/Bulk%20Rename%20Utility%EF%BC%88BRU%EF%BC%89%E2%80%94%E2%80%94%E5%A4%A7%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="Bulk-Rename-Utility（BRU）——大批量重命名实用程序"><a href="#Bulk-Rename-Utility（BRU）——大批量重命名实用程序" class="headerlink" title="Bulk Rename Utility（BRU）——大批量重命名实用程序"></a>Bulk Rename Utility（BRU）——大批量重命名实用程序</h1><p>博主要给博客网站搞博客封面，几百张图没编号，一弄这个就好了，亲测十分好用，下面的b站教程更是一绝，快快使用起来</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Bulk Rename Utility（BRU）是一款免费的适用于 Windows 的文件重命名软件。BRU能帮助解决各种繁琐的重命名任务，个人人为比自己去写<a href="https://so.csdn.net/so/search?q=python%E7%A8%8B%E5%BA%8F&spm=1001.2101.3001.7020">python程序</a>处理更加方便，因为<code>BRU</code>的功能十分强大，且具有友好的<a href="https://so.csdn.net/so/search?q=GUI%E7%95%8C%E9%9D%A2&spm=1001.2101.3001.7020">GUI界面</a>，且同样能够处理大批量<code>重命名任务</code>。</p>
<hr>
<h2 id="BRU背景"><a href="#BRU背景" class="headerlink" title="BRU背景"></a>BRU背景</h2><p>BRU官方网站：<a href="https://www.bulkrenameutility.co.uk/">https://www.bulkrenameutility.co.uk/</a><br>Bulk Rename Utility(BRU)是一个易于使用的文件重命名程序（又名文件重命名器）。重命名多个文件和&#x2F;或多个文件夹从未如此简单！它的内存占用很小，因此可以一直运行而不会消耗所有内存。它最初是一个免费的Visual Basic工具，但随着它的普及，它已经完全用C++重写，变得健壮和轻量级 - 而且非常非常快！它可以轻松处理包含超过 100,000 个条目的文件夹&#x2F;光盘…它可以在几秒钟内批量重命名 1,000 个文件。</p>
<h2 id="BRU下载"><a href="#BRU下载" class="headerlink" title="BRU下载"></a>BRU下载</h2><p>1.BRU官网下载（英文版BRU）：<a href="https://www.bulkrenameutility.co.uk/">https://www.bulkrenameutility.co.uk/</a><br>2.百度网盘下载（博主自己找的汉化版BRU）：<a href="https://pan.baidu.com/s/1oVVCb6JvHHe2UfxPEJh48Q">汉化版BRU 提取码：6666</a></p>
<h2 id="BRU打开方式"><a href="#BRU打开方式" class="headerlink" title="BRU打开方式"></a>BRU打开方式</h2><p>下载汉化版本的BRU后只要在使用时点击<code>x64.exe</code>即可。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/8b6e2bf067a589d1708e2fd27b1d213f.jpeg" alt="在这里插入图片描述"></p>
<h2 id="BRU打开界面"><a href="#BRU打开界面" class="headerlink" title="BRU打开界面"></a>BRU打开界面</h2><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/b419465c6a2e4290efb6e25aa88c8c97.png" alt="在这里插入图片描述"></p>
<h2 id="BRU使用教程"><a href="#BRU使用教程" class="headerlink" title="BRU使用教程"></a>BRU使用教程</h2><p>最后推荐一个B站UP主去使用BRU，我的汉化版BRU也是从这位UP那边下载的。——&gt;<a href="https://www.bilibili.com/video/BV1Aa411K7Wk/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=5f770ca95126cc15282f63ab98691969">BRU使用教程</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>好用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake 保姆级教程（上）</title>
    <url>/2024/11/02/%E5%B7%A5%E5%85%B7/CMake%20%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h1 id="CMake-保姆级教程（上）"><a href="#CMake-保姆级教程（上）" class="headerlink" title="CMake 保姆级教程（上）"></a>CMake 保姆级教程（上）</h1><p><a href="https://www.bilibili.com/video/BV14s4y1g7Zj?spm_id_from=333.788.videopod.episodes&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">CMake 保姆级教程【C&#x2F;C++】_哔哩哔哩_bilibili</a></p>
<h1 id="1-CMake概述"><a href="#1-CMake概述" class="headerlink" title="1. CMake概述"></a>1. CMake概述</h1><p>CMake 是一个项目构建工具，并且是跨平台的。关于项目构建我们所熟知的还有Makefile（通过 make 命令进行项目的构建），大多是IDE软件都集成了make，比如：VS 的 nmake、linux 下的 GNU make、Qt 的 qmake等，如果自己动手写 makefile，会发现，makefile 通常依赖于当前的编译平台，而且编写 makefile 的工作量比较大，解决依赖关系时也容易出错。</p>
<p>而 CMake 恰好能解决上述问题， 其允许开发者指定整个工程的编译流程，在根据编译平台，<code>自动生成本地化的Makefile和工程文件</code>，最后用户只需<code>make</code>编译即可，所以可以把CMake看成一款自动生成 Makefile的工具，其编译流程如下图：</p>
<p><a href="https://subingwen.cn/cmake/CMake-primer/image-20230309130644912.png"><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20230309130644912.png" alt="image-20230309130644912"></a></p>
<ul>
<li>蓝色虚线表示使用<code>makefile</code>构建项目的过程</li>
<li>红色实线表示使用<code>cmake</code>构建项目的过程</li>
</ul>
<p>介绍完CMake的作用之后，再来总结一下它的优点：</p>
<ul>
<li>跨平台</li>
<li>能够管理大型项目</li>
<li>简化编译构建过程和编译过程</li>
<li>可扩展：可以为 cmake 编写特定功能的模块，扩充 cmake 功能</li>
</ul>
<h1 id="2-CMake的使用"><a href="#2-CMake的使用" class="headerlink" title="2. CMake的使用"></a>2. CMake的使用</h1><p><code>CMake</code>支持大写、小写、混合大小写的命令。如果在编写<code>CMakeLists.txt</code>文件时使用的工具有对应的命令提示，那么大小写随缘即可，不要太过在意。</p>
<h2 id="2-1-注释"><a href="#2-1-注释" class="headerlink" title="2.1 注释"></a>2.1 注释</h2><h3 id="2-1-1-注释行"><a href="#2-1-1-注释行" class="headerlink" title="2.1.1 注释行"></a>2.1.1 注释行</h3><p><code>CMake</code> 使用 <code>#</code> 进行<code>行注释</code>，可以放在任何位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line"># 这是一个 CMakeLists.txt 文件</span><br><span class="line">cmake_minimum_required(VERSION 3.0.0)</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-注释块"><a href="#2-1-2-注释块" class="headerlink" title="2.1.2 注释块"></a>2.1.2 注释块</h3><p><code>CMake</code> 使用 <code>#[[ ]]</code> 形式进行<code>块注释</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">#[[ 这是一个 CMakeLists.txt 文件。</span><br><span class="line">这是一个 CMakeLists.txt 文件</span><br><span class="line">这是一个 CMakeLists.txt 文件]]</span><br><span class="line">cmake_minimum_required(VERSION 3.0.0)</span><br></pre></td></tr></table></figure>

<h2 id="2-1-只有源文件"><a href="#2-1-只有源文件" class="headerlink" title="2.1 只有源文件"></a>2.1 只有源文件</h2><h3 id="2-1-1-共处一室-所有文件都放到当前目录"><a href="#2-1-1-共处一室-所有文件都放到当前目录" class="headerlink" title="2.1.1 共处一室 所有文件都放到当前目录"></a>2.1.1 共处一室 所有文件都放到当前目录</h3><ol>
<li><p>准备工作，为了方便测试，在我本地电脑准备了这么几个测试文件</p>
<ul>
<li><p><strong>add.c</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c++</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;head.h&quot;</span><br><span class="line"></span><br><span class="line">int add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>sub.c</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c++</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;head.h&quot;</span><br><span class="line"></span><br><span class="line">// 你好</span><br><span class="line">int subtract(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mult.c</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c++</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;head.h&quot;</span><br><span class="line"></span><br><span class="line">int multiply(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>div.c</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c++</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;head.h&quot;</span><br><span class="line"></span><br><span class="line">double divide(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return (double)a/b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>head.h</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c++</span><br><span class="line">#ifndef _HEAD_H</span><br><span class="line">#define _HEAD_H</span><br><span class="line">// 加法</span><br><span class="line">int add(int a, int b);</span><br><span class="line">// 减法</span><br><span class="line">int subtract(int a, int b);</span><br><span class="line">// 乘法</span><br><span class="line">int multiply(int a, int b);</span><br><span class="line">// 除法</span><br><span class="line">double divide(int a, int b);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>main.c</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c++</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;head.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 20;</span><br><span class="line">    int b = 12;</span><br><span class="line">    printf(&quot;a = %d, b = %d\n&quot;, a, b);</span><br><span class="line">    printf(&quot;a + b = %d\n&quot;, add(a, b));</span><br><span class="line">    printf(&quot;a - b = %d\n&quot;, subtract(a, b));</span><br><span class="line">    printf(&quot;a * b = %d\n&quot;, multiply(a, b));</span><br><span class="line">    printf(&quot;a / b = %f\n&quot;, divide(a, b));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>上述文件的目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── div.c</span><br><span class="line">├── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>添加 <code>CMakeLists.txt</code> 文件</strong></p>
<p>在上述源文件所在目录下添加一个新文件 CMakeLists.txt，文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(CALC)</span><br><span class="line">add_executable(app add.c div.c main.c mult.c sub.c)</span><br></pre></td></tr></table></figure>

<p>接下来依次介绍一下在 CMakeLists.txt 文件中添加的三个命令:</p>
<ul>
<li><p><code>cmake_minimum_required</code>：指定使用的 cmake 的最低版本</p>
<ul>
<li><strong>可选，非必须，如果不加可能会有警告</strong></li>
</ul>
</li>
<li><p><code>project</code>：定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言（默认情况支持所有语言），如果不需要这些都是可以忽略的，只需要指定出工程名字即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># PROJECT 指令的语法是：</span><br><span class="line">project(&lt;PROJECT-NAME&gt; [&lt;language-name&gt;...])</span><br><span class="line">project(&lt;PROJECT-NAME&gt;</span><br><span class="line">       [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]</span><br><span class="line">       [DESCRIPTION &lt;project-description-string&gt;]</span><br><span class="line">       [HOMEPAGE_URL &lt;url-string&gt;]</span><br><span class="line">       [LANGUAGES &lt;language-name&gt;...])</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>add_executable</code>：定义工程会生成一个可执行程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">add_executable(可执行程序名 源文件名称)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这里的可执行程序名和<code>project</code>中的项目名没有任何关系</p>
</li>
<li><p>源文件名可以是一个也可以是多个，如有多个可用空格或<code>;</code>间隔</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 样式1</span><br><span class="line">add_executable(app add.c div.c main.c mult.c sub.c)</span><br><span class="line"># 样式2</span><br><span class="line">add_executable(app add.c;div.c;main.c;mult.c;sub.c)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>执行<code>CMake</code> 命令</p>
<p>万事俱备只欠东风，将 CMakeLists.txt 文件编辑好之后，就可以执行 <code>cmake</code>命令了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line"># cmake 命令原型</span><br><span class="line">$ cmake CMakeLists.txt文件所在路径</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── div.c</span><br><span class="line">├── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br><span class="line"></span><br><span class="line">0 directories, 7 files</span><br><span class="line">robin@OS:~/Linux/3Day/calc$ cmake .</span><br></pre></td></tr></table></figure>

<p>当执行<code>cmake</code>命令之后，CMakeLists.txt 中的命令就会被执行，所以一定要注意给<code>cmake</code> 命令指定路径的时候一定不能出错。</p>
<p>执行命令之后，看一下源文件所在目录中是否多了一些文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── CMakeCache.txt         # new add file</span><br><span class="line">├── CMakeFiles             # new add dir</span><br><span class="line">├── cmake_install.cmake    # new add file</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── div.c</span><br><span class="line">├── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── Makefile               # new add file</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br></pre></td></tr></table></figure>

<p>我们可以看到在对应的目录下生成了一个<code>makefile</code>文件，此时再执行<code>make</code>命令，就可以对项目进行构建得到所需的可执行程序了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">$ make</span><br><span class="line">Scanning dependencies of target app</span><br><span class="line">[ 16%] Building C object CMakeFiles/app.dir/add.c.o</span><br><span class="line">[ 33%] Building C object CMakeFiles/app.dir/div.c.o</span><br><span class="line">[ 50%] Building C object CMakeFiles/app.dir/main.c.o</span><br><span class="line">[ 66%] Building C object CMakeFiles/app.dir/mult.c.o</span><br><span class="line">[ 83%] Building C object CMakeFiles/app.dir/sub.c.o</span><br><span class="line">[100%] Linking C executable app</span><br><span class="line">[100%] Built target app</span><br><span class="line"></span><br><span class="line"># 查看可执行程序是否已经生成</span><br><span class="line">$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── app					# 生成的可执行程序</span><br><span class="line">├── CMakeCache.txt</span><br><span class="line">├── CMakeFiles</span><br><span class="line">├── cmake_install.cmake</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── div.c</span><br><span class="line">├── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── Makefile</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br></pre></td></tr></table></figure>

<p>最终可执行程序<code>app</code>就被编译出来了（这个名字是在<code>CMakeLists.txt</code>中指定的）。</p>
</li>
</ol>
<h3 id="2-1-2-VIP-包房-cmake相关构建的文件都放到一个专门的文件比如build"><a href="#2-1-2-VIP-包房-cmake相关构建的文件都放到一个专门的文件比如build" class="headerlink" title="2.1.2 VIP 包房 cmake相关构建的文件都放到一个专门的文件比如build"></a>2.1.2 VIP 包房 cmake相关构建的文件都放到一个专门的文件比如build</h3><p>通过上面的例子可以看出，如果在<code>CMakeLists.txt</code>文件所在目录执行了<code>cmake</code>命令之后就会生成一些目录和文件（<code>包括 makefile 文件</code>），如果再基于<code>makefile文件</code>执行<code>make</code>命令，程序在编译过程中还会生成一些中间文件和一个可执行文件，这样会导致整个项目目录看起来很混乱，不太容易管理和维护，此时我们就可以把生成的这些与项目源码无关的文件统一放到一个对应的目录里边，比如将这个目录命名为<code>build</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">$ mkdir build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake ..</span><br><span class="line">-- The C compiler identification is GNU 5.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 5.4.0</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/robin/Linux/build</span><br></pre></td></tr></table></figure>

<p>现在<code>cmake</code>命令是在<code>build</code>目录中执行的，但是<code>CMakeLists.txt</code>文件是<code>build</code>目录的上一级目录中，所以<code>cmake </code>命令后指定的路径为<code>..</code>，即当前目录的上一级目录。</p>
<p>当命令执行完毕之后，在<code>build</code>目录中会生成一个<code>makefile</code>文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">$ tree build -L 1</span><br><span class="line">build</span><br><span class="line">├── CMakeCache.txt</span><br><span class="line">├── CMakeFiles</span><br><span class="line">├── cmake_install.cmake</span><br><span class="line">└── Makefile</span><br><span class="line"></span><br><span class="line">1 directory, 3 files</span><br></pre></td></tr></table></figure>

<p>这样就可以在<code>build</code>目录中执行<code>make</code>命令编译项目，生成的相关文件自然也就被存储到<code>build</code>目录中了。这样通过<code>cmake</code>和<code>make</code>生成的所有文件就全部和项目源文件隔离开了，各回各家，各找各妈。</p>
<h2 id="2-2-私人订制"><a href="#2-2-私人订制" class="headerlink" title="2.2 私人订制"></a>2.2 私人订制</h2><p>1.给自定义的变量设置值</p>
<p>2.给cmake提供的宏设置值</p>
<h3 id="2-2-1-定义变量-set"><a href="#2-2-1-定义变量-set" class="headerlink" title="2.2.1 定义变量 set"></a>2.2.1 定义变量 set</h3><p>在上面的例子中一共提供了5个源文件，假设这五个源文件需要反复被使用，每次都直接将它们的名字写出来确实是很麻烦，此时我们就需要定义一个变量，将文件名对应的字符串存储起来，在cmake里定义变量需要使用<code>set</code>。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SET 指令的语法是：</span></span><br><span class="line"><span class="comment"># [] 中的参数为可选项, 如不需要可以不写</span></span><br><span class="line"><span class="keyword">SET</span>(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>VAR</code>：变量名</li>
<li><code>VALUE</code>：变量值</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式1: 各个源文件之间使用空格间隔</span></span><br><span class="line"><span class="comment"># set(SRC_LIST add.c  div.c   main.c  mult.c  sub.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2: 各个源文件之间使用分号 ; 间隔</span></span><br><span class="line"><span class="keyword">set</span>(SRC_LIST add.c;div.c;main.c;mult.c;sub.c)</span><br><span class="line"><span class="keyword">add_executable</span>(app  <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;变量名&#125;</span>代表的就是原来设置的那些变量 可以理解为<span class="variable">$&#123;&#125;</span>把变量取了出来</span><br><span class="line"><span class="variable">$&#123;SRC_LIST&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="2-2-2-指定使用的C-标准"><a href="#2-2-2-指定使用的C-标准" class="headerlink" title="2.2.2 指定使用的C++标准"></a>2.2.2 指定使用的C++标准</h3><p>在编写C++程序的时候，可能会用到C++11、C++14、C++17、C++20等新特性，那么就需要在编译的时候在编译命令中制定出要使用哪个标准：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">$ g++ *.cpp -std=c++11 -o app</span><br></pre></td></tr></table></figure>

<p>上面的例子中通过参数<code>-std=c++11</code>指定出要使用c++11标准编译程序，C++标准对应有一宏叫做<code>DCMAKE_CXX_STANDARD</code>。在CMake中想要指定C++标准有两种方式：</p>
<ol>
<li><p>在 CMakeLists.txt 中通过 set 命令指定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">#增加-std=c++11</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line">#增加-std=c++14</span><br><span class="line">set(CMAKE_CXX_STANDARD 14)</span><br><span class="line">#增加-std=c++17</span><br><span class="line">set(CMAKE_CXX_STANDARD 17)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在执行 cmake 命令的时候指定出这个宏的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">#增加-std=c++11</span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=11</span><br><span class="line">#增加-std=c++14</span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=14</span><br><span class="line">#增加-std=c++17</span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=17</span><br></pre></td></tr></table></figure>

<p>在上面例子中 CMake 后的路径需要根据实际情况酌情修改。</p>
</li>
</ol>
<h3 id="2-2-3-指定输出的路径"><a href="#2-2-3-指定输出的路径" class="headerlink" title="2.2.3 指定输出的路径"></a>2.2.3 指定输出的路径</h3><p>在CMake中指定<strong>可执行程序输出的路径</strong>，也对应一个宏，叫做<code>EXECUTABLE_OUTPUT_PATH</code>，它的值还是通过<code>set</code>命令进行设置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">set(HOME /home/robin/Linux/Sort)</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;/bin)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一行：定义一个变量用于存储一个绝对路径</p>
</li>
<li><p>第二行：将拼接好的路径值设置给</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">EXECUTABLE_OUTPUT_PATH</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果这个路径中的子目录不存在，会自动生成，无需自己手动创建</strong></li>
</ul>
</li>
</ul>
<p>由于可执行程序是基于 cmake 命令生成的 makefile 文件然后再执行 make 命令得到的，所以如果此处指定可执行程序生成路径的时候使用的是相对路径 .&#x2F;xxx&#x2F;xxx，那么这个路径中的 .&#x2F; 对应的就是 makefile 文件所在的那个目录。</p>
<p>示例：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241102192437955.png" alt="image-20241102192437955"></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cmake完成本项目的最低所需版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="comment">#项目名称</span></span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="comment">#设置.cpp 变量</span></span><br><span class="line"><span class="keyword">SET</span>(SRC <span class="keyword">test</span>.cpp)</span><br><span class="line"><span class="comment">#设置可执行程序最后生成到那里</span></span><br><span class="line"><span class="keyword">SET</span>(EXECUTABLE_OUTPUT_PATH /home/darling/桌面/temp00/build)</span><br><span class="line"><span class="comment">#设置cpp标准 11 17 20</span></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment">#定义工程会生成一个可执行文件名 add_executable(可执行程序名 源文件名称)</span></span><br><span class="line"><span class="keyword">add_executable</span>(test00 <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-3-搜索文件"><a href="#2-3-搜索文件" class="headerlink" title="2.3 搜索文件"></a>2.3 搜索文件</h2><p>如果一个项目里边的源文件很多，在编写<code>CMakeLists.txt</code>文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦也不现实。所以，在CMake中为我们提供了搜索文件的命令，可以使用<code>aux_source_directory</code>命令或者<code>file</code>命令。</p>
<h3 id="2-3-1-方式1"><a href="#2-3-1-方式1" class="headerlink" title="2.3.1 方式1"></a>2.3.1 方式1</h3><p>在 CMake 中使用<code>aux_source_directory</code> 命令可以查找某个路径下的<code>所有源文件</code>，命令格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aux_source_directory(&lt; dir &gt; &lt; variable &gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dir</code>：要搜索的目录</li>
<li><code>variable</code>：将从<code>dir</code>目录下搜索到的源文件列表存储到该变量中，该变量不需要提前准备，只要在这个句子中第一次出现就会被创建</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 搜索 src 目录下的源文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src SRC_LIST)</span><br><span class="line"><span class="keyword">add_executable</span>(app  <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PROJECT_SOURCE_DIR 这个宏表示的路径就是我们cmake的时候cmake后面跟着的那个路径</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-方式2"><a href="#2-3-2-方式2" class="headerlink" title="2.3.2 方式2"></a>2.3.2 方式2</h3><p>如果一个项目里边的源文件很多，在编写<code>CMakeLists.txt</code>文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦了。所以，在CMake中为我们提供了搜索文件的命令，他就是<code>file（当然，除了搜索以外通过 file 还可以做其他事情）</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>GLOB</code>: 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。</li>
<li><code>GLOB_RECURSE</code>：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。</li>
</ul>
<p><strong>搜索当前目录的src目录下所有的源文件，并存储到变量中</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file(GLOB MAIN_SRC $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp)</span><br><span class="line">file(GLOB MAIN_HEAD $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include/*.h)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>CMAKE_CURRENT_SOURCE_DIR 宏表示当前访问的 CMakeLists.txt 文件所在的路径。</p>
</li>
<li><p>关于要搜索的文件路径和类型可加双引号，也可不加:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file(GLOB MAIN_HEAD &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.h&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-4-包含头文件"><a href="#2-4-包含头文件" class="headerlink" title="2.4 包含头文件"></a>2.4 包含头文件</h2><p>在编译项目源文件的时候，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能够找到这些头文件，并顺利通过编译。在CMake中设置要包含的目录也很简单，通过一个命令就可以搞定了，他就是<code>include_directories</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">include_directories(headpath)</span><br></pre></td></tr></table></figure>

<p>举例说明，有源文件若干，其目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c++</span><br><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">└── src</span><br><span class="line">    ├── add.cpp</span><br><span class="line">    ├── div.cpp</span><br><span class="line">    ├── main.cpp</span><br><span class="line">    ├── mult.cpp</span><br><span class="line">    └── sub.cpp</span><br><span class="line"></span><br><span class="line">3 directories, 7 files</span><br></pre></td></tr></table></figure>

<p><code>CMakeLists.txt</code>文件内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(CALC)</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line">set(HOME /home/robin/Linux/calc)</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;/bin/)</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line">file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp)</span><br><span class="line">add_executable(app  $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure>

<p>其中，第六行指定就是头文件的路径，<code>PROJECT_SOURCE_DIR</code>宏对应的值就是我们在使用cmake命令时，后面紧跟的目录，一般是工程的根目录。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241102194858709.png" alt="image-20241102194858709"></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cmake完成本项目的最低所需版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="comment">#项目名称</span></span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置.cpp 变量</span></span><br><span class="line"><span class="comment">#SET(SRC test.cpp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#自动搜索.cpp文件 方法1</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src SRC)</span><br><span class="line"><span class="comment">#方法2</span></span><br><span class="line"><span class="comment">#file(GLOB SRC $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定头文件目录</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置可执行程序最后生成到那里</span></span><br><span class="line"><span class="keyword">SET</span>(EXECUTABLE_OUTPUT_PATH /home/darling/桌面/temp002/build)</span><br><span class="line"><span class="comment">#设置cpp标准 11 17 20</span></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="comment">#定义工程会生成一个可执行文件名 add_executable(可执行程序名 源文件名称)</span></span><br><span class="line"><span class="keyword">add_executable</span>(sort <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-5-制作动态库或静态库"><a href="#2-5-制作动态库或静态库" class="headerlink" title="2.5 制作动态库或静态库"></a>2.5 制作动态库或静态库</h2><p>有些时候我们编写的源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面来讲解在cmake中生成这两类库文件的方法。</p>
<p>发布的时候发两个东西</p>
<p>1.头文件</p>
<p>2.自己制作的库，不然库里只有实现，我们也调用不了接口</p>
<h3 id="2-5-0库的名称格式"><a href="#2-5-0库的名称格式" class="headerlink" title="2.5.0库的名称格式"></a>2.5.0库的名称格式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//库的名称：xxx比如mysql吧</span></span><br><span class="line"><span class="comment">//lib+库名称+xxx+后缀</span></span><br><span class="line">linux：</span><br><span class="line">静态库：libmysql.a</span><br><span class="line">动态库：libmysql.so</span><br><span class="line">windows:</span><br><span class="line">静态库：libmysql.lib</span><br><span class="line">动态库：libmysql.dll</span><br></pre></td></tr></table></figure>

<p>我们操控的一般是xxx部分，前面的lib是固定死的，后面的后缀也就是这四种里面挑</p>
<h3 id="2-5-1-制作静态库"><a href="#2-5-1-制作静态库" class="headerlink" title="2.5.1 制作静态库"></a>2.5.1 制作静态库</h3><p>在cmake中，如果要制作静态库，需要使用的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_library(库名称 STATIC 源文件1 [源文件2] ...) </span><br></pre></td></tr></table></figure>

<p>在Linux中，静态库名字分为三部分：<code>lib</code>+<code>库名字</code>+<code>.a</code>，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。</p>
<p>在Windows中虽然库名和Linux格式不同，但也只需指定出名字即可。</p>
<p>下面有一个目录，需要将<code>src</code>目录中的源文件编译成静态库，然后再使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include           # 头文件目录</span><br><span class="line">│   └── head.h</span><br><span class="line">├── main.cpp          # 用于测试的源文件</span><br><span class="line">└── src               # 源文件目录</span><br><span class="line">    ├── add.cpp</span><br><span class="line">    ├── div.cpp</span><br><span class="line">    ├── mult.cpp</span><br><span class="line">    └── sub.cpp</span><br></pre></td></tr></table></figure>

<p>根据上面的目录结构，可以这样编写<code>CMakeLists.txt</code>文件:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>这样最终就会生成对应的静态库文件<code>libcalc.a</code>。</p>
<h3 id="2-5-2-制作动态库"><a href="#2-5-2-制作动态库" class="headerlink" title="2.5.2 制作动态库"></a>2.5.2 制作动态库</h3><p>在cmake中，如果要制作动态库，需要使用的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_library(库名称 SHARED 源文件1 [源文件2] ...) </span><br></pre></td></tr></table></figure>

<p>在Linux中，动态库名字分为三部分：<code>lib</code>+<code>库名字</code>+<code>.so</code>，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。</p>
<p>在Windows中虽然库名和Linux格式不同，但也只需指定出名字即可。</p>
<p>根据上面的目录结构，可以这样编写<code>CMakeLists.txt</code>文件:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(calc SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>这样最终就会生成对应的动态库文件<code>libcalc.so</code>。</p>
<h3 id="2-5-3-指定输出的路径"><a href="#2-5-3-指定输出的路径" class="headerlink" title="2.5.3 指定输出的路径"></a>2.5.3 指定输出的路径</h3><p>如果不指定的话，就生成到当前的构建目录里面</p>
<h4 id="方式1-适用于动态库"><a href="#方式1-适用于动态库" class="headerlink" title="方式1 - 适用于动态库"></a>方式1 - 适用于动态库</h4><p>对于生成的库文件来说和可执行程序一样都可以指定输出路径。<code>由于在Linux下生成的动态库默认是有执行权限的</code>，所以可以按照生成可执行程序的方式去指定它生成的目录：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="comment"># 设置动态库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="keyword">add_library</span>(calc SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>对于这种方式来说，其实就是通过<code>set</code>命令给<code>EXECUTABLE_OUTPUT_PATH</code>宏设置了一个路径，这个路径就是可执行文件生成的路径。</p>
<h4 id="方式2-都适用"><a href="#方式2-都适用" class="headerlink" title="方式2 - 都适用"></a>方式2 - 都适用</h4><p>由于在Linux下生成的静态库默认不具有可执行权限，所以在指定静态库生成的路径的时候就不能使用<code>EXECUTABLE_OUTPUT_PATH</code>宏了，而应该使用<code>LIBRARY_OUTPUT_PATH</code>，这个宏对应静态库文件和动态库文件都适用。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="comment"># 设置动态库/静态库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="comment">#add_library(calc SHARED $&#123;SRC_LIST&#125;)</span></span><br><span class="line"><span class="comment"># 生成静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-6-包含库文件"><a href="#2-6-包含库文件" class="headerlink" title="2.6 包含库文件"></a>2.6 包含库文件</h2><p>在编写程序的过程中，可能会用到一些系统提供的动态库或者自己制作出的动态库或者静态库文件，cmake中也为我们提供了相关的加载动态库的命令。</p>
<h3 id="2-6-1-链接静态库"><a href="#2-6-1-链接静态库" class="headerlink" title="2.6.1 链接静态库"></a>2.6.1 链接静态库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">├── add.cpp</span><br><span class="line">├── div.cpp</span><br><span class="line">├── main.cpp</span><br><span class="line">├── mult.cpp</span><br><span class="line">└── sub.cpp</span><br></pre></td></tr></table></figure>

<p>现在我们把上面<code>src</code>目录中的<code>add.cpp、div.cpp、mult.cpp、sub.cpp</code>编译成一个静态库文件<code>libcalc.a</code>。<a href="https://subingwen.cn/linux/library/#1-1-%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93">通过命令制作并使用静态链接库</a></p>
<p>测试目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tree </span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.a     # 制作出的静态库的名字</span><br><span class="line">└── src</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br><span class="line">4 directories, 4 files</span><br></pre></td></tr></table></figure>

<p>在cmake中，链接静态库的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">link_libraries(&lt;static lib&gt; [&lt;static lib&gt;...])</span><br></pre></td></tr></table></figure>

<p>用于设置全局链接库，这些库会链接到之后定义的所有目标上。</p>
<ul>
<li><p>参数1</p>
<p>：指定出要链接的静态库的名字</p>
<ul>
<li>可以是全名 <code>libxxx.a</code></li>
<li>也可以是掐头（<code>lib</code>）去尾（<code>.a</code>）之后的名字 <code>xxx</code></li>
</ul>
</li>
<li><p><strong>参数2-N</strong>：要链接的其它静态库的名字，表示可以链接很多个静态库而不是一个</p>
</li>
</ul>
<p>如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">link_directories(&lt;lib path&gt;)</span><br></pre></td></tr></table></figure>

<p>这样，修改之后的<code>CMakeLists.txt</code>文件内容如下:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="comment"># 搜索指定目录下源文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="comment"># 包含头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#重点</span></span><br><span class="line"><span class="comment"># 包含静态库路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 链接静态库</span></span><br><span class="line"><span class="keyword">link_libraries</span>(calc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>添加了第8行的代码，就可以根据参数指定的路径找到这个静态库了。</p>
<p>add_executable一定要放在链接库的后面</p>
<p>如果使用的是静态库，静态库和使用的源文件都会被打包到可执行程序里面去</p>
<h3 id="2-6-2-链接动态库"><a href="#2-6-2-链接动态库" class="headerlink" title="2.6.2 链接动态库"></a>2.6.2 链接动态库</h3><p>在程序编写过程中，除了在项目中引入静态库，好多时候也会使用一些标准的或者第三方提供的一些动态库，关于动态库的制作、使用以及在内存中的加载方式和静态库都是不同的，在此不再过多赘述，如有疑惑请参考<a href="https://subingwen.cn/linux/library/">Linux 静态库和动态库</a></p>
<p>在<code>cmake</code>中链接动态库的命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target_link_libraries(</span><br><span class="line">    &lt;target&gt; </span><br><span class="line">    &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;... </span><br><span class="line">    [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)</span><br></pre></td></tr></table></figure>

<p>用于指定一个目标（如可执行文件或库）在编译时需要链接哪些库。它支持指定库的名称、路径以及链接库的顺序。</p>
<ul>
<li><p><strong>target</strong>：指定要加载的库的文件的名字</p>
<ul>
<li>该文件可能是一个源文件</li>
<li>该文件可能是一个动态库&#x2F;静态库文件</li>
<li>该文件可能是一个可执行文件</li>
</ul>
</li>
<li><p><strong>PRIVATE|PUBLIC|INTERFACE</strong>：动态库的访问权限，默认为<code>PUBLIC</code></p>
<ul>
<li><p>如果各个动态库之间没有依赖关系，无需做任何设置，三者没有没有区别，一般无需指定，使用默认的 PUBLIC 即可。</p>
</li>
<li><p><code>动态库的链接具有传递性</code>，如果动态库 A 链接了动态库B、C，动态库D链接了动态库A，此时动态库D相当于也链接了动态库B、C，并可以使用动态库B、C中定义的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target_link_libraries(A B C)</span><br><span class="line">target_link_libraries(D A)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PUBLIC</code>：在public后面的库会被Link到前面的target中，并且里面的符号也会被导出，提供给第三方使用。</li>
<li><code>PRIVATE</code>：在private后面的库仅被link到前面的target中，并且终结掉，第三方不能感知你调了啥库</li>
<li><code>INTERFACE</code>：在interface后面引入的库不会被链接到前面的target中，只会导出符号。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="链接系统动态库"><a href="#链接系统动态库" class="headerlink" title="链接系统动态库"></a>链接系统动态库</h4><p>动态库的链接和静态库是完全不同的：</p>
<ul>
<li>静态库会在生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了。</li>
<li>动态库在生成可执行程序的链接阶段<strong>不会</strong>被打包到可执行程序中，当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存</li>
</ul>
<p>因此，在<code>cmake</code>中指定要链接的动态库的时候，<code>应该将命令写到生成了可执行文件之后：</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(TEST)</span><br><span class="line">file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp)</span><br><span class="line"># 添加并指定最终生成的可执行程序名</span><br><span class="line">add_executable(app $&#123;SRC_LIST&#125;)</span><br><span class="line"># 指定可执行程序要链接的动态库名字</span><br><span class="line">target_link_libraries(app pthread)</span><br></pre></td></tr></table></figure>

<p>在<code>target_link_libraries(app pthread)</code>中：</p>
<ul>
<li><code>app:</code> 对应的是最终生成的可执行程序的名字</li>
<li><code>pthread</code>：这是可执行程序要加载的动态库，这个库是系统提供的线程库，全名为<code>libpthread.so</code>，在指定的时候一般会掐头（lib）去尾（.so）。</li>
</ul>
<h4 id="链接第三方动态库"><a href="#链接第三方动态库" class="headerlink" title="链接第三方动态库"></a>链接第三方动态库</h4><p>现在，自己生成了一个动态库，对应的目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tree </span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h            # 动态库对应的头文件</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.so        # 自己制作的动态库文件</span><br><span class="line">└── main.cpp              # 测试用的源文件</span><br><span class="line"></span><br><span class="line">3 directories, 4 files</span><br></pre></td></tr></table></figure>

<p>假设在测试文件<code>main.cpp</code>中既使用了自己制作的动态库<code>libcalc.so</code>又使用了系统提供的线程库，此时<code>CMakeLists.txt</code>文件可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(TEST)</span><br><span class="line">file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp)</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line">add_executable(app $&#123;SRC_LIST&#125;)</span><br><span class="line">target_link_libraries(app pthread calc)</span><br></pre></td></tr></table></figure>

<p>在<strong>第六行</strong>中，<code>pthread、calc</code>都是可执行程序<code>app</code>要链接的动态库的名字。当可执行程序<code>app</code>生成之后并执行该文件，会提示有如下错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./app </span><br><span class="line">./app: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<p>这是因为可执行程序启动之后，去加载<code>calc</code>这个动态库，但是不知道这个动态库被放到了什么位置<a href="https://subingwen.cn/linux/library/#2-4-1-%E5%BA%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">解决动态库无法加载的问题</a>，所以就加载失败了，在 CMake 中可以在生成可执行程序之前，通过命令指定出要链接的动态库的位置，指定静态库位置使用的也是这个命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">link_directories(path)</span><br></pre></td></tr></table></figure>

<p>所以修改之后的<code>CMakeLists.txt</code>文件应该是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(TEST)</span><br><span class="line">file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp)</span><br><span class="line"># 指定源文件或者动态库对应的头文件路径</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line"># 指定要链接的动态库的路径</span><br><span class="line">link_directories($&#123;PROJECT_SOURCE_DIR&#125;/lib)</span><br><span class="line"># 添加并生成一个可执行程序</span><br><span class="line">add_executable(app $&#123;SRC_LIST&#125;)</span><br><span class="line"># 指定要链接的动态库</span><br><span class="line">target_link_libraries(app pthread calc)</span><br></pre></td></tr></table></figure>

<p>通过<code>link_directories</code>指定了动态库的路径之后，在执行生成的可执行程序的时候，就不会出现找不到动态库的问题了。</p>
<h3 id="2-6-3-总结"><a href="#2-6-3-总结" class="headerlink" title="2.6.3 总结"></a>2.6.3 总结</h3><p>温馨提示：target_link_libraries 和 link_libraries 是 CMake 中用于链接库的两个命令，都可以用于链接动态库和静态库，但它们的使用场景和功能有所不同。下面是关于二者的总结：</p>
<p><strong>target_link_libraries</strong></p>
<ul>
<li><p><strong>功能</strong>: <code>target_link_libraries</code> 用于指定一个目标（如可执行文件或库）在编译时需要链接哪些库。它支持指定库的名称、路径以及链接库的顺序。</p>
</li>
<li><p><strong>语法</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target_link_libraries(target_name [item1 [item2 [...]]]</span><br><span class="line">                      [&lt;debug|optimized|general&gt; &lt;lib1&gt; [&lt;lib2&gt; [...]]])</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点</strong>:</p>
<ul>
<li>更精确地控制目标的链接库。</li>
<li>可以指定库的不同链接条件（如调试版本、发布版本）。</li>
<li>支持多个目标和多个库之间的复杂关系。</li>
<li>更加灵活和易于维护，特别是在大型项目中。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_executable(my_executable main.cpp)</span><br><span class="line">target_link_libraries(my_executable PRIVATE my_dynamic_library)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>link_libraries</strong></p>
<ul>
<li><p><strong>功能</strong>: <code>link_libraries</code> 用于设置全局链接库，这些库会链接到之后定义的所有目标上。它会影响所有的目标，适用于全局设置，但不如 <code>target_link_libraries</code> 精确。</p>
</li>
<li><p><strong>语法</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">link_libraries(lib1 lib2 [...])</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>缺点</strong>:</p>
<ul>
<li>缺乏针对具体目标的控制，不适合复杂的项目结构。</li>
<li>容易导致意外的依赖关系，因为它对所有目标都生效。</li>
<li>一旦设置，全局影响可能导致难以追踪的链接问题。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">link_libraries(my_static_library)</span><br><span class="line">add_executable(my_executable main.cpp)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><strong><code>target_link_libraries</code></strong> 是更推荐的方式，因为它允许更精确的控制和管理链接库的依赖，特别是在大型项目中，它能够避免全局设置可能带来的问题。</li>
<li><strong><code>link_libraries</code></strong> 虽然简单，但在复杂的项目中可能会导致意外的问题，通常适用于简单的项目或临时设置。</li>
</ul>
<p>建议在 CMake 项目中优先使用 <code>target_link_libraries</code>。</p>
<h2 id="2-7-日志"><a href="#2-7-日志" class="headerlink" title="2.7 日志"></a>2.7 日志</h2><p>在CMake中可以用用户显示一条消息，该命令的名字为<code>message</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] &quot;message to display&quot; ...)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>(无) </code>：重要消息</li>
<li><code>STATUS</code> ：非重要消息</li>
<li><code>WARNING</code>：CMake 警告, 会继续执行</li>
<li><code>AUTHOR_WARNING</code>：CMake 警告 (dev), 会继续执行</li>
<li><code>SEND_ERROR</code>：CMake 错误, 继续执行，但是会跳过生成的步骤</li>
<li><code>FATAL_ERROR</code>：CMake 错误, 终止所有处理过程</li>
</ul>
<p>CMake的命令行工具会在stdout上显示<code>STATUS</code>消息，在stderr上显示其他所有消息。CMake的GUI会在它的log区域显示所有消息。</p>
<p>CMake警告和错误消息的文本显示使用的是一种简单的标记语言。文本没有缩进，超过长度的行会回卷，段落之间以新行做为分隔符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 输出一般日志信息</span><br><span class="line">message(STATUS &quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;)</span><br><span class="line"># 输出警告信息</span><br><span class="line">message(WARNING &quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;)</span><br><span class="line"># 输出错误信息</span><br><span class="line">message(FATAL_ERROR &quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="2-8-变量操作"><a href="#2-8-变量操作" class="headerlink" title="2.8 变量操作"></a>2.8 变量操作</h2><h3 id="2-8-1-追加"><a href="#2-8-1-追加" class="headerlink" title="2.8.1 追加"></a>2.8.1 追加</h3><p>有时候项目中的源文件并不一定都在同一个目录中，但是这些源文件最终却需要一起进行编译来生成最终的可执行文件或者库文件。如果我们通过<code>file</code>命令对各个目录下的源文件进行搜索，最后还需要做一个字符串拼接的操作，关于字符串拼接可以使用<code>set</code>命令也可以使用<code>list</code>命令。</p>
<h4 id="使用set拼接"><a href="#使用set拼接" class="headerlink" title="使用set拼接"></a>使用set拼接</h4><p>如果使用set进行字符串拼接，对应的命令格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(变量名1 $&#123;变量名1&#125; $&#123;变量名2&#125; ...)</span><br></pre></td></tr></table></figure>

<p>关于上面的命令其实就是将从第二个参数开始往后所有的字符串进行拼接，<strong>最后将结果存储到第一个参数中，如果第一个参数中原来有数据会对原数据就行覆盖。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(TEST)</span><br><span class="line">set(TEMP &quot;hello,world&quot;)</span><br><span class="line">file(GLOB SRC_1 $&#123;PROJECT_SOURCE_DIR&#125;/src1/*.cpp)</span><br><span class="line">file(GLOB SRC_2 $&#123;PROJECT_SOURCE_DIR&#125;/src2/*.cpp)</span><br><span class="line"># 追加(拼接)</span><br><span class="line">set(SRC_1 $&#123;SRC_1&#125; $&#123;SRC_2&#125; $&#123;TEMP&#125;)</span><br><span class="line">message(STATUS &quot;message: $&#123;SRC_1&#125;&quot;)</span><br></pre></td></tr></table></figure>

<h4 id="使用list拼接"><a href="#使用list拼接" class="headerlink" title="使用list拼接"></a>使用list拼接</h4><p>如果使用list进行字符串拼接，对应的命令格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list(APPEND &lt;list&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></table></figure>

<p><code>list</code>命令的功能比<code>set</code>要强大，字符串拼接只是它的其中一个功能，所以需要在它第一个参数的位置指定出我们要做的操作，<code>APPEND</code>表示进行数据追加，后边的参数和<code>set</code>就一样了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(TEST)</span><br><span class="line">set(TEMP &quot;hello,world&quot;)</span><br><span class="line">file(GLOB SRC_1 $&#123;PROJECT_SOURCE_DIR&#125;/src1/*.cpp)</span><br><span class="line">file(GLOB SRC_2 $&#123;PROJECT_SOURCE_DIR&#125;/src2/*.cpp)</span><br><span class="line"># 追加(拼接)</span><br><span class="line">list(APPEND SRC_1 $&#123;SRC_1&#125; $&#123;SRC_2&#125; $&#123;TEMP&#125;)</span><br><span class="line">message(STATUS &quot;message: $&#123;SRC_1&#125;&quot;)</span><br></pre></td></tr></table></figure>

<p>在CMake中，使用<code>set</code>命令可以创建一个<code>list</code>。一个在<code>list</code>内部是一个由<code>分号;</code>分割的一组字符串。例如，<code>set(var a b c d e)</code>命令将会创建一个<code>list:a;b;c;d;e</code>，但是最终打印变量值的时候得到的是<code>abcde</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(tmp1 a;b;c;d;e)</span><br><span class="line">set(tmp2 a b c d e)</span><br><span class="line">message($&#123;tmp1&#125;)</span><br><span class="line">message($&#123;tmp2&#125;)</span><br></pre></td></tr></table></figure>

<p>输出的结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">abcde</span><br><span class="line">abcde</span><br></pre></td></tr></table></figure>

<h3 id="2-8-2-字符串移除"><a href="#2-8-2-字符串移除" class="headerlink" title="2.8.2 字符串移除"></a>2.8.2 字符串移除</h3><p>我们在通过<code>file</code>搜索某个目录就得到了该目录下所有的源文件，但是其中有些源文件并不是我们所需要的，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── add.cpp</span><br><span class="line">├── div.cpp</span><br><span class="line">├── main.cpp</span><br><span class="line">├── mult.cpp</span><br><span class="line">└── sub.cpp</span><br><span class="line"></span><br><span class="line">0 directories, 5 files</span><br></pre></td></tr></table></figure>

<p>在当前这么目录有五个源文件，其中<code>main.cpp</code>是一个测试文件。如果我们想要把计算器相关的源文件生成一个动态库给别人使用，那么只需要<code>add.cpp、div.cp、mult.cpp、sub.cpp</code>这四个源文件就可以了。此时，就需要将<code>main.cpp</code>从搜索到的数据中剔除出去，想要实现这个功能，也可以使用<code>list</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list(REMOVE_ITEM &lt;list&gt; &lt;value&gt; [&lt;value&gt; ...])</span><br></pre></td></tr></table></figure>

<p>通过上面的命令原型可以看到删除和追加数据类似，只不过是第一个参数变成了<code>REMOVE_ITEM</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(TEST)</span><br><span class="line">set(TEMP &quot;hello,world&quot;)</span><br><span class="line">file(GLOB SRC_1 $&#123;PROJECT_SOURCE_DIR&#125;/*.cpp)</span><br><span class="line"># 移除前日志</span><br><span class="line">message(STATUS &quot;message: $&#123;SRC_1&#125;&quot;)</span><br><span class="line"># 移除 main.cpp</span><br><span class="line">list(REMOVE_ITEM SRC_1 $&#123;PROJECT_SOURCE_DIR&#125;/main.cpp)</span><br><span class="line"># 移除后日志</span><br><span class="line">message(STATUS &quot;message: $&#123;SRC_1&#125;&quot;)</span><br></pre></td></tr></table></figure>

<p>可以看到，在<code>第8行</code>把将要移除的文件的名字指定给<code>list</code>就可以了。但是一定要注意通过 file 命令搜索源文件的时候得到的是文件的绝对路径（在list中每个文件对应的路径都是一个item，并且都是绝对路径），那么在移除的时候也要将该文件的绝对路径指定出来才可以，否是移除操作不会成功。</p>
<p>关于<code>list</code>命令还有其它功能，但是并不常用，在此就不一一进行举例介绍了。</p>
<ol>
<li><p>获取 list 的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list(LENGTH &lt;list&gt; &lt;output variable&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>LENGTH</code>：子命令LENGTH用于读取列表长度</li>
<li><code>&lt;list&gt;</code>：当前操作的列表</li>
<li><code>&lt;output variable&gt;</code>：新创建的变量，用于存储列表的长度。</li>
</ul>
</li>
<li><p>读取列表中指定索引的的元素，可以指定多个索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list(GET &lt;list&gt; &lt;element index&gt; [&lt;element index&gt; ...] &lt;output variable&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;list&gt;</code>：当前操作的列表</p>
</li>
<li><pre><code>&lt;element index&gt;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">     ：列表元素的索引</span><br><span class="line"></span><br><span class="line">     - 从0开始编号，索引0的元素为列表中的第一个元素；</span><br><span class="line">     - 索引也可以是负数，`-1`表示列表的最后一个元素，`-2`表示列表倒数第二个元素，以此类推</span><br><span class="line">     - 当索引（不管是正还是负）超过列表的长度，运行会报错</span><br><span class="line"></span><br><span class="line">   - `&lt;output variable&gt;`：新创建的变量，存储指定索引元素的返回结果，也是一个列表。</span><br><span class="line"></span><br><span class="line">3. 将列表中的元素用连接符（字符串）连接起来组成一个字符串</span><br><span class="line"></span><br></pre></td></tr></table></figure>
list (JOIN &lt;list&gt; &lt;glue&gt; &lt;output variable&gt;)
</code></pre>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   - `&lt;list&gt;`：当前操作的列表</span><br><span class="line">   - `&lt;glue&gt;`：指定的连接符（字符串）</span><br><span class="line">   - `&lt;output variable&gt;`：新创建的变量，存储返回的字符串</span><br><span class="line"></span><br><span class="line">4. 查找列表是否存在指定的元素，若果未找到，返回-1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>list(FIND <list> <value> <output variable>)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `&lt;list&gt;`：当前操作的列表</span><br><span class="line"></span><br><span class="line">- `&lt;value&gt;`：需要再列表中搜索的元素</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  &lt;output variable&gt;</span><br></pre></td></tr></table></figure>

<p>  ：新创建的变量</p>
<ul>
<li>如果列表<code>&lt;list&gt;</code>中存在<code>&lt;value&gt;</code>，那么返回<code>&lt;value&gt;</code>在列表中的索引</li>
<li>如果未找到则返回-1。</li>
</ul>
</li>
<li><p>将元素追加到列表中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list (APPEND &lt;list&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></table></figure>
</li>
<li><p>在list中指定的位置插入若干元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list(INSERT &lt;list&gt; &lt;element_index&gt; &lt;element&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></table></figure>
</li>
<li><p>将元素插入到列表的0索引位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list (PREPEND &lt;list&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></table></figure>
</li>
<li><p>将列表中最后元素移除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list (POP_BACK &lt;list&gt; [&lt;out-var&gt;...])</span><br></pre></td></tr></table></figure>
</li>
<li><p>将列表中第一个元素移除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list (POP_FRONT &lt;list&gt; [&lt;out-var&gt;...])</span><br></pre></td></tr></table></figure>
</li>
<li><p>将指定的元素从列表中移除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list (REMOVE_ITEM &lt;list&gt; &lt;value&gt; [&lt;value&gt; ...])</span><br></pre></td></tr></table></figure>
</li>
<li><p>将指定索引的元素从列表中移除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list (REMOVE_AT &lt;list&gt; &lt;index&gt; [&lt;index&gt; ...])</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除列表中的重复元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list (REMOVE_DUPLICATES &lt;list&gt;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表翻转</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list(REVERSE &lt;list&gt;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list (SORT &lt;list&gt; [COMPARE &lt;compare&gt;] [CASE &lt;case&gt;] [ORDER &lt;order&gt;])</span><br></pre></td></tr></table></figure>

<ul>
<li><pre><code>COMPARE
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ：指定排序方法。有如下几种值可选：</span><br><span class="line"></span><br><span class="line">  - `STRING`:按照字母顺序进行排序，为默认的排序方法</span><br><span class="line">  - `FILE_BASENAME`：如果是一系列路径名，会使用basename进行排序</span><br><span class="line">  - `NATURAL`：使用自然数顺序排序</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  CASE</span><br></pre></td></tr></table></figure>

：指明是否大小写敏感。有如下几种值可选：

- `SENSITIVE`: 按照大小写敏感的方式进行排序，为默认值
- `INSENSITIVE`：按照大小写不敏感方式进行排序
</code></pre>
</li>
<li><pre><code>ORDER
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      ：指明排序的顺序。有如下几种值可选：</span><br><span class="line"></span><br><span class="line">      - `ASCENDING`:按照升序排列，为默认值</span><br><span class="line">      - `DESCENDING`：按照降序排列</span><br><span class="line"></span><br><span class="line">## 2.9 宏定义</span><br><span class="line"></span><br><span class="line">在进行程序测试的时候，我们可以在代码中添加一些宏定义，通过这些宏来控制这些代码是否生效，如下所示：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ol>
<p>#include &lt;stdio.h&gt;<br>#define NUMBER  3</p>
<p>int main()<br>{<br>    int a &#x3D; 10;<br>#ifdef DEBUG<br>    printf(“我是一个程序猿, 我不会爬树…\n”);<br>#endif<br>    for(int i&#x3D;0; i&lt;NUMBER; ++i)<br>    {<br>        printf(“hello, GCC!!!\n”);<br>    }<br>    return 0;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在程序的第七行对`DEBUG`宏进行了判断，如果该宏被定义了，那么第八行就会进行日志输出，如果没有定义这个宏，第八行就相当于被注释掉了，因此最终无法看到日志输入出（**上述代码中并没有定义这个宏**）。</span><br><span class="line"></span><br><span class="line">为了让测试更灵活，我们可以不在代码中定义这个宏，而是在测试的时候去把它定义出来，其中一种方式就是在`gcc/g++`命令中去指定，如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$ gcc test.c -DDEBUG -o app</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在`gcc/g++`命令中通过参数 `-D`指定出要定义的宏的名字，这样就相当于在代码中定义了一个宏，其名字为`DEBUG`。</span><br><span class="line"></span><br><span class="line">在`CMake`中我们也可以做类似的事情，对应的命令叫做`add_definitions`:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>add_definitions(-D宏名称)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">针对于上面的源文件编写一个`CMakeLists.txt`，内容如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>cmake_minimum_required(VERSION 3.0)<br>project(TEST)</p>
<h1 id="自定义-DEBUG-宏"><a href="#自定义-DEBUG-宏" class="headerlink" title="自定义 DEBUG 宏"></a>自定义 DEBUG 宏</h1><p>add_definitions(-DDEBUG)<br>add_executable(app .&#x2F;test.c)</p>
<pre><code>
通过这种方式，上述代码中的第八行日志就能够被输出出来了。

# 3. 预定义宏

下面的列表中为大家整理了一些`CMake`中常用的宏：

| 宏                       | 功能                                                         |
| ------------------------ | ------------------------------------------------------------ |
| PROJECT_SOURCE_DIR       | 使用cmake命令后紧跟的目录，一般是工程的根目录                |
| PROJECT_BINARY_DIR       | 执行cmake命令的目录                                          |
| CMAKE_CURRENT_SOURCE_DIR | 当前处理的CMakeLists.txt所在的路径                           |
| CMAKE_CURRENT_BINARY_DIR | target 编译目录                                              |
| EXECUTABLE_OUTPUT_PATH   | 重新定义目标二进制可执行文件的存放位置                       |
| LIBRARY_OUTPUT_PATH      | 重新定义目标链接库文件的存放位置                             |
| PROJECT_NAME             | 返回通过PROJECT指令定义的项目名称                            |
| CMAKE_BINARY_DIR         | 项目实际构建路径，假设在`build`目录进行的构建，那么得到的就是这个目录的路径 |
</code></pre>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>好用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc 命令详解及最佳实践</title>
    <url>/2024/11/11/%E5%B7%A5%E5%85%B7/gcc%20%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="gcc-命令详解及最佳实践"><a href="#gcc-命令详解及最佳实践" class="headerlink" title="gcc 命令详解及最佳实践"></a>gcc 命令详解及最佳实践</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>GCC（英文全拼：GNU <a href="https://so.csdn.net/so/search?q=Compiler&spm=1001.2101.3001.7020">Compiler</a> Collection）是 GNU 工具链的主要组成部分，是一套以 GPL 和 LGPL 许可证发布的程序语言编译器自由软件，由 Richard Stallman 于 1985 年开始开发。</p>
<p>GCC 原名为 GNU C语言编译器，因为它原本只能处理 C 语言，但如今的 GCC 不仅可以编译 C、C++ 和 Objective-C，还可以通过不同的前端模块支持各种语言，包括 Java、Fortran、Ada、Pascal、Go 和 D 语言等等。</p>
<h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>GCC 的编译过程可以划分为四个阶段：预处理（Pre-Processing）、编译（Compiling）、汇编（Assembling）以及链接（Linking）。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/89290b9ad09e97b78b98e83890892b32.png" alt="img"></p>
<p>Linux 程序员可以根据自己的需要控制 GCC 的编译阶段，以便检查或使用编译器在该阶段的输出信息，帮助调试和优化程序。以 C 语言为例，从源文件的编译到可执行文件的运行，整个过程大致如下。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/441841885094a1f1cbe03182d0032338.png" alt="img"></p>
<p>各文件后缀说明如下：</p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>描述</th>
<th>后缀</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.c</td>
<td>C 源文件</td>
<td>.s&#x2F;.S</td>
<td>汇编语言源文件</td>
</tr>
<tr>
<td>.C&#x2F;.cc&#x2F;.cxx&#x2F;.cpp</td>
<td>C++ 源文件</td>
<td>.o&#x2F;.obj</td>
<td>目标文件</td>
</tr>
<tr>
<td>.h</td>
<td>C&#x2F;C++ 头文件</td>
<td>.a&#x2F;.lib</td>
<td>静态库</td>
</tr>
<tr>
<td>.i&#x2F;.ii</td>
<td>经过预处理的 C&#x2F;C++ 文件</td>
<td>.so&#x2F;.dll</td>
<td>动态库</td>
</tr>
</tbody></table>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc [options] file...</span><br></pre></td></tr></table></figure>

<h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><ul>
<li><code>-pass-exit-codes</code> ：从一个阶段以最高错误代码退出。</li>
<li><code>--target-help</code> ：显示特定于目标的命令行选项。</li>
<li><code>--help=&#123;common|optimizers|params|target|warnings|[^]&#123;joined|separate|undocumented&#125;&#125;[,...]</code> ：显示特定类型的命令行选项（使用 <code>-v --help</code> 显示子进程的命令行选项）。</li>
<li><code>-dumpspecs</code> ：显示所有内置规范字符串。</li>
<li><code>-dumpversion</code> ：显示编译器的版本。</li>
<li><code>-dumpmachine</code> ：显示编译器的目标处理器。</li>
<li><code>-print-search-dirs</code> ：显示编译器搜索路径中的目录。</li>
<li><code>-print-libgcc-file-name</code> ：显示编译器配套库的名称。</li>
<li><code>-print-file-name=&lt;lib&gt;</code> ：显示库 <code>&lt;lib&gt;</code> 的完整路径。</li>
<li><code>-print-prog-name=&lt;prog&gt;</code> ：显示编译器组件 <code>&lt;prog&gt;</code> 的完整路径。</li>
<li><code>-print-multiarch</code> ：显示目标的规范化 GNU 三元组，用作库路径中的一个组件。</li>
<li><code>-print-multi-directory</code> ：显示 libgcc 版本的根目录。</li>
<li><code>-print-multi-lib</code> ：显示命令行选项和多个库搜索目录之间的映射。</li>
<li><code>-print-multi-os-directory</code> ：显示操作系统库的相对路径。</li>
<li><code>-print-sysroot</code> ：显示目标库目录。</li>
<li><code>-print-sysroot-headers-suffix</code> ：显示用于查找标题的 sysroot 后缀。</li>
<li><code>-Wa,&lt;options&gt;</code> ：将逗号分隔的 <code>&lt;options&gt;</code> 传递给汇编器（assembler）。</li>
<li><code>-Wp,&lt;options&gt;</code> ：将逗号分隔的 <code>&lt;options&gt;</code> 传递给预处理器（preprocessor）。</li>
<li><code>-Wl,&lt;options&gt;</code> ：将逗号分隔的 <code>&lt;options&gt;</code> 传递给链接器（linker）。</li>
<li><code>-Xassembler &lt;arg&gt;</code> ：将 <code>&lt;arg&gt;</code> 传递给汇编器（assembler）。</li>
<li><code>-Xpreprocessor &lt;arg&gt;</code> ：将 <code>&lt;arg&gt;</code> 传递给预处理器（preprocessor）。</li>
<li><code>-Xlinker &lt;arg&gt;</code> ：将 <code>&lt;arg&gt;</code> 传递给链接器（linker）。</li>
<li><code>-save-temps</code> ：不用删除中间文件。</li>
<li><code>-save-temps=&lt;arg&gt;</code> ：不用删除指定的中间文件。</li>
<li><code>-no-canonical-prefixes</code> ：在构建其他 gcc 组件的相对前缀时，不要规范化路径。</li>
<li><code>-pipe</code> ：使用管道而不是中间文件。</li>
<li><code>-time</code> ：为每个子流程的执行计时。</li>
<li><code>-specs=&lt;file&gt;</code> ：使用 <code>&lt;file&gt;</code> 的内容覆盖内置规范。</li>
<li><code>-std=&lt;standard&gt;</code> ：假设输入源为 <code>&lt;standard&gt;</code>。</li>
<li><code>--sysroot=&lt;directory&gt;</code> ：使用 <code>&lt;directory&gt;</code> 作为头文件和库的根目录。</li>
<li><code>-B &lt;directory&gt;</code> ：将 <code>&lt;directory&gt;</code> 添加到编译器的搜索路径。</li>
<li><code>-v</code> ：显示编译器调用的程序。</li>
<li><code>-###</code> ：与 <code>-v</code> 类似，但引用的选项和命令不执行。</li>
<li><code>-E</code> ：仅执行预处理（不要编译、汇编或链接）。</li>
<li><code>-S</code> ：只编译（不汇编或链接）。</li>
<li><code>-c</code> ：编译和汇编，但不链接。</li>
<li><code>-o &lt;file&gt;</code> ：指定输出文件。</li>
<li><code>-pie</code> ：创建一个动态链接、位置无关的可执行文件。</li>
<li><code>-I</code> ：指定头文件的包含路径。</li>
<li><code>-L</code> ：指定链接库的包含路径。</li>
<li><code>-shared</code> ：创建共享库&#x2F;动态库。</li>
<li><code>-static</code> ：使用静态链接。</li>
<li><code>--help</code> ：显示帮助信息。</li>
<li><code>--version</code> ：显示编译器版本信息。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="阶段编译"><a href="#阶段编译" class="headerlink" title="阶段编译"></a>阶段编译</h4><p>假设有文件 hello.c，内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, GetIoT\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译 hello.c，默认输出 a.out</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc hello.c</span><br></pre></td></tr></table></figure>

<p>编译 hello.c 并指定输出文件为 hello</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc hello.c -o hello</span><br></pre></td></tr></table></figure>

<p>只执行预处理，输出 hello.i 源文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure>

<p>只执行预处理和编译，输出 hello.s 汇编文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S hello.c</span><br></pre></td></tr></table></figure>

<p>也可以由 hello.i 文件生成 hello.s 汇编文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure>

<p>只执行预处理、编译和汇编，输出 hello.o 目标文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c hello.c</span><br></pre></td></tr></table></figure>

<p>也可以由 hello.i 或 hello.s 生成目标文件 hello.o</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c hello.i -o hello.o</span><br><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure>

<p>由 hello.o 目标文件链接成可执行文件 hello</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure>

<h4 id="使用静态库"><a href="#使用静态库" class="headerlink" title="使用静态库"></a>使用静态库</h4><p>创建一个 foo.c 文件，内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Here is a static library\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 foo.c 编译成静态库 libfoo.a</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c foo.c             # 生成 foo.o 目标文件</span><br><span class="line">ar rcs libfoo.a foo.o    # 生成 libfoo.a 静态库</span><br></pre></td></tr></table></figure>

<p>查看文件描述</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file *</span></span><br><span class="line">foo.c:    C source, ASCII text</span><br><span class="line">foo.o:    ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</span><br><span class="line">libfoo.a: current ar archive</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>修改 hello.c 文件，调用 foo 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, GetIoT\n&quot;</span>);</span><br><span class="line">    foo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译 hello.c 并链接静态库 libfoo.a（加上 <code>-static</code> 选项）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc hello.c -static libfoo.a -o hello</span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>-L</code> 指定库的搜索路径，并使用 <code>-l</code> 指定库名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc hello.c -static -L. -lfoo -o hello</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./hello</span></span><br><span class="line">Hello, GetIoT</span><br><span class="line">Here is a static library</span><br></pre></td></tr></table></figure>

<p>查看 hello 文件描述</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file hello</span></span><br><span class="line">hello: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=b72236c2211dd8f0c3003bc02ad5e70bb2354e8c, for GNU/Linux 3.2.0, not stripped</span><br></pre></td></tr></table></figure>

<h4 id="使用共享库"><a href="#使用共享库" class="headerlink" title="使用共享库"></a>使用共享库</h4><p>修改 foo.c 文件，内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Here is a shared library\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将其编译为动态库&#x2F;共享库（由于动态库可以被多个进程共享加载，所以需要使用 <code>-fPIC</code> 选项生成位置无关的代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc foo.c -shared -fPIC -o libfoo.so</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>hello.c 代码无需修改，内容仍然如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, GetIoT\n&quot;</span>);</span><br><span class="line">    foo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译 hello.c 并链接共享库 libfoo.so</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc hello.c libfoo.so -o hello</span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>-L</code> 和 <code>-l</code> 选项指定库的路径和名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc hello.c -L. -lfoo -o hello</span><br></pre></td></tr></table></figure>

<p>但是此时运行 hello 程序失败</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./hello</span></span><br><span class="line">./hello: error while loading shared libraries: libfoo.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<p>原因是找不到 libfoo.so 共享库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd hello</span></span><br><span class="line">        linux-vdso.so.1 (0x00007fff5276d000)</span><br><span class="line">        libfoo.so =&gt; not found</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fcc90fa7000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007fcc911bd000)</span><br></pre></td></tr></table></figure>

<p>这是因为 libfoo.so 并不在 Linux 系统的默认搜索目录中，解决办法是我们主动告诉系统，libfoo.so 共享库在哪里。</p>
<p><strong>方式一</strong>：设置环境变量 <code>LD_LIBRARY_PATH</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=$(pwd)</span><br></pre></td></tr></table></figure>

<p>将 libfoo.so 所在的当前目录添加到 <code>LD_LIBRARY_PATH</code> 变量，再次执行 hello</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./hello</span></span><br><span class="line">Hello, GetIoT</span><br><span class="line">Here is a shared library</span><br></pre></td></tr></table></figure>

<p><strong>方式二</strong>：使用 rpath 将共享库位置嵌入到程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc hello.c -L. -lfoo -Wl,-rpath=`pwd` -o hello</span><br></pre></td></tr></table></figure>

<p>rpath 即 run path，是种可以将共享库位置嵌入程序中的方法，从而不用依赖于默认位置和环境变量。这里在链接时使用 <code>-Wl,-rpath=/path/to/yours</code> 选项，<code>-Wl</code> 会发送以逗号分隔的选项到链接器，注意逗号分隔符后面没有空格哦。</p>
<p>这种方式要求共享库必须有一个固定的安装路径，欠缺灵活性，不过如果设置了 <code>LD_LIBRARY_PATH</code>，程序加载时也是会到相应路径寻找共享库的。</p>
<p><strong>方式三</strong>：将 libfoo.so 共享库添加到系统路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp libfoo.so /usr/lib/</span><br></pre></td></tr></table></figure>

<p>执行程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./hello</span></span><br><span class="line">Hello, GetIoT</span><br><span class="line">Here is a shared library</span><br></pre></td></tr></table></figure>

<p>如果 hello 程序仍然运行失败，请尝试执行 <a href="https://getiot.tech/linux-command/ldconfig.html">ldconfig</a> 命令更新共享库的缓存列表。</p>
<p>此时，再次查看 hello 程序的共享库依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd hello</span></span><br><span class="line">        linux-vdso.so.1 (0x00007ffecfbb1000)</span><br><span class="line">        libfoo.so =&gt; /lib/libfoo.so (0x00007f3f3f1ad000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3f3efbb000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f3f3f1d6000)</span><br></pre></td></tr></table></figure>

<p>可以看到 libfoo.so 已经被发现了，其中 &#x2F;lib 是 &#x2F;usr&#x2F;lib 目录的软链接。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>好用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake 保姆级教程（下）</title>
    <url>/2024/11/02/%E5%B7%A5%E5%85%B7/CMake%20%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="CMake-保姆级教程（下）"><a href="#CMake-保姆级教程（下）" class="headerlink" title="CMake 保姆级教程（下）"></a>CMake 保姆级教程（下）</h1><p><a href="https://www.bilibili.com/video/BV14s4y1g7Zj?spm_id_from=333.788.videopod.episodes&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">CMake 保姆级教程【C&#x2F;C++】_哔哩哔哩_bilibili</a></p>
<h1 id="1-嵌套的CMake"><a href="#1-嵌套的CMake" class="headerlink" title="1. 嵌套的CMake"></a>1. 嵌套的CMake</h1><p>如果项目很大，或者项目中有很多的源码目录，在通过CMake管理项目的时候如果只使用一个<code>CMakeLists.txt</code>，那么这个文件相对会比较复杂，有一种化繁为简的方式就是给每个源码目录都添加一个<code>CMakeLists.txt</code>文件（头文件目录不需要），这样每个文件都不会太复杂，而且更灵活，更容易维护。</p>
<p>先来看一下下面的这个的目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── calc</span><br><span class="line">│   ├── add.cpp</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── div.cpp</span><br><span class="line">│   ├── mult.cpp</span><br><span class="line">│   └── sub.cpp</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   ├── calc.h</span><br><span class="line">│   └── sort.h</span><br><span class="line">├── sort</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── insert.cpp</span><br><span class="line">│   └── select.cpp</span><br><span class="line">├── test1</span><br><span class="line">│   ├── calc.cpp</span><br><span class="line">│   └── CMakeLists.txt</span><br><span class="line">└── test2</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── sort.cpp</span><br><span class="line"></span><br><span class="line">6 directories, 15 files</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>include 目录</code>：头文件目录</p>
</li>
<li><pre><code>calc 目录
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ：目录中的四个源文件对应的加、减、乘、除算法</span><br><span class="line"></span><br><span class="line">  - 对应的头文件是`include`中的`calc.h`</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  sort 目录</span><br></pre></td></tr></table></figure>

 

：目录中的两个源文件对应的是插入排序和选择排序算法

- 对应的头文件是`include`中的`sort.h`
</code></pre>
</li>
<li><p><code>test1 目录</code>：测试目录，对加、减、乘、除算法进行测试</p>
</li>
<li><p><code>test2 目录</code>：测试目录，对排序算法进行测试</p>
</li>
</ul>
<p>可以看到各个源文件目录所需要的<code>CMakeLists.txt</code>文件现在已经添加完毕了。接下来庖丁解牛，我们依次分析一下各个文件中需要添加的内容。</p>
<h2 id="1-1-准备工作"><a href="#1-1-准备工作" class="headerlink" title="1.1 准备工作"></a>1.1 准备工作</h2><h3 id="1-1-1-节点关系"><a href="#1-1-1-节点关系" class="headerlink" title="1.1.1 节点关系"></a>1.1.1 节点关系</h3><p>众所周知，Linux的目录是树状结构，所以<code>嵌套的 CMake 也是一个树状结构，最顶层的 CMakeLists.txt 是根节点，其次都是子节点。</code>因此，我们需要了解一些关于 <code>CMakeLists.txt</code> 文件变量作用域的一些信息：</p>
<ul>
<li>根节点<code>CMakeLists.txt</code>中的变量全局有效</li>
<li>父节点<code>CMakeLists.txt</code>中的变量可以在子节点中使用</li>
<li>子节点<code>CMakeLists.txt</code>中的变量只能在当前节点中使用</li>
</ul>
<h3 id="1-1-2-添加子目录"><a href="#1-1-2-添加子目录" class="headerlink" title="1.1.2 添加子目录"></a>1.1.2 添加子目录</h3><p>接下来我们还需要知道在 CMake 中父子节点之间的关系是如何建立的，这里需要用到一个 CMake 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>source_dir</code>：指定了<code>CMakeLists.txt</code>源文件和代码文件的位置，其实就是指定子目录</li>
<li><code>binary_dir</code>：指定了输出文件的路径，一般不需要指定，忽略即可。</li>
<li><code>EXCLUDE_FROM_ALL</code>：在子路径下的目标默认不会被包含到父路径的<code>ALL</code>目标里，并且也会被排除在IDE工程文件之外。用户必须显式构建在子路径下的目标。</li>
</ul>
<p>通过这种方式<code>CMakeLists.txt</code>文件之间的父子关系就被构建出来了。</p>
<h2 id="1-2-解决问题"><a href="#1-2-解决问题" class="headerlink" title="1.2 解决问题"></a>1.2 解决问题</h2><p>在上面的目录中我们要做如下事情：</p>
<ol>
<li>通过 <code>test1 目录</code>中的测试文件进行计算器相关的测试</li>
<li>通过 <code>test2 目录</code>中的测试文件进行排序相关的测试</li>
</ol>
<p>现在相当于是要进行模块化测试，对于<code>calc</code>和<code>sort</code>目录中的源文件来说，可以将它们先编译成库文件（可以是静态库也可以是动态库）然后在提供给测试文件使用即可。库文件的本质其实还是代码，只不过是从文本格式变成了二进制格式。</p>
<h3 id="1-2-1-根目录"><a href="#1-2-1-根目录" class="headerlink" title="1.2.1 根目录"></a>1.2.1 根目录</h3><p>根目录中的 <code>CMakeLists.txt</code>文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(test)</span><br><span class="line"># 定义变量</span><br><span class="line"># 静态库生成的路径</span><br><span class="line">set(LIB_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib)</span><br><span class="line"># 测试程序生成的路径</span><br><span class="line">set(EXEC_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/bin)</span><br><span class="line"># 头文件目录</span><br><span class="line">set(HEAD_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include)</span><br><span class="line"># 静态库的名字</span><br><span class="line">set(CALC_LIB calc)</span><br><span class="line">set(SORT_LIB sort)</span><br><span class="line"># 可执行程序的名字</span><br><span class="line">set(APP_NAME_1 test1)</span><br><span class="line">set(APP_NAME_2 test2)</span><br><span class="line"># 添加子目录</span><br><span class="line">add_subdirectory(calc)</span><br><span class="line">add_subdirectory(sort)</span><br><span class="line">add_subdirectory(test1)</span><br><span class="line">add_subdirectory(test2)</span><br></pre></td></tr></table></figure>

<p>在根节点对应的文件中主要做了两件事情：<code>定义全局变量</code>和<code>添加子目录</code>。</p>
<ul>
<li>定义的全局变量主要是给子节点使用，目的是为了提高子节点中的<code>CMakeLists.txt</code>文件的可读性和可维护性，避免冗余并降低出差的概率。</li>
<li>一共添加了四个子目录，每个子目录中都有一个<code>CMakeLists.txt</code>文件，这样它们的父子关系就被确定下来了。</li>
</ul>
<h3 id="1-2-2-calc-目录"><a href="#1-2-2-calc-目录" class="headerlink" title="1.2.2 calc 目录"></a>1.2.2 calc 目录</h3><p>calc 目录中的 <code>CMakeLists.txt</code>文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(CALCLIB)</span><br><span class="line">aux_source_directory(./ SRC)</span><br><span class="line">include_directories($&#123;HEAD_PATH&#125;)</span><br><span class="line">set(LIBRARY_OUTPUT_PATH $&#123;LIB_PATH&#125;)</span><br><span class="line">add_library($&#123;CALC_LIB&#125; STATIC $&#123;SRC&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>第3行<code>aux_source_directory</code>：搜索当前目录（calc目录）下的所有源文件</li>
<li>第4行<code>include_directories</code>：包含头文件路径，<code>HEAD_PATH</code>是在根节点文件中定义的</li>
<li>第5行<code>set</code>：设置库的生成的路径，<code>LIB_PATH</code>是在根节点文件中定义的</li>
<li>第6行<code>add_library</code>：生成静态库，静态库名字<code>CALC_LIB</code>是在根节点文件中定义的</li>
</ul>
<h3 id="1-2-3-sort-目录"><a href="#1-2-3-sort-目录" class="headerlink" title="1.2.3 sort 目录"></a>1.2.3 sort 目录</h3><p>sort 目录中的 <code>CMakeLists.txt</code>文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(SORTLIB)</span><br><span class="line">aux_source_directory(./ SRC)</span><br><span class="line">include_directories($&#123;HEAD_PATH&#125;)</span><br><span class="line">set(LIBRARY_OUTPUT_PATH $&#123;LIB_PATH&#125;)</span><br><span class="line">add_library($&#123;SORT_LIB&#125; SHARED $&#123;SRC&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>第6行<code>add_library</code>：生成动态库，动态库名字<code>SORT_LIB</code>是在根节点文件中定义的</li>
</ul>
<p>这个文件中的内容和<code>calc</code>节点文件中的内容类似，只不过这次生成的是动态库。</p>
<p>在生成库文件的时候，这个库可以是静态库也可以是动态库，一般需要根据实际情况来确定。如果生成的库比较大，建议将其制作成动态库。</p>
<h3 id="1-2-4-test1-目录"><a href="#1-2-4-test1-目录" class="headerlink" title="1.2.4 test1 目录"></a>1.2.4 test1 目录</h3><p>test1 目录中的 <code>CMakeLists.txt</code>文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(CALCTEST)</span><br><span class="line">aux_source_directory(./ SRC)</span><br><span class="line">include_directories($&#123;HEAD_PATH&#125;)</span><br><span class="line">link_directories($&#123;LIB_PATH&#125;)</span><br><span class="line">link_libraries($&#123;CALC_LIB&#125;)</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;EXEC_PATH&#125;)</span><br><span class="line">add_executable($&#123;APP_NAME_1&#125; $&#123;SRC&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>第4行<code>include_directories</code>：指定头文件路径，<code>HEAD_PATH</code>变量是在根节点文件中定义的</li>
<li>第6行<code>link_libraries</code>：指定可执行程序要链接的<code>静态库</code>，<code>CALC_LIB</code>变量是在根节点文件中定义的</li>
<li>第7行<code>set</code>：指定可执行程序生成的路径，<code>EXEC_PATH</code>变量是在根节点文件中定义的</li>
<li>第8行<code>add_executable</code>：生成可执行程序，<code>APP_NAME_1</code>变量是在根节点文件中定义的</li>
</ul>
<p>此处的可执行程序链接的是静态库，最终静态库会被打包到可执行程序中，可执行程序启动之后，静态库也就随之被加载到内存中了。</p>
<h3 id="1-2-5-test2-目录"><a href="#1-2-5-test2-目录" class="headerlink" title="1.2.5 test2 目录"></a>1.2.5 test2 目录</h3><p>test2 目录中的 <code>CMakeLists.txt</code>文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(SORTTEST)</span><br><span class="line">aux_source_directory(./ SRC)</span><br><span class="line">include_directories($&#123;HEAD_PATH&#125;)</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;EXEC_PATH&#125;)</span><br><span class="line">link_directories($&#123;LIB_PATH&#125;)</span><br><span class="line">add_executable($&#123;APP_NAME_2&#125; $&#123;SRC&#125;)</span><br><span class="line">target_link_libraries($&#123;APP_NAME_2&#125; $&#123;SORT_LIB&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>第四行<code>include_directories</code>：包含头文件路径，<code>HEAD_PATH</code>变量是在根节点文件中定义的</li>
<li>第五行<code>set</code>：指定可执行程序生成的路径，<code>EXEC_PATH</code>变量是在根节点文件中定义的</li>
<li>第六行<code>link_directories</code>：指定可执行程序要链接的动态库的路径，<code>LIB_PATH</code>变量是在根节点文件中定义的</li>
<li>第七行<code>add_executable</code>：生成可执行程序，<code>APP_NAME_2</code>变量是在根节点文件中定义的</li>
<li>第八行<code>target_link_libraries</code>：指定可执行程序要链接的动态库的名字</li>
</ul>
<p>在生成可执行程序的时候，动态库不会被打包到可执行程序内部。当可执行程序启动之后动态库也不会被加载到内存，只有可执行程序调用了动态库中的函数的时候，动态库才会被加载到内存中，且多个进程可以共用内存中的同一个动态库，所以动态库又叫共享库。</p>
<h3 id="1-2-6-构建项目"><a href="#1-2-6-构建项目" class="headerlink" title="1.2.6 构建项目"></a>1.2.6 构建项目</h3><p>一切准备就绪之后，开始构建项目，进入到根节点目录的<code>build 目录</code>中，执行<code>cmake 命令</code>，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">$ cmake ..</span><br><span class="line">-- The C compiler identification is GNU 5.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 5.4.0</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/robin/abc/cmake/calc/build</span><br></pre></td></tr></table></figure>

<p>可以看到在<code>build</code>目录中生成了一些文件和目录，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">$ tree build -L 1     </span><br><span class="line">build</span><br><span class="line">├── calc                  # 目录</span><br><span class="line">├── CMakeCache.txt        # 文件</span><br><span class="line">├── CMakeFiles            # 目录</span><br><span class="line">├── cmake_install.cmake   # 文件</span><br><span class="line">├── Makefile              # 文件</span><br><span class="line">├── sort                  # 目录</span><br><span class="line">├── test1                 # 目录</span><br><span class="line">└── test2                 # 目录</span><br></pre></td></tr></table></figure>

<p>然后在<code>build 目录</code>下执行<code>make 命令</code>:</p>
<p><a href="https://subingwen.cn/cmake/CMake-advanced/image-20230313234101139.png"><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20230313234101139.png" alt="image-20230313234101139"></a></p>
<p>通过上图可以得到如下信息：</p>
<ol>
<li>在项目根目录的<code>lib</code>目录中生成了静态库<code>libcalc.a</code></li>
<li>在项目根目录的<code>lib</code>目录中生成了动态库<code>libsort.so</code></li>
<li>在项目根目录的<code>bin</code>目录中生成了可执行程序<code>test1</code></li>
<li>在项目根目录的<code>bin</code>目录中生成了可执行程序<code>test2</code></li>
</ol>
<p>最后再来看一下上面提到的这些文件是否真的被生成到对应的目录中了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">$ tree bin/ lib/</span><br><span class="line">bin/</span><br><span class="line">├── test1</span><br><span class="line">└── test2</span><br><span class="line">lib/</span><br><span class="line">├── libcalc.a</span><br><span class="line">└── libsort.so</span><br></pre></td></tr></table></figure>

<p>由此可见，真实不虚，至此，项目构建完毕。</p>
<p>写在最后：</p>
<p>在项目中，如果将程序中的某个模块制作成了动态库或者静态库<code>并且在CMakeLists.txt 中指定了库的输出目录</code>，而后其它模块又需要加载这个生成的库文件，此时直接使用就可以了，<code>如果没有指定库的输出路径或者需要直接加载外部提供的库文件，此时就需要使用 link_directories 将库文件路径指定出来。</code></p>
<h1 id="2-流程控制"><a href="#2-流程控制" class="headerlink" title="2. 流程控制"></a>2. 流程控制</h1><p>在 CMake 的 CMakeLists.txt 中也可以进行流程控制，也就是说可以像写 shell 脚本那样进行<code>条件判断</code>和<code>循环</code>。</p>
<h2 id="2-1-条件判断"><a href="#2-1-条件判断" class="headerlink" title="2.1 条件判断"></a>2.1 条件判断</h2><p>关于条件判断其语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">if(&lt;condition&gt;)</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line">elseif(&lt;condition&gt;) # 可选快, 可以重复</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line">else()              # 可选快</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>

<p>在进行条件判断的时候，如果有多个条件，那么可以写多个<code>elseif</code>，最后一个条件可以使用<code>else</code>，但是<strong>开始和结束是必须要成对出现的</strong>，分别为：<code>if</code>和<code>endif</code>。</p>
<h3 id="2-1-1-基本表达式"><a href="#2-1-1-基本表达式" class="headerlink" title="2.1.1 基本表达式"></a>2.1.1 基本表达式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">if(&lt;expression&gt;)</span><br></pre></td></tr></table></figure>

<p>如果是基本表达式，<code>expression</code> 有以下三种情况：<code>常量</code>、<code>变量</code>、<code>字符串</code>。</p>
<ul>
<li>如果是<code>1</code>, <code>ON</code>, <code>YES</code>, <code>TRUE</code>, <code>Y</code>, <code>非零值</code>，<code>非空字符串</code>时，条件判断返回<code>True</code></li>
<li>如果是 <code>0</code>, <code>OFF</code>, <code>NO</code>, <code>FALSE</code>, <code>N</code>, <code>IGNORE</code>, <code>NOTFOUND</code>，<code>空字符串</code>时，条件判断返回<code>False</code></li>
</ul>
<h3 id="2-1-2-逻辑判断"><a href="#2-1-2-逻辑判断" class="headerlink" title="2.1.2 逻辑判断"></a>2.1.2 逻辑判断</h3><ul>
<li><p><strong>NOT</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">if(NOT &lt;condition&gt;)</span><br></pre></td></tr></table></figure>

<p>其实这就是一个取反操作，如果条件<code>condition</code>为<code>True</code>将返回<code>False</code>，如果条件<code>condition</code>为<code>False</code>将返回<code>True</code>。</p>
</li>
<li><p><strong>AND</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">if(&lt;cond1&gt; AND &lt;cond2&gt;)</span><br></pre></td></tr></table></figure>

<p>如果<code>cond1</code>和<code>cond2</code>同时为<code>True</code>，返回<code>True</code>否则返回<code>False</code>。</p>
</li>
<li><p><strong>OR</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">if(&lt;cond1&gt; OR &lt;cond2&gt;)</span><br></pre></td></tr></table></figure>

<p>如果<code>cond1</code>和<code>cond2</code>两个条件中至少有一个为<code>True</code>，返回<code>True</code>，如果两个条件都为<code>False</code>则返回<code>False</code>。</p>
</li>
</ul>
<h3 id="2-1-3-比较"><a href="#2-1-3-比较" class="headerlink" title="2.1.3 比较"></a>2.1.3 比较</h3><ul>
<li><p><strong>基于数值的比较</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">if(&lt;variable|string&gt; LESS &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; GREATER &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; EQUAL &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; LESS_EQUAL &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; GREATER_EQUAL &lt;variable|string&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>LESS</code>：如果左侧数值<code>小于</code>右侧，返回<code>True</code></li>
<li><code>GREATER</code>：如果左侧数值<code>大于</code>右侧，返回<code>True</code></li>
<li><code>EQUAL</code>：如果左侧数值<code>等于</code>右侧，返回<code>True</code></li>
<li><code>LESS_EQUAL</code>：如果左侧数值<code>小于等于</code>右侧，返回<code>True</code></li>
<li><code>GREATER_EQUAL</code>：如果左侧数值<code>大于等于</code>右侧，返回<code>True</code></li>
</ul>
</li>
<li><p><strong>基于字符串的比较</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">if(&lt;variable|string&gt; STRLESS &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; STRGREATER &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; STREQUAL &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; STRLESS_EQUAL &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; STRGREATER_EQUAL &lt;variable|string&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>STRLESS</code>：如果左侧字符串<code>小于</code>右侧，返回<code>True</code></li>
<li><code>STRGREATER</code>：如果左侧字符串<code>大于</code>右侧，返回<code>True</code></li>
<li><code>STREQUAL</code>：如果左侧字符串<code>等于</code>右侧，返回<code>True</code></li>
<li><code>STRLESS_EQUAL</code>：如果左侧字符串<code>小于等于</code>右侧，返回<code>True</code></li>
<li><code>STRGREATER_EQUAL</code>：如果左侧字符串<code>大于等于</code>右侧，返回<code>True</code></li>
</ul>
</li>
</ul>
<h3 id="2-1-4-文件操作"><a href="#2-1-4-文件操作" class="headerlink" title="2.1.4 文件操作"></a>2.1.4 文件操作</h3><ol>
<li><p>判断文件或者目录是否存在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">if(EXISTS path-to-file-or-directory)</span><br></pre></td></tr></table></figure>

<p>如果文件或者目录存在返回<code>True</code>，否则返回<code>False</code>。</p>
</li>
<li><p>判断是不是目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">if(IS_DIRECTORY path)</span><br></pre></td></tr></table></figure>

<ul>
<li>此处目录的 path 必须是绝对路径</li>
<li>如果目录存在返回<code>True</code>，目录不存在返回<code>False</code>。</li>
</ul>
</li>
<li><p>判断是不是软连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">if(IS_SYMLINK file-name)</span><br></pre></td></tr></table></figure>

<ul>
<li>此处的 file-name 对应的路径必须是绝对路径</li>
<li>如果软链接存在返回<code>True</code>，软链接不存在返回<code>False</code>。</li>
<li>软链接相当于 Windows 里的快捷方式</li>
</ul>
</li>
<li><p>判断是不是绝对路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">if(IS_ABSOLUTE path)</span><br></pre></td></tr></table></figure>

<ul>
<li>关于绝对路径:<ul>
<li>如果是<code>Linux</code>，该路径需要从根目录开始描述</li>
<li>如果是<code>Windows</code>，该路径需要从盘符开始描述</li>
</ul>
</li>
<li>如果是绝对路径返回<code>True</code>，如果不是绝对路径返回<code>False</code>。</li>
</ul>
</li>
</ol>
<h3 id="2-1-5-其它"><a href="#2-1-5-其它" class="headerlink" title="2.1.5 其它"></a>2.1.5 其它</h3><ul>
<li><p>判断某个元素是否在列表中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">if(&lt;variable|string&gt; IN_LIST &lt;variable&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li>CMake 版本要求：大于等于3.3</li>
<li>如果这个元素在列表中返回<code>True</code>，否则返回<code>False</code>。</li>
</ul>
</li>
<li><p>比较两个路径是否相等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">if(&lt;variable|string&gt; PATH_EQUAL &lt;variable|string&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li>CMake 版本要求：大于等于3.24</li>
<li>如果这个元素在列表中返回<code>True</code>，否则返回<code>False</code>。</li>
</ul>
<p>关于路径的比较其实就是另个字符串的比较，如果路径格式书写没有问题也可以通过下面这种方式进行比较：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">if(&lt;variable|string&gt; STREQUAL &lt;variable|string&gt;)</span><br></pre></td></tr></table></figure>

<p>我们在书写某个路径的时候，可能由于误操作会多写几个分隔符，比如把<code>/a/b/c</code>写成<code>/a//b///c</code>，此时通过<code>STREQUAL</code>对这两个字符串进行比较肯定是不相等的，但是通过<code>PATH_EQUAL</code>去比较两个路径，得到的结果确实相等的，可以看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">cmake_minimum_required(VERSION 3.26)</span><br><span class="line">project(test)</span><br><span class="line"></span><br><span class="line">if(&quot;/home//robin///Linux&quot; PATH_EQUAL &quot;/home/robin/Linux&quot;)</span><br><span class="line">    message(&quot;路径相等&quot;)</span><br><span class="line">else()</span><br><span class="line">    message(&quot;路径不相等&quot;)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">message(STATUS &quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&quot;)</span><br><span class="line"></span><br><span class="line">if(&quot;/home//robin///Linux&quot; STREQUAL &quot;/home/robin/Linux&quot;)</span><br><span class="line">    message(&quot;路径相等&quot;)</span><br><span class="line">else()</span><br><span class="line">    message(&quot;路径不相等&quot;)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>

<p>输出的日志信息如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">路径相等</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">路径不相等</span><br></pre></td></tr></table></figure>

<p>通过得到的结果我们可以得到一个结论：在进行路径比较的时候，如果使用 PATH_EQUAL 可以自动剔除路径中多余的分割线然后再进行路径的对比，使用 STREQUAL 则只能进行字符串比较。</p>
<p>关于 if 的更多条件判断，请参考官方文档</p>
</li>
</ul>
<h2 id="2-2-循环"><a href="#2-2-循环" class="headerlink" title="2.2 循环"></a>2.2 循环</h2><p>在 CMake 中循环有两种方式，分别是：<code>foreach</code>和<code>while</code>。</p>
<h3 id="2-2-1-foreach"><a href="#2-2-1-foreach" class="headerlink" title="2.2.1 foreach"></a>2.2.1 foreach</h3><p>使用 foreach 进行循环，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">foreach(&lt;loop_var&gt; &lt;items&gt;)</span><br><span class="line">    &lt;commands&gt;</span><br><span class="line">endforeach()</span><br></pre></td></tr></table></figure>

<p>通过<code>foreach</code>我们就可以对<code>items</code>中的数据进行遍历，然后通过<code>loop_var</code>将遍历到的当前的值取出，在取值的时候有以下几种用法：</p>
<h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">foreach(&lt;loop_var&gt; RANGE &lt;stop&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>RANGE</code>：关键字，表示要遍历范围</li>
<li><code>stop</code>：这是一个<code>正整数，表示范围的结束值</code>，在遍历的时候<code>从 0 开始，最大值为 stop</code>。</li>
<li><code>loop_var</code>：存储每次循环取出的值</li>
</ul>
<p>举例说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">cmake_minimum_required(VERSION 3.2)</span><br><span class="line">project(test)</span><br><span class="line"># 循环</span><br><span class="line">foreach(item RANGE 10)</span><br><span class="line">    message(STATUS &quot;当前遍历的值为: $&#123;item&#125;&quot; )</span><br><span class="line">endforeach()</span><br></pre></td></tr></table></figure>

<p>输出的日志信息是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">$ cmake ..</span><br><span class="line">-- 当前遍历的值为: 0</span><br><span class="line">-- 当前遍历的值为: 1</span><br><span class="line">-- 当前遍历的值为: 2</span><br><span class="line">-- 当前遍历的值为: 3</span><br><span class="line">-- 当前遍历的值为: 4</span><br><span class="line">-- 当前遍历的值为: 5</span><br><span class="line">-- 当前遍历的值为: 6</span><br><span class="line">-- 当前遍历的值为: 7</span><br><span class="line">-- 当前遍历的值为: 8</span><br><span class="line">-- 当前遍历的值为: 9</span><br><span class="line">-- 当前遍历的值为: 10</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/robin/abc/a/build</span><br></pre></td></tr></table></figure>

<p>再次强调：在对一个整数区间进行遍历的时候，得到的范围是这样的 【0，stop】，右侧是闭区间包含 stop 这个值。</p>
<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">foreach(&lt;loop_var&gt; RANGE &lt;start&gt; &lt;stop&gt; [&lt;step&gt;])</span><br></pre></td></tr></table></figure>

<p>这是上面<code>方法1</code>的加强版，我们在遍历一个整数区间的时候，除了可以指定起始范围，还可以指定步长。</p>
<ul>
<li><code>RANGE</code>：关键字，表示要遍历范围</li>
<li><code>start</code>：这是一个<code>正整数，表示范围的起始值，也就是说最小值为 start</code></li>
<li><code>stop</code>：这是一个<code>正整数，表示范围的结束值，也就是说最大值为 stop</code></li>
<li><code>step</code>：控制每次遍历的时候以怎样的步长增长，<code>默认为1，可以不设置</code></li>
<li><code>loop_var</code>：存储每次循环取出的值</li>
</ul>
<p>举例说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">cmake_minimum_required(VERSION 3.2)</span><br><span class="line">project(test)</span><br><span class="line"></span><br><span class="line">foreach(item RANGE 10 30 2)</span><br><span class="line">    message(STATUS &quot;当前遍历的值为: $&#123;item&#125;&quot; )</span><br><span class="line">endforeach()</span><br></pre></td></tr></table></figure>

<p>输出的结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">$ cmake ..</span><br><span class="line">-- 当前遍历的值为: 10</span><br><span class="line">-- 当前遍历的值为: 12</span><br><span class="line">-- 当前遍历的值为: 14</span><br><span class="line">-- 当前遍历的值为: 16</span><br><span class="line">-- 当前遍历的值为: 18</span><br><span class="line">-- 当前遍历的值为: 20</span><br><span class="line">-- 当前遍历的值为: 22</span><br><span class="line">-- 当前遍历的值为: 24</span><br><span class="line">-- 当前遍历的值为: 26</span><br><span class="line">-- 当前遍历的值为: 28</span><br><span class="line">-- 当前遍历的值为: 30</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/robin/abc/a/build</span><br></pre></td></tr></table></figure>

<p>再次强调：在使用上面的方式对一个整数区间进行遍历的时候，得到的范围是这样的 【start，stop】，左右两侧都是闭区间，包含 start 和 stop 这两个值，步长 step 默认为1，可以不设置。</p>
<h4 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">foreach(&lt;loop_var&gt; IN [LISTS [&lt;lists&gt;]] [ITEMS [&lt;items&gt;]])</span><br></pre></td></tr></table></figure>

<p>这是<code>foreach</code>的另一个变体，通过这种方式我们可以对更加复杂的数据进行遍历，前两种方式只适用于对某个正整数范围内的遍历。</p>
<ul>
<li><code>IN</code>：关键字，表示在 xxx 里边</li>
<li><code>LISTS</code>：关键字，对应的是列表<code>list</code>，通过<code>set、list</code>可以获得</li>
<li><code>ITEMS</code>：关键字，对应的也是列表</li>
<li><code>loop_var</code>：存储每次循环取出的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">cmake_minimum_required(VERSION 3.2)</span><br><span class="line">project(test)</span><br><span class="line"># 创建 list</span><br><span class="line">set(WORD a b c d)</span><br><span class="line">set(NAME ace sabo luffy)</span><br><span class="line"># 遍历 list</span><br><span class="line">foreach(item IN LISTS WORD NAME)</span><br><span class="line">    message(STATUS &quot;当前遍历的值为: $&#123;item&#125;&quot; )</span><br><span class="line">endforeach()</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，创建了两个 <code>list</code> 列表，在遍历的时候对它们两个都进行了遍历（<code>可以根据实际需求选择同时遍历多个或者只遍历一个</code>）。输出的日志信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">$ cd build/</span><br><span class="line">$ cmake ..</span><br><span class="line">-- 当前遍历的值为: a</span><br><span class="line">-- 当前遍历的值为: b</span><br><span class="line">-- 当前遍历的值为: c</span><br><span class="line">-- 当前遍历的值为: d</span><br><span class="line">-- 当前遍历的值为: ace</span><br><span class="line">-- 当前遍历的值为: sabo</span><br><span class="line">-- 当前遍历的值为: luffy</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/robin/abc/a/build</span><br></pre></td></tr></table></figure>

<p>一共输出了7个字符串，说明遍历是没有问题的。接下来看另外一种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">cmake_minimum_required(VERSION 3.2)</span><br><span class="line">project(test)</span><br><span class="line"></span><br><span class="line">set(WORD a b c &quot;d e f&quot;)</span><br><span class="line">set(NAME ace sabo luffy)</span><br><span class="line">foreach(item IN ITEMS $&#123;WORD&#125; $&#123;NAME&#125;)</span><br><span class="line">    message(STATUS &quot;当前遍历的值为: $&#123;item&#125;&quot; )</span><br><span class="line">endforeach()</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，遍历过程中将关键字<code>LISTS</code>改成了<code>ITEMS</code>，后边跟的还是一个或者多个列表，只不过此时需要通过<code>$&#123;&#125;</code>将列表中的值取出。其输出的信息和上一个例子是一样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">$ cd build/</span><br><span class="line">$ cmake ..</span><br><span class="line">-- 当前遍历的值为: a</span><br><span class="line">-- 当前遍历的值为: b</span><br><span class="line">-- 当前遍历的值为: c</span><br><span class="line">-- 当前遍历的值为: d e f</span><br><span class="line">-- 当前遍历的值为: ace</span><br><span class="line">-- 当前遍历的值为: sabo</span><br><span class="line">-- 当前遍历的值为: luffy</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/robin/abc/a/build</span><br></pre></td></tr></table></figure>

<p>小细节：在通过 set 组织列表的时候，如果某个字符串中有空格，可以通过双引号将其包裹起来，具体的操作方法可以参考上面的例子。</p>
<h4 id="方法4"><a href="#方法4" class="headerlink" title="方法4"></a>方法4</h4><p><strong>注意事项：这种循环方式要求CMake的版本大于等于 3.17。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">foreach(&lt;loop_var&gt;... IN ZIP_LISTS &lt;lists&gt;)</span><br></pre></td></tr></table></figure>

<p>通过这种方式，遍历的还是一个或多个列表，可以理解为是<code>方式3</code>的加强版。因为通过上面的方式遍历多个列表，但是又想把指定列表中的元素取出来使用是做不到的，在这个加强版中就可以轻松实现。</p>
<ul>
<li><pre><code>loop_var
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ：存储每次循环取出的值，可以根据要遍历的列表的数量指定多个变量，用于存储对应的列表当前取出的那个值。</span><br><span class="line"></span><br><span class="line">  - `如果指定了多个变量名，它们的数量应该和列表的数量相等`</span><br><span class="line">  - `如果只给出了一个 loop_var，那么它将一系列的 loop_var_N 变量来存储对应列表中的当前项，也就是说 loop_var_0 对应第一个列表，loop_var_1 对应第二个列表，以此类推......`</span><br><span class="line">  - `如果遍历的多个列表中一个列表较短，当它遍历完成之后将不会再参与后续的遍历（因为其它列表还没有遍历完）。`</span><br><span class="line"></span><br><span class="line">- `IN`：关键字，表示在 xxx 里边</span><br><span class="line"></span><br><span class="line">- `ZIP_LISTS`：关键字，对应的是列表`list`，通过`set 、list`可以获得</span><br><span class="line"></span><br></pre></td></tr></table></figure>
cmake
cmake_minimum_required(VERSION 3.17)
project(test)
</code></pre>
</li>
</ul>
<h1 id="通过list给列表添加数据"><a href="#通过list给列表添加数据" class="headerlink" title="通过list给列表添加数据"></a>通过list给列表添加数据</h1><p>list(APPEND WORD hello world “hello world”)<br>list(APPEND NAME ace sabo luffy zoro sanji)</p>
<h1 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h1><p>foreach(item1 item2 IN ZIP_LISTS WORD NAME)<br>    message(STATUS “当前遍历的值为: item1 &#x3D; ${item1}, item2&#x3D;${item2}” )<br>endforeach()</p>
<p>message(“&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;”)</p>
<h1 id="遍历列表-1"><a href="#遍历列表-1" class="headerlink" title="遍历列表"></a>遍历列表</h1><p>foreach(item  IN ZIP_LISTS WORD NAME)<br>    message(STATUS “当前遍历的值为: item1 &#x3D; ${item_0}, item2&#x3D;${item_1}” )<br>endforeach()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在这个例子中关于列表数据的添加是通过`list`来实现的。在遍历列表的时候一共使用了两种方式，一种提供了多个变量来存储当前列表中的值，另一种只有一个变量，但是实际取值的时候需要通过`变量名_0、变量名_1、变量名_N `的方式来操作，注意事项：第一个列表对应的编号是0，第一个列表对应的编号是0，第一个列表对应的编号是0。</span><br><span class="line"></span><br><span class="line">上面的例子输出的结果如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="shell-cd-build-cmake-–-当前遍历的值为-item1-hello-item2-ace–-当前遍历的值为-item1-world-item2-sabo–-当前遍历的值为-item1-hello-world-item2-luffy–-当前遍历的值为-item1-item2-zoro–-当前遍历的值为-item1-item2-sanji"><a href="#shell-cd-build-cmake-–-当前遍历的值为-item1-hello-item2-ace–-当前遍历的值为-item1-world-item2-sabo–-当前遍历的值为-item1-hello-world-item2-luffy–-当前遍历的值为-item1-item2-zoro–-当前遍历的值为-item1-item2-sanji" class="headerlink" title="shell$ cd build&#x2F;$ cmake ..– 当前遍历的值为: item1 &#x3D; hello, item2&#x3D;ace– 当前遍历的值为: item1 &#x3D; world, item2&#x3D;sabo– 当前遍历的值为: item1 &#x3D; hello world, item2&#x3D;luffy– 当前遍历的值为: item1 &#x3D; , item2&#x3D;zoro– 当前遍历的值为: item1 &#x3D; , item2&#x3D;sanji"></a>shell<br>$ cd build&#x2F;<br>$ cmake ..<br>– 当前遍历的值为: item1 &#x3D; hello, item2&#x3D;ace<br>– 当前遍历的值为: item1 &#x3D; world, item2&#x3D;sabo<br>– 当前遍历的值为: item1 &#x3D; hello world, item2&#x3D;luffy<br>– 当前遍历的值为: item1 &#x3D; , item2&#x3D;zoro<br>– 当前遍历的值为: item1 &#x3D; , item2&#x3D;sanji</h1><p>– 当前遍历的值为: item1 &#x3D; hello, item2&#x3D;ace<br>– 当前遍历的值为: item1 &#x3D; world, item2&#x3D;sabo<br>– 当前遍历的值为: item1 &#x3D; hello world, item2&#x3D;luffy<br>– 当前遍历的值为: item1 &#x3D; , item2&#x3D;zoro<br>– 当前遍历的值为: item1 &#x3D; , item2&#x3D;sanji<br>– Configuring done (0.0s)<br>– Generating done (0.0s)<br>– Build files have been written to: &#x2F;home&#x2F;robin&#x2F;abc&#x2F;a&#x2F;build</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 2.2.2 while</span><br><span class="line"></span><br><span class="line">除了使用`foreach`也可以使用 `while` 进行循环，关于循环结束对应的条件判断的书写格式和`if/elseif` 是一样的。`while`的语法格式如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>cmake<br>while(<condition>)<br>    <commands><br>endwhile()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">`while`循环比较简单，只需要指定出循环结束的条件即可：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>cmake<br>cmake_minimum_required(VERSION 3.5)<br>project(test)</p>
<h1 id="创建一个列表-NAME"><a href="#创建一个列表-NAME" class="headerlink" title="创建一个列表 NAME"></a>创建一个列表 NAME</h1><p>set(NAME luffy sanji zoro nami robin)</p>
<h1 id="得到列表长度"><a href="#得到列表长度" class="headerlink" title="得到列表长度"></a>得到列表长度</h1><p>list(LENGTH NAME LEN)</p>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>while(${LEN} GREATER  0)<br>    message(STATUS “names &#x3D; ${NAME}”)<br>    # 弹出列表头部元素<br>    list(POP_FRONT NAME)<br>    # 更新列表长度<br>    list(LENGTH NAME LEN)<br>endwhile()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">输出的结果如下:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>shell<br>$ cd build&#x2F;<br>$ cmake ..<br>– names &#x3D; luffy;sanji;zoro;nami;robin<br>– names &#x3D; sanji;zoro;nami;robin<br>– names &#x3D; zoro;nami;robin<br>– names &#x3D; nami;robin<br>– names &#x3D; robin<br>– Configuring done (0.0s)<br>– Generating done (0.0s)<br>– Build files have been written to: &#x2F;home&#x2F;robin&#x2F;abc&#x2F;a&#x2F;build</p>
<pre><code>
可以看到当列表中的元素全部被弹出之后，列表的长度变成了0，此时`while`循环也就退出了。
</code></pre>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>好用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马程序员 | Git详细教程笔记 | 使用命令 | 从安装到入土</title>
    <url>/2025/02/23/%E5%B7%A5%E5%85%B7/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%20%20Git%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0%20%20%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%20%20%E4%BB%8E%E5%AE%89%E8%A3%85%E5%88%B0%E5%85%A5%E5%9C%9F/</url>
    <content><![CDATA[<h1 id="黑马程序员-Git详细教程笔记-使用命令-从安装到入土"><a href="#黑马程序员-Git详细教程笔记-使用命令-从安装到入土" class="headerlink" title="黑马程序员 | Git详细教程笔记 | 使用命令 | 从安装到入土"></a>黑马程序员 | Git详细教程笔记 | 使用命令 | 从安装到入土</h1><p><a href="https://www.bilibili.com/video/BV1MU4y1Y7h5?spm_id_from=333.788.videopod.episodes&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">黑马程序员Git全套教程，完整的git项目管理工具教程，一套精通git_哔哩哔哩_bilibili</a></p>
<p>笔者就看了前22p，2倍速粗略的学了一下</p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>​    <strong>Git是分布式版本控制工具 分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样工作的时候，无 需要联网了，因为版本库就在你自己的电脑上。多人协作只需要各自的修改推送给对方，就能互相看到对方的修改了。</strong></p>
<p>​    <strong>特点：</strong></p>
<p>​           1.速度</p>
<p>​           2.简单的设计</p>
<p>​           3.对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</p>
<p>​           4.完全分布式</p>
<p>​           5.有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</p>
<h2 id="二、工作流程图"><a href="#二、工作流程图" class="headerlink" title="二、工作流程图"></a>二、工作流程图</h2><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/19c8c14ec2dc36cae056e56a75ee9ec0.png" alt="img"></p>
<p><strong>命令如下：</strong></p>
<ol>
<li>clone（克隆）: 从远程仓库中克隆代码到本地仓库。</li>
<li>checkout （检出）:从本地仓库中检出一个仓库分支然后进行修订。</li>
<li>add（添加）: 在提交前先将代码提交到暂存区。</li>
<li>commit（提交）: 提交到本地仓库。本地仓库中保存修改的各个历史版本。</li>
<li>fetch (抓取) ：从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。</li>
<li>pull (拉取) ：从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于               fetch+merge。</li>
<li>push（推送） : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库。</li>
</ol>
<h2 id="三、Git安装与配置"><a href="#三、Git安装与配置" class="headerlink" title="三、Git安装与配置"></a>三、Git安装与配置</h2><h3 id="1-下载与安装"><a href="#1-下载与安装" class="headerlink" title="1.下载与安装"></a>1.下载与安装</h3><blockquote>
<p>不建议从官网下载，因为速度太慢，建议从国内镜像下载。从里面找到对应版本下载即可。</p>
</blockquote>
<p><a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/">CNPM Binaries Mirror</a></p>
<p> <strong>备注：</strong></p>
<ul>
<li>Git GUI：Git提供的图形界面工具</li>
<li>Git Bash：Git提供的命令行工具</li>
</ul>
<p>​     当安装Git后首先要做的事情是设置用户名称和email地址。这是非常重要的，因为每次Git提交都会使用该用户信息。</p>
<h3 id="2-基本配置"><a href="#2-基本配置" class="headerlink" title="2.基本配置"></a>2.基本配置</h3><ol>
<li>打开Git Bash</li>
<li>设置用户信息</li>
</ol>
<p>设置配置信息</p>
<p>​    git config –global user.name “自己的用户名”    <strong>一定要注意空格！！！！</strong></p>
<p>​    git config –global user.email “自己的邮箱”</p>
<p>查看配置信息</p>
<p>​    git config –global user.name</p>
<p>​    git config –global user.email</p>
<h3 id="3-为常用指令配置别名（可选）"><a href="#3-为常用指令配置别名（可选）" class="headerlink" title="3.为常用指令配置别名（可选）"></a>3.为常用指令配置别名（可选）</h3><h4 id="1-打开用户目录，创建-bashrc-文件"><a href="#1-打开用户目录，创建-bashrc-文件" class="headerlink" title="1. 打开用户目录，创建 .bashrc 文件"></a>1. 打开用户目录，创建 .bashrc 文件</h4><p>​    因为部分windows系统不允许用户创建点号开头的文件，可以打开<a href="https://so.csdn.net/so/search?q=gitBash&spm=1001.2101.3001.7020">gitBash</a>,执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h4 id="2-在-bashrc-文件中输入如下内容："><a href="#2-在-bashrc-文件中输入如下内容：" class="headerlink" title="2.在 .bashrc 文件中输入如下内容："></a>2.在 .bashrc 文件中输入如下内容：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用于输出git提交日志</span></span><br><span class="line"><span class="built_in">alias</span> git-log=<span class="string">&#x27;git log --pretty=oneline --all --graph --abbrev-commit&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用于输出当前目录所有文件及基本信息</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -al&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-打开gitBash，执行"><a href="#3-打开gitBash，执行" class="headerlink" title="3. 打开gitBash，执行"></a>3. 打开gitBash，执行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h3 id="4-解决GitBash乱码问题"><a href="#4-解决GitBash乱码问题" class="headerlink" title="4.解决GitBash乱码问题"></a>4.解决GitBash乱码问题</h3><h4 id="1-打开GitBash执行下面命令"><a href="#1-打开GitBash执行下面命令" class="headerlink" title="1. 打开GitBash执行下面命令"></a>1. 打开GitBash执行下面命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="2-你按照Git的文件目录下-etc-bash-bashrc-文件最后加入下面两行"><a href="#2-你按照Git的文件目录下-etc-bash-bashrc-文件最后加入下面两行" class="headerlink" title="2. ${你按照Git的文件目录下}&#x2F;etc&#x2F;bash.bashrc 文件最后加入下面两行"></a>2. ${你按照Git的文件目录下}&#x2F;etc&#x2F;bash.bashrc 文件最后加入下面两行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LANG=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br><span class="line"><span class="built_in">export</span> LC_ALL=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="四、基础操作指令"><a href="#四、基础操作指令" class="headerlink" title="四、基础操作指令"></a>四、基础操作指令</h2><h3 id="1-获取本地仓库"><a href="#1-获取本地仓库" class="headerlink" title="1.获取本地仓库"></a>1.获取本地仓库</h3><p>​    要使用Git对我们的代码进行版本控制，首先需要获得本地仓库</p>
<ol>
<li>在电脑的任意位置创建一个空目录（例如test）作为我们的本地Git仓库</li>
<li>进入这个目录中，点击右键打开Git bash窗口</li>
<li>执行命令git init</li>
<li>如果创建成功后可在文件夹下看到隐藏的.git目录。</li>
</ol>
<p> <img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/9d3457667191dc71d53fe50ca36ea5da.png" alt="img"></p>
<h3 id="2-基础的操作指令"><a href="#2-基础的操作指令" class="headerlink" title="2.基础的操作指令"></a>2.基础的操作指令</h3><p>加 * 号的是重点</p>
<p>​    Git工作目录下对于文件的修改(增加、删除、更新)会存在几个状态，这些修改的状态会随着我们执行Git 的命令而发生变化。</p>
<p> <img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/8575160fb024491ad5b6cf97eecacd9e.png" alt="img"></p>
<p>​     工作区，暂存区和仓库之间的状态转换： </p>
<ul>
<li>git add (工作区 –&gt; 暂存区)</li>
<li>git commit (暂存区 –&gt; 本地仓库)</li>
</ul>
<h4 id="1-查看修改的状态（status）"><a href="#1-查看修改的状态（status）" class="headerlink" title="1.查看修改的状态（status）*"></a>1.查看修改的状态（status）*</h4><p>​        作用：查看的修改的状态（暂存区、工作区）</p>
<p>​        命令形式：git status</p>
<h4 id="2-添加工作区到暂存区-add"><a href="#2-添加工作区到暂存区-add" class="headerlink" title="2.添加工作区到暂存区(add) *"></a>2.添加工作区到暂存区(add) *</h4><p>​        作用：添加工作区一个或多个文件的修改到暂存区</p>
<p>​        命令形式：git add 单个文件名|通配符</p>
<p>​                将所有修改加入暂存区：git add .</p>
<h4 id="3-提交暂存区到本地仓库-commit"><a href="#3-提交暂存区到本地仓库-commit" class="headerlink" title="3.提交暂存区到本地仓库(commit) *"></a>3.提交暂存区到本地仓库(commit) *</h4><p>​        作用：提交暂存区内容到本地仓库的当前分支</p>
<p>​        命令形式：git commit -m “注释内容”</p>
<h4 id="4-查看提交日志-log"><a href="#4-查看提交日志-log" class="headerlink" title="4.查看提交日志(log) *"></a>4.查看提交日志(log) *</h4><p>​        因为前面配置的别名 git-log 就包含了这些参数，所以<strong>后续可以直接使用指令 git-log</strong></p>
<p>​             作用:查看提交记录</p>
<p>​            命令形式：git log [option]</p>
<p>​               options(非必须填写)</p>
<p>​                    1.all 显示所有分支</p>
<p>​                    2.pretty&#x3D;oneline 将提交信息显示为一行</p>
<p>​                    3.abbrev-commit 使得输出的commitId更简短 </p>
<p>​                    4.graph 以图的形式显示</p>
<h4 id="5-版本回退"><a href="#5-版本回退" class="headerlink" title="5.版本回退"></a>5.版本回退</h4><p>​        作用：版本切换</p>
<p>​        命令形式：git reset –hard commitID</p>
<p>​            commitID 可以使用 <code>git-log</code> 或 <code>git log</code> 指令查看（就是查出来前面那一串字母数字）</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250220204859956.png"></p>
<p>​        <strong>如何查看已经删除的记录？</strong></p>
<p>​            git reflog 这个指令可以看到已经删除的提交记录</p>
<h4 id="6-添加文件至忽略列表-设置文件不让git管理"><a href="#6-添加文件至忽略列表-设置文件不让git管理" class="headerlink" title="6.添加文件至忽略列表(设置文件不让git管理)"></a>6.添加文件至忽略列表(设置文件不让git管理)</h4><p>​    一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动 生成的文件，比如日志文件，或者编译过程中创建的临时文件等。</p>
<p>​    在这种情况下，我们可以在工作目录 中创建一个名为 .gitignore 的文件**（文件名称固定）**，列出要忽略的文件模式。下面是一个示例：</p>
<blockquote>
<p> *.a   ——-意思是.a的文件不用它管理</p>
</blockquote>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250220205046755.png" alt="image-20250220205046755"></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250220205100133.png" alt="image-20250220205100133"></p>
<h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><p>​    几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离 开来进行重大的Bug修改、开发新的功能，以免影响开发主线。</p>
<h4 id="0-head"><a href="#0-head" class="headerlink" title="0.head-&gt;"></a>0.head-&gt;</h4><p>head-&gt;指向谁谁就是当前分支</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250220205800637.png" alt="image-20250220205800637"></p>
<p>当前分支是dev01</p>
<h4 id="1-查看本地分支"><a href="#1-查看本地分支" class="headerlink" title="1.查看本地分支"></a>1.查看本地分支</h4><p>​            命令：git branch</p>
<h4 id="2-创建本地分支"><a href="#2-创建本地分支" class="headerlink" title="2.创建本地分支"></a>2.创建本地分支</h4><p>​            命令：git branch 分支名</p>
<h4 id="3-切换分支-checkout"><a href="#3-切换分支-checkout" class="headerlink" title="3.切换分支(checkout) *"></a>3.切换分支(checkout) *</h4><p>​            命令：git checkout 分支名</p>
<h4 id="4-创建并切换分支"><a href="#4-创建并切换分支" class="headerlink" title="4.创建并切换分支"></a>4.创建并切换分支</h4><p>​            命令：git checkout -b 分支名</p>
<h4 id="5-合并分支-merge"><a href="#5-合并分支-merge" class="headerlink" title="5.合并分支(merge) *"></a>5.合并分支(merge) *</h4><p>​          一个分支上的提交可以合并到另一个分支</p>
<p>​    ·        命令：git merge 分支名称</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250220210110973.png" alt="image-20250220210110973"></p>
<p>当前在master分支输入 git merge dev01，就是把dev01的所有修改移动到master中</p>
<h4 id="6-删除分支"><a href="#6-删除分支" class="headerlink" title="6.删除分支"></a>6.删除分支</h4><p>​         <strong>不能删除当前分支，只能删除其他分支</strong></p>
<p>​            git branch -d 分支名 删除分支时，需要做各种检查。</p>
<p>​            git branch -D 分支名 不做任何检查，强制删除。</p>
<h4 id="7-合并分支时的解决冲突"><a href="#7-合并分支时的解决冲突" class="headerlink" title="7.合并分支时的解决冲突"></a>7.合并分支时的解决冲突</h4><p>​    当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解 决冲突，解决冲突步骤如下：</p>
<ol>
<li>处理文件中冲突的地方</li>
<li>将解决完冲突的文件加入暂存区(add)</li>
<li>提交到仓库(commit)</li>
</ol>
<p> 冲突部分的内容处理如下所示：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/5a7fd3aa07aef98b580ced5fdf2d6b79.png" alt="img"></p>
<h4 id="8-开发中分支使用原则与流程"><a href="#8-开发中分支使用原则与流程" class="headerlink" title="8.开发中分支使用原则与流程"></a>8.开发中分支使用原则与流程</h4><p>​    几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离 开来进行重大的Bug修改、开发新的功能，以免影响开发主线。</p>
<p>​    在开发中，一般有如下分支使用原则与流程：</p>
<p>​    <strong>master （生产） 分支</strong></p>
<p>​        线上分支，主分支，中小规模项目作为线上运行的应用对应的分支；</p>
<p>​    <strong>develop（开发）分支</strong></p>
<p>​        是从master创建的分支，一般作为开发部门的主要开发分支，如果没有其他并行开发不同期上线 要求，都可以在此版本进行开发，阶段开发完成后，需要是合并到master分支,准备上线。</p>
<p>​    <strong>feature&#x2F;xxxx分支</strong></p>
<p>​        从develop创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的研发任务完 成后合并到develop分支。</p>
<p>​    <strong>hotfix&#x2F;xxxx分支</strong></p>
<p>​        从master派生的分支，一般作为线上bug修复使用，修复完成后需要合并到master、test、 develop分支。</p>
<p>​    还有一些其他分支，在此不再详述，例如test分支（用于代码测试）、pre分支（预上线分支）等等。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/34d2ef51ec71b565d3b480e4cec9f0e2.png" alt="img"></p>
<h2 id="六、Git远程仓库"><a href="#六、Git远程仓库" class="headerlink" title="六、Git远程仓库"></a>六、Git远程仓库</h2><h3 id="1-常用的托管服务-远程仓库"><a href="#1-常用的托管服务-远程仓库" class="headerlink" title="1.常用的托管服务[远程仓库]"></a>1.常用的托管服务[远程仓库]</h3><p>​    我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云、GitLab等。</p>
<blockquote>
<p>​    gitHub（ 地址：<a href="https://github.com/">https://github.com/</a> ）是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名gitHub</p>
</blockquote>
<blockquote>
<p>​    码云（地址： <a href="https://gitee.com/">https://gitee.com/</a> ）是国内的一个代码托管平台，由于服务器在国内，所以相比于 GitHub，码云速度会更快</p>
</blockquote>
<blockquote>
<p>​    GitLab （地址： <a href="https://about.gitlab.com/">https://about.gitlab.com/</a> ）是一个用于仓库管理系统的开源项目，使用Git作 为代码管理工具，并在此基础上搭建起来的web服务,一般用于在企业、学校等内部网络搭建git私服。</p>
</blockquote>
<h3 id="2-注册账号"><a href="#2-注册账号" class="headerlink" title="2.注册账号"></a>2.注册账号</h3><p>大家应该都会</p>
<h3 id="3-创建远程仓库"><a href="#3-创建远程仓库" class="headerlink" title="3.创建远程仓库"></a>3.创建远程仓库</h3><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/2898113bd33ffd06e4baceefecea59e9.png" alt="img"></p>
<h3 id="4-配置SSH公钥"><a href="#4-配置SSH公钥" class="headerlink" title="4.配置SSH公钥"></a>4.配置SSH公钥</h3><h4 id="1-生成SSH公钥"><a href="#1-生成SSH公钥" class="headerlink" title="1.生成SSH公钥"></a>1.生成SSH公钥</h4><p>​            输入命令：ssh-keygen -t rsa</p>
<p>​            不断回车</p>
<p>​                如果公钥已经存在，则自动覆盖</p>
<h4 id="2-Gitee设置账户共公钥"><a href="#2-Gitee设置账户共公钥" class="headerlink" title="2.Gitee设置账户共公钥"></a>2.Gitee设置账户共公钥</h4><p>​            获取公钥</p>
<p>​                输入命令：cat ~&#x2F;.ssh&#x2F;id_rsa.pub</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/2eb60352e431289230e4d22241ce7ee5.png" alt="img"></p>
<h4 id="3-验证是否配置成功"><a href="#3-验证是否配置成功" class="headerlink" title="3.验证是否配置成功"></a>3.验证是否配置成功</h4><p>​         输入命令：ssh -T <a href="mailto:&#103;&#105;&#x74;&#64;&#x67;&#x69;&#x74;&#x65;&#x65;&#46;&#99;&#x6f;&#109;">git@gitee.com</a></p>
<h3 id="5-操作远程仓库"><a href="#5-操作远程仓库" class="headerlink" title="5.操作远程仓库"></a>5.操作远程仓库</h3><h4 id="1-添加远程仓库"><a href="#1-添加远程仓库" class="headerlink" title="1. 添加远程仓库"></a>1. 添加远程仓库</h4><p>​            此操作是先初始化本地库，然后与已创建的远程库进行对接。</p>
<p>​                命令： git remote add &lt;远端名称&gt;&lt;仓库路径&gt;，</p>
<p>​                远程名称，默认是origin，取决于远端服务器设置</p>
<p>​                仓库路径，从远端服务器获取此URL</p>
<blockquote>
<p>例如: git remote add origin <a href="mailto:&#103;&#x69;&#116;&#x40;&#x67;&#105;&#116;&#101;&#x65;&#x2e;&#99;&#x6f;&#x6d;">git@gitee.com</a>:czbk_zhang_meng&#x2F;git_test.git</p>
</blockquote>
<p>​     <strong>仓库路径获取示例如下：</strong></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/e7c0119b3248bb96bc4a759cf3d2719c.png" alt="img"></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@gitee.com:darling_123456/git_test.git</span><br></pre></td></tr></table></figure>

<h4 id="2-查看远程仓库"><a href="#2-查看远程仓库" class="headerlink" title="2.查看远程仓库"></a>2.查看远程仓库</h4><p>​            命令：git remote</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250223154842556.png" alt="image-20250223154842556"></p>
<h4 id="3-推送到远程仓库"><a href="#3-推送到远程仓库" class="headerlink" title="3. 推送到远程仓库"></a>3. 推送到远程仓库</h4><p>命令：git push [-f] [–set-upstream] [远端名称 [本地分支名][:远端分支名] ]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master:master</span><br></pre></td></tr></table></figure>

<p>如果远程分支名和本地分支名称相同，则可以只写本地分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>​                -f 表示强制覆盖</p>
<p>​                –set-upstream 推送到远端的同时并且建立起和远端分支的关联关系。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250223155204568.png" alt="image-20250223155204568"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure>

<p>执行这句以后就不用写origin和master直接给git push它也知道要往哪里push</p>
<p>如果<strong>当前分支已经和远端分支关联</strong>，则可以省略分支名和远端名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push  <span class="comment">#将master分支推送到已关联的远端分支。</span></span><br></pre></td></tr></table></figure>

<h4 id="4-本地分支与远程分支的关联关系"><a href="#4-本地分支与远程分支的关联关系" class="headerlink" title="4.本地分支与远程分支的关联关系"></a>4.本地分支与远程分支的关联关系</h4><p>查看关联关系我们可以使用 git branch -vv 命令</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250223160010339.png" alt="image-20250223160010339"></p>
<h4 id="5-从远程仓库克隆"><a href="#5-从远程仓库克隆" class="headerlink" title="5.从远程仓库克隆"></a>5.从远程仓库克隆</h4><p>如果已经有一个远端仓库，我们可以直接clone到本地。</p>
<blockquote>
<p>命令: git clone &lt;仓库路径&gt; [本地目录]  本地目录可以省略，会自动生成一个目录</p>
</blockquote>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/330e945ebd5a2f47f0ae3eea97275142.png" alt="img"></p>
<h4 id="6-从远程仓库中抓取和拉取"><a href="#6-从远程仓库中抓取和拉取" class="headerlink" title="6.从远程仓库中抓取和拉取"></a>6.从远程仓库中抓取和拉取</h4><p> 远程分支和本地的分支一样，我们可以进行merge操作，只是需要先把远端仓  库里的更新都下载到本地，再进行操作。</p>
<p> **抓取命令：**git fetch [remote name] [branch name]</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250223160832106.png" alt="image-20250223160832106"></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250223161201571.png" alt="image-20250223161201571"></p>
<blockquote>
<ul>
<li>抓取指令就是将仓库里的更新都抓取到本地，不会进行合并</li>
<li>如果不指定远端名称和分支名，则抓取所有分支</li>
</ul>
</blockquote>
<p><strong>拉取命令</strong>：git pull [remote name] [branch name]</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250223161113504.png" alt="image-20250223161113504"></p>
<blockquote>
<ul>
<li>拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge</li>
<li><strong>如果不指定远端名称和分支名，则抓取所有并更新当前分支。</strong></li>
</ul>
</blockquote>
<p>这里如果看他的b视频没看懂的话可以去看上面的整体的工作流程图，就容易多了。</p>
<h4 id="7-解决合并冲突"><a href="#7-解决合并冲突" class="headerlink" title="7.解决合并冲突"></a>7.解决合并冲突</h4><p>​    在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。 A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要 推送到远程仓库，此时B用户晚于A用户，故需要先拉取远程仓库的提交，经过合并后才能推送到远端分支,如下图所示。 </p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/6178d6725f1b5198b31af6bdaa2986e4.png" alt="img"></p>
<p>​    在B用户拉取代码时，因为A、B用户同一段时间修改了同一个文件的相同位置代码，故会发生合并冲 突。</p>
<blockquote>
<p>远程分支也是分支，所以合并时冲突的解决方式也和解决本地分支冲突相同相同。</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>好用工具</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>尚硅谷 | Nginx | 学习笔记</title>
    <url>/2024/10/26/%E5%B7%A5%E5%85%B7/%E5%B0%9A%E7%A1%85%E8%B0%B7%20%20Nginx%20%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="尚硅谷-Nginx-学习笔记"><a href="#尚硅谷-Nginx-学习笔记" class="headerlink" title="尚硅谷 | Nginx | 学习笔记"></a>尚硅谷 | Nginx | 学习笔记</h1><p><a href="https://www.bilibili.com/video/BV1zJ411w7SV?vd_source=7831c5b97cfc5c745eb48ff04f6515e7&spm_id_from=333.788.videopod.episodes">尚硅谷Nginx教程由浅入深（一套打通丨初学者也可掌握）_哔哩哔哩_bilibili</a></p>
<p>正向隐藏客户端，反向隐藏服务器端</p>
<h2 id="一、Nginx相关概念"><a href="#一、Nginx相关概念" class="headerlink" title="一、Nginx相关概念"></a>一、Nginx相关概念</h2><h3 id="1-Nginx是什么"><a href="#1-Nginx是什么" class="headerlink" title="1.Nginx是什么"></a>1.Nginx是什么</h3><ul>
<li>Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、简单的配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。</li>
<li>Nginx是一款<strong>轻量级</strong>的Web 服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器，在BSD-like 协议下发行。其特点是<strong>占有内存少，并发能力强</strong>，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</li>
<li>Nginx 是高性能的 HTTP 和反向代理的web服务器，处理高并发能力是十分强大的，能经受高负 载的考验,有报告表明能支持高达 50,000 个并发连接数。</li>
<li>Nginx支持热部署，启动简单，可以做到7*24不间断运行。几个月都不需要重新启动。</li>
</ul>
<h3 id="2-正向代理和反向代理"><a href="#2-正向代理和反向代理" class="headerlink" title="2.正向代理和反向代理"></a>2.正向代理和反向代理</h3><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>Nginx 不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。 <strong>正向代理：如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访 问 Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理。</strong></p>
<ul>
<li>简单一点：通过代理服务器来访问服务器的过程 就叫 正向代理。</li>
<li>需要在客户端配置代理服务器进行指定网站访问</li>
</ul>
<p><code>举个例子：</code></p>
<p>我们如果要科学上网的话，就可以通过nginx代理服务器访问外网的服务器。而我们直接访问外网的服务器是访问不了的。</p>
<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><ul>
<li><strong>我们只 需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返 回给客户端</strong>，此时反向代理服务器和目标服务器对外就是一个服务器，<strong>暴露的是代理服务器 地址，隐藏了真实服务器 IP 地址。</strong></li>
<li>反向代理，<strong>客户端对代理是无感知的，因为客户端不需要任何配置就可以访问</strong>。</li>
</ul>
<p><code>总结</code></p>
<p>正向代理隐藏客户端，反向代理隐藏服务器端</p>
<h3 id="3-负载均衡和动静分离"><a href="#3-负载均衡和动静分离" class="headerlink" title="3.负载均衡和动静分离"></a>3.负载均衡和动静分离</h3><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><ul>
<li>增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的 情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负 载均衡</li>
<li>客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服 务器处理完毕后，再将结果返回给客户端。</li>
</ul>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241025182817000.png" alt="image-20241025182817000"></p>
<p>原来只有8081，有15个请求只能挨个等着处理</p>
<p>现在有三台，每台就只需要处理5个，用户等待的时间就会变短。</p>
<h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。</p>
<p>就是把动态的资源放到专门的服务器，静态的放到别的的专门的服务器，客户访问的时候由nginx进行请求的转发。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241026093216904.png" alt="image-20241026093216904"></p>
<h2 id="二、Nginx-的安装-Linux-centos为例"><a href="#二、Nginx-的安装-Linux-centos为例" class="headerlink" title="二、Nginx 的安装(Linux:centos为例)"></a>二、Nginx 的安装(Linux:centos为例)</h2><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h3><ul>
<li><p>打开虚拟机，使用finallshell链接Linux操作系统</p>
</li>
<li><p>到nginx下载软件<br><a href="http://nginx.org/">http://nginx.org/</a><br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/8f7f9c7db231d0ede18d7ea39d7aab36.png" alt="在这里插入图片描述"></p>
</li>
<li><p>先安装其依赖软件，最后安装nginx。</p>
</li>
<li><p>依赖工具：</p>
<p>pcre-8.3.7.tar.gz， openssl-1.0.1t.tar.gz， zlib-1.2.8.tar.gz， nginx-1.11.1.tar.gz。</p>
<p>我这里也提供下。</p>
<ol>
<li>nginx的http模块使用pcre来解析正则表达式，需要在linux上安装<code>pcre</code>库</li>
<li>nginx使用zlib对http包的内容进行gzip，需要在linux上安装安装<code>zlib</code>库</li>
<li>安装<code>openssl</code>库，让 nginx 支持 https（即在ssl协议上传输http）</li>
</ol>
</li>
</ul>
<h3 id="2-开始安装"><a href="#2-开始安装" class="headerlink" title="2. 开始安装"></a>2. 开始安装</h3><ul>
<li>都有两种方式，一种直接下载，第二种使用解压包方式。这里大多使用解压包方式。</li>
<li><strong>我的安装路径：&#x2F;usr&#x2F;feng&#x2F;</strong></li>
<li>Mac系统安装请移步到这儿（和Linux安装并无多大区别）：<a href="https://blog.csdn.net/qq_40036754/article/details/127668301">Mac os 安装 nginx 教程（success）</a></li>
</ul>
<ol>
<li><strong>安装pcre</strong><br>方式一、<code>wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz </code>。<br>方拾二、上传源码压缩包，解压、编译、安装 三部曲。<br>1）、解压文件， 进入pcre目录，<br>2）、.&#x2F;configure 完成后，<br>3）、执行命令： make &amp;&amp; make install</li>
<li><strong>安装 openssl</strong><br>下载OpenSSL的地址:<br><a href="http://distfiles.macports.org/openssl/">http://distfiles.macports.org/openssl/</a><br>1）、解压文件， 回到 openssl目录下，<br>2）、.&#x2F;configure 完成后，<br>3）、执行命令： make &amp;&amp; make install</li>
<li><strong>安装 zlib</strong><br>1）、解压文件， 回到 zlib 目录下，<br>2）、.&#x2F;configure 完成后，<br>3）、执行命令： make &amp;&amp; make install</li>
<li>**安装 nginx **<br>1）、解压文件， 回到 nginx 目录下，<br>2）、.&#x2F;configure 完成后，<br>3）、执行命令： make &amp;&amp; make install</li>
</ol>
<h3 id="3-运行nginx"><a href="#3-运行nginx" class="headerlink" title="3. 运行nginx"></a>3. 运行nginx</h3><ul>
<li>安装完nginx后，会在 路径 <code>/usr/local</code> 下自动生成 <code>nginx</code> 文件夹。这是自动生成的。</li>
<li>进入这个目录：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx</span><br></pre></td></tr></table></figure>

<p>目录内容如下：<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/e80ed439333ee9efb0927463b4795270.png" alt="在这里插入图片描述"></p>
<ul>
<li>进入sbin文件夹,里面有两个文件：<code>nginx</code> 和 <code>nginx.old</code>。</li>
<li>执行命令：<strong>.&#x2F;nginx</strong> 即可执行</li>
<li>测试启动： <strong>ps -ef | grep nginx</strong><br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/852e2cf5895e53b9510929906b23b3eb.png" alt="在这里插入图片描述"><br>已经启动。</li>
<li>查看nginx默认端口（默认为80），使用网页的形式测试，（像Tomcat一样。）</li>
<li><strong>进入目录查看端口：cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf 下的 nginx.conf文件</strong>。这个文件也是nginx的配置文件。vim 下：<br>如下<img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/e73a412bcb03e0d37a877b58ebf01a98.png" alt="在这里插入图片描述"></li>
<li>输入IP:80，则显示：<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/a20946e0f25a15d1382bbd85caa62477.png" alt="在这里插入图片描述"></li>
</ul>
<h3 id="4-防火墙问题"><a href="#4-防火墙问题" class="headerlink" title="4. 防火墙问题"></a>4. 防火墙问题</h3><p>在 windows 系统中访问 linux 中 nginx，默认不能访问的，因为防火墙问题 （1）关闭防火墙 （2）开放访问的端口号，80 端口</p>
<p>查看开放的端口号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-all </span><br></pre></td></tr></table></figure>

<p>设置开放的端口号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-service=http –permanent </span><br><span class="line">firewall-cmd --add-port=80/tcp --permanent </span><br></pre></td></tr></table></figure>

<p>重启防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd –reload </span><br></pre></td></tr></table></figure>

<h2 id="三、-Nginx-的常用命令和配置文件"><a href="#三、-Nginx-的常用命令和配置文件" class="headerlink" title="三、 Nginx 的常用命令和配置文件"></a>三、 Nginx 的常用命令和配置文件</h2><h3 id="1-Nginx常用命令"><a href="#1-Nginx常用命令" class="headerlink" title="1. Nginx常用命令"></a>1. Nginx常用命令</h3><h4 id="a-使用nginx操作命令前提"><a href="#a-使用nginx操作命令前提" class="headerlink" title="a. 使用nginx操作命令前提"></a>a. 使用nginx操作命令前提</h4><p>使用nginx操作命令前提：<strong>必须进入到nginx的自动生成目录的下&#x2F;sbin文件夹下</strong>。<br>nginx有两个目录：<br><strong>第一个</strong>：安装目录，我放在：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/feng/</span><br></pre></td></tr></table></figure>

<p><strong>第二个</strong>：自动生成目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/</span><br></pre></td></tr></table></figure>

<h4 id="b-查看-nginx-的版本号"><a href="#b-查看-nginx-的版本号" class="headerlink" title="b. 查看 nginx 的版本号"></a>b. 查看 nginx 的版本号</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./nginx -v</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/4ddc16d9763ca9b0a8ab669da0e430c7.png" alt="在这里插入图片描述"></p>
<h4 id="c-启动-nginx"><a href="#c-启动-nginx" class="headerlink" title="c. 启动 nginx"></a>c. 启动 nginx</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./nginx</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/20201a5670ffd72ca8bc5d1878c0a16a.png" alt="在这里插入图片描述"></p>
<h4 id="d-关闭nginx"><a href="#d-关闭nginx" class="headerlink" title="d. 关闭nginx"></a>d. 关闭nginx</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./nginx -s stop</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/306c0f4e65171101d12f3428ccce21ea.png" alt="在这里插入图片描述"></p>
<h4 id="e-重新加载-nginx"><a href="#e-重新加载-nginx" class="headerlink" title="e. 重新加载 nginx"></a>e. 重新加载 nginx</h4><p>在目录：<strong>&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin 下执行命令</strong>，不需要重启服务器，自动编译。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure>

<h3 id="2-Nginx配置文件"><a href="#2-Nginx配置文件" class="headerlink" title="2. Nginx配置文件"></a>2. Nginx配置文件</h3><h4 id="a-配置文件位置"><a href="#a-配置文件位置" class="headerlink" title="a. 配置文件位置"></a>a. 配置文件位置</h4><p>&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/a5b2476f5079f3ddb3442329aba618a0.png" alt="在这里插入图片描述"></p>
<h4 id="b-nginx-的组成部分"><a href="#b-nginx-的组成部分" class="headerlink" title="b. nginx 的组成部分"></a>b. nginx 的组成部分</h4><p>配置文件中有很多#， 开头的表示注释内容，我们去掉所有以 # 开头的段落，精简之后的 内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>nginx 配置文件有三部分组成</li>
</ul>
<h5 id="第一部分：全局块"><a href="#第一部分：全局块" class="headerlink" title="第一部分：全局块"></a>第一部分：全局块</h5><p>从配置文件开始到 events 块之间的内容，主要会设置一些影响nginx 服务器整体运行的配置指令，主要包括配 置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以 及配置文件的引入等。<br>比如上面第一行配置的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_processes  1;</span><br></pre></td></tr></table></figure>

<p>这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是 会受到硬件、软件等设备的制约。</p>
<h5 id="第二部分：events块"><a href="#第二部分：events块" class="headerlink" title="第二部分：events块"></a>第二部分：events块</h5><p>比如上面的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>events 块涉及的指令<strong>主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否 允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。</strong><br>上述例子就表示每个 work process 支持的最大连接数为 1024.<br>这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。</p>
<h5 id="第三部分："><a href="#第三部分：" class="headerlink" title="第三部分："></a>第三部分：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。</p>
<p>需要注意的是：http 块也可以包括 http全局块、server 块。</p>
<ul>
<li><strong>http全局块</strong><br>http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</li>
<li><strong>server 块</strong><br>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了 节省互联网服务器硬件成本。<br><strong>每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。</strong><br><strong>而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。</strong></li>
</ul>
<ol>
<li><strong>全局 server 块</strong><br>最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。</li>
<li><strong>location 块</strong><br>一个 server 块可以配置多个 location 块。<br>这块的主要作用是<strong>基于 Nginx 服务器接收到的请求字符串（例如 server_name&#x2F;uri-string），对虚拟主机名称 （也可以是IP 别名）之外的字符串（例如 前面的 &#x2F;uri-string）进行匹配，对特定的请求进行处理。</strong> 地址定向、数据缓 存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</li>
</ol>
<h2 id="四、-Nginx-反向代理-https-so-csdn-net-so-search-q-Nginx-反向代理-spm-1001-2101-3001-7020-配置实例-1-1"><a href="#四、-Nginx-反向代理-https-so-csdn-net-so-search-q-Nginx-反向代理-spm-1001-2101-3001-7020-配置实例-1-1" class="headerlink" title="四、 [Nginx 反向代理](https://so.csdn.net/so/search?q=Nginx 反向代理&amp;spm&#x3D;1001.2101.3001.7020) 配置实例 1.1"></a>四、 [Nginx 反向代理](<a href="https://so.csdn.net/so/search?q=Nginx">https://so.csdn.net/so/search?q=Nginx</a> 反向代理&amp;spm&#x3D;1001.2101.3001.7020) 配置实例 1.1</h2><h3 id="1-实现效果"><a href="#1-实现效果" class="headerlink" title="1. 实现效果"></a>1. 实现效果</h3><ul>
<li>打开浏览器，在浏览器地址栏输入地址 <a href="http://www.123.com,跳转到/">www.123.com，跳转到</a> liunx 系统 tomcat 主页 面中</li>
</ul>
<h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h3><p>（1）在 liunx 系统安装 tomcat，使用默认端口 8080，<strong>我这里8080被其他应用占用，所以我已修改端口为8081。在conf目录下的server.xml配置文件中，如下，将port改为 8081，其实下面也有类似的Connector 标签，但是要看protocol协议为HTTP&#x2F;1.1的标签修改即可。</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8081&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>tomcat 安装文件放到 liunx 系统中，解压。<br><strong>Tomcat的路径</strong>：&#x2F;usr&#x2F;feng&#x2F;apach-tomcat&#x2F;tomcat8081下</li>
<li>进入 tomcat 的 bin 目录中，.&#x2F;startup.sh 启动 tomcat 服务器。</li>
</ul>
<p>（2）<strong>对外开放访问的端口</strong> （我这里不需要）</p>
<ul>
<li>firewall-cmd –add-port&#x3D;8080&#x2F;tcp –permanent</li>
<li>firewall-cmd –reload</li>
<li>查看已经开放的端口号 firewall-cmd –list-all</li>
</ul>
<p>（3）<strong>在 windows 系统中通过浏览器访问 tomcat 服务器</strong><br>别忘了开启tomcat，在bin目录下，使用 命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./startup.sh</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/3c945431dadec06fd786647d5e579319.png" alt="在这里插入图片描述"></p>
<h3 id="3-访问过程的分析"><a href="#3-访问过程的分析" class="headerlink" title="3. 访问过程的分析"></a>3. 访问过程的分析</h3><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/506f0e209685570147eda75b77e4f839.png" alt="在这里插入图片描述"></p>
<h3 id="4、具体配置"><a href="#4、具体配置" class="headerlink" title="4、具体配置"></a>4、具体配置</h3><h4 id="a-第一步-在-windows-系统的-host-文件进行域名和-ip-对应关系的配置"><a href="#a-第一步-在-windows-系统的-host-文件进行域名和-ip-对应关系的配置" class="headerlink" title="a. 第一步 在 windows 系统的 host 文件进行域名和 ip 对应关系的配置"></a>a. 第一步 在 windows 系统的 host 文件进行域名和 ip 对应关系的配置</h4><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/777e31a4c36cd547ad3a38547c6c478f.png" alt="在这里插入图片描述"><br><strong>添加内容在 host 文件中</strong><br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/66e7ca230738a7e51737d540127e10b4.png" alt="在这里插入图片描述"></p>
<h4 id="2-第二步-在-nginx-进行请求转发的配置（反向代理配置）"><a href="#2-第二步-在-nginx-进行请求转发的配置（反向代理配置）" class="headerlink" title="2. 第二步 在 nginx 进行请求转发的配置（反向代理配置）"></a>2. 第二步 在 nginx 进行请求转发的配置（反向代理配置）</h4><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/56af00e9abc7b78569f57a3308b6168a.png" alt="在这里插入图片描述"></p>
<h3 id="5、最终测试"><a href="#5、最终测试" class="headerlink" title="5、最终测试"></a>5、最终测试</h3><p><strong>如上配置，我们监听 80 端口，访问域名为 <a href="http://www.123.com,不加端口号时默认为/">www.123.com，不加端口号时默认为</a> 80 端口，故 访问该域名时会跳转到 127.0.0.1:8081 路径上。在浏览器端输入 <a href="http://www.123.com/">www.123.com</a> 结果如下：</strong></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/14f9bc5c2ef9da801e327eb39f00e798.png" alt="在这里插入图片描述"></p>
<h2 id="五、-Nginx-反向代理-配置实例-1-2"><a href="#五、-Nginx-反向代理-配置实例-1-2" class="headerlink" title="五、 Nginx 反向代理 配置实例 1.2"></a>五、 Nginx 反向代理 配置实例 1.2</h2><h3 id="1-实现效果-1"><a href="#1-实现效果-1" class="headerlink" title="1. 实现效果"></a>1. 实现效果</h3><p>实现效果：使用 nginx 反向代理，根据访问的路径跳转到不同端口的服务中<br>nginx 监听端口为 8001，<br>访问 <a href="http://127.0.0.1:8001/edu/">http://127.0.0.1:8001/edu/</a> 直接跳转到 127.0.0.1:8081<br>访问 <a href="http://127.0.0.1:8001/vod/">http://127.0.0.1:8001/vod/</a> 直接跳转到 127.0.0.1:8082</p>
<h3 id="2-准备工作-1"><a href="#2-准备工作-1" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h3><h4 id="a-第一步，两个tomcat端口和测试页面"><a href="#a-第一步，两个tomcat端口和测试页面" class="headerlink" title="a. 第一步，两个tomcat端口和测试页面"></a>a. 第一步，两个tomcat端口和测试页面</h4><ul>
<li>准备两个 tomcat，一个 8081 端口，一个 8082 端口。<br>在**&#x2F;usr&#x2F;feng&#x2F;apach-tomcat&#x2F;<strong>下 新建tomcat8081和tomcat8082两个文件夹，将 Tomcat安装包 分别上传到两个文件夹，进行解压缩安装，8081的Tomcat只改一个</strong>http协议默认端口号** 就行，直接启动即可。<br>这里需要改8082的端口号，需要修改三个端口，只修改一个端口号的话，是启动不了的，我已经测试过了（如果只修改http协议默认端口的话，8081和8082只会启动一个）。因为默认的都是8080（<strong>没有的直接创建文件夹，好多都是刚建的，与上面的第一个示例示例有点改动</strong>）</li>
</ul>
<ol>
<li>tomcat8081 解压包，然后进入到 &#x2F;bin 下 ，使用命令 .&#x2F;startup 启动</li>
<li>tomcat8082<br>使用命令 编辑 文件 ：&#x2F;conf&#x2F;server.xml 文件<br>vim server.xml<br>修改后如下：<br><strong>1、修改server 的默认端口，由默认8005-&gt;8091</strong><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/90d70a9a740cdb3bcecc7e731e3c8b1f.png" alt="在这里插入图片描述"><br><strong>2、修改http协议的默认端口，由默认的8080-&gt;8082</strong><br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/5412598d639e04cddfaa877b9b759c6d.png" alt="在这里插入图片描述"><br><strong>3、修改默认ajp协议的默认端口，由默认的8009-&gt;9001</strong><br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/f6c6ac68ab44377881ac99dfcbab0897.png" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li>并准备好测试的页面<br>写一个a.html页面，<br>tomcat8081的tomcat，放到目录 &#x2F;webapp&#x2F;vod 下，内容：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>fengfanchen-nginx-8081!!!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>tomcat8082的tomcat，放到目录 &#x2F;webapp&#x2F;edu 下，内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>fengfanchen-nginx-8082!!!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>测试页面<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/dcb63e1a86744a2bbbcef75affaeb5ea.png" alt="在这里插入图片描述"><br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/98a18856e1104c6e464fbb8f4b62b6b7.png" alt="在这里插入图片描述"></li>
</ul>
<h4 id="b-第二步，修改-nginx-的配置文件"><a href="#b-第二步，修改-nginx-的配置文件" class="headerlink" title="b. 第二步，修改 nginx 的配置文件"></a>b. 第二步，修改 nginx 的配置文件</h4><p>修改 nginx 的配置文件 在 http 块中添加 server{}<br>修改其中注释的就行。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/51118112c1eb7c5ea99c04a7e6834892.png" alt="在这里插入图片描述"><br><strong>修改成功后</strong><br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/1c3d83290ff9f60cec05810070232db5.png" alt="在这里插入图片描述"></p>
<ul>
<li><strong>开发的端口： nginx监听端口：8001，tomcat8081端口：8081，tomcat8082端口：8082。</strong></li>
<li>测试结果<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/0fd38d9a658cc02539f882cb326ed766.png" alt="在这里插入图片描述"><br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/cb9a11eb7a689d99ff751c00cde47eb5.png" alt="在这里插入图片描述"></li>
<li><strong>location 指令说明</strong></li>
</ul>
<p>该指令用于匹配 URL。<br>语法如下：</p>
<p>1、&#x3D; ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配 成功，就停止继续向下搜索并立即处理该请求。<br>2、<del>：用于表示 uri 包含正则表达式，并且区分大小写。<br>3、</del>*：用于表示 uri 包含正则表达式，并且不区分大小写。<br>4、^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字 符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。</p>
<p><strong>注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~*标识。</strong></p>
<h2 id="六、-Nginx-负载均衡-配置实例-2"><a href="#六、-Nginx-负载均衡-配置实例-2" class="headerlink" title="六、 Nginx 负载均衡 配置实例 2"></a>六、 Nginx 负载均衡 配置实例 2</h2><h3 id="1-实现效果-2"><a href="#1-实现效果-2" class="headerlink" title="1. 实现效果"></a>1. 实现效果</h3><p>浏览器地址栏输入地址 <a href="http://208.208.128.122/edu/a.html%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%95%88%E6%9E%9C%EF%BC%8C%E5%B9%B3%E5%9D%87">http://208.208.128.122/edu/a.html，负载均衡效果，平均</a> 8081 和 8082 端口中</p>
<h3 id="2-准备工作-2"><a href="#2-准备工作-2" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h3><h4 id="a-准备两台-tomcat-服务器"><a href="#a-准备两台-tomcat-服务器" class="headerlink" title="a.准备两台 tomcat 服务器"></a>a.准备两台 tomcat 服务器</h4><ul>
<li>准备两台 tomcat 服务器，一台 8081，一台 8082</li>
<li>上面的反向代理第二个实例中已经配置成功了。但是需要添加点东西，如下哦。</li>
</ul>
<h4 id="b-修改一处"><a href="#b-修改一处" class="headerlink" title="b. 修改一处"></a>b. 修改一处</h4><ul>
<li>在两台 tomcat 里面 webapps 目录中，<strong>创建名称是 edu 文件夹，在 edu 文件夹中创建 页面 a.html，用于测试。</strong></li>
<li>由于第二个实例中，8082中有了 edu 的文件夹，所以只在8081 文件夹下创建即可。<br>然后使用在vod文件下使用命令：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp a.html ../edu/</span><br></pre></td></tr></table></figure>

<p>即可完成，<br>查看命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ../edu/  # 进入到 edu 目录下</span><br><span class="line">cat a.html  #查看内容</span><br></pre></td></tr></table></figure>

<h4 id="c-测试页面"><a href="#c-测试页面" class="headerlink" title="c. 测试页面"></a>c. 测试页面</h4><p>测试URL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://208.208.128.122:8081/edu/a.html</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/33a7fba42d6b2e697937b60ae73e6476.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://208.208.128.122:8082/edu/a.html</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/06379041c8b2c03b6898b251c710559b.png" alt="在这里插入图片描述"></p>
<h3 id="3-在-nginx-的配置文件中进行负载均衡的配置"><a href="#3-在-nginx-的配置文件中进行负载均衡的配置" class="headerlink" title="3. 在 nginx 的配置文件中进行负载均衡的配置"></a>3. 在 nginx 的配置文件中进行负载均衡的配置</h3><p>修改了第一个示例的 配置<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/3360379cf27d2bc0b6e13feedbbdf7cd.png" alt="在这里插入图片描述"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">upstream myserver &#123;</span><br><span class="line">    server 208.208.128.122:8081;</span><br><span class="line">    server 208.208.128.122:8082;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  208.208.128.122;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        proxy_pass   http://myserver;</span><br><span class="line">        #proxy_pass   http://127.0.0.1:8081;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-最终测试"><a href="#4-最终测试" class="headerlink" title="4. 最终测试"></a>4. 最终测试</h3><p>测试url</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://208.208.128.122/edu/a.html</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/61c78816a924018172b57d62a0513aec.png" alt="在这里插入图片描述"><br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/ea2573360902cdfc7d0bc9e7e0fef101.png" alt="在这里插入图片描述"></p>
<h3 id="4-nginx-分配服务器策略"><a href="#4-nginx-分配服务器策略" class="headerlink" title="4. nginx 分配服务器策略"></a>4. nginx 分配服务器策略</h3><p>随着互联网信息的爆炸性增长，负载均衡（load balance）已经不再是一个很陌生的话题， 顾名思义，负载均衡即是将负载分摊到不同的服务单元，既保证服务的可用性，又保证响应 足够快，给用户很好的体验。快速增长的访问量和数据流量催生了各式各样的负载均衡产品， 很多专业的负载均衡硬件提供了很好的功能，但却价格不菲，这使得负载均衡软件大受欢迎， nginx 就是其中的一个，在 linux 下有 Nginx、LVS、Haproxy 等等服务可以提供负载均衡服 务，而且 Nginx 提供了几种分配方式(策略)：</p>
<h4 id="a-轮询（默认）"><a href="#a-轮询（默认）" class="headerlink" title="a. 轮询（默认）"></a>a. 轮询（默认）</h4><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。<br>配置方式：</p>
<h4 id="b-weight"><a href="#b-weight" class="headerlink" title="b. weight"></a>b. weight</h4><p>weight 代表权重, 默认为 1,权重越高被分配的客户端越多</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream myserver &#123;</span><br><span class="line">    server 208.208.128.122:8081 weight=10;   #  在这儿</span><br><span class="line">    server 208.208.128.122:8082 weight=10;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  208.208.128.122;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        proxy_pass   http://myserver;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="c-ip-hash"><a href="#c-ip-hash" class="headerlink" title="c. ip_hash"></a>c. ip_hash</h4><p>ip_hash 每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream myserver &#123;</span><br><span class="line">	ip_hash;							//  在这儿</span><br><span class="line">    server 208.208.128.122:8081 ;   </span><br><span class="line">    server 208.208.128.122:8082 ;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  208.208.128.122;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        proxy_pass   http://myserver;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="d-fair（第三方）"><a href="#d-fair（第三方）" class="headerlink" title="d. fair（第三方）"></a>d. fair（第三方）</h4><p>fair（第三方），按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream myserver &#123;					</span><br><span class="line">    server 208.208.128.122:8081 ;   </span><br><span class="line">    server 208.208.128.122:8082 ;</span><br><span class="line">    fair; 														#  在这儿</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  208.208.128.122;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        proxy_pass   http://myserver;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、-Nginx-动静分离-配置实例-3"><a href="#七、-Nginx-动静分离-配置实例-3" class="headerlink" title="七、 Nginx 动静分离 配置实例 3"></a>七、 Nginx 动静分离 配置实例 3</h2><h3 id="1-什么是动静分离"><a href="#1-什么是动静分离" class="headerlink" title="1. 什么是动静分离"></a>1. 什么是动静分离</h3><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/d2a052bc3e43d63306f3679bfb538e1e.png" alt="在这里插入图片描述"><br>Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和 静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用 Nginx 处理静态页面，Tomcat 处理动态页面。动静分离从目前实现角度来讲大致分为两种：</p>
<ul>
<li>一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案；</li>
<li>另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。</li>
</ul>
<p>通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使 浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资 源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可， 所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件， 不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送 一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码 304，如果有修改，则直接从服务器重新下载，返回状态码 200。</p>
<h3 id="2-准备工作-3"><a href="#2-准备工作-3" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h3><ul>
<li>在Linux 系统中准备 静态资源，用于进行访问。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/624c3b661056c6209fad50529351b34b.png" alt="在这里插入图片描述"></li>
</ul>
<ol>
<li>www文件夹中 a.html</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>fengfanchen-test-html<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>image 中的 01.jpg<br>我的照片哈！！！（自动忽略）<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/ab1b837f85555355c4081dfff45b84b0.png" alt="在这里插入图片描述"></li>
</ol>
<h3 id="3-具体配置"><a href="#3-具体配置" class="headerlink" title="3. 具体配置"></a>3. 具体配置</h3><h4 id="a-在-nginx-配置文件中进行配置"><a href="#a-在-nginx-配置文件中进行配置" class="headerlink" title="a. 在 nginx 配置文件中进行配置"></a>a. 在 nginx 配置文件中进行配置</h4><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/e977972feb126567f0b457d1421ddb34.png" alt="在这里插入图片描述"></p>
<h3 id="4-最终测试-1"><a href="#4-最终测试-1" class="headerlink" title="4. 最终测试"></a>4. 最终测试</h3><h4 id="a-测试-image"><a href="#a-测试-image" class="headerlink" title="a. 测试 image"></a>a. 测试 image</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://208.208.128.122/image/</span><br><span class="line">http://208.208.128.122/image/01.jpg</span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/ca44f8556aebd1639ce2874ed21c1e87.png" alt="在这里插入图片描述"><br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/9dec2cf247c4601315596a8ad9bace7e.png" alt="在这里插入图片描述"></p>
<h4 id="b-测试-www"><a href="#b-测试-www" class="headerlink" title="b. 测试 www"></a>b. 测试 www</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://208.208.128.122/www/a.html </span><br></pre></td></tr></table></figure>

<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/e905bf3469a7d1c7810c2bb6ee8cf74e.png" alt="在这里插入图片描述"></p>
<h2 id="八、-Nginx-的高可用集群"><a href="#八、-Nginx-的高可用集群" class="headerlink" title="八、 Nginx 的高可用集群"></a>八、 Nginx 的高可用集群</h2><h3 id="1-什么是nginx-高可用"><a href="#1-什么是nginx-高可用" class="headerlink" title="1. 什么是nginx 高可用"></a>1. 什么是nginx 高可用</h3><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/335b2a2cd58e29be7cc8e6c2801fcfcd.png" alt="在这里插入图片描述"><br>配置示例流程：</p>
<ol>
<li>需要两台nginx 服务器</li>
<li>需要keepalived</li>
<li>需要虚拟IP</li>
</ol>
<h3 id="2-配置高可用的准备工作"><a href="#2-配置高可用的准备工作" class="headerlink" title="2. 配置高可用的准备工作"></a>2. 配置高可用的准备工作</h3><ol>
<li>需要两台服务器 208.208.128.122 和 208.208.128.85</li>
<li>在两台服务器安装 nginx(流程最上面有)<br>第二台服务器的默认端口 改为 9001 ，运行并测试，如下：<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/a01eb0d806a8cf13dba12b8895a96682.png" alt="在这里插入图片描述"></li>
<li>在两台服务器安装 keepalived</li>
</ol>
<h3 id="2-在两台服务器安装keepalived"><a href="#2-在两台服务器安装keepalived" class="headerlink" title="2. 在两台服务器安装keepalived"></a>2. 在两台服务器安装keepalived</h3><h4 id="a-安装："><a href="#a-安装：" class="headerlink" title="a)安装："></a>a)安装：</h4><p>第一种方式：命令安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install keepalived -y</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看版本：</span></span><br><span class="line">rpm -q -a keepalived</span><br></pre></td></tr></table></figure>

<p>第二种方式：安装包方式（这里我使用这个）<br>将压缩包上传至：&#x2F;usr&#x2F;feng&#x2F;<br>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/feng/</span><br><span class="line">tar -zxvf keepalived-2.0.18.tar.gz</span><br><span class="line">cd keepalived-2.0.18</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h4 id="b-配置文件"><a href="#b-配置文件" class="headerlink" title="b) 配置文件"></a>b) 配置文件</h4><p><strong>安装之后，在 etc 里面生成目录 keepalived，有文件 keepalived.conf 。</strong><br>这个就是主配置文件。<br>主从模式主要在这个文件里配置。</p>
<h3 id="完成高可用配置（主从配置）"><a href="#完成高可用配置（主从配置）" class="headerlink" title="完成高可用配置（主从配置）"></a>完成高可用配置（主从配置）</h3><h4 id="a-修改-keepalived-conf-配置文件"><a href="#a-修改-keepalived-conf-配置文件" class="headerlink" title="a) 修改 keepalived.conf 配置文件"></a>a) 修改 keepalived.conf 配置文件</h4><p><strong>修改&#x2F;etc&#x2F;keepalived&#x2F;keepalivec.conf 配置文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global_defs &#123; </span><br><span class="line">   notification_email &#123; </span><br><span class="line">     acassen@firewall.loc </span><br><span class="line">     failover@firewall.loc </span><br><span class="line">     sysadmin@firewall.loc </span><br><span class="line">   &#125; </span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc </span><br><span class="line">   smtp_server 208.208.128.122</span><br><span class="line">   smtp_connect_timeout 30 </span><br><span class="line">   router_id LVS_DEVEL </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">vrrp_script chk_http_port &#123; </span><br><span class="line">  </span><br><span class="line">   script &quot;/usr/local/src/nginx_check.sh&quot; </span><br><span class="line">   </span><br><span class="line">   interval 2      #（检测脚本执行的间隔） </span><br><span class="line">  </span><br><span class="line">   weight 2 </span><br><span class="line">  </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">vrrp_instance VI_1 &#123;     </span><br><span class="line">	state MASTER   # 备份服务器上将 MASTER 改为 BACKUP       </span><br><span class="line">	interface ens192  //网卡     </span><br><span class="line">	virtual_router_id 51   # 主、备机的 virtual_router_id 必须相同     </span><br><span class="line">	priority 100     # 主、备机取不同的优先级，主机值较大，备份机值较小 </span><br><span class="line">    advert_int 1 </span><br><span class="line">    authentication &#123; </span><br><span class="line">        auth_type PASS </span><br><span class="line">        auth_pass 1111 </span><br><span class="line">    &#125; </span><br><span class="line">    virtual_ipaddress &#123;         </span><br><span class="line">		208.208.128.50 // VRRP H 虚拟地址 </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="b-添加检测脚本"><a href="#b-添加检测脚本" class="headerlink" title="b) 添加检测脚本"></a>b) 添加检测脚本</h4><p><strong>在&#x2F;usr&#x2F;local&#x2F;src 添加检测脚本</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">A=`ps -C nginx –no-header |wc -l`</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line">    /usr/local/nginx/sbin/nginx</span><br><span class="line">    sleep 2</span><br><span class="line">    if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then</span><br><span class="line">        killall keepalived</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h4 id="c-开启nginx-和-keepalived"><a href="#c-开启nginx-和-keepalived" class="headerlink" title="c) 开启nginx 和 keepalived"></a>c) 开启nginx 和 keepalived</h4><p>把两台服务器上 nginx 和 keepalived 启动 ：<br>启动 nginx：.&#x2F;nginx<br>启动 keepalived：systemctl start keepalived.service<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/6de53ee1b01a485b50d5c59124bb7628.png" alt="在这里插入图片描述"><br><strong>85服务一样。</strong></p>
<h3 id="4-最终测试-2"><a href="#4-最终测试-2" class="headerlink" title="4. 最终测试"></a>4. 最终测试</h3><h4 id="a-在浏览器地址栏输入-虚拟-ip-地址-192-168-17-50"><a href="#a-在浏览器地址栏输入-虚拟-ip-地址-192-168-17-50" class="headerlink" title="a)在浏览器地址栏输入 虚拟 ip 地址 192.168.17.50"></a>a)在浏览器地址栏输入 虚拟 ip 地址 192.168.17.50</h4><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/227253bccd8bafa3a93df09f42c2075f.png" alt="在这里插入图片描述"><br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/842bdd842847b676312899bbc09761f5.png" alt="在这里插入图片描述"></p>
<h4 id="b-把主服务器（192-168-17-129）nginx-和-keepalived-停止，再输入-192-168-17-50"><a href="#b-把主服务器（192-168-17-129）nginx-和-keepalived-停止，再输入-192-168-17-50" class="headerlink" title="b)把主服务器（192.168.17.129）nginx 和 keepalived 停止，再输入 192.168.17.50"></a>b)把主服务器（192.168.17.129）nginx 和 keepalived 停止，再输入 192.168.17.50</h4><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/227253bccd8bafa3a93df09f42c2075f.png" alt="在这里插入图片描述"><br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/842bdd842847b676312899bbc09761f5.png" alt="在这里插入图片描述"></p>
<h2 id="九、-Nginx-的原理"><a href="#九、-Nginx-的原理" class="headerlink" title="九、 Nginx 的原理"></a>九、 Nginx 的原理</h2><h3 id="1-mater-和-worker"><a href="#1-mater-和-worker" class="headerlink" title="1. mater 和 worker"></a>1. mater 和 worker</h3><ul>
<li>nginx 启动后，是由两个进程组成的。master（管理者）和worker（工作者）。</li>
<li>一个nginx 只有一个master。但可以有多个worker<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/5db3f8fdb0c33d25cd78371c7fb4c760.png" alt="在这里插入图片描述"></li>
<li>，过来的请求由master管理，worker进行争抢式的方式去获取请求。<br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/b15947a9cd9f13d4f2ea698a58fa75d7.png" alt="在这里插入图片描述"><br><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/caadce221bb67bcd6de9e00544af07a1.png" alt="在这里插入图片描述"></li>
</ul>
<h3 id="2-master-workers-的机制的好处"><a href="#2-master-workers-的机制的好处" class="headerlink" title="2. master-workers 的机制的好处"></a>2. master-workers 的机制的好处</h3><ul>
<li>首先，对于每个 worker 进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销， 同时在编程以及问题查找时，也会方便很多。</li>
<li>可以使用 nginx –s reload 热部署，利用 nginx 进行热部署操作</li>
<li>其次，采用独立的进程，可以让互相之间不会 影响，一个进程退出后，其它进程还在工作，服务不会中断，master 进程则很快启动新的 worker 进程。当然，worker 进程的异常退出，肯定是程序有 bug 了，异常退出，会导致当 前 worker 上的所有请求失败，不过不会影响到所有请求，所以降低了风险。</li>
</ul>
<h3 id="3-设置多少个-worker"><a href="#3-设置多少个-worker" class="headerlink" title="3. 设置多少个 worker"></a>3. 设置多少个 worker</h3><p>Nginx 同 redis 类似都采用了 io 多路复用机制，每个 worker 都是一个独立的进程，但每个进 程里只有一个主线程，通过异步非阻塞的方式来处理请求， 即使是千上万个请求也不在话 下。每个 worker 的线程可以把一个 cpu 的性能发挥到极致。所以 worker 数和服务器的 cpu 数相等是最为适宜的。设少了会浪费 cpu，设多了会造成 cpu 频繁切换上下文带来的损耗。</p>
<ul>
<li><strong>worker 数和服务器的 cpu 数相等是最为适宜</strong></li>
</ul>
<h3 id="4-连接数-worker-connection"><a href="#4-连接数-worker-connection" class="headerlink" title="4. 连接数 worker_connection"></a>4. 连接数 worker_connection</h3><p><strong>第一个</strong>：发送请求，占用了 woker 的几个连接数？</p>
<ul>
<li>答案：2 或者 4 个</li>
</ul>
<p><strong>第二个</strong>：nginx 有一个 master，有四个 woker，每个 woker 支持最大的连接数 1024，支持的 最大并发数是多少？</p>
<ul>
<li>普通的静态访问最大并发数是： worker_connections * worker_processes &#x2F;2，</li>
<li>而如果是 HTTP 作 为反向代理来说，最大并发数量应该是 worker_connections * worker_processes&#x2F;4。</li>
</ul>
<p>这个值是表示每个 worker 进程所能建立连接的最大值，所以，一个 nginx 能建立的最大连接 数，应该是 worker_connections * worker_processes。当然，这里说的是最大连接数，对于 HTTP 请 求 本 地 资 源 来 说 ， 能 够 支 持 的 最 大 并 发 数 量 是 worker_connections * worker_processes，如果是支持 http1.1 的浏览器每次访问要占两个连接，所以普通的静态访 问最大并发数是： worker_connections * worker_processes &#x2F;2，而如果是 HTTP 作 为反向代 理来说，最大并发数量应该是 worker_connections * worker_processes&#x2F;4。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服 务的连接，会占用两个连接。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/9bb66c082c43ae5a452e454f8b574207.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>好用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Source insight源码查看工具的使用</title>
    <url>/2024/10/24/%E5%B7%A5%E5%85%B7/Source%20insight%E6%BA%90%E7%A0%81%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Source-insight源码查看工具的使用"><a href="#Source-insight源码查看工具的使用" class="headerlink" title="Source insight源码查看工具的使用"></a>Source insight源码查看工具的使用</h1><h1 id="常用的基本操作"><a href="#常用的基本操作" class="headerlink" title="常用的基本操作"></a>常用的基本操作</h1><h2 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h2><p>点击new project</p>
<p>在源代码同级目录下创建一个insight，将我们的项目工程放在这里（这样只是方便好找）</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241024144416964.png" alt="image-20241024144416964"></p>
<p>刚刚创建的文件和源码文件同级，点击源码文件，点击Add Tree</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241024144644466.png" alt="image-20241024144644466"></p>
<p>添加完毕后直接关了就行</p>
<p>之后点击project-&gt;synchronize Files进行同步，点击start，然后同步完关闭</p>
<p>这样做直接就可以把修改同步到源码文件上面了</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241024145125511.png" alt="image-20241024145125511"></p>
<p>点击菜单这个P图标</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241024145308514.png" alt="image-20241024145308514"></p>
<p>侧边出现这样的目录</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241024150036959.png" alt="image-20241024150036959"></p>
<p>有些.cc文件出不来的更改操作</p>
<p>点击菜单栏options-&gt;file type options</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241024145539242.png" alt="image-20241024145539242"></p>
<p>在filefilit处加上     <code> ,*.cc</code>     注意是英文的</p>
<p>添加后关闭</p>
<p>之后点击project的add and remove project file重新Add tree一下就有了</p>
<h2 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h2><p>在P图标点击后直接在搜索栏搜索就行</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241024150036959.png"></p>
<p>后面的project symbols可以直接搜想看的函数</p>
<h2 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h2><p>options-&gt; key Assignments</p>
<p>搜索Hi</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241024150547888.png" alt="image-20241024150547888"></p>
<p>图上这个是设置代码高亮的，挺好用</p>
<p>点击Assign new key然后按键盘按自己想要的快捷键</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241024150818421.png" alt="image-20241024150818421"></p>
<p>点击conn然后按刚刚的快捷键所有的conn就会变成这个颜色，方便查看</p>
<h2 id="ctrl-鼠标左键"><a href="#ctrl-鼠标左键" class="headerlink" title="ctrl+鼠标左键"></a>ctrl+鼠标左键</h2><p>直接进去鼠标所点的代码所在</p>
<p>其他操作大家可以上网自己查阅</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>好用工具</tag>
      </tags>
  </entry>
</search>
