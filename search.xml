<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Day67 | 灵神 | 二分查找：统计公平数对的数目</title>
    <url>/2025/03/19/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day67%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%85%AC%E5%B9%B3%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="Day67-灵神-二分查找：统计公平数对的数目"><a href="#Day67-灵神-二分查找：统计公平数对的数目" class="headerlink" title="Day67 | 灵神 | 二分查找：统计公平数对的数目"></a>Day67 | 灵神 | 二分查找：统计公平数对的数目</h1><h2 id="2563-统计公平数对的数目"><a href="#2563-统计公平数对的数目" class="headerlink" title="2563.统计公平数对的数目"></a>2563.统计公平数对的数目</h2><p><a href="https://leetcode.cn/problems/count-the-number-of-fair-pairs/description/">2563. 统计公平数对的数目 - 力扣（LeetCode）</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先说一下为什么排序不会影响本道题目的结果，因为本质上是从数组中选择两个数，满足0&lt;i&lt;j&lt;n，lower &lt;&#x3D; nums[i] + nums[j] &lt;&#x3D; upper的条件。就算你排序之后，那两个数还是那两个数，无非就是从[1,4]变成了[4,1]而已。</p>
<p>先来说一说错误的，希望大家不要和笔者一样</p>
<p>想的是在二分查找过程中把对数给统计了，check函数也是传入的nums[l],nums[r],lower,upper，按照题目给的条件去比较，然后判断符合条件不符合条件</p>
<p>这时候就发现，我符合条件以后我该往哪边收缩呢？不管往那边收缩都会漏掉情况，往左收缩会漏掉往右的情况，往右收缩会漏掉左边的，同时收缩更不用说了</p>
<p>所以这个时候就该发现自己的思路出了问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> c,<span class="type">long</span> <span class="type">long</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a+b&gt;=c&amp;&amp;a+b&lt;=d)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> lower, <span class="type">int</span> upper)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(nums[l],nums[r],lower,upper))</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                r=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countFairPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lower, <span class="type">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">lower_bound</span>(nums,lower,upper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h4><p>参考的灵神的思路</p>
<p>用j遍历数组，那么我们的nums[i]需要满足什么条件呢？</p>
<p><em>lower</em>−<em>nums</em>[<em>j</em>]≤<em>nums</em>[<em>i</em>]≤<em>upper</em>−<em>nums</em>[<em>j</em>]</p>
<p>这时候你就发现呢我们只要用lower-nums[j]去找nums[i]的左边界，用upper-nums[j]去找nums[i]的右边界，那么在左右边界内的数字一定符合条件，也就是数对的数量</p>
<p>不过要注意是在[0,j)这个左开右闭区间进行二分，因为题目说了要i&lt;j</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>笔者的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums,<span class="type">int</span> bound,<span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=bound;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countFairPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lower, <span class="type">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// &lt; lower-nums[j] 的 nums[i] 的个数</span></span><br><span class="line">            <span class="type">int</span> l=<span class="built_in">lower_bound</span>(nums,j,lower-nums[j]);</span><br><span class="line">            <span class="comment">// &lt;= upper-nums[j] 的 nums[i] 的个数</span></span><br><span class="line">            <span class="comment">//这个+1是因为&lt;=x就是(&gt;x+1)的位置-1</span></span><br><span class="line">            <span class="comment">//这里没减1是下面的r-l懒得+1了，减了1就是[l,r]的闭区间，不减就是[l,r)的区间，效果都一样</span></span><br><span class="line">            <span class="type">int</span> r=<span class="built_in">lower_bound</span>(nums,j,upper-nums[j]<span class="number">+1</span>);</span><br><span class="line">            res += r- l;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>灵神的使用二分查找函数的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countFairPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> lower, <span class="type">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="comment">// 注意要在 [0, j) 中二分，因为题目要求两个下标 i &lt; j</span></span><br><span class="line">            <span class="keyword">auto</span> r = <span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + j, upper - nums[j]); <span class="comment">// &lt;= upper-nums[j] 的 nums[i] 的个数</span></span><br><span class="line">            <span class="keyword">auto</span> l = <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + j, lower - nums[j]); <span class="comment">// &lt; lower-nums[j] 的 nums[i] 的个数</span></span><br><span class="line">            ans += r - l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="补充知识：upper-bound和lower-bound"><a href="#补充知识：upper-bound和lower-bound" class="headerlink" title="补充知识：upper_bound和lower_bound"></a>补充知识：<code>upper_bound</code>和<code>lower_bound</code></h3><p><code>upper_bound</code>和<code>lower_bound</code>是C++标准库中用于在<strong>已排序序列</strong>中查找边界的算法，它们的返回值是<strong>迭代器</strong>，具体行为如下：</p>
<hr>
<h3 id="1-返回值类型"><a href="#1-返回值类型" class="headerlink" title="1. 返回值类型"></a><strong>1. 返回值类型</strong></h3><ul>
<li><p>返回值为迭代器：两者均返回指向容器中特定位置的迭代器（ForwardIterator或RandomAccessIterator），而非直接返回下标或元素值</p>
<p><strong>示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>);  <span class="comment">// it指向元素8的迭代器（即v[4]）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-返回值指向的位置"><a href="#2-返回值指向的位置" class="headerlink" title="2. 返回值指向的位置"></a><strong>2. 返回值指向的位置</strong></h3><h4 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a><strong>lower_bound</strong></h4><ul>
<li><p>返回第一个 <em>≥</em> val 的元素位置：若存在等于val的元素，返回第一个等于val的元素的迭代器；若不存在，则返回第一个大于val的元素的迭代器；若所有元素均小于val，返回last（容器的end()迭代器）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>);  <span class="comment">// 指向第一个2的迭代器（v[2]）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a><strong>upper_bound</strong></h4><ul>
<li><p>返回第一个 <em>&gt;</em> val 的元素位置：无论是否存在等于val的元素，均返回第一个大于val的元素的迭代器；若所有元素均小于等于val，返回last（容器的end()迭代器）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>);  <span class="comment">// 指向8的迭代器（v[4]）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-特殊情况处理"><a href="#3-特殊情况处理" class="headerlink" title="3. 特殊情况处理"></a><strong>3. 特殊情况处理</strong></h3><ul>
<li><p>元素不存在时：若序列中无符合条件的元素，两者均返回last（即end()迭代器），表示“结束位置”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">9</span>);  <span class="comment">// 返回v.end()（指向末尾后一位置）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>元素为最大值时：若val等于最后一个元素的值，upper_bound仍返回end()，而lower_bound返回最后一个元素的迭代器</p>
</li>
</ul>
<hr>
<h3 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a><strong>4. 应用场景</strong></h3><ul>
<li><p>计算元素出现次数：结合upper_bound - lower_bound可快速计算有序序列中某元素的出现次数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>) - <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入元素保持有序：使用返回的迭代器插入新元素，可维持序列的有序性</p>
</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">返回值类型</th>
<th align="center">指向位置</th>
<th align="center">特殊返回值（无匹配时）</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>lower_bound</code></td>
<td align="center">迭代器</td>
<td align="center">第一个 <strong>≥ val</strong> 的元素</td>
<td align="center"><code>end()</code></td>
</tr>
<tr>
<td align="center"><code>upper_bound</code></td>
<td align="center">迭代器</td>
<td align="center">第一个 <strong>&gt; val</strong> 的元素</td>
<td align="center"><code>end()</code></td>
</tr>
</tbody></table>
<p>使用时需确保序列<strong>已排序</strong>，否则结果未定义</p>
]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>刷题记录</tag>
        <tag>算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马程序员 | Git详细教程笔记 | 使用命令 | 从安装到入土</title>
    <url>/2025/02/23/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%20%20Git%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0%20%20%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%20%20%E4%BB%8E%E5%AE%89%E8%A3%85%E5%88%B0%E5%85%A5%E5%9C%9F/</url>
    <content><![CDATA[<h1 id="黑马程序员-Git详细教程笔记-使用命令-从安装到入土"><a href="#黑马程序员-Git详细教程笔记-使用命令-从安装到入土" class="headerlink" title="黑马程序员 | Git详细教程笔记 | 使用命令 | 从安装到入土"></a>黑马程序员 | Git详细教程笔记 | 使用命令 | 从安装到入土</h1><p><a href="https://www.bilibili.com/video/BV1MU4y1Y7h5?spm_id_from=333.788.videopod.episodes&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">黑马程序员Git全套教程，完整的git项目管理工具教程，一套精通git_哔哩哔哩_bilibili</a></p>
<p>笔者就看了前22p，2倍速粗略的学了一下</p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>​    <strong>Git是分布式版本控制工具 分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样工作的时候，无 需要联网了，因为版本库就在你自己的电脑上。多人协作只需要各自的修改推送给对方，就能互相看到对方的修改了。</strong></p>
<p>​    <strong>特点：</strong></p>
<p>​           1.速度</p>
<p>​           2.简单的设计</p>
<p>​           3.对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</p>
<p>​           4.完全分布式</p>
<p>​           5.有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</p>
<h2 id="二、工作流程图"><a href="#二、工作流程图" class="headerlink" title="二、工作流程图"></a>二、工作流程图</h2><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/19c8c14ec2dc36cae056e56a75ee9ec0.png" alt="img"></p>
<p><strong>命令如下：</strong></p>
<ol>
<li>clone（克隆）: 从远程仓库中克隆代码到本地仓库。</li>
<li>checkout （检出）:从本地仓库中检出一个仓库分支然后进行修订。</li>
<li>add（添加）: 在提交前先将代码提交到暂存区。</li>
<li>commit（提交）: 提交到本地仓库。本地仓库中保存修改的各个历史版本。</li>
<li>fetch (抓取) ：从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。</li>
<li>pull (拉取) ：从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于               fetch+merge。</li>
<li>push（推送） : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库。</li>
</ol>
<h2 id="三、Git安装与配置"><a href="#三、Git安装与配置" class="headerlink" title="三、Git安装与配置"></a>三、Git安装与配置</h2><h3 id="1-下载与安装"><a href="#1-下载与安装" class="headerlink" title="1.下载与安装"></a>1.下载与安装</h3><blockquote>
<p>不建议从官网下载，因为速度太慢，建议从国内镜像下载。从里面找到对应版本下载即可。</p>
</blockquote>
<p><a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/">CNPM Binaries Mirror</a></p>
<p> <strong>备注：</strong></p>
<ul>
<li>Git GUI：Git提供的图形界面工具</li>
<li>Git Bash：Git提供的命令行工具</li>
</ul>
<p>​     当安装Git后首先要做的事情是设置用户名称和email地址。这是非常重要的，因为每次Git提交都会使用该用户信息。</p>
<h3 id="2-基本配置"><a href="#2-基本配置" class="headerlink" title="2.基本配置"></a>2.基本配置</h3><ol>
<li>打开Git Bash</li>
<li>设置用户信息</li>
</ol>
<p>设置配置信息</p>
<p>​    git config –global user.name “自己的用户名”    <strong>一定要注意空格！！！！</strong></p>
<p>​    git config –global user.email “自己的邮箱”</p>
<p>查看配置信息</p>
<p>​    git config –global user.name</p>
<p>​    git config –global user.email</p>
<h3 id="3-为常用指令配置别名（可选）"><a href="#3-为常用指令配置别名（可选）" class="headerlink" title="3.为常用指令配置别名（可选）"></a>3.为常用指令配置别名（可选）</h3><h4 id="1-打开用户目录，创建-bashrc-文件"><a href="#1-打开用户目录，创建-bashrc-文件" class="headerlink" title="1. 打开用户目录，创建 .bashrc 文件"></a>1. 打开用户目录，创建 .bashrc 文件</h4><p>​    因为部分windows系统不允许用户创建点号开头的文件，可以打开<a href="https://so.csdn.net/so/search?q=gitBash&spm=1001.2101.3001.7020">gitBash</a>,执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h4 id="2-在-bashrc-文件中输入如下内容："><a href="#2-在-bashrc-文件中输入如下内容：" class="headerlink" title="2.在 .bashrc 文件中输入如下内容："></a>2.在 .bashrc 文件中输入如下内容：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用于输出git提交日志</span></span><br><span class="line"><span class="built_in">alias</span> git-log=<span class="string">&#x27;git log --pretty=oneline --all --graph --abbrev-commit&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用于输出当前目录所有文件及基本信息</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -al&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-打开gitBash，执行"><a href="#3-打开gitBash，执行" class="headerlink" title="3. 打开gitBash，执行"></a>3. 打开gitBash，执行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h3 id="4-解决GitBash乱码问题"><a href="#4-解决GitBash乱码问题" class="headerlink" title="4.解决GitBash乱码问题"></a>4.解决GitBash乱码问题</h3><h4 id="1-打开GitBash执行下面命令"><a href="#1-打开GitBash执行下面命令" class="headerlink" title="1. 打开GitBash执行下面命令"></a>1. 打开GitBash执行下面命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="2-你按照Git的文件目录下-etc-bash-bashrc-文件最后加入下面两行"><a href="#2-你按照Git的文件目录下-etc-bash-bashrc-文件最后加入下面两行" class="headerlink" title="2. ${你按照Git的文件目录下}&#x2F;etc&#x2F;bash.bashrc 文件最后加入下面两行"></a>2. ${你按照Git的文件目录下}&#x2F;etc&#x2F;bash.bashrc 文件最后加入下面两行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LANG=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br><span class="line"><span class="built_in">export</span> LC_ALL=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="四、基础操作指令"><a href="#四、基础操作指令" class="headerlink" title="四、基础操作指令"></a>四、基础操作指令</h2><h3 id="1-获取本地仓库"><a href="#1-获取本地仓库" class="headerlink" title="1.获取本地仓库"></a>1.获取本地仓库</h3><p>​    要使用Git对我们的代码进行版本控制，首先需要获得本地仓库</p>
<ol>
<li>在电脑的任意位置创建一个空目录（例如test）作为我们的本地Git仓库</li>
<li>进入这个目录中，点击右键打开Git bash窗口</li>
<li>执行命令git init</li>
<li>如果创建成功后可在文件夹下看到隐藏的.git目录。</li>
</ol>
<p> <img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/9d3457667191dc71d53fe50ca36ea5da.png" alt="img"></p>
<h3 id="2-基础的操作指令"><a href="#2-基础的操作指令" class="headerlink" title="2.基础的操作指令"></a>2.基础的操作指令</h3><p>加 * 号的是重点</p>
<p>​    Git工作目录下对于文件的修改(增加、删除、更新)会存在几个状态，这些修改的状态会随着我们执行Git 的命令而发生变化。</p>
<p> <img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/8575160fb024491ad5b6cf97eecacd9e.png" alt="img"></p>
<p>​     工作区，暂存区和仓库之间的状态转换： </p>
<ul>
<li>git add (工作区 –&gt; 暂存区)</li>
<li>git commit (暂存区 –&gt; 本地仓库)</li>
</ul>
<h4 id="1-查看修改的状态（status）"><a href="#1-查看修改的状态（status）" class="headerlink" title="1.查看修改的状态（status）*"></a>1.查看修改的状态（status）*</h4><p>​        作用：查看的修改的状态（暂存区、工作区）</p>
<p>​        命令形式：git status</p>
<h4 id="2-添加工作区到暂存区-add"><a href="#2-添加工作区到暂存区-add" class="headerlink" title="2.添加工作区到暂存区(add) *"></a>2.添加工作区到暂存区(add) *</h4><p>​        作用：添加工作区一个或多个文件的修改到暂存区</p>
<p>​        命令形式：git add 单个文件名|通配符</p>
<p>​                将所有修改加入暂存区：git add .</p>
<h4 id="3-提交暂存区到本地仓库-commit"><a href="#3-提交暂存区到本地仓库-commit" class="headerlink" title="3.提交暂存区到本地仓库(commit) *"></a>3.提交暂存区到本地仓库(commit) *</h4><p>​        作用：提交暂存区内容到本地仓库的当前分支</p>
<p>​        命令形式：git commit -m “注释内容”</p>
<h4 id="4-查看提交日志-log"><a href="#4-查看提交日志-log" class="headerlink" title="4.查看提交日志(log) *"></a>4.查看提交日志(log) *</h4><p>​        因为前面配置的别名 git-log 就包含了这些参数，所以<strong>后续可以直接使用指令 git-log</strong></p>
<p>​             作用:查看提交记录</p>
<p>​            命令形式：git log [option]</p>
<p>​               options(非必须填写)</p>
<p>​                    1.all 显示所有分支</p>
<p>​                    2.pretty&#x3D;oneline 将提交信息显示为一行</p>
<p>​                    3.abbrev-commit 使得输出的commitId更简短 </p>
<p>​                    4.graph 以图的形式显示</p>
<h4 id="5-版本回退"><a href="#5-版本回退" class="headerlink" title="5.版本回退"></a>5.版本回退</h4><p>​        作用：版本切换</p>
<p>​        命令形式：git reset –hard commitID</p>
<p>​            commitID 可以使用 <code>git-log</code> 或 <code>git log</code> 指令查看（就是查出来前面那一串字母数字）</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250220204859956.png"></p>
<p>​        <strong>如何查看已经删除的记录？</strong></p>
<p>​            git reflog 这个指令可以看到已经删除的提交记录</p>
<h4 id="6-添加文件至忽略列表-设置文件不让git管理"><a href="#6-添加文件至忽略列表-设置文件不让git管理" class="headerlink" title="6.添加文件至忽略列表(设置文件不让git管理)"></a>6.添加文件至忽略列表(设置文件不让git管理)</h4><p>​    一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动 生成的文件，比如日志文件，或者编译过程中创建的临时文件等。</p>
<p>​    在这种情况下，我们可以在工作目录 中创建一个名为 .gitignore 的文件**（文件名称固定）**，列出要忽略的文件模式。下面是一个示例：</p>
<blockquote>
<p> *.a   ——-意思是.a的文件不用它管理</p>
</blockquote>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250220205046755.png" alt="image-20250220205046755"></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250220205100133.png" alt="image-20250220205100133"></p>
<h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><p>​    几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离 开来进行重大的Bug修改、开发新的功能，以免影响开发主线。</p>
<h4 id="0-head"><a href="#0-head" class="headerlink" title="0.head-&gt;"></a>0.head-&gt;</h4><p>head-&gt;指向谁谁就是当前分支</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250220205800637.png" alt="image-20250220205800637"></p>
<p>当前分支是dev01</p>
<h4 id="1-查看本地分支"><a href="#1-查看本地分支" class="headerlink" title="1.查看本地分支"></a>1.查看本地分支</h4><p>​            命令：git branch</p>
<h4 id="2-创建本地分支"><a href="#2-创建本地分支" class="headerlink" title="2.创建本地分支"></a>2.创建本地分支</h4><p>​            命令：git branch 分支名</p>
<h4 id="3-切换分支-checkout"><a href="#3-切换分支-checkout" class="headerlink" title="3.切换分支(checkout) *"></a>3.切换分支(checkout) *</h4><p>​            命令：git checkout 分支名</p>
<h4 id="4-创建并切换分支"><a href="#4-创建并切换分支" class="headerlink" title="4.创建并切换分支"></a>4.创建并切换分支</h4><p>​            命令：git checkout -b 分支名</p>
<h4 id="5-合并分支-merge"><a href="#5-合并分支-merge" class="headerlink" title="5.合并分支(merge) *"></a>5.合并分支(merge) *</h4><p>​          一个分支上的提交可以合并到另一个分支</p>
<p>​    ·        命令：git merge 分支名称</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250220210110973.png" alt="image-20250220210110973"></p>
<p>当前在master分支输入 git merge dev01，就是把dev01的所有修改移动到master中</p>
<h4 id="6-删除分支"><a href="#6-删除分支" class="headerlink" title="6.删除分支"></a>6.删除分支</h4><p>​         <strong>不能删除当前分支，只能删除其他分支</strong></p>
<p>​            git branch -d 分支名 删除分支时，需要做各种检查。</p>
<p>​            git branch -D 分支名 不做任何检查，强制删除。</p>
<h4 id="7-合并分支时的解决冲突"><a href="#7-合并分支时的解决冲突" class="headerlink" title="7.合并分支时的解决冲突"></a>7.合并分支时的解决冲突</h4><p>​    当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解 决冲突，解决冲突步骤如下：</p>
<ol>
<li>处理文件中冲突的地方</li>
<li>将解决完冲突的文件加入暂存区(add)</li>
<li>提交到仓库(commit)</li>
</ol>
<p> 冲突部分的内容处理如下所示：</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/5a7fd3aa07aef98b580ced5fdf2d6b79.png" alt="img"></p>
<h4 id="8-开发中分支使用原则与流程"><a href="#8-开发中分支使用原则与流程" class="headerlink" title="8.开发中分支使用原则与流程"></a>8.开发中分支使用原则与流程</h4><p>​    几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离 开来进行重大的Bug修改、开发新的功能，以免影响开发主线。</p>
<p>​    在开发中，一般有如下分支使用原则与流程：</p>
<p>​    <strong>master （生产） 分支</strong></p>
<p>​        线上分支，主分支，中小规模项目作为线上运行的应用对应的分支；</p>
<p>​    <strong>develop（开发）分支</strong></p>
<p>​        是从master创建的分支，一般作为开发部门的主要开发分支，如果没有其他并行开发不同期上线 要求，都可以在此版本进行开发，阶段开发完成后，需要是合并到master分支,准备上线。</p>
<p>​    <strong>feature&#x2F;xxxx分支</strong></p>
<p>​        从develop创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的研发任务完 成后合并到develop分支。</p>
<p>​    <strong>hotfix&#x2F;xxxx分支</strong></p>
<p>​        从master派生的分支，一般作为线上bug修复使用，修复完成后需要合并到master、test、 develop分支。</p>
<p>​    还有一些其他分支，在此不再详述，例如test分支（用于代码测试）、pre分支（预上线分支）等等。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/34d2ef51ec71b565d3b480e4cec9f0e2.png" alt="img"></p>
<h2 id="六、Git远程仓库"><a href="#六、Git远程仓库" class="headerlink" title="六、Git远程仓库"></a>六、Git远程仓库</h2><h3 id="1-常用的托管服务-远程仓库"><a href="#1-常用的托管服务-远程仓库" class="headerlink" title="1.常用的托管服务[远程仓库]"></a>1.常用的托管服务[远程仓库]</h3><p>​    我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云、GitLab等。</p>
<blockquote>
<p>​    gitHub（ 地址：<a href="https://github.com/">https://github.com/</a> ）是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名gitHub</p>
</blockquote>
<blockquote>
<p>​    码云（地址： <a href="https://gitee.com/">https://gitee.com/</a> ）是国内的一个代码托管平台，由于服务器在国内，所以相比于 GitHub，码云速度会更快</p>
</blockquote>
<blockquote>
<p>​    GitLab （地址： <a href="https://about.gitlab.com/">https://about.gitlab.com/</a> ）是一个用于仓库管理系统的开源项目，使用Git作 为代码管理工具，并在此基础上搭建起来的web服务,一般用于在企业、学校等内部网络搭建git私服。</p>
</blockquote>
<h3 id="2-注册账号"><a href="#2-注册账号" class="headerlink" title="2.注册账号"></a>2.注册账号</h3><p>大家应该都会</p>
<h3 id="3-创建远程仓库"><a href="#3-创建远程仓库" class="headerlink" title="3.创建远程仓库"></a>3.创建远程仓库</h3><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/2898113bd33ffd06e4baceefecea59e9.png" alt="img"></p>
<h3 id="4-配置SSH公钥"><a href="#4-配置SSH公钥" class="headerlink" title="4.配置SSH公钥"></a>4.配置SSH公钥</h3><h4 id="1-生成SSH公钥"><a href="#1-生成SSH公钥" class="headerlink" title="1.生成SSH公钥"></a>1.生成SSH公钥</h4><p>​            输入命令：ssh-keygen -t rsa</p>
<p>​            不断回车</p>
<p>​                如果公钥已经存在，则自动覆盖</p>
<h4 id="2-Gitee设置账户共公钥"><a href="#2-Gitee设置账户共公钥" class="headerlink" title="2.Gitee设置账户共公钥"></a>2.Gitee设置账户共公钥</h4><p>​            获取公钥</p>
<p>​                输入命令：cat ~&#x2F;.ssh&#x2F;id_rsa.pub</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/2eb60352e431289230e4d22241ce7ee5.png" alt="img"></p>
<h4 id="3-验证是否配置成功"><a href="#3-验证是否配置成功" class="headerlink" title="3.验证是否配置成功"></a>3.验证是否配置成功</h4><p>​         输入命令：ssh -T <a href="mailto:&#103;&#x69;&#x74;&#64;&#x67;&#x69;&#x74;&#x65;&#x65;&#x2e;&#99;&#111;&#x6d;">git@gitee.com</a></p>
<h3 id="5-操作远程仓库"><a href="#5-操作远程仓库" class="headerlink" title="5.操作远程仓库"></a>5.操作远程仓库</h3><h4 id="1-添加远程仓库"><a href="#1-添加远程仓库" class="headerlink" title="1. 添加远程仓库"></a>1. 添加远程仓库</h4><p>​            此操作是先初始化本地库，然后与已创建的远程库进行对接。</p>
<p>​                命令： git remote add &lt;远端名称&gt;&lt;仓库路径&gt;，</p>
<p>​                远程名称，默认是origin，取决于远端服务器设置</p>
<p>​                仓库路径，从远端服务器获取此URL</p>
<blockquote>
<p>例如: git remote add origin <a href="mailto:&#103;&#x69;&#116;&#64;&#103;&#x69;&#116;&#101;&#101;&#x2e;&#x63;&#111;&#x6d;">git@gitee.com</a>:czbk_zhang_meng&#x2F;git_test.git</p>
</blockquote>
<p>​     <strong>仓库路径获取示例如下：</strong></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/e7c0119b3248bb96bc4a759cf3d2719c.png" alt="img"></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@gitee.com:darling_123456/git_test.git</span><br></pre></td></tr></table></figure>

<h4 id="2-查看远程仓库"><a href="#2-查看远程仓库" class="headerlink" title="2.查看远程仓库"></a>2.查看远程仓库</h4><p>​            命令：git remote</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250223154842556.png" alt="image-20250223154842556"></p>
<h4 id="3-推送到远程仓库"><a href="#3-推送到远程仓库" class="headerlink" title="3. 推送到远程仓库"></a>3. 推送到远程仓库</h4><p>命令：git push [-f] [–set-upstream] [远端名称 [本地分支名][:远端分支名] ]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master:master</span><br></pre></td></tr></table></figure>

<p>如果远程分支名和本地分支名称相同，则可以只写本地分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>​                -f 表示强制覆盖</p>
<p>​                –set-upstream 推送到远端的同时并且建立起和远端分支的关联关系。</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250223155204568.png" alt="image-20250223155204568"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure>

<p>执行这句以后就不用写origin和master直接给git push它也知道要往哪里push</p>
<p>如果<strong>当前分支已经和远端分支关联</strong>，则可以省略分支名和远端名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push  <span class="comment">#将master分支推送到已关联的远端分支。</span></span><br></pre></td></tr></table></figure>

<h4 id="4-本地分支与远程分支的关联关系"><a href="#4-本地分支与远程分支的关联关系" class="headerlink" title="4.本地分支与远程分支的关联关系"></a>4.本地分支与远程分支的关联关系</h4><p>查看关联关系我们可以使用 git branch -vv 命令</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250223160010339.png" alt="image-20250223160010339"></p>
<h4 id="5-从远程仓库克隆"><a href="#5-从远程仓库克隆" class="headerlink" title="5.从远程仓库克隆"></a>5.从远程仓库克隆</h4><p>如果已经有一个远端仓库，我们可以直接clone到本地。</p>
<blockquote>
<p>命令: git clone &lt;仓库路径&gt; [本地目录]  本地目录可以省略，会自动生成一个目录</p>
</blockquote>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/330e945ebd5a2f47f0ae3eea97275142.png" alt="img"></p>
<h4 id="6-从远程仓库中抓取和拉取"><a href="#6-从远程仓库中抓取和拉取" class="headerlink" title="6.从远程仓库中抓取和拉取"></a>6.从远程仓库中抓取和拉取</h4><p> 远程分支和本地的分支一样，我们可以进行merge操作，只是需要先把远端仓  库里的更新都下载到本地，再进行操作。</p>
<p> **抓取命令：**git fetch [remote name] [branch name]</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250223160832106.png" alt="image-20250223160832106"></p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250223161201571.png" alt="image-20250223161201571"></p>
<blockquote>
<ul>
<li>抓取指令就是将仓库里的更新都抓取到本地，不会进行合并</li>
<li>如果不指定远端名称和分支名，则抓取所有分支</li>
</ul>
</blockquote>
<p><strong>拉取命令</strong>：git pull [remote name] [branch name]</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250223161113504.png" alt="image-20250223161113504"></p>
<blockquote>
<ul>
<li>拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge</li>
<li><strong>如果不指定远端名称和分支名，则抓取所有并更新当前分支。</strong></li>
</ul>
</blockquote>
<p>这里如果看他的b视频没看懂的话可以去看上面的整体的工作流程图，就容易多了。</p>
<h4 id="7-解决合并冲突"><a href="#7-解决合并冲突" class="headerlink" title="7.解决合并冲突"></a>7.解决合并冲突</h4><p>​    在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。 A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要 推送到远程仓库，此时B用户晚于A用户，故需要先拉取远程仓库的提交，经过合并后才能推送到远端分支,如下图所示。 </p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/6178d6725f1b5198b31af6bdaa2986e4.png" alt="img"></p>
<p>​    在B用户拉取代码时，因为A、B用户同一段时间修改了同一个文件的相同位置代码，故会发生合并冲 突。</p>
<blockquote>
<p>远程分支也是分支，所以合并时冲突的解决方式也和解决本地分支冲突相同相同。</p>
</blockquote>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Day68 | 灵神 | 二分查找：H指数II</title>
    <url>/2025/03/20/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day68%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9AH%E6%8C%87%E6%95%B0II/</url>
    <content><![CDATA[<h1 id="Day68-灵神-二分查找：H指数II"><a href="#Day68-灵神-二分查找：H指数II" class="headerlink" title="Day68 | 灵神 | 二分查找：H指数II"></a>Day68 | 灵神 | 二分查找：H指数II</h1><h2 id="275-H指数II"><a href="#275-H指数II" class="headerlink" title="275.H指数II"></a>275.H指数II</h2><p><a href="https://leetcode.cn/problems/h-index-ii/description/">275. H 指数 II - 力扣（LeetCode）</a></p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>很遗憾笔者这道题没做出来，看了灵神的还是不太懂，后来看了评论区各位大佬的解释，来这里浅显的说一下自己的理解</p>
<p>在此之前请先看看灵神的题解，如果看懂了还是不要继续往下看了，如果没看懂的话，我来说一说我疑惑的点，看看是不是也是你疑惑的点呢？</p>
<p>灵神题解：<a href="https://leetcode.cn/problems/h-index-ii/solutions/2504326/tu-jie-yi-tu-zhang-wo-er-fen-da-an-si-ch-d15k/">275. H 指数 II - 力扣（LeetCode）</a></p>
<h3 id="可能对灵神的题解中的疑惑的点"><a href="#可能对灵神的题解中的疑惑的点" class="headerlink" title="可能对灵神的题解中的疑惑的点"></a>可能对灵神的题解中的疑惑的点</h3><h4 id="1-理解本道题最重要的一点"><a href="#1-理解本道题最重要的一点" class="headerlink" title="1.理解本道题最重要的一点"></a>1.理解本道题最重要的一点</h4><p>为什么左闭右开区间的时候，l要初始化为1，r要初始化为citations.size()+1呢？</p>
<p>因为这道题二分的其实是h指数的数组，而h指数的数组你可以看做是[0,1,2,3,4,5]，因为h指数可以取到这些数字，也就是说h指数的范围是[0,5]即[0,citations.size()]，但是笔者写的是左开右闭区间所以就是[0,citations.size()+1)了，也就是[0,6)</p>
<p>所以其实我们二分的是[0,1,2,3,4,5]这个数组，我们最后返回的答案一定在这之中</p>
<p><strong>所以说白了citations这个数组起到的作用就是辅助我们把h从[0,citations.size()+1)给挑选出来，也就是用来写判断条件的，除此之外没有什么其他的作用</strong></p>
<p>而为什么l初始化为0而不是1呢？</p>
<p>这个灵神有说</p>
<p>肯定有0篇论文的引用次数&gt;&#x3D;0，那么二分区间就不需要包括0，直接从1开始就好了，也就是说我们二分的区间其实是[1,2,3,4,5]，等价于[1,2,3,4,5,6)</p>
<p>这让我想起洛谷做过的一道题，是砍树的，也是把树的高度进行二分而不是去看树的高度的数组，完了有空再去刷一下</p>
<h4 id="2-比较重要的理解，为啥最后返回的是l-1不是l"><a href="#2-比较重要的理解，为啥最后返回的是l-1不是l" class="headerlink" title="2.比较重要的理解，为啥最后返回的是l-1不是l"></a>2.比较重要的理解，为啥最后返回的是l-1不是l</h4><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250320092859009.png" alt="image-20250320092859009"></p>
<p>首先要理解这个，这个比较容易，大家自行理解就好</p>
<p>其次要知道，二分区间[l,r)内的性质我们还没有判断，就是我们不知道二分区间内的数是否满足条件，而二分区间外面的数字是已经被筛选过的，肯定满足条件的</p>
<p>就像是[1,2,3,4,5,6)当我们二分区间为[3,4,5,6)的时候，我们肯定可以判断1,2是合法或者不合法的才会更新到[3,4,5,6)这个区间</p>
<p><strong>再次，通过上面的第一条我们得知citations是来辅助我们筛选h的，所以更新区间时的mid其实就是满足条件的答案h，下面的代码我也有写，用res记录答案，每次更新时res&#x3D;mid，然后才是l&#x3D;mid+1</strong></p>
<p>也就是说，我们每次判断的时候l-1&#x3D;&#x3D;mid，也就是l-1就是答案，这也是为什么灵神最后返回的是l-1</p>
<p>满足条件在灵神的题解中等价于是询问的结果是   “是”</p>
<h4 id="3-citations-citations-size-mid-mid这个判断条件该如何理解？"><a href="#3-citations-citations-size-mid-mid这个判断条件该如何理解？" class="headerlink" title="3.citations[citations.size()-mid]&gt;&#x3D;mid这个判断条件该如何理解？"></a>3.citations[citations.size()-mid]&gt;&#x3D;mid这个判断条件该如何理解？</h4><p>citations.size()-mid这个下标对应的是数组倒数第mid个数，因为是单调自增的，如果说 这个下标对应的数要大于我们本轮筛选的h即mid，那说明这个数以及以后的数都是大于mid的，即至少有mid篇论文被引用mid次，用灵神的一张图说明吧</p>
<p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250320094417918.png" alt="image-20250320094417918"></p>
<p>下面的[0,1,2,3,4,5]可以看做我们的h数组，我们正在用二分筛选这个数组，现在筛选的是h=&#x3D;2&#x3D;&#x3D;mid</p>
<p>citations[0,1,3,5,6]中，citations.size()-mid&#x3D;5-2&#x3D;3</p>
<p>citations[3]&#x3D;5,5&gt;2,而5又是倒数第二个数，5,6，都大于2，那说明肯定至少有两篇论文大于等于2，那么h=&#x3D;2=&#x3D;mid就是一个合法的状态，然后下次更新就是更新到l=&#x3D;mid+1，因为[mid+1,r)这个区间还没有判断是否合法，而[0,mid]这个区间已经被判断为是合法的了</p>
<p>那自然我们确定的答案就是l-1，即mid，就是我们目前帅选出来的最大的h指数了</p>
<p>往后就是反复这个过程</p>
<h3 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h3><p>完整代码部分我觉得加一个res比较好理解，也是看的评论区学习到的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; citations)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>,r=citations.<span class="built_in">size</span>()<span class="number">+1</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(citations[citations.<span class="built_in">size</span>()-mid]&gt;=mid)</span><br><span class="line">            &#123;</span><br><span class="line">                res=mid;</span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">lower_bound</span>(citations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>刷题记录</tag>
        <tag>算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/03/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂</title>
    <url>/2025/03/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day69%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/</url>
    <content><![CDATA[<h1 id="Day69-灵神-二分查找：爱吃香蕉的珂珂"><a href="#Day69-灵神-二分查找：爱吃香蕉的珂珂" class="headerlink" title="Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂"></a>Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂</h1><h2 id="875-爱吃香蕉的珂珂"><a href="#875-爱吃香蕉的珂珂" class="headerlink" title="875.爱吃香蕉的珂珂"></a>875.爱吃香蕉的珂珂</h2><p><a href="https://leetcode.cn/problems/koko-eating-bananas/description/">875. 爱吃香蕉的珂珂 - 力扣（LeetCode）</a></p>
<h3 id="笔者关键点记录：怎么想到的要二分k而不是原来区间呢？"><a href="#笔者关键点记录：怎么想到的要二分k而不是原来区间呢？" class="headerlink" title="笔者关键点记录：怎么想到的要二分k而不是原来区间呢？"></a>笔者关键点记录：怎么想到的要二分k而不是原来区间呢？</h3><p>可以看到灵神的题解：</p>
<p>看示例 1，piles&#x3D;[3,6,7,11], h&#x3D;8。</p>
<p>如果珂珂能用 k&#x3D;4 的速度吃掉所有香蕉，那么也能用更快的速度 k&#x3D;5,6,⋯ 吃掉所有香蕉。<br>如果珂珂不能用 k&#x3D;3 的速度吃掉所有香蕉，那么也不能用更慢的速度 k&#x3D;2,1,⋯ 吃掉所有香蕉。<br>这种单调性意味着我们像 二分查找 那样，把答案 k 猜出来。</p>
<p><strong>我感觉也可以理解为题目让求啥我们就二分什么东西</strong></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>有了昨天的H指数II，这道题只能说是 so easy，还是一样，piles只是用来写判断条件的，我们二分的是速度k</p>
<p>注意，题目说piles的大小小于时间h，这使得我们很容易找到k的最大值，那就是数组的最大值，我每个小时吃这么多肯定可以吃得完，而最小值肯定不能是0，因为怎么都不可能吃完，所以从1开始</p>
<p><strong>那么我们要二分的k的区间就是[1,数组最大值]，在第一个例子中就是[1,11]</strong></p>
<p><strong>那么接下来就是判断条件咋写了</strong></p>
<p>我们二分的是k，是速度，那要如何判断一个k是否满足条件？那就看这个k可以在多少小时（sum）内吃完香蕉，如果这个sum小于等于h，那肯定就是符合条件的k，那么<code>[k,数组最大值]</code>这个区间肯定都符合条件</p>
<p>然后继续往左收缩就是了</p>
<p><code>注意点：</code></p>
<p>每一堆计算时，如果可以整除k，那就是直接除以k，不可以整除就得让结果+1，因为C++默认除法下取整</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>说明：</p>
<p>1.笔者用的是左闭右开区间，是[l,r)，所以求出最大值后要加1</p>
<p>2.满足条件更新r还是l，那就看sum是大于还是小于h了，本题是sum小于等于h，找的是左边界，只要mid满足条件，那么大于mid的肯定都满足条件，所以更新r</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles,<span class="type">int</span> k,<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:piles)、</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c%k==<span class="number">0</span>)</span><br><span class="line">                sum+=(c/k);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sum+=(c/k)<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum&lt;=h?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minEatingSpeed</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:piles)</span><br><span class="line">            r=<span class="built_in">max</span>(r,c)<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(piles,mid,h))</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>刷题记录</tag>
        <tag>算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
</search>
