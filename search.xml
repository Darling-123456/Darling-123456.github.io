<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂</title>
      <link href="/2025/03/21/Day69%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/"/>
      <url>/2025/03/21/Day69%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/</url>
      
        <content type="html"><![CDATA[<h1 id="Day69-灵神-二分查找：爱吃香蕉的珂珂"><a href="#Day69-灵神-二分查找：爱吃香蕉的珂珂" class="headerlink" title="Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂"></a>Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂</h1><h2 id="875-爱吃香蕉的珂珂"><a href="#875-爱吃香蕉的珂珂" class="headerlink" title="875.爱吃香蕉的珂珂"></a>875.爱吃香蕉的珂珂</h2><p><a href="https://leetcode.cn/problems/koko-eating-bananas/description/">875. 爱吃香蕉的珂珂 - 力扣（LeetCode）</a></p><h3 id="笔者关键点记录：怎么想到的要二分k而不是原来区间呢？"><a href="#笔者关键点记录：怎么想到的要二分k而不是原来区间呢？" class="headerlink" title="笔者关键点记录：怎么想到的要二分k而不是原来区间呢？"></a>笔者关键点记录：怎么想到的要二分k而不是原来区间呢？</h3><p>可以看到灵神的题解：</p><p>看示例 1，piles&#x3D;[3,6,7,11], h&#x3D;8。</p><p>如果珂珂能用 k&#x3D;4 的速度吃掉所有香蕉，那么也能用更快的速度 k&#x3D;5,6,⋯ 吃掉所有香蕉。<br>如果珂珂不能用 k&#x3D;3 的速度吃掉所有香蕉，那么也不能用更慢的速度 k&#x3D;2,1,⋯ 吃掉所有香蕉。<br>这种单调性意味着我们像 二分查找 那样，把答案 k 猜出来。</p><p><strong>我感觉也可以理解为题目让求啥我们就二分什么东西</strong></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>有了昨天的H指数II，这道题只能说是 so easy，还是一样，piles只是用来写判断条件的，我们二分的是速度k</p><p>注意，题目说piles的大小小于时间h，这使得我们很容易找到k的最大值，那就是数组的最大值，我每个小时吃这么多肯定可以吃得完，而最小值肯定不能是0，因为怎么都不可能吃完，所以从1开始</p><p><strong>那么我们要二分的k的区间就是[1,数组最大值]，在第一个例子中就是[1,11]</strong></p><p><strong>那么接下来就是判断条件咋写了</strong></p><p>我们二分的是k，是速度，那要如何判断一个k是否满足条件？那就看这个k可以在多少小时（sum）内吃完香蕉，如果这个sum小于等于h，那肯定就是符合条件的k，那么<code>[k,数组最大值]</code>这个区间肯定都符合条件</p><p>然后继续往左收缩就是了</p><p><code>注意点：</code></p><p>每一堆计算时，如果可以整除k，那就是直接除以k，不可以整除就得让结果+1，因为C++默认除法下取整</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>说明：</p><p>1.笔者用的是左闭右开区间，是[l,r)，所以求出最大值后要加1</p><p>2.满足条件更新r还是l，那就看sum是大于还是小于h了，本题是sum小于等于h，找的是左边界，只要mid满足条件，那么大于mid的肯定都满足条件，所以更新r</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles,<span class="type">int</span> k,<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:piles)、</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c%k==<span class="number">0</span>)</span><br><span class="line">                sum+=(c/k);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sum+=(c/k)<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum&lt;=h?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minEatingSpeed</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:piles)</span><br><span class="line">            r=<span class="built_in">max</span>(r,c)<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(piles,mid,h))</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑马程序员 | Git详细教程笔记 | 使用命令 | 从安装到入土</title>
      <link href="/2025/03/19/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%20%20Git%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0%20%20%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%20%20%E4%BB%8E%E5%AE%89%E8%A3%85%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
      <url>/2025/03/19/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%20%20Git%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0%20%20%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%20%20%E4%BB%8E%E5%AE%89%E8%A3%85%E5%88%B0%E5%85%A5%E5%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="黑马程序员-Git详细教程笔记-使用命令-从安装到入土"><a href="#黑马程序员-Git详细教程笔记-使用命令-从安装到入土" class="headerlink" title="黑马程序员 | Git详细教程笔记 | 使用命令 | 从安装到入土"></a>黑马程序员 | Git详细教程笔记 | 使用命令 | 从安装到入土</h1><p><a href="https://www.bilibili.com/video/BV1MU4y1Y7h5?spm_id_from=333.788.videopod.episodes&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">黑马程序员Git全套教程，完整的git项目管理工具教程，一套精通git_哔哩哔哩_bilibili</a></p><p>笔者就看了前22p，2倍速粗略的学了一下</p><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>​    <strong>Git是分布式版本控制工具 分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样工作的时候，无 需要联网了，因为版本库就在你自己的电脑上。多人协作只需要各自的修改推送给对方，就能互相看到对方的修改了。</strong></p><p>​    <strong>特点：</strong></p><p>​           1.速度</p><p>​           2.简单的设计</p><p>​           3.对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</p><p>​           4.完全分布式</p><p>​           5.有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</p><h2 id="二、工作流程图"><a href="#二、工作流程图" class="headerlink" title="二、工作流程图"></a>二、工作流程图</h2><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/19c8c14ec2dc36cae056e56a75ee9ec0.png" alt="img"></p><p><strong>命令如下：</strong></p><ol><li>clone（克隆）: 从远程仓库中克隆代码到本地仓库。</li><li>checkout （检出）:从本地仓库中检出一个仓库分支然后进行修订。</li><li>add（添加）: 在提交前先将代码提交到暂存区。</li><li>commit（提交）: 提交到本地仓库。本地仓库中保存修改的各个历史版本。</li><li>fetch (抓取) ：从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。</li><li>pull (拉取) ：从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于               fetch+merge。</li><li>push（推送） : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库。</li></ol><h2 id="三、Git安装与配置"><a href="#三、Git安装与配置" class="headerlink" title="三、Git安装与配置"></a>三、Git安装与配置</h2><h3 id="1-下载与安装"><a href="#1-下载与安装" class="headerlink" title="1.下载与安装"></a>1.下载与安装</h3><blockquote><p>不建议从官网下载，因为速度太慢，建议从国内镜像下载。从里面找到对应版本下载即可。</p></blockquote><p><a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/">CNPM Binaries Mirror</a></p><p> <strong>备注：</strong></p><ul><li>Git GUI：Git提供的图形界面工具</li><li>Git Bash：Git提供的命令行工具</li></ul><p>​     当安装Git后首先要做的事情是设置用户名称和email地址。这是非常重要的，因为每次Git提交都会使用该用户信息。</p><h3 id="2-基本配置"><a href="#2-基本配置" class="headerlink" title="2.基本配置"></a>2.基本配置</h3><ol><li>打开Git Bash</li><li>设置用户信息</li></ol><p>设置配置信息</p><p>​    git config –global user.name “自己的用户名”    <strong>一定要注意空格！！！！</strong></p><p>​    git config –global user.email “自己的邮箱”</p><p>查看配置信息</p><p>​    git config –global user.name</p><p>​    git config –global user.email</p><h3 id="3-为常用指令配置别名（可选）"><a href="#3-为常用指令配置别名（可选）" class="headerlink" title="3.为常用指令配置别名（可选）"></a>3.为常用指令配置别名（可选）</h3><h4 id="1-打开用户目录，创建-bashrc-文件"><a href="#1-打开用户目录，创建-bashrc-文件" class="headerlink" title="1. 打开用户目录，创建 .bashrc 文件"></a>1. 打开用户目录，创建 .bashrc 文件</h4><p>​    因为部分windows系统不允许用户创建点号开头的文件，可以打开<a href="https://so.csdn.net/so/search?q=gitBash&spm=1001.2101.3001.7020">gitBash</a>,执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h4 id="2-在-bashrc-文件中输入如下内容："><a href="#2-在-bashrc-文件中输入如下内容：" class="headerlink" title="2.在 .bashrc 文件中输入如下内容："></a>2.在 .bashrc 文件中输入如下内容：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用于输出git提交日志</span></span><br><span class="line"><span class="built_in">alias</span> git-log=<span class="string">&#x27;git log --pretty=oneline --all --graph --abbrev-commit&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用于输出当前目录所有文件及基本信息</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -al&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="3-打开gitBash，执行"><a href="#3-打开gitBash，执行" class="headerlink" title="3. 打开gitBash，执行"></a>3. 打开gitBash，执行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="4-解决GitBash乱码问题"><a href="#4-解决GitBash乱码问题" class="headerlink" title="4.解决GitBash乱码问题"></a>4.解决GitBash乱码问题</h3><h4 id="1-打开GitBash执行下面命令"><a href="#1-打开GitBash执行下面命令" class="headerlink" title="1. 打开GitBash执行下面命令"></a>1. 打开GitBash执行下面命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="2-你按照Git的文件目录下-etc-bash-bashrc-文件最后加入下面两行"><a href="#2-你按照Git的文件目录下-etc-bash-bashrc-文件最后加入下面两行" class="headerlink" title="2. ${你按照Git的文件目录下}&#x2F;etc&#x2F;bash.bashrc 文件最后加入下面两行"></a>2. ${你按照Git的文件目录下}&#x2F;etc&#x2F;bash.bashrc 文件最后加入下面两行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LANG=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br><span class="line"><span class="built_in">export</span> LC_ALL=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br></pre></td></tr></table></figure><h2 id="四、基础操作指令"><a href="#四、基础操作指令" class="headerlink" title="四、基础操作指令"></a>四、基础操作指令</h2><h3 id="1-获取本地仓库"><a href="#1-获取本地仓库" class="headerlink" title="1.获取本地仓库"></a>1.获取本地仓库</h3><p>​    要使用Git对我们的代码进行版本控制，首先需要获得本地仓库</p><ol><li>在电脑的任意位置创建一个空目录（例如test）作为我们的本地Git仓库</li><li>进入这个目录中，点击右键打开Git bash窗口</li><li>执行命令git init</li><li>如果创建成功后可在文件夹下看到隐藏的.git目录。</li></ol><p> <img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/9d3457667191dc71d53fe50ca36ea5da.png" alt="img"></p><h3 id="2-基础的操作指令"><a href="#2-基础的操作指令" class="headerlink" title="2.基础的操作指令"></a>2.基础的操作指令</h3><p>加 * 号的是重点</p><p>​    Git工作目录下对于文件的修改(增加、删除、更新)会存在几个状态，这些修改的状态会随着我们执行Git 的命令而发生变化。</p><p> <img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/8575160fb024491ad5b6cf97eecacd9e.png" alt="img"></p><p>​     工作区，暂存区和仓库之间的状态转换： </p><ul><li>git add (工作区 –&gt; 暂存区)</li><li>git commit (暂存区 –&gt; 本地仓库)</li></ul><h4 id="1-查看修改的状态（status）"><a href="#1-查看修改的状态（status）" class="headerlink" title="1.查看修改的状态（status）*"></a>1.查看修改的状态（status）*</h4><p>​        作用：查看的修改的状态（暂存区、工作区）</p><p>​        命令形式：git status</p><h4 id="2-添加工作区到暂存区-add"><a href="#2-添加工作区到暂存区-add" class="headerlink" title="2.添加工作区到暂存区(add) *"></a>2.添加工作区到暂存区(add) *</h4><p>​        作用：添加工作区一个或多个文件的修改到暂存区</p><p>​        命令形式：git add 单个文件名|通配符</p><p>​                将所有修改加入暂存区：git add .</p><h4 id="3-提交暂存区到本地仓库-commit"><a href="#3-提交暂存区到本地仓库-commit" class="headerlink" title="3.提交暂存区到本地仓库(commit) *"></a>3.提交暂存区到本地仓库(commit) *</h4><p>​        作用：提交暂存区内容到本地仓库的当前分支</p><p>​        命令形式：git commit -m “注释内容”</p><h4 id="4-查看提交日志-log"><a href="#4-查看提交日志-log" class="headerlink" title="4.查看提交日志(log) *"></a>4.查看提交日志(log) *</h4><p>​        因为前面配置的别名 git-log 就包含了这些参数，所以<strong>后续可以直接使用指令 git-log</strong></p><p>​             作用:查看提交记录</p><p>​            命令形式：git log [option]</p><p>​               options(非必须填写)</p><p>​                    1.all 显示所有分支</p><p>​                    2.pretty&#x3D;oneline 将提交信息显示为一行</p><p>​                    3.abbrev-commit 使得输出的commitId更简短 </p><p>​                    4.graph 以图的形式显示</p><h4 id="5-版本回退"><a href="#5-版本回退" class="headerlink" title="5.版本回退"></a>5.版本回退</h4><p>​        作用：版本切换</p><p>​        命令形式：git reset –hard commitID</p><p>​            commitID 可以使用 <code>git-log</code> 或 <code>git log</code> 指令查看（就是查出来前面那一串字母数字）</p><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250220204859956.png"></p><p>​        <strong>如何查看已经删除的记录？</strong></p><p>​            git reflog 这个指令可以看到已经删除的提交记录</p><h4 id="6-添加文件至忽略列表-设置文件不让git管理"><a href="#6-添加文件至忽略列表-设置文件不让git管理" class="headerlink" title="6.添加文件至忽略列表(设置文件不让git管理)"></a>6.添加文件至忽略列表(设置文件不让git管理)</h4><p>​    一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动 生成的文件，比如日志文件，或者编译过程中创建的临时文件等。</p><p>​    在这种情况下，我们可以在工作目录 中创建一个名为 .gitignore 的文件**（文件名称固定）**，列出要忽略的文件模式。下面是一个示例：</p><blockquote><p> *.a   ——-意思是.a的文件不用它管理</p></blockquote><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250220205046755.png" alt="image-20250220205046755"></p><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250220205100133.png" alt="image-20250220205100133"></p><h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><p>​    几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离 开来进行重大的Bug修改、开发新的功能，以免影响开发主线。</p><h4 id="0-head"><a href="#0-head" class="headerlink" title="0.head-&gt;"></a>0.head-&gt;</h4><p>head-&gt;指向谁谁就是当前分支</p><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250220205800637.png" alt="image-20250220205800637"></p><p>当前分支是dev01</p><h4 id="1-查看本地分支"><a href="#1-查看本地分支" class="headerlink" title="1.查看本地分支"></a>1.查看本地分支</h4><p>​            命令：git branch</p><h4 id="2-创建本地分支"><a href="#2-创建本地分支" class="headerlink" title="2.创建本地分支"></a>2.创建本地分支</h4><p>​            命令：git branch 分支名</p><h4 id="3-切换分支-checkout"><a href="#3-切换分支-checkout" class="headerlink" title="3.切换分支(checkout) *"></a>3.切换分支(checkout) *</h4><p>​            命令：git checkout 分支名</p><h4 id="4-创建并切换分支"><a href="#4-创建并切换分支" class="headerlink" title="4.创建并切换分支"></a>4.创建并切换分支</h4><p>​            命令：git checkout -b 分支名</p><h4 id="5-合并分支-merge"><a href="#5-合并分支-merge" class="headerlink" title="5.合并分支(merge) *"></a>5.合并分支(merge) *</h4><p>​          一个分支上的提交可以合并到另一个分支</p><p>​    ·        命令：git merge 分支名称</p><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250220210110973.png" alt="image-20250220210110973"></p><p>当前在master分支输入 git merge dev01，就是把dev01的所有修改移动到master中</p><h4 id="6-删除分支"><a href="#6-删除分支" class="headerlink" title="6.删除分支"></a>6.删除分支</h4><p>​         <strong>不能删除当前分支，只能删除其他分支</strong></p><p>​            git branch -d 分支名 删除分支时，需要做各种检查。</p><p>​            git branch -D 分支名 不做任何检查，强制删除。</p><h4 id="7-合并分支时的解决冲突"><a href="#7-合并分支时的解决冲突" class="headerlink" title="7.合并分支时的解决冲突"></a>7.合并分支时的解决冲突</h4><p>​    当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解 决冲突，解决冲突步骤如下：</p><ol><li>处理文件中冲突的地方</li><li>将解决完冲突的文件加入暂存区(add)</li><li>提交到仓库(commit)</li></ol><p> 冲突部分的内容处理如下所示：</p><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/5a7fd3aa07aef98b580ced5fdf2d6b79.png" alt="img"></p><h4 id="8-开发中分支使用原则与流程"><a href="#8-开发中分支使用原则与流程" class="headerlink" title="8.开发中分支使用原则与流程"></a>8.开发中分支使用原则与流程</h4><p>​    几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离 开来进行重大的Bug修改、开发新的功能，以免影响开发主线。</p><p>​    在开发中，一般有如下分支使用原则与流程：</p><p>​    <strong>master （生产） 分支</strong></p><p>​        线上分支，主分支，中小规模项目作为线上运行的应用对应的分支；</p><p>​    <strong>develop（开发）分支</strong></p><p>​        是从master创建的分支，一般作为开发部门的主要开发分支，如果没有其他并行开发不同期上线 要求，都可以在此版本进行开发，阶段开发完成后，需要是合并到master分支,准备上线。</p><p>​    <strong>feature&#x2F;xxxx分支</strong></p><p>​        从develop创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的研发任务完 成后合并到develop分支。</p><p>​    <strong>hotfix&#x2F;xxxx分支</strong></p><p>​        从master派生的分支，一般作为线上bug修复使用，修复完成后需要合并到master、test、 develop分支。</p><p>​    还有一些其他分支，在此不再详述，例如test分支（用于代码测试）、pre分支（预上线分支）等等。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/34d2ef51ec71b565d3b480e4cec9f0e2.png" alt="img"></p><h2 id="六、Git远程仓库"><a href="#六、Git远程仓库" class="headerlink" title="六、Git远程仓库"></a>六、Git远程仓库</h2><h3 id="1-常用的托管服务-远程仓库"><a href="#1-常用的托管服务-远程仓库" class="headerlink" title="1.常用的托管服务[远程仓库]"></a>1.常用的托管服务[远程仓库]</h3><p>​    我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云、GitLab等。</p><blockquote><p>​    gitHub（ 地址：<a href="https://github.com/">https://github.com/</a> ）是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名gitHub</p></blockquote><blockquote><p>​    码云（地址： <a href="https://gitee.com/">https://gitee.com/</a> ）是国内的一个代码托管平台，由于服务器在国内，所以相比于 GitHub，码云速度会更快</p></blockquote><blockquote><p>​    GitLab （地址： <a href="https://about.gitlab.com/">https://about.gitlab.com/</a> ）是一个用于仓库管理系统的开源项目，使用Git作 为代码管理工具，并在此基础上搭建起来的web服务,一般用于在企业、学校等内部网络搭建git私服。</p></blockquote><h3 id="2-注册账号"><a href="#2-注册账号" class="headerlink" title="2.注册账号"></a>2.注册账号</h3><p>大家应该都会</p><h3 id="3-创建远程仓库"><a href="#3-创建远程仓库" class="headerlink" title="3.创建远程仓库"></a>3.创建远程仓库</h3><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/2898113bd33ffd06e4baceefecea59e9.png" alt="img"></p><h3 id="4-配置SSH公钥"><a href="#4-配置SSH公钥" class="headerlink" title="4.配置SSH公钥"></a>4.配置SSH公钥</h3><h4 id="1-生成SSH公钥"><a href="#1-生成SSH公钥" class="headerlink" title="1.生成SSH公钥"></a>1.生成SSH公钥</h4><p>​            输入命令：ssh-keygen -t rsa</p><p>​            不断回车</p><p>​                如果公钥已经存在，则自动覆盖</p><h4 id="2-Gitee设置账户共公钥"><a href="#2-Gitee设置账户共公钥" class="headerlink" title="2.Gitee设置账户共公钥"></a>2.Gitee设置账户共公钥</h4><p>​            获取公钥</p><p>​                输入命令：cat ~&#x2F;.ssh&#x2F;id_rsa.pub</p><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/2eb60352e431289230e4d22241ce7ee5.png" alt="img"></p><h4 id="3-验证是否配置成功"><a href="#3-验证是否配置成功" class="headerlink" title="3.验证是否配置成功"></a>3.验证是否配置成功</h4><p>​         输入命令：ssh -T <a href="mailto:&#103;&#105;&#x74;&#64;&#x67;&#105;&#116;&#101;&#x65;&#x2e;&#x63;&#x6f;&#109;">git@gitee.com</a></p><h3 id="5-操作远程仓库"><a href="#5-操作远程仓库" class="headerlink" title="5.操作远程仓库"></a>5.操作远程仓库</h3><h4 id="1-添加远程仓库"><a href="#1-添加远程仓库" class="headerlink" title="1. 添加远程仓库"></a>1. 添加远程仓库</h4><p>​            此操作是先初始化本地库，然后与已创建的远程库进行对接。</p><p>​                命令： git remote add &lt;远端名称&gt;&lt;仓库路径&gt;，</p><p>​                远程名称，默认是origin，取决于远端服务器设置</p><p>​                仓库路径，从远端服务器获取此URL</p><blockquote><p>例如: git remote add origin <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#x65;&#101;&#46;&#x63;&#x6f;&#x6d;">git@gitee.com</a>:czbk_zhang_meng&#x2F;git_test.git</p></blockquote><p>​     <strong>仓库路径获取示例如下：</strong></p><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/e7c0119b3248bb96bc4a759cf3d2719c.png" alt="img"></p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@gitee.com:darling_123456/git_test.git</span><br></pre></td></tr></table></figure><h4 id="2-查看远程仓库"><a href="#2-查看远程仓库" class="headerlink" title="2.查看远程仓库"></a>2.查看远程仓库</h4><p>​            命令：git remote</p><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250223154842556.png" alt="image-20250223154842556"></p><h4 id="3-推送到远程仓库"><a href="#3-推送到远程仓库" class="headerlink" title="3. 推送到远程仓库"></a>3. 推送到远程仓库</h4><p>命令：git push [-f] [–set-upstream] [远端名称 [本地分支名][:远端分支名] ]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master:master</span><br></pre></td></tr></table></figure><p>如果远程分支名和本地分支名称相同，则可以只写本地分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>​                -f 表示强制覆盖</p><p>​                –set-upstream 推送到远端的同时并且建立起和远端分支的关联关系。</p><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250223155204568.png" alt="image-20250223155204568"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure><p>执行这句以后就不用写origin和master直接给git push它也知道要往哪里push</p><p>如果<strong>当前分支已经和远端分支关联</strong>，则可以省略分支名和远端名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push  <span class="comment">#将master分支推送到已关联的远端分支。</span></span><br></pre></td></tr></table></figure><h4 id="4-本地分支与远程分支的关联关系"><a href="#4-本地分支与远程分支的关联关系" class="headerlink" title="4.本地分支与远程分支的关联关系"></a>4.本地分支与远程分支的关联关系</h4><p>查看关联关系我们可以使用 git branch -vv 命令</p><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250223160010339.png" alt="image-20250223160010339"></p><h4 id="5-从远程仓库克隆"><a href="#5-从远程仓库克隆" class="headerlink" title="5.从远程仓库克隆"></a>5.从远程仓库克隆</h4><p>如果已经有一个远端仓库，我们可以直接clone到本地。</p><blockquote><p>命令: git clone &lt;仓库路径&gt; [本地目录]  本地目录可以省略，会自动生成一个目录</p></blockquote><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/330e945ebd5a2f47f0ae3eea97275142.png" alt="img"></p><h4 id="6-从远程仓库中抓取和拉取"><a href="#6-从远程仓库中抓取和拉取" class="headerlink" title="6.从远程仓库中抓取和拉取"></a>6.从远程仓库中抓取和拉取</h4><p> 远程分支和本地的分支一样，我们可以进行merge操作，只是需要先把远端仓  库里的更新都下载到本地，再进行操作。</p><p> **抓取命令：**git fetch [remote name] [branch name]</p><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250223160832106.png" alt="image-20250223160832106"></p><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250223161201571.png" alt="image-20250223161201571"></p><blockquote><ul><li>抓取指令就是将仓库里的更新都抓取到本地，不会进行合并</li><li>如果不指定远端名称和分支名，则抓取所有分支</li></ul></blockquote><p><strong>拉取命令</strong>：git pull [remote name] [branch name]</p><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250223161113504.png" alt="image-20250223161113504"></p><blockquote><ul><li>拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge</li><li><strong>如果不指定远端名称和分支名，则抓取所有并更新当前分支。</strong></li></ul></blockquote><p>这里如果看他的b视频没看懂的话可以去看上面的整体的工作流程图，就容易多了。</p><h4 id="7-解决合并冲突"><a href="#7-解决合并冲突" class="headerlink" title="7.解决合并冲突"></a>7.解决合并冲突</h4><p>​    在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。 A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要 推送到远程仓库，此时B用户晚于A用户，故需要先拉取远程仓库的提交，经过合并后才能推送到远端分支,如下图所示。 </p><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/6178d6725f1b5198b31af6bdaa2986e4.png" alt="img"></p><p>​    在B用户拉取代码时，因为A、B用户同一段时间修改了同一个文件的相同位置代码，故会发生合并冲 突。</p><blockquote><p>远程分支也是分支，所以合并时冲突的解决方式也和解决本地分支冲突相同相同。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/03/17/hello-world/"/>
      <url>/2025/03/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
