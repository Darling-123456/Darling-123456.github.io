<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Day70 | 灵神 | 二分查找：完成旅途的最少时间</title>
      <link href="/2025/03/22/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day70%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E5%AE%8C%E6%88%90%E6%97%85%E9%80%94%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/"/>
      <url>/2025/03/22/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day70%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E5%AE%8C%E6%88%90%E6%97%85%E9%80%94%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="Day70-灵神-二分查找：完成旅途的最少时间"><a href="#Day70-灵神-二分查找：完成旅途的最少时间" class="headerlink" title="Day70 | 灵神 | 二分查找：完成旅途的最少时间"></a>Day70 | 灵神 | 二分查找：完成旅途的最少时间</h1><h2 id="2187-完成旅途的最少时间"><a href="#2187-完成旅途的最少时间" class="headerlink" title="2187.完成旅途的最少时间"></a>2187.完成旅途的最少时间</h2><p><a href="https://leetcode.cn/problems/minimum-time-to-complete-trips/description/">2187. 完成旅途的最少时间 - 力扣（LeetCode）</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="1-单调性判断二分谁"><a href="#1-单调性判断二分谁" class="headerlink" title="1.单调性判断二分谁"></a>1.单调性判断二分谁</h4><p>本题还是和前两天的那两道题一样，我们平分的还是时间</p><p>从单调性来讲，如果t的时间可以正好完成旅途，那么t+1，t+2的时间一定也可以</p><p>但是t-1就不行了，我们就是要找这样的t</p><h4 id="2-求出二分区间"><a href="#2-求出二分区间" class="headerlink" title="2.求出二分区间"></a>2.求出二分区间</h4><p>现在我们首先要做的就是求出我们的二分区间，即时间t的范围</p><p>笔者的思路是，找到单次旅途时间最短的车，然后乘以totalTrips，那这样也不用管别的车跑了几次，因为只需要这一辆车就可以跑够totalTrips，所以这是一个最大值</p><p>最小值不用思考了，那当然就是1了</p><p><code>注：</code>这里最大值最小值灵神有个优化，感兴趣可以自行查看</p><p><a href="https://leetcode.cn/problems/minimum-time-to-complete-trips/solutions/1295955/er-fen-da-an-python-yi-xing-gao-ding-by-xwvs8/">2187. 完成旅途的最少时间 - 力扣（LeetCode）</a></p><h4 id="3-写出判断条件即check函数"><a href="#3-写出判断条件即check函数" class="headerlink" title="3.写出判断条件即check函数"></a>3.写出判断条件即check函数</h4><p>判断条件就是所有的车在t的时间内完成的所有旅程数量能否达到totalTrips</p><p>那么所有车在t的时间内完成的所有旅程数量怎么计算？</p><p>一辆车的旅程其实就是总时间t除以单次时间time[i]，而且是下取整，所以我们不需要做过多的处理</p><p>到这里就可以开始写代码了</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; time, <span class="type">int</span> totalTrips,<span class="type">long</span> <span class="type">long</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> c:time)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=(t/c);</span><br><span class="line">            <span class="keyword">if</span>(res&gt;=totalTrips)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minimumTime</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; time, <span class="type">int</span> totalTrips)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> min_time=ranges::<span class="built_in">min</span>(time);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> l=<span class="number">1</span>,r=min_time*totalTrips<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(time,totalTrips,mid))</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果你卡在了116&#x2F;124，即第116个例子左右，那你一定要看看该改long long的地方改没改</p><p>特别是传入check函数的t，那个形参的类型必须得是long long，笔者改了这个就通过了</p>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂</title>
      <link href="/2025/03/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day69%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/"/>
      <url>/2025/03/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day69%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/</url>
      
        <content type="html"><![CDATA[<h1 id="Day69-灵神-二分查找：爱吃香蕉的珂珂"><a href="#Day69-灵神-二分查找：爱吃香蕉的珂珂" class="headerlink" title="Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂"></a>Day69 | 灵神 | 二分查找：爱吃香蕉的珂珂</h1><h2 id="875-爱吃香蕉的珂珂"><a href="#875-爱吃香蕉的珂珂" class="headerlink" title="875.爱吃香蕉的珂珂"></a>875.爱吃香蕉的珂珂</h2><p><a href="https://leetcode.cn/problems/koko-eating-bananas/description/">875. 爱吃香蕉的珂珂 - 力扣（LeetCode）</a></p><h3 id="笔者关键点记录：怎么想到的要二分k而不是原来区间呢？"><a href="#笔者关键点记录：怎么想到的要二分k而不是原来区间呢？" class="headerlink" title="笔者关键点记录：怎么想到的要二分k而不是原来区间呢？"></a>笔者关键点记录：怎么想到的要二分k而不是原来区间呢？</h3><p>可以看到灵神的题解：</p><p>看示例 1，piles&#x3D;[3,6,7,11], h&#x3D;8。</p><p>如果珂珂能用 k&#x3D;4 的速度吃掉所有香蕉，那么也能用更快的速度 k&#x3D;5,6,⋯ 吃掉所有香蕉。<br>如果珂珂不能用 k&#x3D;3 的速度吃掉所有香蕉，那么也不能用更慢的速度 k&#x3D;2,1,⋯ 吃掉所有香蕉。<br>这种单调性意味着我们像 二分查找 那样，把答案 k 猜出来。</p><p><strong>我感觉也可以理解为题目让求啥我们就二分什么东西</strong></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>有了昨天的H指数II，这道题只能说是 so easy，还是一样，piles只是用来写判断条件的，我们二分的是速度k</p><p>注意，题目说piles的大小小于时间h，这使得我们很容易找到k的最大值，那就是数组的最大值，我每个小时吃这么多肯定可以吃得完，而最小值肯定不能是0，因为怎么都不可能吃完，所以从1开始</p><p><strong>那么我们要二分的k的区间就是[1,数组最大值]，在第一个例子中就是[1,11]</strong></p><p><strong>那么接下来就是判断条件咋写了</strong></p><p>我们二分的是k，是速度，那要如何判断一个k是否满足条件？那就看这个k可以在多少小时（sum）内吃完香蕉，如果这个sum小于等于h，那肯定就是符合条件的k，那么<code>[k,数组最大值]</code>这个区间肯定都符合条件</p><p>然后继续往左收缩就是了</p><p><code>注意点：</code></p><p>每一堆计算时，如果可以整除k，那就是直接除以k，不可以整除就得让结果+1，因为C++默认除法下取整</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>说明：</p><p>1.笔者用的是左闭右开区间，是[l,r)，所以求出最大值后要加1</p><p>2.满足条件更新r还是l，那就看sum是大于还是小于h了，本题是sum小于等于h，找的是左边界，只要mid满足条件，那么大于mid的肯定都满足条件，所以更新r</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles,<span class="type">int</span> k,<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:piles)、</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c%k==<span class="number">0</span>)</span><br><span class="line">                sum+=(c/k);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sum+=(c/k)<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum&lt;=h?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minEatingSpeed</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:piles)</span><br><span class="line">            r=<span class="built_in">max</span>(r,c)<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(piles,mid,h))</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day68 | 灵神 | 二分查找：H指数II</title>
      <link href="/2025/03/20/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day68%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9AH%E6%8C%87%E6%95%B0II/"/>
      <url>/2025/03/20/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day68%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9AH%E6%8C%87%E6%95%B0II/</url>
      
        <content type="html"><![CDATA[<h1 id="Day68-灵神-二分查找：H指数II"><a href="#Day68-灵神-二分查找：H指数II" class="headerlink" title="Day68 | 灵神 | 二分查找：H指数II"></a>Day68 | 灵神 | 二分查找：H指数II</h1><h2 id="275-H指数II"><a href="#275-H指数II" class="headerlink" title="275.H指数II"></a>275.H指数II</h2><p><a href="https://leetcode.cn/problems/h-index-ii/description/">275. H 指数 II - 力扣（LeetCode）</a></p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>很遗憾笔者这道题没做出来，看了灵神的还是不太懂，后来看了评论区各位大佬的解释，来这里浅显的说一下自己的理解</p><p>在此之前请先看看灵神的题解，如果看懂了还是不要继续往下看了，如果没看懂的话，我来说一说我疑惑的点，看看是不是也是你疑惑的点呢？</p><p>灵神题解：<a href="https://leetcode.cn/problems/h-index-ii/solutions/2504326/tu-jie-yi-tu-zhang-wo-er-fen-da-an-si-ch-d15k/">275. H 指数 II - 力扣（LeetCode）</a></p><h3 id="可能对灵神的题解中的疑惑的点"><a href="#可能对灵神的题解中的疑惑的点" class="headerlink" title="可能对灵神的题解中的疑惑的点"></a>可能对灵神的题解中的疑惑的点</h3><h4 id="1-理解本道题最重要的一点"><a href="#1-理解本道题最重要的一点" class="headerlink" title="1.理解本道题最重要的一点"></a>1.理解本道题最重要的一点</h4><p>为什么左闭右开区间的时候，l要初始化为1，r要初始化为citations.size()+1呢？</p><p>因为这道题二分的其实是h指数的数组，而h指数的数组你可以看做是[0,1,2,3,4,5]，因为h指数可以取到这些数字，也就是说h指数的范围是[0,5]即[0,citations.size()]，但是笔者写的是左开右闭区间所以就是[0,citations.size()+1)了，也就是[0,6)</p><p>所以其实我们二分的是[0,1,2,3,4,5]这个数组，我们最后返回的答案一定在这之中</p><p><strong>所以说白了citations这个数组起到的作用就是辅助我们把h从[0,citations.size()+1)给挑选出来，也就是用来写判断条件的，除此之外没有什么其他的作用</strong></p><p>而为什么l初始化为0而不是1呢？</p><p>这个灵神有说</p><p>肯定有0篇论文的引用次数&gt;&#x3D;0，那么二分区间就不需要包括0，直接从1开始就好了，也就是说我们二分的区间其实是[1,2,3,4,5]，等价于[1,2,3,4,5,6)</p><p>这让我想起洛谷做过的一道题，是砍树的，也是把树的高度进行二分而不是去看树的高度的数组，完了有空再去刷一下</p><h4 id="2-比较重要的理解，为啥最后返回的是l-1不是l"><a href="#2-比较重要的理解，为啥最后返回的是l-1不是l" class="headerlink" title="2.比较重要的理解，为啥最后返回的是l-1不是l"></a>2.比较重要的理解，为啥最后返回的是l-1不是l</h4><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250320092859009.png" alt="image-20250320092859009"></p><p>首先要理解这个，这个比较容易，大家自行理解就好</p><p>其次要知道，二分区间[l,r)内的性质我们还没有判断，就是我们不知道二分区间内的数是否满足条件，而二分区间外面的数字是已经被筛选过的，肯定满足条件的</p><p>就像是[1,2,3,4,5,6)当我们二分区间为[3,4,5,6)的时候，我们肯定可以判断1,2是合法或者不合法的才会更新到[3,4,5,6)这个区间</p><p><strong>再次，通过上面的第一条我们得知citations是来辅助我们筛选h的，所以更新区间时的mid其实就是满足条件的答案h，下面的代码我也有写，用res记录答案，每次更新时res&#x3D;mid，然后才是l&#x3D;mid+1</strong></p><p>也就是说，我们每次判断的时候l-1&#x3D;&#x3D;mid，也就是l-1就是答案，这也是为什么灵神最后返回的是l-1</p><p>满足条件在灵神的题解中等价于是询问的结果是   “是”</p><h4 id="3-citations-citations-size-mid-mid这个判断条件该如何理解？"><a href="#3-citations-citations-size-mid-mid这个判断条件该如何理解？" class="headerlink" title="3.citations[citations.size()-mid]&gt;&#x3D;mid这个判断条件该如何理解？"></a>3.citations[citations.size()-mid]&gt;&#x3D;mid这个判断条件该如何理解？</h4><p>citations.size()-mid这个下标对应的是数组倒数第mid个数，因为是单调自增的，如果说 这个下标对应的数要大于我们本轮筛选的h即mid，那说明这个数以及以后的数都是大于mid的，即至少有mid篇论文被引用mid次，用灵神的一张图说明吧</p><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250320094417918.png" alt="image-20250320094417918"></p><p>下面的[0,1,2,3,4,5]可以看做我们的h数组，我们正在用二分筛选这个数组，现在筛选的是h=&#x3D;2&#x3D;&#x3D;mid</p><p>citations[0,1,3,5,6]中，citations.size()-mid&#x3D;5-2&#x3D;3</p><p>citations[3]&#x3D;5,5&gt;2,而5又是倒数第二个数，5,6，都大于2，那说明肯定至少有两篇论文大于等于2，那么h=&#x3D;2=&#x3D;mid就是一个合法的状态，然后下次更新就是更新到l=&#x3D;mid+1，因为[mid+1,r)这个区间还没有判断是否合法，而[0,mid]这个区间已经被判断为是合法的了</p><p>那自然我们确定的答案就是l-1，即mid，就是我们目前帅选出来的最大的h指数了</p><p>往后就是反复这个过程</p><h3 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h3><p>完整代码部分我觉得加一个res比较好理解，也是看的评论区学习到的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; citations)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>,r=citations.<span class="built_in">size</span>()<span class="number">+1</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(citations[citations.<span class="built_in">size</span>()-mid]&gt;=mid)</span><br><span class="line">            &#123;</span><br><span class="line">                res=mid;</span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">lower_bound</span>(citations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day67 | 灵神 | 二分查找：统计公平数对的数目</title>
      <link href="/2025/03/19/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day67%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%85%AC%E5%B9%B3%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/"/>
      <url>/2025/03/19/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day67%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%85%AC%E5%B9%B3%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Day67-灵神-二分查找：统计公平数对的数目"><a href="#Day67-灵神-二分查找：统计公平数对的数目" class="headerlink" title="Day67 | 灵神 | 二分查找：统计公平数对的数目"></a>Day67 | 灵神 | 二分查找：统计公平数对的数目</h1><h2 id="2563-统计公平数对的数目"><a href="#2563-统计公平数对的数目" class="headerlink" title="2563.统计公平数对的数目"></a>2563.统计公平数对的数目</h2><p><a href="https://leetcode.cn/problems/count-the-number-of-fair-pairs/description/">2563. 统计公平数对的数目 - 力扣（LeetCode）</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先说一下为什么排序不会影响本道题目的结果，因为本质上是从数组中选择两个数，满足0&lt;i&lt;j&lt;n，lower &lt;&#x3D; nums[i] + nums[j] &lt;&#x3D; upper的条件。就算你排序之后，那两个数还是那两个数，无非就是从[1,4]变成了[4,1]而已。</p><p>先来说一说错误的，希望大家不要和笔者一样</p><p>想的是在二分查找过程中把对数给统计了，check函数也是传入的nums[l],nums[r],lower,upper，按照题目给的条件去比较，然后判断符合条件不符合条件</p><p>这时候就发现，我符合条件以后我该往哪边收缩呢？不管往那边收缩都会漏掉情况，往左收缩会漏掉往右的情况，往右收缩会漏掉左边的，同时收缩更不用说了</p><p>所以这个时候就该发现自己的思路出了问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> c,<span class="type">long</span> <span class="type">long</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a+b&gt;=c&amp;&amp;a+b&lt;=d)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> lower, <span class="type">int</span> upper)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(nums[l],nums[r],lower,upper))</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                r=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countFairPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lower, <span class="type">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">lower_bound</span>(nums,lower,upper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h4><p>参考的灵神的思路</p><p>用j遍历数组，那么我们的nums[i]需要满足什么条件呢？</p><p><em>lower</em>−<em>nums</em>[<em>j</em>]≤<em>nums</em>[<em>i</em>]≤<em>upper</em>−<em>nums</em>[<em>j</em>]</p><p>这时候你就发现呢我们只要用lower-nums[j]去找nums[i]的左边界，用upper-nums[j]去找nums[i]的右边界，那么在左右边界内的数字一定符合条件，也就是数对的数量</p><p>不过要注意是在[0,j)这个左开右闭区间进行二分，因为题目说了要i&lt;j</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>笔者的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums,<span class="type">int</span> bound,<span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=bound;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countFairPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lower, <span class="type">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// &lt; lower-nums[j] 的 nums[i] 的个数</span></span><br><span class="line">            <span class="type">int</span> l=<span class="built_in">lower_bound</span>(nums,j,lower-nums[j]);</span><br><span class="line">            <span class="comment">// &lt;= upper-nums[j] 的 nums[i] 的个数</span></span><br><span class="line">            <span class="comment">//这个+1是因为&lt;=x就是(&gt;x+1)的位置-1</span></span><br><span class="line">            <span class="comment">//这里没减1是下面的r-l懒得+1了，减了1就是[l,r]的闭区间，不减就是[l,r)的区间，效果都一样</span></span><br><span class="line">            <span class="type">int</span> r=<span class="built_in">lower_bound</span>(nums,j,upper-nums[j]<span class="number">+1</span>);</span><br><span class="line">            res += r- l;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>灵神的使用二分查找函数的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countFairPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> lower, <span class="type">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="comment">// 注意要在 [0, j) 中二分，因为题目要求两个下标 i &lt; j</span></span><br><span class="line">            <span class="keyword">auto</span> r = <span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + j, upper - nums[j]); <span class="comment">// &lt;= upper-nums[j] 的 nums[i] 的个数</span></span><br><span class="line">            <span class="keyword">auto</span> l = <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + j, lower - nums[j]); <span class="comment">// &lt; lower-nums[j] 的 nums[i] 的个数</span></span><br><span class="line">            ans += r - l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="补充知识：upper-bound和lower-bound"><a href="#补充知识：upper-bound和lower-bound" class="headerlink" title="补充知识：upper_bound和lower_bound"></a>补充知识：<code>upper_bound</code>和<code>lower_bound</code></h3><p><code>upper_bound</code>和<code>lower_bound</code>是C++标准库中用于在<strong>已排序序列</strong>中查找边界的算法，它们的返回值是<strong>迭代器</strong>，具体行为如下：</p><hr><h3 id="1-返回值类型"><a href="#1-返回值类型" class="headerlink" title="1. 返回值类型"></a><strong>1. 返回值类型</strong></h3><ul><li><p>返回值为迭代器：两者均返回指向容器中特定位置的迭代器（ForwardIterator或RandomAccessIterator），而非直接返回下标或元素值</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>);  <span class="comment">// it指向元素8的迭代器（即v[4]）</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="2-返回值指向的位置"><a href="#2-返回值指向的位置" class="headerlink" title="2. 返回值指向的位置"></a><strong>2. 返回值指向的位置</strong></h3><h4 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a><strong>lower_bound</strong></h4><ul><li><p>返回第一个 <em>≥</em> val 的元素位置：若存在等于val的元素，返回第一个等于val的元素的迭代器；若不存在，则返回第一个大于val的元素的迭代器；若所有元素均小于val，返回last（容器的end()迭代器）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>);  <span class="comment">// 指向第一个2的迭代器（v[2]）</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a><strong>upper_bound</strong></h4><ul><li><p>返回第一个 <em>&gt;</em> val 的元素位置：无论是否存在等于val的元素，均返回第一个大于val的元素的迭代器；若所有元素均小于等于val，返回last（容器的end()迭代器）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>);  <span class="comment">// 指向8的迭代器（v[4]）</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="3-特殊情况处理"><a href="#3-特殊情况处理" class="headerlink" title="3. 特殊情况处理"></a><strong>3. 特殊情况处理</strong></h3><ul><li><p>元素不存在时：若序列中无符合条件的元素，两者均返回last（即end()迭代器），表示“结束位置”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">9</span>);  <span class="comment">// 返回v.end()（指向末尾后一位置）</span></span><br></pre></td></tr></table></figure></li><li><p>元素为最大值时：若val等于最后一个元素的值，upper_bound仍返回end()，而lower_bound返回最后一个元素的迭代器</p></li></ul><hr><h3 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a><strong>4. 应用场景</strong></h3><ul><li><p>计算元素出现次数：结合upper_bound - lower_bound可快速计算有序序列中某元素的出现次数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>) - <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p>插入元素保持有序：使用返回的迭代器插入新元素，可维持序列的有序性</p></li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table><thead><tr><th align="center">函数</th><th align="center">返回值类型</th><th align="center">指向位置</th><th align="center">特殊返回值（无匹配时）</th></tr></thead><tbody><tr><td align="center"><code>lower_bound</code></td><td align="center">迭代器</td><td align="center">第一个 <strong>≥ val</strong> 的元素</td><td align="center"><code>end()</code></td></tr><tr><td align="center"><code>upper_bound</code></td><td align="center">迭代器</td><td align="center">第一个 <strong>&gt; val</strong> 的元素</td><td align="center"><code>end()</code></td></tr></tbody></table><p>使用时需确保序列<strong>已排序</strong>，否则结果未定义</p>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day66 | 灵神 | 二分查找：咒语和药水的成功对数</title>
      <link href="/2025/03/18/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day66%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E5%92%92%E8%AF%AD%E5%92%8C%E8%8D%AF%E6%B0%B4%E7%9A%84%E6%88%90%E5%8A%9F%E5%AF%B9%E6%95%B0/"/>
      <url>/2025/03/18/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day66%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E5%92%92%E8%AF%AD%E5%92%8C%E8%8D%AF%E6%B0%B4%E7%9A%84%E6%88%90%E5%8A%9F%E5%AF%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Day66-灵神-二分查找：咒语和药水的成功对数"><a href="#Day66-灵神-二分查找：咒语和药水的成功对数" class="headerlink" title="Day66 | 灵神 | 二分查找：咒语和药水的成功对数"></a>Day66 | 灵神 | 二分查找：咒语和药水的成功对数</h1><h2 id="2300-咒语和药水的成功对数"><a href="#2300-咒语和药水的成功对数" class="headerlink" title="2300.咒语和药水的成功对数"></a>2300.咒语和药水的成功对数</h2><p><a href="https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/description/">2300. 咒语和药水的成功对数 - 力扣（LeetCode）</a></p><p><code>思路：</code></p><p>这个题目还挺好想的</p><p>其实还是在数组里面去找左边界而已，只是在外面多套了一层数组的遍历</p><p>遍历spells数组，然后里面套找左边界的二分查找就行，查找options数组里面的满足条件的左边界，找到之后求出左边界到数组末尾这个区间的长度就行</p><p><strong>记得先排序options，因为只有有序我们才可以使用二分查找</strong></p><p>时间复杂度是遍历数组spells，二分查找options，一共O(nlogm)。再加上排序的时间复杂度O(mlogm)</p><p>时间复杂度&#x3D; O(nlogm)+O(mlogm)&#x3D;O((n+m)logm)</p><p>如果不太会写左边界的二分查找，可以看看昨天的博客：</p><p><a href="https://blog.csdn.net/m0_74795952/article/details/146308117?spm=1001.2014.3001.5501">Day65 | 灵神 | 二分查找：红蓝染色法-CSDN博客</a></p><p><code>完整代码：</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a*b&gt;=c)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(<span class="type">int</span> spells,vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">long</span> <span class="type">long</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(nums[mid],spells,target))</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">successfulPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; spells, vector&lt;<span class="type">int</span>&gt;&amp; potions, <span class="type">long</span> <span class="type">long</span> success)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; pairs;</span><br><span class="line">        <span class="type">int</span> single_pairs=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(potions.<span class="built_in">begin</span>(),potions.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;spells.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            single_pairs=potions.<span class="built_in">size</span>()-<span class="built_in">lower_bound</span>(spells[i],potions,success);</span><br><span class="line">            pairs.<span class="built_in">push_back</span>(single_pairs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pairs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day65 | 灵神 | 二分查找：红蓝染色法</title>
      <link href="/2025/03/17/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day65%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%BA%A2%E8%93%9D%E6%9F%93%E8%89%B2%E6%B3%95/"/>
      <url>/2025/03/17/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day65%20%20%E7%81%B5%E7%A5%9E%20%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E7%BA%A2%E8%93%9D%E6%9F%93%E8%89%B2%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Day65-灵神-二分查找：红蓝染色法"><a href="#Day65-灵神-二分查找：红蓝染色法" class="headerlink" title="Day65 | 灵神 | 二分查找：红蓝染色法"></a>Day65 | 灵神 | 二分查找：红蓝染色法</h1><p>灵神讲解的非常好建议大家去听听灵神的，二分查找就是常忘常学常新，我之前学过很多次二分，但这次还是有新的理解，我把可能比较难理解的点写到了下面，大家没看懂视频的地方可以看看我写的</p><p>当然主要的其实是check函数，在本题中就是大于等于target这个条件，估计灵神下个视频会讲吧</p><p><a href="https://www.bilibili.com/video/BV1AP41137w7?spm_id_from=333.788.videopod.sections&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">二分查找 红蓝染色法【基础算法精讲 04】_哔哩哔哩_bilibili</a></p><h2 id="34-在数组排序中查找元素的第一个和最后一个位置"><a href="#34-在数组排序中查找元素的第一个和最后一个位置" class="headerlink" title="34.在数组排序中查找元素的第一个和最后一个位置"></a>34.在数组排序中查找元素的第一个和最后一个位置</h2><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></p><h3 id="视频中的可能的难点"><a href="#视频中的可能的难点" class="headerlink" title="视频中的可能的难点"></a>视频中的可能的难点</h3><h4 id="0-区间的定义"><a href="#0-区间的定义" class="headerlink" title="0.区间的定义"></a>0.区间的定义</h4><p>我觉得这个很重要，不管是定义左闭右开还是左闭右闭，在区间内的数字就是我们接下来要去判断的数字，看看是否满足条件</p><p>而区间外的数字都是已经判断过的不满足条件的</p><h4 id="1-关于while中什么时候有等号，什么时候没等号的问题"><a href="#1-关于while中什么时候有等号，什么时候没等号的问题" class="headerlink" title="1.关于while中什么时候有等号，什么时候没等号的问题"></a>1.关于while中什么时候有等号，什么时候没等号的问题</h4><p>循环条件中的l&lt;r或者l&lt;&#x3D;r有没有等号看的是当l&#x3D;&#x3D;r的时候[l,r]这个区间是否有数字</p><p>如果是左闭右闭，那当然有意义，两个指向同一个数字，比如[2,2]</p><p>如果是左闭右开，那当然就是空的了，比如[2,2)，在数学上这是个空集</p><p>如果是左开右开那更不必说了</p><h4 id="2-循环不变量"><a href="#2-循环不变量" class="headerlink" title="2.循环不变量"></a>2.循环不变量</h4><p>而灵神说的循环不变量就是指的是循环过程中要保证区间左闭右闭这个性质不发生改变，不可以原来是左闭右闭，后面直接换成左闭右开了，那样就会出错</p><h4 id="3-关于if中-什么时候是mid-1，mid-1什么时候是mid"><a href="#3-关于if中-什么时候是mid-1，mid-1什么时候是mid" class="headerlink" title="3.关于if中 什么时候是mid-1，mid+1什么时候是mid"></a>3.关于if中 什么时候是mid-1，mid+1什么时候是mid</h4><p>看你选定的区间的l和r在mid+1或者mid-1或者mid，什么时候可以<strong>保持循环不变量</strong>，那就是什么</p><p><code>举例</code></p><p>1.比如我选定的是左闭右开区间[l,r)，那我每次更新l的时候l就是mid+1，因为当l&#x3D;&#x3D;mid时nums[mid]可以取到并且不符合条件，那就直接等于mid+1</p><p>而更新r的时候呢？r&#x3D;&#x3D;mid时nums[mid]其实没有意义，因为r这边是开区间，我们取不到r，所以更新r的时候必须是r&#x3D;mid，才可以继续保证[l,r)是一个开区间</p><p>2.选定的如果是左闭右闭区间[l,r]，那更新l就是mid+1，更新r就是mid-1，因为不管是l=&#x3D;mid时还是r&#x3D;&#x3D;mid都是有意义的，而且只有这样才能满足更新后的区间继续保持[l,r]这个闭区间</p><h4 id="4-关于-大于、小于、大于等于、小于等于这四种情况的举例说明"><a href="#4-关于-大于、小于、大于等于、小于等于这四种情况的举例说明" class="headerlink" title="4.关于 大于、小于、大于等于、小于等于这四种情况的举例说明"></a>4.关于 大于、小于、大于等于、小于等于这四种情况的举例说明</h4><p>关于大于、小于、大于等于、小于等于这四个情况的说明，如果大家没听懂灵神说的可以看看我写的</p><p><strong>大于和大于等于找的是左边界，小于和小于等于找的是右边界</strong></p><p>我就拿题目中的例子作为说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><p>target&#x3D;8，令x&#x3D;8</p><p>大于等于x就是我们原来找的，直接就可以找到下标为3的8，即左边界</p><p>大于x可以看做大于等于x+1，即在这个数组里面大于8就相当于大于等于9，直接找到的就是10</p><p>小于x可以看做     找到大于等于x的那个数的下标之后再减1，即(&gt;&#x3D;x)-1，在数组中就是要找小于8的数，而我们找到下标为3的第一个8，再用下标3-1&#x3D;2，那就是小于8的数，也就是7，但这个是右边界</p><p>在本题中可以直接用(&gt;&#x3D;9)-1这样的方式直接找到8的右边界，即4</p><p>小于等于x可以看做     找到大于x的那个数的下标之后再-1，即(&gt;x)-1，在本题中找到的是下标为5的10，再减去1得到的是下标为4的8，即找到的是右边界，并且这个直接就找到了目标值8的右边界</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p><strong>大家记住一个写法就行，我一般常用的是左闭右开的写法，因为很多容器和算法都是左闭右开这个区间，有些习惯吧算是</strong></p><p>可能遇到的不清楚的我都写了注释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)<span class="comment">//l==r时没有意义，不写等号</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;<span class="comment">//防止溢出</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)</span><br><span class="line">                r=mid;<span class="comment">//左闭右开，右边是开的 不需要写mid-1</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//找左边界</span></span><br><span class="line">        <span class="type">int</span> first=<span class="built_in">lower_bound</span>(nums,target);</span><br><span class="line">        <span class="comment">//这两种情况说明数组里面没target</span></span><br><span class="line">        <span class="keyword">if</span>(first==nums.<span class="built_in">size</span>()||nums[first]!= target)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="comment">//找右边界，刚刚说了找右边界肯定就是小于或者小于等于的情况，这两种情况可以由找左边的情况互换过来</span></span><br><span class="line">        <span class="comment">//即去找&gt;=target+1的的左边界，在第一个例子中就是大于等于9，找到后就是右边界的下一位置，那么再减去1，那就是最后的答案</span></span><br><span class="line">        <span class="type">int</span> last=<span class="built_in">lower_bound</span>(nums,target<span class="number">+1</span>)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;first,last&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="笔者自己学过的二分代码的思路"><a href="#笔者自己学过的二分代码的思路" class="headerlink" title="笔者自己学过的二分代码的思路"></a>笔者自己学过的二分代码的思路</h3><p>找左右边界，左边界找法和灵神相同，右边界找法就是我下面写的这种，也就是nums[mid]&lt;&#x3D;target时去更新l</p><p><strong>其实找左边界就是根据条件从右往左收缩，找右边界就是从左往右收缩</strong></p><p>然而不管是左边界还是右边界，终止条件都是l&#x3D;&#x3D;r，也就是最后的时候l和r是相等的，返回哪个都行</p><p>最后还要注意一点是我用的是左闭右开区间，最后找到的右边界取不到，所以记得看看题目要求，如果找的是target这个数字的右边界记得要-1，要是算个数啥的一般不用减</p><p>顺带一提这个和stl算法中的二分查找函数的结果相同，即左边界是第一个target，右边界是最后一个target+1的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;<span class="comment">//防止溢出</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">upper_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;<span class="comment">//防止溢出</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=target)</span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> first=<span class="built_in">lower_bound</span>(nums,target);</span><br><span class="line">        <span class="keyword">if</span>(first==nums.<span class="built_in">size</span>()||nums[first]!= target)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> last=<span class="built_in">upper_bound</span>(nums,target)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;first,last&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2529-正整数和负整数的最大计数"><a href="#2529-正整数和负整数的最大计数" class="headerlink" title="2529.正整数和负整数的最大计数"></a>2529.正整数和负整数的最大计数</h2><p><a href="https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/description/">2529. 正整数和负整数的最大计数 - 力扣（LeetCode）</a></p><p>做一道题练练手，检验一下自己的学习成果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums,<span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//找0的左边界 这是负整数的右边界 并且取不到，给出答案 因为下标本身比第几个数字小1，所以不用做别的处理，直接就是负整数的个数</span></span><br><span class="line">        <span class="type">int</span> first=<span class="built_in">lower_bound</span>(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//找1的左边界 这是正整数的左边界</span></span><br><span class="line">        <span class="type">int</span> last=<span class="built_in">lower_bound</span>(nums,<span class="number">0</span><span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">return</span> first&gt;nums.<span class="built_in">size</span>()-last?first:nums.<span class="built_in">size</span>()-last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，直接遍历也可以</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> neg = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                neg++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(neg, pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day64 | 灵神 | 滑动窗口：最小覆盖子串</title>
      <link href="/2025/03/16/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day64%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
      <url>/2025/03/16/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day64%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="Day64-灵神-滑动窗口：最小覆盖子串"><a href="#Day64-灵神-滑动窗口：最小覆盖子串" class="headerlink" title="Day64 | 灵神 | 滑动窗口：最小覆盖子串"></a>Day64 | 灵神 | 滑动窗口：最小覆盖子串</h1><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76.最小覆盖子串"></a>76.最小覆盖子串</h2><p><a href="https://leetcode.cn/problems/minimum-window-substring/description/">76. 最小覆盖子串 - 力扣（LeetCode）</a></p><p>总的来说笔者自己很难做出这道题，基本都是参考了灵神的题解，下面记录自己的理解和踩坑记录</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路还是好想的，就和之前的滑动窗口题目一样，<strong>固定右端点，遍历右端点，寻找左指针的收缩条件</strong>，好想的地方在于收缩条件无比的简单，就是看[l,r]内是否涵盖了t中的所有的字符即可，如果涵盖了，我们就收缩左指针，寻找更小的子串，如果不再涵盖的话，那说明已经不满足收缩条件，我们就继续往后遍历右指针，看看新的[l,r]内是否可以涵盖t的所有字符</p><h3 id="可能产生的疑惑"><a href="#可能产生的疑惑" class="headerlink" title="可能产生的疑惑"></a>可能产生的疑惑</h3><p>我在固定r的时候，把l收缩到一个位置了，那么当固定r+1时，需要重新把l置为0吗？</p><p>其实是不需要的，固定r的时候我们如果找到了一个最小的区间[l,r]是满足条件的，那么[l,r+1]肯定是大于[l,r]的，所以没必要重新把l置为0</p><h3 id="笔者认为的本题难点"><a href="#笔者认为的本题难点" class="headerlink" title="笔者认为的本题难点"></a>笔者认为的本题难点</h3><p>困难题还是困难题呀，考察一个人的综合素养，反正是给笔者卡住了</p><p><code>1.如何知道我当前的[l,r]区间涵盖了t的所有字符？</code></p><p>笔者第一想法是用哈希表统计t的所有字符数量，另一个哈希表统计[l,r]的所有字符数量，然后再遍历一遍[l,r]，把哈希表中的数都给减掉，如果t的字符的哈希值最后都大于0那就说明是涵盖了，可是这个代码实现真的太麻烦了，时间复杂度我也不敢想（现在想想这个想法还有点可笑）</p><p>就去参考了灵神的，灵神也是用两个哈希表，灵神是统计完t的字符数量之后，把大写英文和小写英文遍历一遍，然后比较同一个字符的两个哈希表的数值，如果s的哈希表的所有的大小写字符都比t的哈希表的数值大，那就说明肯定涵盖了所有的t的字符。</p><p><strong>只需要比大小就好，不需要加加减减的。这个方法要记住。</strong></p><p><code>2.内存超出限制</code></p><p>看下方的踩坑记录即可</p><p><code>3.我的res一开始是空串，如果最后还是空串，我如何得知那么是没有答案，还是有答案但是没有更新呢？</code></p><p>看下方的踩坑记录即可</p><p><code>4.更新答案的条件该如何写呢？</code></p><p>用左右两个端点res_l,res_r记录最后的答案，如果[l,r]区间长度小于[res_l,res_r]我们就去更新res_l和res_r</p><h3 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h3><h4 id="1-超出内存限制"><a href="#1-超出内存限制" class="headerlink" title="1.超出内存限制"></a>1.超出内存限制</h4><p>我一开始是用res存储最后的答案，然后在循环过程中去更新答案。但是如果s很大，每次循环中的res也会很大，导致内存超出了限制</p><p>只需要保存答案子串的左右端点即可，然后返回时使用</p><h4 id="2-我的res一开始是空串，如果最后还是空串，那么可能是没有答案，也有可能是答案但是没有更新"><a href="#2-我的res一开始是空串，如果最后还是空串，那么可能是没有答案，也有可能是答案但是没有更新" class="headerlink" title="2.我的res一开始是空串，如果最后还是空串，那么可能是没有答案，也有可能是答案但是没有更新"></a>2.我的res一开始是空串，如果最后还是空串，那么可能是没有答案，也有可能是答案但是没有更新</h4><p>下面是笔者遇到的有答案但是没有更新的例子</p><p>前面说到，我是用res存储答案，后面改为了用res_l,res_r存储左右端点，一开始我的初始化是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res_l=0,res_r=s.size()-1;</span><br></pre></td></tr></table></figure><p>可是这样就出现了一个问题，当</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=&quot;a&quot;,t=&quot;a&quot;</span><br></pre></td></tr></table></figure><p>的时候，就会发现，我的[l,r]和[res_l,和res_r]竟然是一样的，而更新答案的条件是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r-l&lt;res_r-res_l</span><br></pre></td></tr></table></figure><p>那么就不会更新答案了</p><p><strong>要解决这个问题，只需要把res_l初始化为-1，然后看最后res_l是不是-1即可，是-1就没更新，返回空串，不是-1就更新了，返回[res_l,res_r]区间的子串即可</strong></p><p><code>下面是超出内存限制和没有修改前更新答案条件的代码</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_covered</span><span class="params">(vector&lt;<span class="type">int</span>&gt; s,vector&lt;<span class="type">int</span>&gt; t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="string">&#x27;A&#x27;</span>;i&lt;=<span class="string">&#x27;Z&#x27;</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(s[i]&lt;t[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="string">&#x27;a&#x27;</span>;i&lt;=<span class="string">&#x27;z&#x27;</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(s[i]&lt;t[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v_s</span><span class="params">(<span class="number">128</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v_t</span><span class="params">(<span class="number">128</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:t)</span><br><span class="line">            <span class="type">v_t</span>[c]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            v_s[s[i]]++;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">is_covered</span>(v_s,<span class="type">v_t</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(res.<span class="built_in">size</span>()==<span class="number">0</span>||res.<span class="built_in">size</span>()&gt;i-l<span class="number">+1</span>)</span><br><span class="line">                    res=<span class="built_in">string</span>(s.<span class="built_in">begin</span>()+l,s.<span class="built_in">begin</span>()+i<span class="number">+1</span>);</span><br><span class="line">                v_s[s[l]]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_covered</span><span class="params">(<span class="type">int</span> s[],<span class="type">int</span> t[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="string">&#x27;A&#x27;</span>;i&lt;=<span class="string">&#x27;Z&#x27;</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(s[i]&lt;t[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="string">&#x27;a&#x27;</span>;i&lt;=<span class="string">&#x27;z&#x27;</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(s[i]&lt;t[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> res_l=<span class="number">-1</span>,res_r=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> v_s[<span class="number">128</span>]&#123;&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="type">v_t</span>[<span class="number">128</span>]&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:t)</span><br><span class="line">            <span class="type">v_t</span>[c]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            v_s[s[i]]++;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">is_covered</span>(v_s,<span class="type">v_t</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i-l&lt;res_r-res_l<span class="number">+1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res_r=i;</span><br><span class="line">                    res_l=l;</span><br><span class="line">                &#125;</span><br><span class="line">                v_s[s[l]]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res_l==<span class="number">-1</span>?<span class="string">&quot;&quot;</span>:s.<span class="built_in">substr</span>(res_l,res_r-res_l<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day63 | 灵神 | 滑动窗口：将x减到0的最小操作数</title>
      <link href="/2025/03/15/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day63%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A%E5%B0%86x%E5%87%8F%E5%88%B00%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0/"/>
      <url>/2025/03/15/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day63%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A%E5%B0%86x%E5%87%8F%E5%88%B00%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Day63-灵神-滑动窗口：将x减到0的最小操作数"><a href="#Day63-灵神-滑动窗口：将x减到0的最小操作数" class="headerlink" title="Day63 | 灵神 | 滑动窗口：将x减到0的最小操作数"></a>Day63 | 灵神 | 滑动窗口：将x减到0的最小操作数</h1><h2 id="1658-将x减到0的最小操作数"><a href="#1658-将x减到0的最小操作数" class="headerlink" title="1658.将x减到0的最小操作数"></a>1658.将x减到0的最小操作数</h2><p><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/description/">1658. 将 x 减到 0 的最小操作数 - 力扣（LeetCode）</a></p><p><code>思路：</code></p><p>这道题笔者没什么思路，直接做的，答案是错误的，遗憾落泪</p><p>就去看了灵神的思路</p><p><strong>要逆向思维，把这道题转化为滑动窗口的题，先求出数组和再减去x，这个数字表示为sum，这时候我们要求的就是在数组中找一个最长子数组，使得这个子数组的和等于sum，然后再用数组长度减去最长子数组长度就是我们要的最小操作数了</strong></p><p>说实话我想不出来</p><p>既然知道了这个思路</p><p>还是继续前几天的核心思路，固定右端点，遍历右端点，然后寻找左指针收缩条件</p><p>这道题左指针收缩条件得根据我们转换后的思维来写，不能通过原来的题目得出这个收缩条件</p><p>根据我们的思路，左指针收缩条件那就是当前子数组的和大于sum这个数，我们就收缩左指针，从而减小子数组的和，来和sum进行比较</p><p>如果正好等于sum才是满足条件的情况，才会去更新最后的结果</p><p>子数组的长度还是(r-l+1)</p><p>下面看完整代码</p><p><code>完整代码:</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">-1</span>,l=<span class="number">0</span>,temp=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//得到我们的最长子数组的和要相等的数字</span></span><br><span class="line">        <span class="type">int</span> sum=<span class="built_in">reduce</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>())-x;</span><br><span class="line">        <span class="comment">//如果一开始sum就小于0，说明整个数组都减了也不能达到x</span></span><br><span class="line">        <span class="keyword">if</span> (sum&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">//记录子数组的和</span></span><br><span class="line">            temp+=nums[i];</span><br><span class="line">            <span class="comment">//左指针收缩</span></span><br><span class="line">            <span class="keyword">while</span>(temp&gt;sum)</span><br><span class="line">            &#123;</span><br><span class="line">                temp-=nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//满足条件的情况，更新答案</span></span><br><span class="line">            <span class="keyword">if</span>(temp==sum)</span><br><span class="line">                res=<span class="built_in">max</span>(res,i-l<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">if</span>(res==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> nums.<span class="built_in">size</span>()-res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day62 | 灵神 | 滑动窗口：统计得分小于K的子数组数目</title>
      <link href="/2025/03/14/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day62%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%BE%97%E5%88%86%E5%B0%8F%E4%BA%8EK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/"/>
      <url>/2025/03/14/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day62%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%BE%97%E5%88%86%E5%B0%8F%E4%BA%8EK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Day62-灵神-滑动窗口：统计得分小于K的子数组数目"><a href="#Day62-灵神-滑动窗口：统计得分小于K的子数组数目" class="headerlink" title="Day62 | 灵神 | 滑动窗口：统计得分小于K的子数组数目"></a>Day62 | 灵神 | 滑动窗口：统计得分小于K的子数组数目</h1><h2 id="2302-统计得分小于K的子数组数目"><a href="#2302-统计得分小于K的子数组数目" class="headerlink" title="2302.统计得分小于K的子数组数目"></a>2302.统计得分小于K的子数组数目</h2><p><a href="https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/description/">2302. 统计得分小于 K 的子数组数目 - 力扣（LeetCode）</a></p><p>这道题目虽然是hard，但是通过前几天的做题，我个人觉得这道题反而比<a href="https://leetcode.cn/problems/count-subarrays-where-max-element-appears-at-least-k-times/description/">2962. 统计最大元素出现至少 K 次的子数组 - 力扣（LeetCode）</a>，因为这道题的统计子数组的方式比2962这道题好想很多</p><p><code>思路：</code></p><p>还是那个核心思路，固定右端点，遍历右端点，找左指针收缩的条件，这道题的收缩条件很简单，就是左右指针区间[l,r]内的数的和再乘以数量得到的数大于等于k就行。</p><p>所以思路比较简单。</p><p>另外统计子数组方式就是(r-l+1)，即区间长度</p><p><strong>举例：</strong></p><p>[2,1,4,3]如果这四个数满足条件的话，那么[1,4,3]，[4,3]，[3]那必然符合，那所有的子数组数量就是(r-l+1)&#x3D;4咯</p><p><strong>下面是笔者的代码，这个代码会有一个测试用例超时，咱们来看看有什么地方可以进行优化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> nums_sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;=i;j++)</span><br><span class="line">                sum+=nums[j];</span><br><span class="line">            nums_sum=sum*(i-l<span class="number">+1</span>);</span><br><span class="line">            <span class="keyword">while</span>(nums_sum&gt;=k)</span><br><span class="line">            &#123;</span><br><span class="line">                nums_sum/=(i-l<span class="number">+1</span>);</span><br><span class="line">                nums_sum-=nums[l];</span><br><span class="line">                l++;</span><br><span class="line">                nums_sum*=(i-l<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res+=(i-l<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>1.while循环中每次都要乘除乘除，有很多的重复计算</p><p>改为用sum记录[l,r]区间的和，while条件改为乘法的表达式，这样左指针移动后只需要进行sum的加减就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(sum*(i-l<span class="number">+1</span>)&gt;=k)</span><br><span class="line">&#123;</span><br><span class="line">sum-=nums[l];</span><br><span class="line">l++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.每次都用for循环计算[l,r]区间的和，这个没啥必要，因为左指针往右收缩的时候就已经对sum进行了修改，我们只需要加上右端点，就能得到区间的和，而不是每次都要计算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;=i;j++)</span><br><span class="line">sum+=nums[j];</span><br><span class="line">改为</span><br><span class="line">sum+=nums[i];</span><br></pre></td></tr></table></figure><p><code>完整代码：</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算[l,r]的和</span></span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="comment">//左指针收缩使得子数组满足题目条件</span></span><br><span class="line">            <span class="keyword">while</span>(sum*(i-l<span class="number">+1</span>)&gt;=k)</span><br><span class="line">            &#123;</span><br><span class="line">                sum-=nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新答案</span></span><br><span class="line">            res+=(i-l<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day61 | 灵神 | 滑动窗口：统计最大元素出现至少K次的子数组</title>
      <link href="/2025/03/13/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day61%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A%E7%BB%9F%E8%AE%A1%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E8%87%B3%E5%B0%91K%E6%AC%A1%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2025/03/13/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day61%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A%E7%BB%9F%E8%AE%A1%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E8%87%B3%E5%B0%91K%E6%AC%A1%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Day61-灵神-滑动窗口：统计最大元素出现至少K次的子数组"><a href="#Day61-灵神-滑动窗口：统计最大元素出现至少K次的子数组" class="headerlink" title="Day61 | 灵神 | 滑动窗口：统计最大元素出现至少K次的子数组"></a>Day61 | 灵神 | 滑动窗口：统计最大元素出现至少K次的子数组</h1><h2 id="2962-统计最大元素出现至少K次的子数组"><a href="#2962-统计最大元素出现至少K次的子数组" class="headerlink" title="2962.统计最大元素出现至少K次的子数组"></a>2962.统计最大元素出现至少K次的子数组</h2><p><a href="https://leetcode.cn/problems/count-subarrays-where-max-element-appears-at-least-k-times/description/">2962. 统计最大元素出现至少 K 次的子数组 - 力扣（LeetCode）</a></p><p><code>思路：</code></p><p>一开始我并没有想出来，这是笔者的代码，很遗憾超时了，因为这个和暴力的思路差不多</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> l=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max_num = ranges::<span class="built_in">max</span>(nums),max_cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(max_num==nums[i])</span><br><span class="line">                max_cnt++;</span><br><span class="line">            <span class="type">int</span> temp=max_cnt;</span><br><span class="line">            <span class="keyword">while</span>(max_cnt&gt;=k)</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">if</span>(nums[l]==max_num)</span><br><span class="line">                    max_cnt--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            l=<span class="number">0</span>;</span><br><span class="line">            max_cnt=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>核心思路还是和前面滑动窗口的题一样，都是固定并遍历右端点，然后去寻找左指针收缩的条件。</p><p>本题左指针收缩的条件就是当前左右端点区间内的最大值的数量max_cnt大于等于k时，左指针收缩，收缩到当前左右端点区间内的最大值数量max_cnt小于k的时候就可以停止了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    long long countSubarrays(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        long long l=0,res=0;</span><br><span class="line">        int max_num = ranges::max(nums),max_cnt=0;</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(max_num==nums[i])</span><br><span class="line">                max_cnt++;</span><br><span class="line">            int temp=max_cnt;</span><br><span class="line">            while(max_cnt&gt;=k)</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                if(nums[l]==max_num)</span><br><span class="line">                    max_cnt--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一开始并没有下面这两行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l=<span class="number">0</span>;</span><br><span class="line">max_cnt=temp;</span><br></pre></td></tr></table></figure><p>后来加上是因为我发现了我的代码的漏洞</p><p>比如区间为[1,3,2,3]时，我固定了第二个3，当左指针收缩到第一个3的时候会把max_cnt–，这就导致当区间为[1,3,2,3,3]时，我的max_cnt&#x3D;2，而不是3。</p><p>所以我加上了上面这两行，让右边固定的时候左边从头开始计算。可是这样就和暴力解法的时间复杂度差不多了</p><p><strong>问题的核心在于如何统计子数组的数量</strong></p><p>如果在max_cnt–之后，仍然不影响统计满足条件的子数组的数量呢？</p><p>答案是在循环退出后直接 res+&#x3D;l</p><p>举两个例子</p><p>当右端点固定为第二个3，区间为[1,3,2,3]，这时左指针往左移动，移动到l&#x3D;2，即区间为[2,3]时，max_cnt变为1，退出了循环，而满足条件的子数组为[1,3,2,3],[3,2,3]，而l正好就是2，因为我们左指针移动过的路径就是所有满足条件的子数组。</p><p>再举一个例子：</p><p>右端点固定为第3个3，区间为[1,3,2,3,3]，这是我们的l从2开始，真实区间其实是[2,3,3]，这其实没有关系，因为l的2在这里其实代表的是[1,3,2,3,3]和[3,2,3,3]这两个子数组。然后移动到最后一个数[3]，此时l&#x3D;4，这四个子数组就是[1,3,2,3,3]、[3,2,3,3]、[2,3,3]、[3,3]，没错，就是左指针走过的路径长度，即l的大小，所以直接res+&#x3D;l就记录了子数组的个数.</p><p><code>完整代码：</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> l=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max_num = ranges::<span class="built_in">max</span>(nums),max_cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==max_num)</span><br><span class="line">                max_cnt++;</span><br><span class="line">            <span class="keyword">while</span>(max_cnt==k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[l]==max_num)</span><br><span class="line">                    max_cnt--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            res+=l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day60 | 灵神 | 滑动窗口：最大连续1的个数III</title>
      <link href="/2025/03/12/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day60%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0III/"/>
      <url>/2025/03/12/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day60%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0III/</url>
      
        <content type="html"><![CDATA[<h1 id="Day60-灵神-滑动窗口：最大连续1的个数III"><a href="#Day60-灵神-滑动窗口：最大连续1的个数III" class="headerlink" title="Day60 | 灵神 | 滑动窗口：最大连续1的个数III"></a>Day60 | 灵神 | 滑动窗口：最大连续1的个数III</h1><h2 id="1004-最大连续1的个数III"><a href="#1004-最大连续1的个数III" class="headerlink" title="1004.最大连续1的个数III"></a>1004.最大连续1的个数III</h2><p><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/description/">1004. 最大连续1的个数 III - 力扣（LeetCode）</a></p><p><code>思路：</code></p><p>和前两天核心思路一样，还是固定右端点，遍历右端点，然后去找左指针往右收缩的条件。</p><p>而这个条件一般和题目条件相关。</p><p>在本题中就是要找最多翻转k个0后，数组中连续1的个数，换句话说，我们左右区间[l,r]内最多只能包含k个0，超过了就无法翻转，无法翻转就无法保证全是连续的1,。我们只需要记录碰到0的次数，只要碰到0，那么记录0的变量num_zero就++，只要碰到0的次数超过了k，那说明我们现在翻转不了这么多的0，所以我们这时候就可以移动左指针，直到我们的左右区间[l,r]内0的数量小于等于k停止。</p><p><code>完整代码：</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestOnes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> nums_zero=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//记录0的数量</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums_zero++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左指针收缩条件</span></span><br><span class="line">            <span class="keyword">while</span>(nums_zero&gt;k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[l]==<span class="number">0</span>)</span><br><span class="line">                    nums_zero--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//记录答案</span></span><br><span class="line">            res=<span class="built_in">max</span>(res,i-l<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day59 | 灵神 | 滑动窗口：最多K个重复元素的最长子数组&amp;&amp;找到最长的半重复子字符串</title>
      <link href="/2025/03/11/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day59%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A%E6%9C%80%E5%A4%9AK%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84&amp;&amp;%E6%89%BE%E5%88%B0%E6%9C%80%E9%95%BF%E7%9A%84%E5%8D%8A%E9%87%8D%E5%A4%8D%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2025/03/11/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day59%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A%E6%9C%80%E5%A4%9AK%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84&amp;&amp;%E6%89%BE%E5%88%B0%E6%9C%80%E9%95%BF%E7%9A%84%E5%8D%8A%E9%87%8D%E5%A4%8D%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="Day59-灵神-滑动窗口：最多K个重复元素的最长子数组-找到最长的半重复子字符串"><a href="#Day59-灵神-滑动窗口：最多K个重复元素的最长子数组-找到最长的半重复子字符串" class="headerlink" title="Day59 | 灵神 | 滑动窗口：最多K个重复元素的最长子数组&amp;&amp;找到最长的半重复子字符串"></a>Day59 | 灵神 | 滑动窗口：最多K个重复元素的最长子数组&amp;&amp;找到最长的半重复子字符串</h1><p>##2958.最多K个重复元素的最长子数组</p><p><a href="https://leetcode.cn/problems/length-of-longest-subarray-with-at-most-k-frequency/description/">2958. 最多 K 个重复元素的最长子数组 - 力扣（LeetCode）</a></p><p><code>思路：</code></p><p>和<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">3. 无重复字符的最长子串 - 力扣（LeetCode）</a>可以说是一模一样，可以查看我昨天的题解</p><p>无重复最长子串是这道题K等于2的情况而已</p><p>即左指针移动的条件是把右端点包含在好数组内时，右端点nums[i]代表的数字个数超过了k。那我们就移动左指针，直到固定右端点时整个子数组都满足数字个数小于等于k的条件。</p><p><code>完整代码：</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubarrayLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p[nums[i]]++;</span><br><span class="line">            <span class="keyword">while</span>(p[nums[i]]&gt;k)</span><br><span class="line">            &#123;</span><br><span class="line">                p[nums[l]]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            res=<span class="built_in">max</span>(res,i-l<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2730-找到最长的半重复子字符串"><a href="#2730-找到最长的半重复子字符串" class="headerlink" title="2730.找到最长的半重复子字符串"></a>2730.找到最长的半重复子字符串</h2><p><a href="https://leetcode.cn/problems/find-the-longest-semi-repetitive-substring/description/">2730. 找到最长的半重复子字符串 - 力扣（LeetCode）</a></p><p><code>思路：</code></p><p>还是和前面的思路相同，固定遍历右端点，然后根据具体条件收缩左指针。</p><p>本题左指针往后移动的条件是 在左右指针之间有一对以上的相邻字符相等。</p><p>那我们就自然而然想到拿一个变量来记录相邻字符相等的数量，如果大于1，说明满足了条件，我们应该向后移动左指针，直到左指针满足条件了为止，而怎么判断左指针满足条件该停止移动了又是新的难点。</p><p>我们先往右移动1个字符，这样就可以比较l和l-1所指的字符，如果不相等，那说明我们没有找到第一对相等的相邻字符，我们就继续往后移动，只有l和l-1相等的时候，我们才达到了左指针停止移动的条件，就是左右指针之间已经没有1对以上的相邻相等字符了。（当前第一对相等的相邻字符是l和l-1，而我们的窗口是l到r，[l,r]，不包括l-1，自然也就排除了第一对相等的相邻字符）</p><p><code>完整代码：</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSemiRepetitiveSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//记录相邻字符相等的对数</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;s[i]==s[i<span class="number">-1</span>])</span><br><span class="line">                flag++;</span><br><span class="line">            <span class="comment">//对数大于1</span></span><br><span class="line">            <span class="keyword">if</span>(flag&gt;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               l++;</span><br><span class="line">               <span class="comment">//左指针移动停止的条件 就是找到第一对相等的相邻字符</span></span><br><span class="line">               <span class="keyword">while</span>(s[l]!=s[l<span class="number">-1</span>]) </span><br><span class="line">                    l++;</span><br><span class="line">                <span class="comment">//更新flag</span></span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res=<span class="built_in">max</span>(res,i-l<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day58 | 灵神 | 滑动窗口：长度最小的子数组&amp;&amp;乘积小于K的子数组&amp;&amp;无重复字符的最长子串</title>
      <link href="/2025/03/10/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day58%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84&amp;&amp;%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8EK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84&amp;&amp;%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2025/03/10/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day58%20%20%E7%81%B5%E7%A5%9E%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84&amp;&amp;%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8EK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84&amp;&amp;%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="Day58-灵神-滑动窗口：长度最小的子数组-乘积小于K的子数组-无重复字符的最长子串"><a href="#Day58-灵神-滑动窗口：长度最小的子数组-乘积小于K的子数组-无重复字符的最长子串" class="headerlink" title="Day58 | 灵神 | 滑动窗口：长度最小的子数组&amp;&amp;乘积小于K的子数组&amp;&amp;无重复字符的最长子串"></a>Day58 | 灵神 | 滑动窗口：长度最小的子数组&amp;&amp;乘积小于K的子数组&amp;&amp;无重复字符的最长子串</h1><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组 - 力扣（LeetCode）</a></p><p><code>思路：</code></p><p>思考的关键点：固定右指针，移动左指针，而我们要做的就是找到左指针移动的条件，即在什么情况下移动左指针，而这个条件一般都在题目中。</p><p>在本题中，我们固定右端点</p><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20250310182605966.png" alt="image-20250310182605966"></p><p>以固定4，我们目前左指针l&#x3D;0，指向的是2，右指针为4，指向4</p><p>我们发现这个子数组的和是大于target7的，满足了子数组和大于target的条件，子数组大小是5，那这个时候我们就可以通过移动左指针来缩小子数组的大小。我们移动左指针，l++，发现和是10，仍旧大于target，那说明我们可以继续往左移动指针来缩小子数组的大小，一直到l&#x3D;2，指向1时，我们找到了子数组和仍大于等于7的最小的子数组，因为再减一位就不大于7了，就不满足条件了，所以我们更新答案，就是右指针减去左指针再加1就是这个子数组的长度，即4-2+1&#x3D;3。到这里我们就找到了以4为右端点的满足条件的最小的子数组的长度为3。</p><p>那么只要从头遍历右端点，每个端点都重复这个过程，在这之间记录最小值，那么就会找到我们想要的答案。</p><p><code>完整代码：</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=INT_MAX;<span class="comment">//最后结果</span></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;<span class="comment">//记录数组和</span></span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;<span class="comment">//左指针</span></span><br><span class="line">        <span class="comment">//i是右指针，右端点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="comment">//满足条件 子数组和大于target</span></span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp=i-l<span class="number">+1</span>;</span><br><span class="line">                <span class="comment">//更新答案</span></span><br><span class="line">                res=<span class="built_in">min</span>(res,temp);</span><br><span class="line">                sum-=nums[l];</span><br><span class="line">                <span class="comment">//更新左指针</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//res还是初始值，说明整个数组加起来都不到target，返回0即可</span></span><br><span class="line">        <span class="keyword">if</span>(res==INT_MAX)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="713-乘积小于K的子数组"><a href="#713-乘积小于K的子数组" class="headerlink" title="713.乘积小于K的子数组"></a>713.乘积小于K的子数组</h2><p><a href="https://leetcode.cn/problems/subarray-product-less-than-k/">713. 乘积小于 K 的子数组 - 力扣（LeetCode）</a></p><p><code>思路：</code></p><p>和上一题思路一样，只是这道题更新答案变为在while循环外。因为上一题在while循环内是，是满足子数组和大于target这一条件的，所以在while内更新答案。而本题sum&lt;k即在while外才是满足条件的情况，所以在while循环外更新答案。</p><p>本题的关键点，也就是左指针移动条件是子数组乘积大于K时进行移动。</p><p><strong>另一个关键点是子数组的数量如何计算。</strong></p><p>假设当前满足条件的子数组为[5,2,6]，那么以6为右端点(即必须包括6)有几个满足条件的数组？</p><p>[5,2,6],[2,6],[6]这三个。而我们不需要管[5],[5,2]这类的子数组，因为这类的数组在以5或者2为右端点时已经计算过一次了。</p><p>推广一下，[l,r]这个区间的子数组乘积小于k，那么[l+1,r],…..[r,r]都是小于k的，那么数量就是</p><p>r-l+1个子数组满足条件</p><p><code>完整代码：</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum*=nums[i];</span><br><span class="line">            <span class="comment">//更新l使得子数组满足条件</span></span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//res+=(i-l+1);</span></span><br><span class="line">                sum/=nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//结果更新是在满足题目条件时进行更新，上一道题在while内更新是因为在while内是满足条件的时候</span></span><br><span class="line">            <span class="comment">//这道题是while外才是符合条件的时候，所以在while外更新结果</span></span><br><span class="line">            res+=(i-l<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h2><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p><p><code>思路：</code></p><p>和上面两道题思路相同，固定右端点，遍历右端点。只要碰到重复的字符，那么左指针就一直往右移动，直到没有重复的字符为止。</p><p>记录字符的方式：哈希表，key为字符，value为字数个数，只要不为1就说明有重复，那就左指针一直往右移动，直到没有重复的字符。</p><p>在遍历过程中记录子串的长度，碰到长度更大的子串就更新结果。</p><p><code>完整代码：</code></p><p>注释部分是笔者原来的错误，没有找到正确的记录字符的方式。仅作为一个记录，不必在意</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; p;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*if(p.find(s[i])==p.end())</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                p.insert(&#123;s[i],i&#125;);</span></span><br><span class="line"><span class="comment">                res=max(res,i-l);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                res=max(res,i-l);</span></span><br><span class="line"><span class="comment">                int temp=p[s[i]]+1;</span></span><br><span class="line"><span class="comment">                for(int j=l;j&lt;=p[s[i]];j++)</span></span><br><span class="line"><span class="comment">                    p.erase(s[j]);</span></span><br><span class="line"><span class="comment">                l=temp;</span></span><br><span class="line"><span class="comment">                p.insert(&#123;s[i],i&#125;);</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//记录字符</span></span><br><span class="line">            p[s[i]]++;</span><br><span class="line">            <span class="comment">//移动左指针</span></span><br><span class="line">            <span class="keyword">while</span>(p[s[i]]!=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p[s[l]]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新答案</span></span><br><span class="line">            res=<span class="built_in">max</span>(res,i-l<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day57 | 灵神 | 相向双指针：四数之和&amp;&amp;有效三角形的个数</title>
      <link href="/2025/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day57%20%20%E7%81%B5%E7%A5%9E%20%20%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9A%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C&amp;&amp;%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2025/02/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day57%20%20%E7%81%B5%E7%A5%9E%20%20%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9A%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C&amp;&amp;%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Day57-灵神-相向双指针：四数之和-有效三角形的个数"><a href="#Day57-灵神-相向双指针：四数之和-有效三角形的个数" class="headerlink" title="Day57 | 灵神 | 相向双指针：四数之和&amp;&amp;有效三角形的个数"></a>Day57 | 灵神 | 相向双指针：四数之和&amp;&amp;有效三角形的个数</h1><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h2><p><a href="https://leetcode.cn/problems/4sum/description/">18. 四数之和 - 力扣（LeetCode）</a></p><p><code>思路：</code></p><p>在三数之和的基础上再套了一层循环</p><p>i在最外层，然后对i去重</p><p>j，l，r就是三数之和的代码</p><p><strong>区别在于：</strong></p><p>1.对于第二个数字num[j]的去重：因为j是从i+1开始的，而j对j的去重只能是在j自己的遍历过程中，即，当j大于i+1时，这说明j-1&gt;i，说明此时去重不会让j&#x3D;&#x3D;i的情况给去掉了</p><p>2.如果数组大小小于4那就没必要列举了</p><p>3.leetcode增大了数值，要使用long long防止溢出</p><p>主要是防止四个数字相加时的溢出，所以四个数字相加时至少得有一个是long long类型</p><p><code>完整代码：</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-3</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> a=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(i&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])   <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j&gt;i<span class="number">+1</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">// 跳过重复数字</span></span><br><span class="line">                <span class="type">int</span> l=j<span class="number">+1</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> x=a+nums[j]+nums[l]+nums[r];</span><br><span class="line">                    <span class="keyword">if</span>(x&gt;target)</span><br><span class="line">                        r--;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;target)</span><br><span class="line">                        l++;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(&#123;nums[i],nums[j],nums[l],nums[r]&#125;);</span><br><span class="line">                        <span class="keyword">for</span>(l++;l&lt;r&amp;&amp;nums[l]==nums[l<span class="number">-1</span>];l++);</span><br><span class="line">                        <span class="keyword">for</span>(r--;l&lt;r&amp;&amp;nums[r]==nums[r<span class="number">+1</span>];r--);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="611-有效三角形的个数"><a href="#611-有效三角形的个数" class="headerlink" title="611.有效三角形的个数"></a>611.有效三角形的个数</h2><p><a href="https://leetcode.cn/problems/valid-triangle-number/description/">611. 有效三角形的个数 - 力扣（LeetCode）</a></p><p><code>思路：</code></p><p>还是和两数之和三数之和一样的思路，只是判定条件不同，本题是利用两数之和大于第三边的性质来做。</p><p>三角形三边 a，b，c   a&lt;b&lt;c</p><p>把最大的一边（c）当做固定边，通过  比较a+b和c的大小来确定指针的移动</p><p>i是c的下标，a的下标是l，b的下标是r</p><p>从末尾往前遍历i，相当于从大到小遍历i</p><p>每次都在[0,i-1]范围内遍历l和r，即对l和r进行加减操作</p><p>只要 a + b &gt; c 说明找到了一个合法方案，res++，并且大的指针减小（r–）继续查找合法方案</p><p>否则的话，说明a + b &lt; c 那说明 a太小了，那就 l++</p><h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><p>不可以有思维惯性，两数之和和三数之和都是固定最小的i，从前往后遍历</p><p>但是本题固定最小边却行不通</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">triangleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=i<span class="number">+1</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[l]&gt;nums[r])</span><br><span class="line">                &#123;</span><br><span class="line">                    res+=(r-l);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[l]==nums[r])</span><br><span class="line">                    l++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原因在于，当我们固定最小边a的时候，我们会遇到 a + b &#x3D;&#x3D; c的情况</p><p>但是这种情况下我们a是固定的，那这种情况下指针一定有可能是b太小了，那就是往大的移动，那就是l++，但是也有可能是c太大了，那就是r–</p><p>但是我们在else if(nums[i]+nums[l]&#x3D;&#x3D;nums[r])这个条件判定中不可以即写l++又写r–，因为这样的话肯定会漏掉一些合理的答案</p><p>但是我们也不能只写l++和r–其中的一个，因为不管写哪个都会漏掉另外一种的情况，这样还是得不到正确答案</p><p>而正确做法的固定最大边c就不同了，a + b &gt; c的时候就说明是b大了移动b就行</p><p>a + b &lt;&#x3D; c的时候就说明是a小了，移动a就行</p><p><strong>关键就是：指针的移动不能出现二义性，不能往这边移动也行往那边移动也行，这样的话一定会漏掉另外一种情况</strong></p><p><code>完整代码：</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">triangleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">2</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>,r=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[r]+nums[l]&gt;nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    res+=(r-l);</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 相向双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day56 | 灵神 | 相向双指针：四数之和&amp;&amp;有效三角形的个数</title>
      <link href="/2025/02/20/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day56%20%20%E7%81%B5%E7%A5%9E%20%20%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2025/02/20/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day56%20%20%E7%81%B5%E7%A5%9E%20%20%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Day56-灵神-相向双指针：统计和小于目标的下标对数目-最接近的三数之和"><a href="#Day56-灵神-相向双指针：统计和小于目标的下标对数目-最接近的三数之和" class="headerlink" title="Day56| 灵神 | 相向双指针：统计和小于目标的下标对数目&amp;&amp;最接近的三数之和"></a>Day56| 灵神 | 相向双指针：统计和小于目标的下标对数目&amp;&amp;最接近的三数之和</h1><h2 id="2824-统计和小于目标的下标对数目"><a href="#2824-统计和小于目标的下标对数目" class="headerlink" title="2824.统计和小于目标的下标对数目"></a>2824.统计和小于目标的下标对数目</h2><p><a href="https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/description/">2824. 统计和小于目标的下标对数目 - 力扣（LeetCode）</a></p><p><code>思路：</code></p><p>和两数之和思路一样</p><p>大了就r–</p><p>小了就收集答案</p><p><code>完整代码：</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l]+nums[r]&gt;=target)</span><br><span class="line">                r--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res+=(r-l);</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>记录一下自己写的，上面的版本是灵神的答案，把我的优化了，其实就是没想到l在取过答案以后，r就不可能从最后开始了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=i,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[l]+nums[r]&gt;=target)</span><br><span class="line">                    r--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res+=(r-l);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16.最接近的三数之和"></a>16.最接近的三数之和</h2><p><a href="https://leetcode.cn/problems/3sum-closest/description/">16. 最接近的三数之和 - 力扣（LeetCode）</a></p><p><code>思路：</code></p><p>和三数之和思路类似，甚至不需要去重，所以更加简单。</p><p>只需要增加一个变量x来记录三个数的和与target之间的最小差值就是了</p><p>只要target和三数之和的差值小于x，那就更新x和最后返回的答案</p><p><code>完整代码：</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minTemp=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=i<span class="number">+1</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> cur=nums[i]+nums[r]+nums[l];</span><br><span class="line">                <span class="keyword">if</span>(cur&gt;target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur-target&lt;minTemp)</span><br><span class="line">                    &#123;</span><br><span class="line">                        minTemp=cur-target;</span><br><span class="line">                        res=cur;</span><br><span class="line">                    &#125;</span><br><span class="line">                    r--;    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(cur&lt;target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(target-cur&lt;minTemp)</span><br><span class="line">                    &#123;</span><br><span class="line">                        minTemp=target-cur;</span><br><span class="line">                        res=cur;</span><br><span class="line">                    &#125;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 相向双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day55 | 灵神 | 相向双指针：盛最多水的容器&amp;&amp;接雨水</title>
      <link href="/2024/12/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day55%20%20%E7%81%B5%E7%A5%9E%20%20%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9A%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8&amp;&amp;%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <url>/2024/12/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day55%20%20%E7%81%B5%E7%A5%9E%20%20%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9A%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8&amp;&amp;%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="Day55-灵神-相向双指针：盛最多水的容器-接雨水"><a href="#Day55-灵神-相向双指针：盛最多水的容器-接雨水" class="headerlink" title="Day55 | 灵神 | 相向双指针：盛最多水的容器&amp;&amp;接雨水"></a>Day55 | 灵神 | 相向双指针：盛最多水的容器&amp;&amp;接雨水</h1><p><a href="https://www.bilibili.com/video/BV1Qg411q7ia?spm_id_from=333.788.videopod.sections&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">盛最多水的容器 接雨水_哔哩哔哩_bilibili</a></p><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h2><p><a href="https://leetcode.cn/problems/container-with-most-water/description/">11. 盛最多水的容器 - 力扣（LeetCode）</a></p><p>这道题就不太能想到思路了（悲）</p><p><strong>思路：</strong></p><p>还是使用相向双指针</p><p>我们随便挑两根柱子，就比如图中的两根，左边的下标为l，右边的下标为r，那么能接的水就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum=min(height[l],height[r])*(r-l)</span><br></pre></td></tr></table></figure><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241221195333819.png" alt="image-20241221195333819"></p><p>首先先找出短的一端，然后固定它，（为什么找短端而不找长端？这个稍后解释）这个例子中r比较短，那么就固定r。此时接水总量为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum1=height[r]*(r-l)</span><br></pre></td></tr></table></figure><p><strong>分类讨论:</strong></p><p>1.假设在l和r中间，找到一根比height[r]要小的柱子k来当左端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum2=height[k]*(r-k)</span><br></pre></td></tr></table></figure><p>由于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">height[r]&gt;height[k]</span><br><span class="line">r-l&gt;r-k  (因为k在l和r中间)</span><br></pre></td></tr></table></figure><p>所以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum1&gt;sum2</span><br></pre></td></tr></table></figure><p>就是说，高变小了，宽也变小了，那肯定比原来小了</p><p>2.假设在l和r中间，找到一根比height[r]要大的柱子i来当左端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum3=height[r]*(r-i)</span><br></pre></td></tr></table></figure><p>由于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r-i&gt;r-l (因为i在l和r中间)</span><br></pre></td></tr></table></figure><p>所以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum1&gt;sum3</span><br></pre></td></tr></table></figure><p>这种是高没变，宽变小了，也肯定比原来小了</p><p>3.假设在l和r中间，找到一根和height[r]一样大的柱子j来当左端</p><p>那不用说了，高没变宽变小了，自然是不如l和r的大</p><p><strong>综上所述，我们发现，图中l和r中间的柱子无论怎么取，都不如l和r的大。</strong></p><p>可我们还要继续往遍历去找更大的值，去尝试得到更多的水，那该怎么继续遍历呢？</p><p><strong>答案是移动短端，相当于去掉短的一端，看l和r-1这两根柱子。</strong></p><p>因为我们发现了，只要固定住短端，长端只要在（l,r）中间取值，那都不可能比l和r大，所以这时候就只能移动短端了，就相当于把r给去掉了，去比较l和r-1，看看在这个区间里面有没有比在(l,r)的最大值更大的。</p><p>那结论就出来了，我们每次更新完最大值以后，就把短端给去掉即可。</p><p><strong>完整代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新最大值</span></span><br><span class="line">            <span class="type">int</span> tmp=<span class="built_in">min</span>(height[l],height[r])*(r-l);</span><br><span class="line">            res=<span class="built_in">max</span>(res,tmp);</span><br><span class="line">            <span class="comment">//去掉短端</span></span><br><span class="line">            <span class="keyword">if</span>(height[l]&lt;height[r])</span><br><span class="line">                l++;</span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看到这里你应该明白为什么找短端而不找长端，我们固定的是短端，这是因为算高度的时候看的是短端而不是长端，固定短端可以减少一个变量。</p><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42.接雨水"></a>42.接雨水</h2><p><a href="https://leetcode.cn/problems/trapping-rain-water/description/">42. 接雨水 - 力扣（LeetCode）</a></p><p>理解不了的话记个单调栈的做法也行。</p><p><strong>思路：前后缀分解</strong></p><p>笔者说个大概，如果看不懂的话可以去看灵神的视频。</p><p>怎么算：我们分别算出每一个柱子能接多少水，然后都加起来就是全部的</p><p>前缀就是包含当前柱子在内，当前柱子的前面最高的柱子高度</p><p>后缀就是包含当前柱子在内，当前柱子的后面最高的柱子高度</p><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241221205529594.png" alt="image-20241221205529594"></p><p>如图，上面一行是前缀，下面一行是后缀</p><p>就拿图中的第5列（下标为4）的柱子来举例子吧</p><p>它的前缀最大是2，后缀最大是3，那么如果只看它这一根柱子的话，它能接多少水就是，前缀和后缀选个小的（大的柱子比小的柱子多的部分装不了水），再减去柱子本身的高度</p><p>对于第5列就是 min(3,2)-1&#x3D;1，所以这根柱子可以接1格水</p><p>其他柱子都这么算一遍然后把每个柱子的水加起来就是答案了</p><p><strong>完整代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> mpre=<span class="number">0</span>,mtail=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(height.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tail</span><span class="params">(height.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">//计算前缀</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;height.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mpre=<span class="built_in">max</span>(mpre,height[i]);</span><br><span class="line">            pre[i]=mpre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算后缀</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=height.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            mtail=<span class="built_in">max</span>(mtail,height[i]);</span><br><span class="line">            tail[i]=mtail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算每个柱子的水</span></span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;height.<span class="built_in">size</span>();i++)</span><br><span class="line">            res+=(<span class="built_in">min</span>(tail[i],pre[i])-height[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="优化：双指针做法"><a href="#优化：双指针做法" class="headerlink" title="优化：双指针做法"></a>优化：双指针做法</h3><p><strong>这个好难用文字讲出来，大家听灵神的视频讲解吧</strong></p><p>总体思路还是一个柱子一个柱子算，算完一个再算下一个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> r=height.size()<span class="number">-1</span>,l=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//分别保存前缀和后缀的两个值</span></span><br><span class="line">        <span class="type">int</span> mpre=height[l],mtail=height[r];</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//前缀小于后缀</span></span><br><span class="line">            <span class="comment">//那计算当前柱子能接多少水就取决于前缀了，因为比前缀多的部分就流走了</span></span><br><span class="line">            <span class="keyword">if</span>(mpre&lt;mtail)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//计算能接多少水</span></span><br><span class="line">                res+=mpre-height[l];</span><br><span class="line">                <span class="comment">//计算完当前柱子可以接多少水就去算下一个柱子</span></span><br><span class="line">                l++;</span><br><span class="line">                <span class="comment">//更新前缀的值</span></span><br><span class="line">                mpre=max(mpre,height[l]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//前缀大于后缀</span></span><br><span class="line">            <span class="comment">//那计算当前柱子能接多少水就取决于后缀了，因为比后缀多的部分就流走了</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//计算能接多少水</span></span><br><span class="line">                res+=mtail-height[r];</span><br><span class="line">                <span class="comment">//计算完当前柱子可以接多少水就去算下一个柱子</span></span><br><span class="line">                r--;</span><br><span class="line">                <span class="comment">//更新后缀的值</span></span><br><span class="line">                mtail=max(mtail,height[r]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 相向双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day54 | 灵神 | 相向双指针：两数之和II-输入有序数组&amp;&amp;三数之和</title>
      <link href="/2024/12/20/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day54%20%20%E7%81%B5%E7%A5%9E%20%20%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84&amp;&amp;%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2024/12/20/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day54%20%20%E7%81%B5%E7%A5%9E%20%20%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84&amp;&amp;%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Day54-灵神-相向双指针：两数之和II-输入有序数组-三数之和"><a href="#Day54-灵神-相向双指针：两数之和II-输入有序数组-三数之和" class="headerlink" title="Day54 | 灵神 | 相向双指针：两数之和II-输入有序数组&amp;&amp;三数之和"></a>Day54 | 灵神 | 相向双指针：两数之和II-输入有序数组&amp;&amp;三数之和</h1><p><a href="https://www.bilibili.com/video/BV1bP411c7oJ?spm_id_from=333.788.videopod.sections&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">两数之和 三数之和【基础算法精讲 01】_哔哩哔哩_bilibili</a></p><h2 id="167-两数之和II-输入有序数组"><a href="#167-两数之和II-输入有序数组" class="headerlink" title="167.两数之和II-输入有序数组"></a>167.两数之和II-输入有序数组</h2><p><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/">167. 两数之和 II - 输入有序数组 - 力扣（LeetCode）</a></p><p><strong>思路：</strong></p><p>数组给咱们的是排序好的，那自然而然定义两根指针，一个在数组头l，一个在数组尾r</p><p>这样定义的好处是</p><p>两根指针中间的数字一定比头指针要大，一定比尾指针要小</p><p>如果两指针之和大于target的话，那中间某个数加上尾指针肯定也比target要大，那说明两个数加起来大了，那就把右边大的数字减小一点</p><p>如果两指针之和小于target的话，那头指针加上中间某个数肯定也比target要小，那说明两个数加起来小了，那就把左边大的数字增大一点</p><p>如果两指针之和等于target的话，那说明我们找到了答案直接返回就行</p><p><strong>举例：</strong></p><p>24689    target&#x3D;12</p><p>一开始 2 + 9&#x3D;11小于12，那么不管是2和4,6,8哪个数字加都不可能达到12了，说明左边的选小了（同时也说明2肯定不会是答案了，就把2排除了，在4,6,8,9中选答案）</p><p>后来 4 + 9&#x3D;13,大于12，那么不管是6,8哪个和9加都不可能比12小了，说明右边选大了（同时也说明9肯定不是答案了，就把9排除了，在4,6,8中选答案）</p><p><strong>完整代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=numbers.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[l]+numbers[r]&gt;target)</span><br><span class="line">                r--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[l]+numbers[r]&lt;target)</span><br><span class="line">                l++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> &#123;l<span class="number">+1</span>,r<span class="number">+1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;l<span class="number">+1</span>,r<span class="number">+1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="一个分析时间复杂度的新角度："><a href="#一个分析时间复杂度的新角度：" class="headerlink" title="一个分析时间复杂度的新角度："></a>一个分析时间复杂度的新角度：</h3><p>为什么双指针能从暴力算法的O(n²)优化到O(n)呢？</p><p>我们可以试着量化得到的信息</p><p>暴力做法中，我们是拿着两个数字加起来和target比一比大小，我们花费了O(1)的时间，得到了O(1)的信息</p><p>而双指针做法中，我们利用单调性这个性质，只要这两个数加起来比target大，那我就知道数组中比两个数中较大的数大的那边全都不行，我们花费了O(1)的时间，却得到了O(n)的信息，所以我们可以从O(n²)优化到O(n)。</p><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和 - 力扣（LeetCode）</a></p><p><strong>思路：</strong></p><p>跟着上一题的思路走。上一次是nums[l]和nums[r]和target比大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums[l]+nums[r]=target </span><br></pre></td></tr></table></figure><p>的时候我们就找到了答案，这一题只不过是转换为了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums[l]+nums[r]-target = 0</span><br><span class="line">nums[l]+nums[r]+nums[i] = 0</span><br></pre></td></tr></table></figure><p>我们要找的就是</p><p>nums[i]在什么时候等于-target就行，在转换一下</p><p>其实就是找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums[l]+nums[r]= -nums[i]</span><br></pre></td></tr></table></figure><p>所以上一题是一个数组里面找到两个数加起来是一个固定的数target</p><p>这一题就一个数组里面找到两个数加起来是一个变化的数字nums[i]</p><p>那么只需要在上一题的代码上加一层循环，循环i就完事了</p><p><strong>注意：不要忘记了排序，因为有序的情况下我们才用的双向双指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=i+<span class="number">1</span>,r=nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[l]+nums[r]+nums[i]&gt;<span class="number">0</span>)</span><br><span class="line">                    r--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[l]+nums[r]+nums[i]&lt;<span class="number">0</span>)</span><br><span class="line">                    l++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(&#123;nums[i],nums[l],nums[r]&#125;);</span><br><span class="line">                    l++;r--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是跟着上一题的思路可以写到的地方</p><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p><code>1.对i去重</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>就是i在大于0时，如果和上一个i值一样的话那就直接跳过</p><p><code>2.对l和r进行优化</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;r&amp;&amp;nums[l]==nums[l<span class="number">-1</span>]) l++;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r&amp;&amp;nums[r]==nums[r+<span class="number">1</span>]) r--;</span><br></pre></td></tr></table></figure><p>对l和r和 对i的操作是一样的</p><p><strong>完整代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=i<span class="number">+1</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (x + nums[i + 1] + nums[i + 2] &gt; 0) break; // 优化一  前三个数字加起来都大于target了，就不用再算后面了</span></span><br><span class="line"><span class="comment">            if (x + nums[n - 2] + nums[n - 1] &lt; 0) continue; // 优化二 第一个数和最后两个数加起来都小于0了，那后面的数也没必要遍历了，直接去遍历下一个i值</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[l]+nums[r]+nums[i]&gt;<span class="number">0</span>)</span><br><span class="line">                    r--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[l]+nums[r]+nums[i]&lt;<span class="number">0</span>)</span><br><span class="line">                    l++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i],nums[l],nums[r]&#125;);</span><br><span class="line">                    l++;r--;</span><br><span class="line">                    <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[l]==nums[l<span class="number">-1</span>]) l++;</span><br><span class="line">                    <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[r]==nums[r<span class="number">+1</span>]) r--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 相向双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day53 | 单调栈：接雨水&amp;&amp;柱形图中最大的矩形</title>
      <link href="/2024/12/05/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day53%20%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20%EF%BC%9A%E5%8D%95%E8%B0%83%E6%A0%88%20%E6%8E%A5%E9%9B%A8%E6%B0%B4&amp;&amp;%E6%9F%B1%E5%BD%A2%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
      <url>/2024/12/05/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day53%20%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20%EF%BC%9A%E5%8D%95%E8%B0%83%E6%A0%88%20%E6%8E%A5%E9%9B%A8%E6%B0%B4&amp;&amp;%E6%9F%B1%E5%BD%A2%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Day53-单调栈：接雨水-柱形图中最大的矩形"><a href="#Day53-单调栈：接雨水-柱形图中最大的矩形" class="headerlink" title="Day53 | 单调栈：接雨水&amp;&amp;柱形图中最大的矩形"></a>Day53 | 单调栈：接雨水&amp;&amp;柱形图中最大的矩形</h1><p><a href="https://www.bilibili.com/video/BV1VN411J7S7?spm_id_from=333.788.videopod.sections&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">单调栈【基础算法精讲 26】_哔哩哔哩_bilibili</a></p><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42.接雨水"></a>42.接雨水</h2><p><a href="https://leetcode.cn/problems/trapping-rain-water/description/">42. 接雨水 - 力扣（LeetCode）</a></p><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241205114540833.png" alt="image-20241205114540833"></p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>还是和昨天差不多一样的思路，只是昨天找到下一个更大元素就只是记录了一下，这次我们要用这个更大元素计算一下可以接多少雨水。</p><p>单调栈依旧是单调递减的，如图中所示。</p><p><strong>我们要如何计算可以接多少雨水呢?</strong></p><p><strong>比如我们选定2,1,0,4这几个柱子</strong></p><p><strong>那就是先算1,0,4。</strong></p><p><strong>宽为4的下标减去1的下标再减1，高为1和4的最小值减去中间的0，宽*高即为答案，为1</strong></p><p><strong>再算2,1,4。</strong></p><p><strong>宽为4的下标减去2的下标再减1，高为2和4的最小值减去中间的1，宽*高即为答案，为2</strong></p><p><strong>再把两者相加就是2,1,0,4这几个柱子可以接多少雨水了</strong></p><p>单调栈的入栈出栈过程：</p><p>灵神总结为：找上一个更大元素，在找的过程中填坑，我来举个例子大家就明白了。</p><p>5，入栈</p><p>2&lt;5，入栈</p><p>1&lt;2，入栈</p><p>0&lt;1，入栈</p><p>4&gt;0，我们找到了一个更大的元素</p><p>那就是计算以0为中心的柱子1,0,4可以接多少，然后把0弹出</p><p>计算以1为中心的柱子2,1,4可以接多少，然后把1弹出</p><p>计算以2为中心的柱子5,2,4可以接多少，然后把2弹出</p><p><strong>完整代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;height.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;height[i]&gt;height[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid=st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="type">int</span> left=st.<span class="built_in">top</span>();</span><br><span class="line">                res=res+(i-left<span class="number">-1</span>)*(<span class="built_in">min</span>(height[i],height[left])-height[mid]);</span><br><span class="line">                <span class="comment">//          宽                  高</span></span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="84-柱状图中的最大矩形"><a href="#84-柱状图中的最大矩形" class="headerlink" title="84.柱状图中的最大矩形"></a>84.柱状图中的最大矩形</h2><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">84. 柱状图中最大的矩形 - 力扣（LeetCode）</a></p><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>这次的单调栈是递增的</p><p>还是和接雨水一样，只是接雨水是中间凹下去的，比如1,0,4，中间的0要小于1和4</p><p>而这道题中间是突出来的，比如下图中的1，5，6，2，<strong>并且两边的柱子不能参与合并（就和上一题1,4不能接雨水一样）</strong></p><p><strong>即1,5,6,2中只有5,6可以去合并，如果是5,6,2的话那就是只有6了</strong></p><p>如果碰到元素小于栈顶元素，我们才会去计算矩形的面积，否则不会计算</p><p><strong>栈的具体过程：</strong></p><p>那1,5,6,2举例</p><p>栈中为1,1&lt;5,5入栈</p><p>5&lt;6,6入栈</p><p>6&gt;2，开始计算矩形大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">heights[i]=2;</span><br><span class="line">heights[st.top()]=6;</span><br></pre></td></tr></table></figure><p>到这里我们发现还需要栈顶元素的下一个元素5，才能够进行计算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">st.pop();</span><br><span class="line">heights[st.pop()]=5;</span><br><span class="line">高：6</span><br><span class="line">宽：i-st.top()-1=1;</span><br><span class="line">最大矩形:6*1=6</span><br></pre></td></tr></table></figure><p>继续，此时栈内为1,5，而heights[i]还是2，heights[st.pop()]就是5;</p><p>我们还是需要栈顶元素的下一个元素1，才能够进行计算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">st.pop();</span><br><span class="line">heights[st.pop()]=1;</span><br><span class="line">高：5</span><br><span class="line">宽：i-st.top()-1=2;</span><br><span class="line">最大矩形:5*2=10</span><br></pre></td></tr></table></figure><h3 id="难理解的点：为什么要在数组前后多加高度为0的柱子"><a href="#难理解的点：为什么要在数组前后多加高度为0的柱子" class="headerlink" title="难理解的点：为什么要在数组前后多加高度为0的柱子?"></a>难理解的点：为什么要在数组前后多加高度为0的柱子?</h3><p>第一根柱子和最后一根柱子如果是最高的，并且也没有多加高度为0的柱子的话，那是不会被计算的</p><p>如果heights为100,1那最后的结果还是0，因为我们没有进行任何的计算（栈顶为100，heights[i]为1，但是我们获取不到栈顶元素的下一个元素），但实际上应该是100</p><p>如果是1,100，栈顶为1，heights[i]为100，没有末尾的0，我们不会进行任何计算，因为它本身就是单调递增的</p><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241205120328724.png" alt="image-20241205120328724"></p><p><strong>完整代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在高度数组的两端添加 0</span></span><br><span class="line">        heights.<span class="built_in">insert</span>(heights.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heights.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; heights[i] &lt; heights[s.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="comment">// 弹出栈顶，计算对应的面积</span></span><br><span class="line">                <span class="type">int</span> dh = heights[s.<span class="built_in">top</span>()];</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> dw = i - s.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dh * dw);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前元素下标压入栈</span></span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day52 | 单调栈：每日温度&amp;&amp;下一个更大的元素I&amp;&amp;下一个更大元素II</title>
      <link href="/2024/12/04/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day52%20%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20%EF%BC%9A%E5%8D%95%E8%B0%83%E6%A0%88%20%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6&amp;&amp;%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0I&amp;&amp;%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II/"/>
      <url>/2024/12/04/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Day52%20%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20%EF%BC%9A%E5%8D%95%E8%B0%83%E6%A0%88%20%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6&amp;&amp;%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0I&amp;&amp;%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II/</url>
      
        <content type="html"><![CDATA[<h1 id="Day52-单调栈：每日温度-下一个更大的元素I-下一个更大元素II"><a href="#Day52-单调栈：每日温度-下一个更大的元素I-下一个更大元素II" class="headerlink" title="Day52 | 单调栈：每日温度&amp;&amp;下一个更大的元素I&amp;&amp;下一个更大元素II"></a>Day52 | 单调栈：每日温度&amp;&amp;下一个更大的元素I&amp;&amp;下一个更大元素II</h1><p><a href="https://www.bilibili.com/video/BV1VN411J7S7?spm_id_from=333.788.videopod.sections&vd_source=7831c5b97cfc5c745eb48ff04f6515e7">单调栈【基础算法精讲 26】_哔哩哔哩_bilibili</a></p><p>及时去掉无用数据，保证栈中元素有序</p><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h2><p><a href="https://leetcode.cn/problems/daily-temperatures/description/">739. 每日温度 - 力扣（LeetCode）</a></p><p>从左往右遍历</p><p>每次碰到一个数就先和栈顶元素进行比较，如果比栈顶元素大，那说明我们找到了答案，就记录答案，然后把找到答案的元素出栈</p><p>我们这样收集下来，栈里面的元素都是单调递减的</p><p><img src="https://darling-darling.oss-cn-beijing.aliyuncs.com/image-20241202175614447.png" alt="image-20241202175614447"></p><p>举个例子，如图所示</p><p>我们从1往后遍历，栈为空，1入栈，此时栈内为1</p><p>碰到4，4大于1，那就把1出栈，然后记录答案，4入栈，栈内为4</p><p>碰到3，3小于4, 3入栈，栈内为4,3</p><p>碰到5, 5大于3,3出栈，记录答案，栈内为4</p><p>栈顶元素变成了4，继续比较，5大于4，4也找到了答案，记录答案，4弹出，5入栈</p><p>以此类推</p><p>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(temperatures.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;temperatures.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;temperatures[i]&gt;temperatures[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                res[st.<span class="built_in">top</span>()]=i-st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="496-下一个更大元素I"><a href="#496-下一个更大元素I" class="headerlink" title="496.下一个更大元素I"></a>496.下一个更大元素I</h2><p><a href="https://leetcode.cn/problems/next-greater-element-i/description/">496. 下一个更大元素 I - 力扣（LeetCode）</a></p><p>和上一题思路基本一模一样的，就说一下怎么由第一道题变到第二道题</p><p><strong>题意：</strong></p><p>第二题的意思是第一个数组里面的数字对应到第二个数组里面的相应位置，在第二个数组里面找它的下一个更大数字</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出：[-1,3,-1]</span><br></pre></td></tr></table></figure><p>第一个数组里面的1，对应第二个数组里面的第一个元素，第一个元素的下一个更大数字就是3，我们返回的就是3</p><p>栈还是单调递减的栈，单调栈遍历的是数组2，我们在哪里找下一个更大数字，就遍历哪个数组</p><p><strong>第一题第二题区别：</strong></p><p>首先要知道nums1是nums2的子集，如果nums1有，但是nums2没有，那说明肯定就是-1，不用管的</p><p>那既然知道nums1有的nums2肯定有，那我们就直接在第二个数组里面找下一个更大数，每一个元素都找。</p><p>在更新答案的时候，如果当前元素是nums1里面的，那我们才会记录到res，否则的话就直接弹出就行</p><p><strong>完整代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums<span class="number">1.</span>size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums<span class="number">1.</span><span class="built_in">size</span>(); i++) </span><br><span class="line">            m[nums1[i]] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums<span class="number">2.</span><span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; nums2[i] &gt; nums2[st.<span class="built_in">top</span>()]) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (m.<span class="built_in">find</span>(nums2[st.<span class="built_in">top</span>()])!=m.<span class="built_in">end</span>())</span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="type">int</span> index = m[nums2[st.<span class="built_in">top</span>()]]; </span><br><span class="line">                    res[index] = nums2[i];</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>灵神解法：</strong></p><p>单调栈存的是元素而不是下标了。</p><p>笔者这里其实不是很理解，似懂非懂，大家看看代码随想录的就挺好。</p><p>感觉是单调栈又不是单调栈，单调栈遍历的感觉像是数组1，但是也能得到正确的答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums<span class="number">1.</span>size(),<span class="number">-1</span>)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums<span class="number">1.</span><span class="built_in">size</span>();i++)</span><br><span class="line">            m[nums1[i]]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums<span class="number">2.</span><span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;nums2[i]&gt;st.<span class="built_in">top</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                res[m[st.<span class="built_in">top</span>()]]=nums2[i];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">find</span>(nums2[i])!=m.<span class="built_in">end</span>())</span><br><span class="line">                st.<span class="built_in">push</span>(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="503-下一个更大的元素II"><a href="#503-下一个更大的元素II" class="headerlink" title="503.下一个更大的元素II"></a>503.下一个更大的元素II</h2><p><a href="https://leetcode.cn/problems/next-greater-element-ii/description/">503. 下一个更大元素 II - 力扣（LeetCode）</a></p><p><strong>思路：</strong></p><p>每日温度基础上，加个取余就行，碰到循环数组类似的题很好用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">输出: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>例如这个输入</p><p>我们就把他当做两个相同的数组拼起来的就行，实际上我们物理上直接把两个一样的数组拼到一起形成一个新数组和加取余符号效果相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,3,   1,2,3,4,3]</span><br></pre></td></tr></table></figure><p><strong>完整代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;nums[i%n]&gt;nums[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                res[st.<span class="built_in">top</span>()]=nums[i%n];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i%n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
